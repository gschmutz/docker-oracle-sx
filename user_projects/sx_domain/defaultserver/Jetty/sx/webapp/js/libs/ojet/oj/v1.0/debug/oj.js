"use strict";
(function(){/*
** Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/
/*jslint browser: true*/
/*global define: false,goog: true,self:true*/

/**
 * Defines the oj namespace
 */

/**
 * @private
 */
var _scope = {};

// Bug 16874826 - check if the window object is available
// Note that the 'typeof' check  is required
if (typeof window !== 'undefined')
{
  _scope = window;
}
else if (typeof self !== 'undefined')
{
  _scope = self;
}

/**
 * @private
 */
var _oldVal = _scope['oj'];

/**
 * Global exported Oracle JET namespace
 * @property {String} version JET version number
 * @property {String} build JET build number
 * @property {String} revision JET source code revision number
 */
var oj = _scope['oj'] =
{
  'version': "1.0",
  'build' : "3157",
  'revision': "10321",
          
  // This function is only meant to be used outside the library, so quoting the name
  // to avoid renaming is appropriate
  'noConflict': function()
  {
    _scope['oj'] = _oldVal;
  }

};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved.

/*jslint browser: true*/

/**
 * @class  A wrapper above different output writers. The default writer is the native browser console. 
 * It also supports a custom writer objects that are compatible with JET logger API. 
 * In order to be compatible with JET logger API the writer should implement the following methods: log(), info(), warn(), error()
 * @export
 */ 
oj.Logger = {}; 
/**
 * Log level none
 * @const
 * @export 
 */
oj.Logger.LEVEL_NONE = 0;
/**
 * Log level error
 * @const
 * @export 
 */
oj.Logger.LEVEL_ERROR = 1;
/**
 * Log level warning
 * @const
 * @export 
 */
oj.Logger.LEVEL_WARN = 2;
/**
 * Log level info
 * @const
 * @export 
 */
oj.Logger.LEVEL_INFO = 3;
/**
 * Log level - general message
 * @const
 * @export 
 */
oj.Logger.LEVEL_LOG = 4;

/* private constants*/
oj.Logger._METHOD_ERROR = "error";
oj.Logger._METHOD_WARN = "warn";
oj.Logger._METHOD_INFO = "info";
oj.Logger._METHOD_LOG = "log";
oj.Logger._defaultOptions = {'level': oj.Logger.LEVEL_ERROR, 'writer': null};
oj.Logger._options = oj.Logger._defaultOptions;


/*public members*/
/**
 * Writes an error message.  
 * @param {...Object|string} obj 
 * @export 
 */
oj.Logger.error = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_ERROR, oj.Logger._METHOD_ERROR, arguments);
};

/**
 * Writes an informational  message. 
 * @param {...Object|string} obj
 * @export 
 */
oj.Logger.info = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_INFO, oj.Logger._METHOD_INFO, arguments);
};

/**
 * Writes a warning message.
 * @param {...Object|string} obj
 * @export 
 */
oj.Logger.warn = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_WARN, oj.Logger._METHOD_WARN, arguments);
};

/**
 * Writes a general message. 
 * @param {...Object|string} obj 
 * @export 
 */
oj.Logger.log = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_LOG, oj.Logger._METHOD_LOG, arguments);
};

/**
 * Method for setting and getting logger option/options
 * @param {Object|string=} key
 * @param {Object|string=} value 
 * @export
 */
oj.Logger.option = function (key, value)
{
  //getters
  var ret = {}, opt;
  if (arguments.length == 0) {
     for (opt in oj.Logger._options) {
      if (oj.Logger._options.hasOwnProperty(opt)) {
        ret[opt]=oj.Logger._options[opt];
      }
     }
     return ret;
  }
  if (typeof key === "string" && value === undefined) {
     return oj.Logger._options[key] === undefined ? null : oj.Logger._options[key];
  }
     
  //setters
  if (typeof key === "string") {
    oj.Logger._options[key] = value;
  }
  else { // case when all options are set in one call
    var options = key;
    for (opt in options) {
      if (options.hasOwnProperty(opt)) {
        oj.Logger.option(opt, options[opt]);
      }
    }
  }
};

/* private members*/
/*
 * Helper method - calls a specified method on the available writer (console or custom) 
 * if the logging level is sufficient
 */
oj.Logger._write = function(level, method, args)
{
  if (oj.Logger.option("level") < level) {
    return;
  }

  var writer = oj.Logger._getWriter();
  if (writer != null) {
    if (args.length == 1 && (args[0] instanceof Function)) {
      var msg = args[0]();
      args = [msg];
    }
    if (writer[method] && writer[method].apply) {
      writer[method].apply(writer, args);
    }
    else if (writer[method]) {
      writer[method] = Function.prototype.bind.call(writer[method], writer);
      oj.Logger._write(level, method, args);
    } 
  }
};

/*
 * Helper method - returns available writer (console or custom) 
 */
oj.Logger._getWriter = function()
{
  var writer = null;
  if (oj.Logger.option("writer")) {
    writer =  oj.Logger.option("writer");
  }
  else if (window !== undefined && window.console !== undefined) {
    writer = window.console;
  }
  return writer;
};

/*
 * Helper method - validates an option against default options
 * Returns true if the option(key) is a default option
 */
oj.Logger._validateOption = function(key)
{
  return oj.Logger._defaultOptions[key] !== undefined; 
};
/*
** Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/
/*jslint browser: true*/
/*global define: false,goog: true*/

/**
 * Base class of all OJET Objects.
 * <p>
 * To create a subclass of another oj.Object, use oj.Object.createSubclass.
 * The subclass can specify class-level initialization by implementing an
 * <code>InitClass()</code> method on its constructor.  <code>InitClass</code>
 * is guaranteed to be called only once per class.  Further, a class'
 * <code>InitClass</code> method is guranteed to be called only after its
 * superclass' class initialization has been called.  When <code>InitClass</code>
 * is called, <code>this</code> is the class' constructor.  This allows class
 * initialization implementations to be shared in some cases.
 * </p>
 * @author Blake Sullivan
 */


/**
 * @constructor
 * @export
 */
oj.Object = function()
{
  this.Init();
};
 
oj.Object.superclass = null;

/**
 * @private
 */
oj.Object._typeName = "oj.Object";

// regular expressicloneon for stripping out the name of a function
/**
 * @private
 */
oj.Object._GET_FUNCTION_NAME_REGEXP = /function\s+([\w\$][\w\$\d]*)\s*\(/;
// oj.Object._TRIM_REGEXP = /(^\s*)|(\s*$)/g; this.replace(/(^\s*)|(\s*$)/g, "");

oj.Object.prototype = {};
oj.Object.prototype.constructor = oj.Object;


/**
 * Calls to  this method are added by the Closure Compiler pass during JET's build process.
 * It should never be called by the Application code
 * 
 * The method delegates to goog.exportProperty() for exporting a symbol with Closure compiler,
 * while recording a map of the renamed names to an original names and a map of original names to the renamed names
 * @param {string} name - name of the property ('CCCC.prototype.FFFF' is expected)
 * @param {Object} valueMapping - a name-value pair, where tke key is the renamed name (renamed FFFF), and the value is the refernce to the member function
 * whose name was exported
 * @ignore
 */
oj.Object.exportPrototypeSymbol = function(name, valueMapping)
{
  var renamed = null;
  var val = null, prop;
  for (prop in valueMapping)
  {
    if (valueMapping.hasOwnProperty(prop)) {
        renamed = prop;
        val = valueMapping[prop];
        break;
    }
  }

  var tokens = name.split('.');

  var constructor = oj[tokens[0]];
  var original = tokens[2];

  // Do nothing if we are exporting a function that has not been renamed
  if (renamed == original || renamed == null)
  {
    return;
  }

  var renameMap = constructor._r2o;
  if (!renameMap)
  {
     renameMap = {};
     constructor._r2o = renameMap;
  }

  renameMap[renamed] = original;

  goog.exportProperty(constructor.prototype, original, val);
};

/**
 * Creates a subclass of a baseClass
 * @param {Function} extendingClass The class to extend from the base class
 * @param {Function} baseClass class to make the superclass of extendingClass
 * @param {string=} typeName to use for new class.  If not specified, the typeName will be extracted from the
 * baseClass's function if possible
 * @export
 */
oj.Object.createSubclass = function(
  extendingClass,
  baseClass,
  typeName)  // optional name to name this class
{
  oj.Assert.assertFunction(extendingClass);
  oj.Assert.assertFunctionOrNull(baseClass);
  oj.Assert.assertStringOrNull(typeName);

  if (baseClass === undefined)
  {
    // assume oj.Object
    baseClass = oj.Object;
  }

  oj.Assert.assert(extendingClass !== baseClass, "Class can't extend itself");

  // use a temporary constructor to get our superclass as our prototype
  // without out having to initialize the superclass
  /**
   * @private
   * @constructor
   */
  var TempConstructor = oj.Object._tempSubclassConstructor;

  TempConstructor.prototype = baseClass.prototype;
  extendingClass.prototype = new TempConstructor();

  extendingClass.prototype.constructor = extendingClass;
  extendingClass.superclass = extendingClass["superclass"] = baseClass.prototype;

  if (typeName) {
    extendingClass._typeName = typeName;
  }
};

/**
 * Copies properties from the source object to the prototype of the target class
 * Only properties 'owned' by the source object will be copied, i.e. the properties
 * from the source object's prototype chain will not be included.
 * To copy properties from another class with methods defined on the prototype, pass
 * otherClass.prototype as the source.
 * @param {Function} targetClass - the function whose prototype will be used a 
 * copy target
 * @param {Object} source - object whose properties will be copied
 * @export
 */
oj.Object.copyPropertiesForClass = function(targetClass, source) 
{ 
  var prop;
  oj.Assert.assertFunction(targetClass);
  oj.Assert.assert(source != null, "source object cannot be null");
  
  for(prop in source) 
  { 
    if(source.hasOwnProperty(prop)) 
    { 
      targetClass.prototype[prop] = source[prop]; 
    } 
  } 
};

/**
 * @private
 */
oj.Object._tempSubclassConstructor = function(){};




/**
 * Returns the class object for the instance
 * @param {Object=} otherInstance - if specified, the instance whose type
 * should be returned. Otherwise the type if this instance will be returned
 * @return {Function} the class object for the instance
 * @final
 * @export
 */
oj.Object.prototype.getClass = function(
  otherInstance)
{
  if (otherInstance === undefined) {
    otherInstance = this;
  }
  else if (otherInstance === null)
  {
    return null;
  }
  return otherInstance["constructor"];
};


/**
 * Returns a clone of this object.  The default implementation is a shallow
 * copy.  Subclassers can override this method to implement a deep copy.
 * @return {Object} a clone of this object
 * @export
 */
oj.Object.prototype.clone = function()
{
  var clone = new this.constructor();

  oj.CollectionUtils.copyInto(clone, this);

  return clone;
};

/**
 * @export
 */
oj.Object.prototype.toString = function()
{
  return this.toDebugString();
};

/**
 * @export
 */
oj.Object.prototype.toDebugString = function()
{
  return this.getTypeName() + " Object";
};


/**
 * Returns the type name for a class derived from oj.Object
 * @param {Function!|null} clazz Class to get the name of
 * @return {String} name of the Class
 * @export
 */
oj.Object.getTypeName = function(clazz)
{
  oj.Assert.assertFunction(clazz);

  var typeName = clazz._typeName, constructorText, matches;

  if (typeName == null)
  {
    constructorText = clazz.toString();
    matches = oj.Object._GET_FUNCTION_NAME_REGEXP.exec(constructorText);

    if (matches)
    {
      typeName = matches[1];
    }
    else
    {
      typeName = "anonymous";
    }

    // cache the result on the function
    clazz._typeName = typeName;
  }

  return typeName;
};

/**
 * Returns the type name for this instance
 * @return {String} name of the Class
 * @final
 * @export
 */
oj.Object.prototype.getTypeName = function()
{
  return oj.Object.getTypeName(this.constructor);
};

/**
 * Initializes the instance.  Subclasses of oj.Object must call
 * their superclass' Init
 * @export
 */
oj.Object.prototype.Init = function()
{
  if (oj.Assert.DEBUG) {
    oj.Assert.assert(this["getTypeName"], "Not an oj.Object");
  }

  // do any class initialization.  This code is duplicated from
  // oj.Object.ensureClassInitialization()

  var currClass = this.constructor;
  if (!currClass._initialized) {
    oj.Object._initClasses(currClass);
  }
};

/**
 * Ensures that a class is initialized.  Although class initialization occurs
 * by default the first time that an instance of a class is created, classes that
 * use static factory methods to create their instances may
 * still need to ensure that their class has been initialized when the factory
 * method is called.
 *
 * @param {Function} clazz The class to ensure initialization of
 * @export
 */
oj.Object.ensureClassInitialization = function(clazz)
{
  oj.Assert.assertFunction(clazz);

  if (!clazz._initialized) {
    oj.Object._initClasses(clazz);
  }
};

/**
 * Returns the specified Map property.  If createIfNonexistent is true and
 * the property doesn't exist, an empty Object will be created, and returned.
 */
/*oj.Object.prototype.GetLazyMapProperty = function(
  propName,
  createIfNonexistent,
  otherInstance)
{
  if (otherInstance == undefined)
    otherInstance = this;

  var property = otherInstance[propName];

  if ((property == undefined) && createIfNonexistent)
  {
    property = new Object();
    otherInstance[propName] = property;
  }

  return property;
}*/

/**
 * Returns the specified array property.  If createIfNonexistent is true and
 * the property doesn't exist, it will be created, and returned.
 */
 /*
oj.Object.prototype.GetLazyArrayProperty = function(
  propName,
  createIfNonexistent,
  otherInstance)
{
  if (otherInstance == undefined)
    otherInstance = this;

  var property = otherInstance[propName];

  if ((property == undefined) && createIfNonexistent)
  {
    property = new Array();
    otherInstance[propName] = property;
  }

  return property;
}*/

/**
 * Indicates whether some other oj.Object is "equal to" this one.
 * Method is equivalent to java ".equals()" method.
 * @param {Object} object - comparison target
 * @return {boolean} true if if the comparison target is equal to this object, false otherwise
 * @export
 */
oj.Object.prototype.equals = function(
  object)
{
  return this === object;
};

/**
 * Binds the supplied callback function to an object
 * @param {Object!} obj - object that will be available to the supplied callback 
 * function as 'this'
 * @param {Function!} func - the original callback
 * @return {Function} a function that will be invoking the original callback with
 * 'this' object assigned to obj
 * @export
 */
oj.Object.createCallback = function(obj, func)
{
  oj.Assert.assertFunction(func);

  // All browsers supported by JET support bind() method
  return func.bind(obj);
};


/**
 * @private
 */
oj.Object._applyFunctionProperties = function(
  target,
  className)
{
  var funcNameProperty = oj.Assert.FUNC_NAME_PROPERTY, classNameProperty = oj.Assert.CLASS_NAME_PROPERTY, currPropName, currProp;

  for (currPropName in target)
  {
    if (target.hasOwnProperty(currPropName)) {
        currProp = target[currPropName];

        if ((typeof currProp) === "function")
        {
          // we only care about methods defined on our object
          if (!currProp.hasOwnProperty(funcNameProperty))
          {
            currProp[funcNameProperty] = currPropName;
            currProp[classNameProperty] = className;
          }
        }
    }
  }
};

/**
 * @private
 */
oj.Object._initClasses = function(currClass)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertFunction(currClass);
    oj.Assert.assert(!currClass._initialized);
  }

  currClass._initialized = true;

  var superclass = currClass.superclass, superclassConstructor, typeName, InitClassFunc;

  // initialize the superclass if necessary
  if (superclass)
  {
    superclassConstructor = superclass.constructor;

    if (superclassConstructor && !superclassConstructor._initialized) {
      oj.Object._initClasses(superclassConstructor);
    }
      
    oj.Object._applyRenamesToSubclass(currClass);
  }

  typeName = oj.Object.getTypeName(currClass);

  try
  {
    // if the class has an initialization function, call it
    InitClassFunc = currClass["InitClass"] || null;
    
    // Check for the quoted name in case InitClass is renamed by Closure compiler
    if (!InitClassFunc)
    {
      InitClassFunc = currClass["InitClass"];
    }

    if (InitClassFunc)
    {
      InitClassFunc.call(currClass);
    }
  }
  finally
  {
    // set names on all of the functions so that we can pick them up for
    // stack dumps.  By the time the subclasses have inited, we should
    // have all of our functions
    if (oj.Assert.DEBUG)
    {
      // apply the stack information to our instance's instance methods
      oj.Object._applyFunctionProperties(currClass.prototype, typeName);

      // apply the stack information to our class's static methods
      oj.Object._applyFunctionProperties(currClass, "static " + typeName);
    }
  }
};

/**
 * Compares 2 values using strict equality except for the case of 
 * <ol>
 *   <li> Array [order matters]; will traverse through the arrays and compare oj.Object.compareValues(array[i], array2[i]) </li>
 *   <li> Instances that support valueOf [i.e. Boolean, String, Number, Date, and etc] will be compared by usage of that function </li>
 * </ol>
 * 
 * @public
 * @export
 */
oj.Object.compareValues = function (obj1, obj2)
{
  if (obj1 === obj2) 
  {
    return true;
  }
  
  var obj1Type = typeof obj1,
      obj2Type = typeof obj2;
  
  if (obj1Type !== obj2Type) 
  {
    //of different type so consider them unequal
    return false;
  }
  
  //At this point means the types are equal
  
  //note that if the operand is an array or a null then typeof is an object
  //check if either is null and if so return false [i.e. case where one might be a null and another an object]
  //and one wishes to avoid the null pointer in the following checks. Note that null === null has been already tested 
  if(obj1 === null || obj2 === null) 
  {
    return false;
  }
  
  //now check for constructor since I think by here one has ruled out primitive values and if the constructors 
  //aren't equal then return false
  if(obj1.constructor === obj2.constructor) 
  {
    
    //these are special cases and will need to be modded on a need to have basis
    if(Array.isArray(obj1))
    {
      return oj.Object._compareArrayValues(obj1, obj2);
    }
    else if(obj1.constructor === Object)
    {
      //for now invoke innerEquals and in the future if there are issues then resolve them
      return oj.Object.__innerEquals(obj1, obj2);
    }
    else if(obj1["valueOf"] && typeof obj1["valueOf"] === "function") 
    {
      //test cases for Boolean, String, Number, Date
      //Note if some future JavaScript constructors 
      //do not impl it then it's their fault
      return obj1.valueOf() === obj2.valueOf();
    }
    
  }
  
  return false;
};

oj.Object._compareArrayValues = function (array1, array2) 
{
  if (array1.length !== array2.length)
  {
    return false;
  }

  for (var i = 0, j = array1.length;i < j;i++)
  {
    //recurse on each of the values, order does matter for our case since do not wish to search 
    //for the value [expensive]
    if (!oj.Object.compareValues(array1[i], array2[i]))
    {
      return false;
    }
  }
  return true;
}

oj.Object.__innerEquals = function (obj1, obj2) {
  var prop, hasProperties = false;

  if (obj1 === obj2) {
    return true;
  }

  if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
    return false;
  }

  if (obj1.constructor !== obj2.constructor) 
  {
    return false;
  }

  for (prop in obj1) 
  {
    if (!hasProperties)
    {
      hasProperties = true;
    }
    if (obj1.hasOwnProperty(prop)) {        
      if (!obj2.hasOwnProperty(prop)) 
      {
        return false;
      }

      if (obj1[prop] !== obj2[prop]) 
      {
        if (typeof(obj1[prop]) !== 'object') {
          return false;
        }

        if (!oj.Object.__innerEquals(obj1[prop], obj2[prop])) 
        {
          return false;
        }
      }
    }
  }
  
  for (prop in obj2) 
  {
    if (!hasProperties)
    {
      hasProperties = true;
    }
    
    if (obj2.hasOwnProperty(prop) && !obj1.hasOwnProperty(prop)) {
      return false;
    }
  }
  
  if (!hasProperties)
  {
    // we are dealing with objects that have no properties like Number or Date.
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }
  
  return true;
};

oj.Object.isEmpty = function(object) {
    var prop;
    // Test if an object is empty
    if (object === undefined || object === null) {
        return true;
    }
    
    for (prop in object) {
        if (object.hasOwnProperty(prop)) {
            return false;
        }
    }
    return true;
};

/**
 * @private
 */
oj.Object._applyRenamesToSubclass = function (currClass)
{
  // Check whether any renames actually happened
  if (!oj.Object._r2o)
  {
    return;
  }
  var ancestor = currClass.superclass;
  oj.Object._applyRenamesFromChain(currClass, ancestor);
};

/**
 * @private
 */
oj.Object._applyRenamesFromChain = function(currClass, superclass)
{
  if (!superclass)
  {
    return;
  }
  
  var ancestor = superclass.constructor;
  
  
  //Recurse up the inheritance chain first
  oj.Object._applyRenamesFromChain(currClass, ancestor.superclass);
  
  var renameMap = ancestor._r2o, alias;
  if (renameMap)
  {
    for (alias in renameMap)
    {
      if (renameMap.hasOwnProperty(alias)) {
        var orig = renameMap[alias];
        if (alias != orig)
        {
          var prot = currClass.prototype;
          if (!prot.hasOwnProperty(alias) && prot.hasOwnProperty(orig))
          {
            prot[alias] = prot[orig];
          }
          else if(!prot.hasOwnProperty(orig) && prot.hasOwnProperty(alias))
          {
            prot[orig] = prot[alias];
          }
        }
      }  
    }
  }
};

/**
 * @private
 */
oj.Object.__getPromise = function(func) {
    if (!Promise.prototype['done']) {
        Promise.prototype['done'] = Promise.prototype['then'];
    }
    return new Promise(func);
};

/**
 * @private
 * @return  {boolean} true if AMD Loader (such as Require.js) is present, 
 *                    false otherwise
 */
oj.__isAmdLoaderPresent = function()
{
  return (typeof define === 'function' && define['amd']);
};



/*
** Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
*/

/*jslint browser: true*/

/**
 * Assertion utilities.
 * The container is expected to have already initialized the oj.Assert Object before this
 * code is executed and initialized the oj.Assert.DEBUG flag/
 * @author Blake Sullivan
 * @constant {Object|Boolean} DEBUG <code>true</code> if assertions are enabled.
 * @export
 * @ignore
 */
oj.Assert = {};


/**
 * Forces DEBUG to be set to true
 * @export
 */
oj.Assert.forceDebug = function()
{
  oj.Assert.DEBUG = oj.Assert["DEBUG"] = true;
};

// name of property on function objects that stack dumping will look for
// to get the function name
oj.Assert.FUNC_NAME_PROPERTY = "_funcName";

// name of property on function objects that stack dumping will look for
// to get the class name
oj.Assert.CLASS_NAME_PROPERTY = "_className";

// maximum stack depth that we will generate a stack trace for
oj.Assert._MAX_STACK_DEPTH_LIMIT = 20;

/**
 * Asserts that a condition is true.  If the condition does not
 * evaluate to true, an exception is thrown with the optional message
 * and reason
 * @param {boolean} condition condition to test
 * @param {string=} message message to display
 * @export
 */
oj.Assert.assert = function(
  condition,
  message
  )
{
  if (oj.Assert.DEBUG && !condition)
  {
    var myMessage = message || "", i;
    if (arguments.length > 2)
    {      
      myMessage += "(";
      for(i=2; i<arguments.length; i=i+1)
      {
        myMessage += arguments[i];
      }
      myMessage += ")";
    }
    oj.Assert.assertionFailed(myMessage, 1);
  }
};

/**
 * Convenience function for asserting when an abstact function is called
 * @export
 */
oj.Assert.failedInAbstractFunction = function()
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertionFailed("Abstract function called", 1);
  }
};



/**
 * Asserts that the the target object has the same prototype as the example
 * type
 * @param {Object} target description
 * @param {Function} theConstructor
 * @param {string=} reason
 * @export
 */
oj.Assert.assertPrototype = function(
  target,
  theConstructor,
  reason
  )
{
  var thePrototype;
  
  if (oj.Assert.DEBUG)
  {
    if (target !== null)
    {
      oj.Assert.assertType(theConstructor, "function", null, 1, false);
      thePrototype = theConstructor.prototype;
    
      if (!thePrototype.isPrototypeOf(target))
      {
        oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype "
                               + thePrototype,
                               1,
                               reason);
      }
    }
    else
    {
      oj.Assert.assertionFailed("null object doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};

/**
 * Asserts that the the target object has the same prototype as the example
 * type or is null.
 * @export
 */
oj.Assert.assertPrototypeOrNull = function(
  target,
  theConstructor,
  reason
  )
{
  var thePrototype;
  
  if (oj.Assert.DEBUG && (target !== null))
  {
    if (target !== null)
    {
      oj.Assert.assertType(theConstructor, "function", null, 1, false);
      thePrototype = theConstructor.prototype;
    
      if (!thePrototype.isPrototypeOf(target))
      {
        oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype "
                               + thePrototype,
                               1,
                               reason);
      }
    }
    else
    {
      oj.Assert.assertionFailed("null object doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};

/**
 * Asserts that the the target object has the same prototype as the example
 * types
 * @export
 */
oj.Assert.assertPrototypes = function(
  target,
  instanceOne,
  instanceTwo,
  reason
  )
{
  if (oj.Assert.DEBUG)
  {
    var thePrototype = instanceOne.prototype, thePrototypeTwo = instanceTwo.prototype;
    
    if (!(thePrototype.isPrototypeOf(target) ||
          thePrototypeTwo.isPrototypeOf(target)))
    {
      oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype "
                             + thePrototype + " or " + thePrototypeTwo,
                             1,
                             reason);
    }
  }
};


/**
 * Asserts that the target is a DOM Node or Null
 * @export
 */
oj.Assert.assertDomNodeOrNull = function(target, depth)
{
  if (oj.Assert.DEBUG && target)
  {
    if (target["nodeType"] === undefined)
    {
      oj.Assert.assertionFailed(target + " is not a DOM Node", depth + 1);
    }
  }
};

/**
 * Asserts that the target is a DOM Node
 * @export
 */
oj.Assert.assertDomNode = function(target, depth)
{
  if (oj.Assert.DEBUG)
  {
    if (!target || (target["nodeType"] === undefined))
    {
      oj.Assert.assertionFailed(target + " is not a DOM Node", depth + 1);
    }
  }
};

/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @param {Object} target target object
 * @param {string=} nodeName name of the element
 * @export
 */
oj.Assert.assertDomElement = function(target, nodeName)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1)
    {
      oj.Assert.assertionFailed(target + " is not a DOM Element", 1);
    }
    else if (nodeName && (target.nodeName !== nodeName))
    {      
      oj.Assert.assertionFailed(target + " is not a " + nodeName + " Element", 1);
    }
  }
};

/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @export
 */
oj.Assert.assertDomElementOrNull = function(target, nodeName)
{
  if (oj.Assert.DEBUG && (target !== null))
  {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1)
    {
      oj.Assert.assertionFailed(target + " is not a DOM Element", 1);
    }
    else if (nodeName && (target.nodeName !== nodeName))
    {
      oj.Assert.assertionFailed(target + " is not a " + nodeName + " Element", 1);
    }
  }
};


/**
 * Asserts that the target object has the typeof specified
 * 
 * @param {Object|null|string|undefined} target 
 * @param {string} type typeof type that statisfies this condition
 * @param {string|undefined|null} prefix
 * @param {number} depth stack depth to skip when printing stack traces
 * @param {boolean} nullOK true if a null value satisfies this condition
 * @export
 */
oj.Assert.assertType = function(target,type,prefix,depth, nullOK)
{
  if (oj.Assert.DEBUG)
  {
    // either the target is null and null is OK, or the target better
    // be of the correct type
    var message, targetType = typeof target;
    if (!(((target === null) && nullOK) || (targetType === type)))
    {
      message = target + " is not of type " + type;
      
      if (prefix) {
        message = prefix + message;
      }
        
      if (!depth) {
        depth = 0;
      }
        
      oj.Assert.assertionFailed(message, depth + 1);
    }
  }
};

/**
 * Asserts that the target is an Object
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 */
oj.Assert.assertObject = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "object", prefix, 1, false);
  }
};

/**
 * Asserts that the target is an Object or null
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 */
oj.Assert.assertObjectOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "object", prefix, 1, true);
  }
};

/**
 * Asserts that the target is a non-empty String
 * @export
 */
oj.Assert.assertNonEmptyString = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "string", prefix, 1, false);
    oj.Assert.assert(target.length > 0, "empty string"); 
  }
};

/**
 * Asserts that the target is a String
 * @param {Object} target target object
 * @param {string=} prefix prefix string
 * @export
 */
oj.Assert.assertString = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "string", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a String or null
 * @param {string|null|undefined|Object} target target object
 * @param {string=} prefix prefix string
 * @export
 */
oj.Assert.assertStringOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "string", prefix, 1, true);
  }
};

/**
 * Asserts that the target is a Function
 * @param {Object} target target object
 * @param {string=} prefix prefix string
 * @export
 */
oj.Assert.assertFunction = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "function", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a Function or null
 * @param {Object} target target object
 * @param {string=} prefix prefix
 * @export
 */
oj.Assert.assertFunctionOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "function", prefix, 1, true);
  }
};

/**
 * Asserts that the target is a boolean 
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 */
oj.Assert.assertBoolean = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "boolean", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a number
 * @export
 */
oj.Assert.assertNumber = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "number", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a number or Null
 * @export
 */
oj.Assert.assertNumberOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "number", prefix, 1, true);
  }
};


/**
 * Asserts that the target object is an Array
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertArray = function(
  target,
  message
  )
{
  if (oj.Assert.DEBUG)
  {
    if (!Array.isArray(target))
    {
      if (message === undefined) {
        message = target + " is not an array";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};

/**
 * Asserts that the target object is an Array or null
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertArrayOrNull = function(
  target,
  message)
{
  if (oj.Assert.DEBUG && (target !== null))
  {
    if (!Array.isArray(target))
    {
      if (message === undefined) {
        message = target + " is not an array";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};


/**
 * Asserts that the target object is not either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertNonNumeric = function(
  target,
  message
  )
{
  if (oj.Assert.DEBUG)
  { 
    if (!isNaN(target))
    {
      if (message === undefined) {
        message = target + " is convertible to a number";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};

/**
 * Asserts that the target object is either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertNumeric = function(
  target,
  message
  )
{
  if (oj.Assert.DEBUG)
  {
    if (isNaN(target))
    {
      if (message === undefined) {
        message = target + " is not convertible to a number";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};

/**
 * Asserts that value String is in the Set
 * @param {Object} value value to check
 * @param {Object} set set to check
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertInSet = function(
  value,
  set,
  message)
{
  var keyString, k;
  if ((value === null) || (set[value.toString()] === undefined))
  {
    if (message === undefined)
    {
      keyString = " is not in set: {";
      
      for (k in set)
      {
        if (set.hasOwnProperty(k)) {
            keyString += k;
            keyString += ",";
        }
      }
      
      keyString += "}";
      
      message = value + keyString;
    }
      
    oj.Assert.assertionFailed(message, 1);
  }
};

/**
 * Base assertion failure support that supports specifying the stack skipping
 * level
 * @param {string} message Message to display
 * @param {number} skipLevel assertion level
 * @param {string=} reason reason to display
 * @export
 */
oj.Assert.assertionFailed = function(
  message,
  skipLevel,
  reason)
{  
  if (!skipLevel) {
    skipLevel = 0;
  }

  var errorMessage = "Assertion", stackTrace, stackTraceString, error;
  
  if (reason)
  {
    errorMessage += " (" + reason + ")";
  }
  
  errorMessage += " failed: ";
  
  if (message !== undefined)
  {
    errorMessage += message;
  }
    
  stackTrace = oj.Assert._getStackTrace(skipLevel + 1);
  
  stackTraceString = oj.Assert._getStackString(stackTrace);
  
  errorMessage += "\nStackTrace:\n" + stackTraceString;

  error = new Error(errorMessage);
  
  
  window.alert(errorMessage);

  throw error;
};

/**
 * Returns the name of a function, or <code>null</code> if the
 * name can't be determined
 * @export
 */
oj.Assert.getFunctionName = function(func)
{
  // check if the function name has been stored on the function already
  var funcName = func[oj.Assert.FUNC_NAME_PROPERTY], functionString, startFuncParamsIndex, startFuncNameIndex;

  if (funcName === undefined)
  {
    functionString = func.toString();
    startFuncParamsIndex = functionString.indexOf('(');
    
    // back up to the first space
    startFuncNameIndex = functionString.lastIndexOf(" ", startFuncParamsIndex);

    // the function name is contained in the portion of the function string between
    // the beginning of the function and the first "("
    funcName = functionString.substring(startFuncNameIndex + 1, startFuncParamsIndex);
             
    if (!funcName.length) {
      funcName = null;
    }
      
    // store the derived function name or null if the function
    // name can't be determined
    func[oj.Assert.FUNC_NAME_PROPERTY] = funcName;
  }
  
  return funcName;
};

/**
 * Returns the stack trace as a string
 * @export
 */
oj.Assert.getStackString = function(depth)
{
  if (depth === null) {
    depth = 1;
  }
    
  return oj.Assert._getStackString(oj.Assert._getStackTrace(1));
};

/**
 * @suppress {es5Strict}
 * Returns the stack trace as an array of function callers
 */
oj.Assert._getStackTrace = function(
  skipLevel)
{
  if (skipLevel === undefined) {
    skipLevel = 0;
  }
    
  oj.Assert.assert(skipLevel >= 0);
  
  var stackTrace = [], currCaller;
  
  // crawl up starting at our caller
  try
  {
    currCaller = oj.Assert._getStackTrace.caller;
    
    while (currCaller && (stackTrace.length < oj.Assert._MAX_STACK_DEPTH_LIMIT))
    {    
      if (!skipLevel)
      {
        stackTrace.push(currCaller);
      }
      else
      {
        skipLevel=skipLevel-1;
      }
  
      currCaller = currCaller.caller;
    }
  }
  catch (e)
  {
    // just eat it because we have no place to log this
  }
  
  
  return stackTrace;
};

/**
 * Returns the param String for a function, or null if there are no parameters
 */
oj.Assert._getFuncParams = function(func)
{
  // check if the function parameters have been stored on the function already
  var funcParams = func[oj.Assert._PARAMS_NAME_PROPERTY], currFunctionString, startFuncParams, endFuncParams;

  if (funcParams === undefined)
  {
    currFunctionString = func.toString();
    startFuncParams    = currFunctionString.indexOf('(');
    endFuncParams      = currFunctionString.indexOf(')', startFuncParams + 1);
    
    funcParams = currFunctionString.substring(startFuncParams, endFuncParams + 1);

    // remove all whitespace
    funcParams = funcParams.replace(/\s+/g, "");
    
    if (!funcParams.length) {
      funcParams = null;
    }
      
    // store the derived function name or null if the function
    // parameters don't exist
    func[oj.Assert._PARAMS_NAME_PROPERTY] = funcParams;
  }
  
  return funcParams;
};

oj.Assert._getStackString = function(
  stackTrace
  )
{  
  if (!stackTrace) {
    return "";
  }
    
  var functionCount = stackTrace.length, stackStrings = [], stackIndex, currFunction,
      funcName, className, funcParams, functionArgs, argCount, argsArray,
      argIndex, currArg, argFuncName, argFuncParams, stackStringArray;
  
  for (stackIndex = 0; stackIndex < functionCount; stackIndex=stackIndex+1)
  {
    currFunction = stackTrace[stackIndex];

    funcName = oj.Assert.getFunctionName(currFunction);
    
    if (!funcName) {
      funcName = "anonymous";
    }
      
    // try to pull the class name off of the function object
    className = currFunction[oj.Assert.CLASS_NAME_PROPERTY];
    
    // try to pull the class name off of the function object.  If we have one,
    // prepend it to the function name
    if (className) {
      funcName = className + "." + funcName;
    }

    funcParams = oj.Assert._getFuncParams(currFunction);

    functionArgs = currFunction['arguments'];
    argCount     = functionArgs.length;
    argsArray    = null;    
    
    // copy arguments into an array so that we can call join on it
    if (argCount)
    {
      // copy the entries the lame way
      argsArray = [];
              
      for (argIndex = 0; argIndex < argCount; argIndex=argIndex+1)
      {
        currArg = functionArgs[argIndex];
        
        if (typeof currArg === "function")
        {
          argFuncName = oj.Assert.getFunctionName(currArg);
   
          if (!argFuncName) {
            argFuncName = "anonymous";
          }

          argFuncParams = oj.Assert._getFuncParams(currArg);

          currArg = "function " + argFuncName + argFuncParams;
        }
        
        argsArray[argIndex] = currArg;
      }
    }

    // concatenate the pieces together
    stackStringArray = [];
    
    stackStringArray[0] = funcName;
    stackStringArray[1] = funcParams;
    
    // add in the arguments, if any
    if (argsArray)
    {
      stackStringArray[2] = "\n";
      stackStringArray[3] = "[";
      stackStringArray[4] = oj.Assert._safeJoin(argsArray, ",");
      stackStringArray[5] = "]";      
    }
    
        
    stackStrings[stackIndex] = stackStringArray.join("");
  }
  
  return stackStrings.join("\n");
};

// Joins the array elements into a single string, checking for the
// presence of toString() on each element.
oj.Assert._safeJoin = function(arr, sep)
{
  var length = arr.length, joinedString = "", i, ele, str;
  for (i = 0; i < length; i=i+1)
  {
    ele = arr[i];
    str = ele ? (ele.toString ? ele.toString() : "Unknown") : "(empty)";

    // If we care about performance, we should use a string buffer
    joinedString += str;
    
    if (sep)
    {
      if (i < length - 1) {
        joinedString += sep;
      }
    }
  }
  
  return joinedString;
};

// name of property on function objects that stack dumping will look for
// the param names
oj.Assert._PARAMS_NAME_PROPERTY = "_funcParams";

/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/
/*jslint browser: true*/
/*global require:false,ojt:true */

/**
 * @class Services for setting and retrieving configuration options
 * @export
 */
oj.Config = {};

/**
 * Retrieves the current locale
 * @return {string} current locale
 * @export 
 */
oj.Config.getLocale = function()
{
  var rl, loc;
  if (oj.__isAmdLoaderPresent())
  {
    oj.Assert.assert(ojt !== undefined, "ojtranslations module must be defined");
    rl = ojt['_ojLocale_'];
    
    // If Require.js internationalziation plugin resolved the locale to "root" (presumably because "lang" attribute was not
    // set, and neither navigator.language or navigator.userLanguage were not available), return "en"
    return (rl == "root") ? "en" : rl;
  }
    loc = oj.Config._locale;
    if (loc == null)
    {
      loc = document.documentElement.lang;
      if (!loc)
      {
         loc = navigator === undefined ? "en" :
                            (navigator['language'] ||
                             navigator['userLanguage'] || "en").toLowerCase();
      }
      oj.Config._locale = loc = loc.toLowerCase();
    }
    return loc;
};

/**
 * Changes the current locale
 * @param {string} locale (language code and subtags separated by dash)
 * @param {Function} callback - for applications running with an AMD Loader (such as Require.js), this optional callback 
 * will be invoked when the framework is done loading its translated resources and Locale Elements for the newly specified locale. 
 * For applications running without an AMD loader, this optional callback will be invoked immediately
 * @export
 */
oj.Config.setLocale = function(locale, callback)
{
  if (oj.__isAmdLoaderPresent())
  {
    var prefix = "ojL10n!ojtranslations/nls/",
        requestedBundles = [prefix + locale + "/ojtranslations"];
    
    // Request LocaleElements only if ojlocaledata module is loaded
    if (oj.LocaleData) 
    {
      requestedBundles.push(prefix + locale + "/localeElements");    
    }
    
    require(requestedBundles,
      function(translations, localeElements)
      {
        ojt = translations;
        
        if (localeElements)
        {
          oj.LocaleData.__updateBundle(localeElements);
        }
        
        if (callback)
        {
          callback();
        }
      }
    );
  }
  else
  {
    oj.Config._locale = locale;
    if (callback)
    {
      callback();
    }
  }
};

/**
 * Retrieves a URL for loading a component-specific resource.
 * The URL is resolved as follows:
 * 1. If the application has specified a base URL with setResourceBaseUrl(), the return values will be
 * a relative path appended to the base URL.
 * 2. Otherwise, if the application running with an AMD Loader (such as Require.js), the parent folder of a 
 * module with ojs/ mapping will be used as a base URL.
 * 3. Otherwise, the original relative path will be returned.
 * 
 * @param {string} relativePath resource path
 * @return {string} resource URL
 * @see oj.Config.setResourceBaseUrl
 * @export
 */
oj.Config.getResourceUrl = function(relativePath)
{
  // Returning null and full URLs (containing protocol or a leading slash) as is
  var fullUrlExp = /^\/|:/, base, modulePath;
  if (relativePath == null || fullUrlExp.test(relativePath))
  {
    return relativePath;
  }
  
  base = oj.Config._resourceBaseUrl;
  
  if (base)
  {
    return base + (base.charAt(base.length-1) == '/' ? "" : '/') + relativePath;
  }
  
  if (oj.__isAmdLoaderPresent())
  {
    // Bug #18726114: use ojs/_foo_ instead of ojs/ojcore to handle the case when ojs.core ends up in a partition bundle
    // in a different location
    modulePath = require.toUrl("ojs/_foo_");
    return modulePath.replace(/[^\/]*$/, "../" + relativePath);
  }
  
  return relativePath;
};

/**
 * Sets the base URL for retrieving component-specific resources
 * @param {string} baseUrl base URL
 * @see oj.Config.getResourceUrl
 * @export
 */
oj.Config.setResourceBaseUrl = function(baseUrl)
{
  oj.Config._resourceBaseUrl = baseUrl;  
};

/**
 * Sets the automation mode.
 * @param {string} mode "enabled" for running in automation mode
 * @see oj.Config.getAutomationMode
 * @export
 */
oj.Config.setAutomationMode = function(mode)
{
  oj.Config._automationMode = mode;
};

/**
 * Gets the automation mode.
 * @return {string} automation mode
 * @see oj.Config.setAutomationMode
 * @export
 */
oj.Config.getAutomationMode = function()
{
  return oj.Config._automationMode;
}; 



/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/
/**
 * String utilities.
 * @export
 * @ignore
 */
oj.StringUtils = {};

oj.StringUtils._TRIM_ALL_RE = /^\s*|\s*$/g;

/**
  * Returns true if the value is null or if the trimmed value is of zero length.
  * 
  * @param {Object|string|null} value
  * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
  * @export
  */        
 oj.StringUtils.isEmpty = function(value)
 {    
   if (value === null)
   {
     return true;
   }

   var trimValue = oj.StringUtils.trim(value);
   
   return (trimValue.length === 0);
 };
 
 /**
  * Returns true if the value is null, undefined or if the trimmed value is of zero length.
  * 
  * @param {Object|string|null} value
  * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
  * @export
  */
 oj.StringUtils.isEmptyOrUndefined = function (value)
 {
   if (value === undefined || oj.StringUtils.isEmpty(value))
   {
     return true;
   }
   
   return false;
 };

/**
 * Test if an object is a string (either a string constant or a string object)
 * @param {Object|string|null} obj object to test
 * @return {boolean} true if a string constant or string object
 * @export
 */
oj.StringUtils.isString = function(obj)
{
  return obj !== null && ((typeof obj === 'string') || obj instanceof String);
};

/**
 * Remove leading and trailing whitespace
 * @param {Object|string|null} data to trim
 * @return {Object|string|null}
 * @export
 */
oj.StringUtils.trim = function(data)
{
  if (oj.StringUtils.isString(data))
  {
    return data.replace(oj.StringUtils._TRIM_ALL_RE, '');
  }

  return data;
};
/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/

/**
 * Utilities for working with collections
 * @export
 */
oj.CollectionUtils = {};


/**
 * Copies all of the properties of source into the target and returns the target
 * 
 * @param {Object} target - target collection
 * @param {Object} source - source collection
 * @param {function(string)=} keyConverter a callback for converting the key
 * @param {boolean=} recurse - true if this method should recurse into plain Javascript object properties
 * @param {number=} maxRecursionDepth - the maximum depth of the recursion into plain Javascript object properties
 * @return target collection
 * @export
 */
oj.CollectionUtils.copyInto = function(
  target,
  source,
  keyConverter,
  recurse,
  maxRecursionDepth)
{
  return oj.CollectionUtils._copyIntoImpl(
                                          target,
                                          source,
                                          keyConverter,
                                          recurse,
                                          maxRecursionDepth,
                                          0);
};


/**
 * Checks whether the object is a direct instance of Object
 * @param {Object} obj - object to test
 * 
 * @return {boolean} true if the object is a direct instance of Object, false otherwise
 * @export
 */
oj.CollectionUtils.isPlainObject = function(obj)
{
  if (typeof obj === 'object')
  {
    try
    {
      if (obj.constructor && obj.constructor.prototype.hasOwnProperty("isPrototypeOf"))
      {
        return true;
      }
    }
    catch(e){}
  }
  
  return false;
};


/**
 * @private
 */
oj.CollectionUtils._copyIntoImpl = function(
  target,
  source,
  keyConverter,
  recurse,
  maxRecursionDepth,
  currentLevel)
{
  var k, targetKey, keys;
  if (target && source && (target !== source))
  {    
    keys = Object.keys(source);
    for (var i=0; i<keys.length; i++)
    {      
      k = keys[i];
      // allow the key mapping to be overridden
      if (keyConverter)
      {
        targetKey = keyConverter(k);
      }
      else
      {
        targetKey = k;
      }
      
      var sourceVal = source[k];
      
      var recursed = false;
      
      if (recurse && currentLevel < maxRecursionDepth)
      {
        var targetVal = target[targetKey];
        if (oj.CollectionUtils.isPlainObject(targetVal) && oj.CollectionUtils.isPlainObject(sourceVal))
        {
          recursed = true;
          oj.CollectionUtils._copyIntoImpl(
                                          targetVal,
                                          sourceVal,
                                          keyConverter,
                                          true,
                                          maxRecursionDepth,
                                          currentLevel + 1);
        }
      }
      if (!recursed)
      {
        target[targetKey] = sourceVal;
      }

    }
  }
  
  return target;
};

/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/

/*global ojt:false*/

/**
 * @class Services for Retrieving Translated Resources
 * @export
 */
oj.Translations = {};

/**
 * Sets the translation bundle used by JET
 * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
 * translated strings for JET.
 * This method may also be used by an application that wants to completely replace the resource bundle that is automatically
 * fetched by an AMD loader.
 * @param {Object} bundle resource bundle that should be used by the framework
 * @export
 */
oj.Translations.setBundle = function(bundle)
{
  oj.Translations._bundle = bundle;
};

/**
 * Retrives a translated resource for a given key
 * @param {string} key
 * @return {Object|string|null} resource associated with the key or null if none was found
 * @export
 */
oj.Translations.getResource = function(key)
{
  return oj.Translations._getResourceString(key);
};

/**
 * Applies parameters to a format pattern
 * @param {string} pattern. Tokens ike {0}, {1}, {name} within the pattern 
 * will be used to define string keys for retrieving values from the parameters
 * object. Token strings should not contain comma (') 
 * or space characters, since they are reserved for future format type enhancements. 
 * The reserved characters within a pattern are:
 * $ { } [ ]  
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 * 
 * @param {Object|Array} parameters to be inserted into the string. Both arrays and
 * Javascript objects with string keys are accepted.
 * 
 * @return formatted message or null if the pattern argument was null
 * @export
 */
oj.Translations.applyParameters = function(pattern, parameters)
{
  return (pattern == null) ? null : oj.Translations._format(pattern, parameters);
};

/**
 * Retrieves a translated string after inserting optional parameters
 * @param {string} key - translations resource key
 * The key is used to retrieve a format pattern from the resource bundle.
 * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
 * for the optional parameters.  Token strings should not contain comma (,) 
 * or space characters, since they are reserved for future format type enhancements.
 * The reserved characters within a pattern are:
 * $ { } [ ]  
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 * 
 * @param {...string|Object|Array} var_args  - optional parameters to be inserted into the 
 * translated pattern.
 * 
 * If more than one var_args arguments are passed, they will be treated as an array 
 * for replacing positional tokens like {0}, {1}, etc.
 * If a single argument is passed, it will be treated as a Javascript Object whose
 * keys will be matched to tokens within the pattern. Note that an Array is just
 * a special kind of such an Object.
 * 
 * For backward compatibility, a var_args argument whose type is neither 
 * Object or Array will be used to replace {0} in the pattern.
 * 
 * @return formatted translated string
 * @export
 */
oj.Translations.getTranslatedString = function(key, var_args)
{  
  var val = oj.Translations._getResourceString(key);
  
  if (val == null)
  {
    return key;
  }
  
  var params = {};
  
  if (arguments.length > 2)
  {
    params = Array.prototype.slice.call(arguments, 1);
  }
  else if (arguments.length == 2)
  {
    params = arguments[1];
    if (typeof params !== 'object' && !(params instanceof Array))
    {
      params = [params];
    }
      
  }
  
  return oj.Translations.applyParameters(val, params);
};


/**
 * Provides a key-to-value map of the translated resources for a given component name
 * @param {string} componentName
 * @return a map of translated resources
 * @export
 */
oj.Translations.getComponentTranslations = function(componentName)
{
  var bundle = oj.Translations._getBundle()[componentName], translations, k;
  
  if (bundle == null)
  {
    return {};
  }
  
  // Assume that the set of keys remains constant regardless of the current locale
  translations = {};
  for(k in bundle)
  {
    if (bundle.hasOwnProperty(k)) {
        translations[k] = bundle[k];
    }
  }
  return translations;
};

/**
 * Retrives a translated resource for a given key, accounting for nested keys
 * @param {string} key
 * @returns {string|null} resource associated with the key or null if none was found
 */
oj.Translations._getResourceString = function(key)
{
  // Account for dot separated nested keys
  var keys = key ? key.split(".") : [], bundle = oj.Translations._getBundle(), 
          iteration = keys.length, index = 0, subkey = keys[index];
  oj.Assert.assertObject(bundle);
  
  // even though we start with a valid bundle it's possible that part or all of the key is invalid, 
  // so check we have a valid bundle in the while loop
  while (--iteration > 0 && bundle) 
  {
    // if we have a key like a.b.c
    bundle = bundle[subkey];
    index++;
    subkey = keys[index];
  }
    
  return bundle ? (bundle[subkey] || null) : null;
};

oj.Translations._format = function(formatString, parameters)
{
  var formatLength = formatString.length;
  
  // Use the javascript StringBuffer technique.
  var buffer = [];
  
  var token = null;
  
  
  var escaped = false;
  var isToken = false;
  var isGroup = false;
  var isExcluded = false;
  
  var tokenTerminated; // this will be set to true when a comma or space is 
                       // encountered in teh token
  var i;
  
  for (i = 0; i < formatLength; i++)
  {
    var ch = formatString.charAt(i);
    
    var accumulate = false;
    
    if (!escaped)
    {
      switch(ch)
      {
        case '$':
          escaped = true;
          break;
          
        case '{':
          if (!isExcluded)
          {
            if (!isToken)
            {
              tokenTerminated = false;
              token = [];
            }
            isToken = true;
          }
          break;
          
        case '}':
          if (isToken && token.length > 0)
          {
            var val = parameters[token.join('')];
            buffer.push((val === undefined) ? "null" : val);
          }
          isToken = false;
          break;
          
        case '[':
          if (!isToken)
          {
            if (isGroup)
            {
              isExcluded = true;
            }
            else
            {
              isGroup = true;
            }
          }
          break;
          
        case ']':
          if (isExcluded)
          {
            isExcluded = false;
          }
          else
          {
            isGroup = false;
          }
          break;
        
        default:
          accumulate = true;
      }
    }
    else
    {
      accumulate = true;
      escaped = false;  
    }
    
    if (accumulate)
    {
      if (isToken)
      {
        if (ch == ',' || ch ==' ')
        {
          tokenTerminated = true;
        }
        else if (!tokenTerminated)
        {
          token.push(ch);
        }
      }
      else if (!isExcluded)
      {
        buffer.push(ch);
      }
    } 
  }

  // Use the javascript StringBuffer technique for toString()
  return buffer.join("");
};


oj.Translations._getBundle = function()
{
  var b = oj.Translations._bundle;
  if (b)
  {
    return b;
  }
  
  if (oj.__isAmdLoaderPresent()) {
    oj.Assert.assert(ojt !== undefined, "ojtranslations module must be defined");
    return ojt;
  }
  return {};
};
/**
 * Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
/*jslint browser: true*/
/**
 * @constructor
 * @class oj.Events
 * @classdesc Supports event system for the common model (oj.Collection and oj.Model)
 */
oj.Events = window['oj']['Events'] =
/** @lends oj.Events */
{        
    /**
     * Add an event handler for an event type to the model or collection object.
     * @param {String|Object} eventType Types of event handlers to add (may be a single event type, a space-delimited set of event types, or an object mapping events to callbacks). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     * @param {Object=} context A context for the event 
     */
    'on': function (eventType, callback, context) {
            return this.OnInternal(eventType, callback, context, false, false);
        },

    /**
     * Remove an event handler for an event type from the model or collection object.
     * @param {String|Object=} eventType Types of event handlers to remove (may be a single event type, a space-delimited set of event types, or a map of events to callbacks). If omitted, remove all event handlers. 
     * @param {function(String, Object)=} callback If provided, remove handlers only for eventType events with the given callback function. 
     * @param {Object=} context If provided, remove handlers only for eventType events with the given callback function and context object. 
     */
    'off': function(eventType, callback, context) {
             return this._offInternal(eventType, callback, context, false);
        },
    
    /**
     * Fire the given event type(s) for all registered handlers.
     * @param {String} eventType Types of event handlers to fire (may be a single event type or a space-delimited set of event types). 
     */        
    'trigger': function(eventType) {
                 var args = Array.prototype.slice.call(arguments);
                 // Inject a silent setting in there: if this is being called outside we want to fire all relevant events
                 args.unshift(false);
                 return oj.Events.TriggerInternal.apply(this, args);
             },
            
    /**
     * Add an event handler for an event type to the model or collection object, but only fire it once, then remove it from the list of handlers.
     * @param {String} eventType Types of event handlers to add (may be a single event type or a space-delimited set of event types). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     * @param {Object=} context A context for the event
     */
    'once': function(eventType, callback, context) {
                return this._onceInternal(eventType, callback, context, false);
            },
               
    /**
     * Add an event handler for an event type to a second model or collection object ("otherObj"), but track it on the called object.
     * @param {Object} otherObj Model or collection object on which to add this event handler. 
     * @param {String} eventType Types of event handlers to add (may be a single event type or a space-delimited set of event types). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     */
    'listenTo': function(otherObj, eventType, callback) {
                var eventArray, e, event, attr, eventString, listenerObj, index, prop, eventMap = {};

                if (eventType.constructor === String) {
                    // Create a map out of it
                    eventMap[eventType] = callback;
                }
                else {
                    eventMap = eventType;
                }
        
                for (prop in eventMap) {
                    if (eventMap.hasOwnProperty(prop)) {
                        eventArray = oj.Events._getEvents(prop);
                        for (e = 0; e < eventArray.length; e=e+1) {
                            event = eventArray[e].event;
                            attr = eventArray[e].attribute;
                            listenerObj = {event: event, attribute: attr, object: otherObj, callback: eventMap[prop]};
                            index = this._checkForHandler(this.listeningList, listenerObj, oj.Events._listenersIdentical);
                            eventString = attr ? event + ":" + attr : event;    
                            if (this.listeningList === undefined) {
                                this.listeningList = [];
                            }
//                            if (index === -1) {
                                this.listeningList.push(listenerObj);    
/*                           }
                            else {
                                // Replace it
                                this.listeningList[index] = listenerObj;
                                otherObj.off(eventString);
                            }*/
                            // fire
                            otherObj.OnInternal(eventString, eventMap[prop], null, true, false);
                        }
                    }
                }
                return this;
            },

    /**
     * Add an event handler for an event type to a second model or collection object ("otherObj"), but track it on the called object.  Only fire once.
     * @param {Object} otherObj Model or collection object on which to add this event handler. 
     * @param {String} eventType Types of event handlers to add (may be a single event type or a space-delimited set of event types). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     */
    'listenToOnce': function(otherObj, eventType, callback) {
                var eventArray, e, event, attr, eventString, listenerObj, index, prop, eventMap = {};

                if (eventType.constructor === String) {
                    // Create a map out of it
                    eventMap[eventType] = callback;
                }
                else {
                    eventMap = eventType;
                }
        
                for (prop in eventMap) {
                    if (eventMap.hasOwnProperty(prop)) {
                        eventArray = oj.Events._getEvents(prop);
                        for (e = 0; e < eventArray.length; e=e+1) {
                            event = eventArray[e].event;
                            attr = eventArray[e].attribute;
                            listenerObj = {event: event, attribute: attr, object: otherObj, callback: eventMap[prop]};
                            index = this._checkForHandler(this.listeningList, listenerObj, oj.Events._listenersIdentical);
                            eventString = attr ? event + ":" + attr : event;    
                            if (this.listeningList === undefined) {
                                this.listeningList = [];
                            }
//                            if (index === -1) {
                                this.listeningList.push(listenerObj);    
/*                            }
                            else {
                                // Replace it
                                this.listeningList[index] = listenerObj;
                                otherObj.off(eventString);
                            }*/
                            // fire
                            otherObj._onceInternal(eventString, eventMap[prop], null, true);
                        }
                    }
                }
                return this;
            },
            
    /**
     * Remove event handlers from a model or collection object. If the arguments are omitted, removes all event handlers from the model or collection.
     * @param {Object=} otherObj If specified, remove event handlers that target otherObj from this model or collection. 
     * @param {String=} eventType If specified, remove the event handlers for the given event types from this model or collection 
     * @param {function(String, Object)=} callback If specified, remove event handlers that call the given user callback function from this model or collection 
     */
    'stopListening': function(otherObj, eventType, callback) {
                        var eventArray, actualType, eventMap = {}, e, oneEvent, oneAttr, event, objEqual,
                                eventEqual, callbackEqual, attrEqual, i, prop, len, cb;
                        
                        if (arguments == null || arguments.length == 0) {
                            len = this.listeningList ? this.listeningList.length : 0;
                            // Remove everything
                            for (i = 0; i < len; i++) {
                                cb = this.listeningList[i].object._offInternal;
                                cb.apply(this.listeningList[i].object, [this.listeningList[i].event, this.listeningList[i].callback, this.listeningList[i].context, true]);
                            }
                            this.listeningList = [];
                            return this;
                        }

                        actualType = eventType;
                        // Account for missing otherObj
                        if (otherObj && otherObj.constructor === String) {
                            actualType = otherObj;
                        }
                        
                        if (actualType.constructor === String) {
                            // Create a map out of it
                            eventMap[actualType] = callback;
                        }
                        else {
                            eventMap = actualType;
                        }
        
                        for (prop in eventMap) {
                            if (eventMap.hasOwnProperty(prop)) {
                                eventArray = oj.Events._getEvents(prop);
                                for (e = 0; e < eventArray.length; e=e+1) {
                                    oneEvent = eventArray[e].event;
                                    oneAttr = eventArray[e].attribute;
                                    len = this.listeningList ? this.listeningList.length : 0;
                                    for (i = len-1; i >= 0; i=i-1) {
                                        event = this.listeningList[i];
                                        objEqual = otherObj ? otherObj === event.object : true;
                                        eventEqual = oneEvent ? oneEvent === event.event : true;
                                        callbackEqual = callback ? eventMap[prop] === event.callback : true;
                                        attrEqual = oneAttr ? oneAttr === event.attribute : true;
                                        if (objEqual && eventEqual && callbackEqual && attrEqual) {
                                            cb = this.listeningList[i].object._offInternal;
                                            cb.apply(this.listeningList[i].object, [this.listeningList[i].event, this.listeningList[i].callback, this.listeningList[i].context, true]);
                                            this.listeningList.splice(i, 1);
                                        }
                                    }                        
                                }
                            }        
                        }
                    return this;
                }
};

// Aliases for backward compatibility
oj.Events['bind'] =  oj.Events['on'];
oj.Events['unbind'] = oj.Events['off'];

/**
 * @export
 * Event types
 * @enum {string}
 */
  oj.Events.EventType = {
        /** Triggered when a model is added to a collection<p> 
         *  The event passes these arguments to the handler: <p>
         *  model - the model being added to the collection<p>
         *  collection - the collection to which the model has been added<p>
         *  options - any options passed in to the add call that triggered the event
         */
        'ADD' : "add",
        /** Triggered when a model is removed from a collection<p>
         *  The event passes these arguments to the handler: <p>
         * model - the model being removed from the collection<p>
         * collection - the collection from which the model was removed<p>
         * options - index: the index of the model being removed
         */
        'REMOVE' : "remove",
        /** Triggered when a collection is reset (see oj.Collection.reset)<p>
         *  The event passes these arguments to the handler: <p>
         *  collection - the collection being reset<p>
         *  options - any options passed in to the reset call
         */
        'RESET' : "reset",
        /** Triggered when a collection is refreshed (see oj.Collection.refresh)<p>
         *  The event passes these arguments to the handler: <p>
         *  collection - the collection being refreshed<p>
         *  options - any options passed in to the refresh call
         */
        'REFRESH' : "refresh",
        /** Triggered when a collection is sorted.  If the second argument to the callback is set (options) and 'add' is true, it means this sort event was triggered as a result of an add <p>
         *  The event passes these arguments to the handler:<p>
         *  collection - the collection being sorted<p>
         *  options - add: true if this sort event was triggered as the result of an add call, undefined or false if not
         */
        'SORT' : "sort",
        /** Triggered when a model's attributes are changed.  This can be the result of a clear call on a model; a property set call on a model; an unset call on a model; or the changing of properties due to the merging of models (in an add, for example) <p>
         * The event passes these arguments to the handler:<p>
         * model - the model on which the change occurred<p>
         * value - for property-specific change events, the new value of the property being changed<p>
         * options - any options passed in to the call that triggered the change event.  This is the second argument passed for overall change events, and the third parameter (after value) for property-specific change events.
         */
        'CHANGE' : "change",
        /** Triggered when a model is deleted from the data service (and thus from its Collection), due to a model destroy call<p>
         * The event passes these arguments to the handler:<p>
         * model - the model being deleted<p>
         * collection - the deleted model's collection, if any <p>
         */
        'DESTROY' : "destroy",
        /** Triggered by a collection during a remove call once all models passed in have been removed and destroyed<p>
         * The event passes these arguments to the handler:<p>
         * collection - the collection from which the models have been removed<p>
         * models - the array of models that have been removed <p>
         * options - any options passed in to the remove call
         */
        'ALLREMOVED': "allremoved",
        /** Triggered when a model or collection has sent a request to the data service <p>
         *  The event passes these arguments to the handler:<p>
         *  collection or model - the collection or model triggering the request<p>
         *  xhr - the xhr argument for the request<p>
         *  options - any options passed as part of the request<p>
         */
        'REQUEST' : "request",
        /** Triggered when a model or collection has been updated from the data service<p>
         *  The event passes these arguments to the handler:<p>
         *  collection or model - the collection or model that triggered the update<p>
         *  response - the response object from the data service<p>
         *  options - any options passed in to the call that triggered the update
         */
        'SYNC' : "sync",
        /** Triggered when a model has failed to update on the data service<p>
         *  The event passes these arguments to the handler:<p>
         *  collection or model - the collection or model that made the call that resulted in the error<p>
         *  xhr - the xhr argument for the failing request, if any<p>
         *  options - any options passed in to the call that triggered the failing request
         */
        'ERROR' : "error",
        /** Triggered when a model being saved or created or a model's property being set has been invalidated <p>
         * The event passes these arguments to the handler:<p>
         * model - the model on which the save or property set is invalid <p>
         * validationError - the model's validationError property<p>
         * options - any options passed in to the call that triggered the invalid event
         */
        'INVALID' : "invalid",
        /** Triggered for any of the above events <p>
         * The event passes the name of the actual event and then any arguments normally passed to that event following the name
         */
        'ALL' : "all"
    };
            

/**
 * @private
 * @param {Object} myClass
 * @param {Object=} source
 */
oj.Events.Mixin = function(myClass, source) {
    var methodName, obj = source || this;
    for (methodName in obj ) {
        if (typeof obj[methodName] === 'function' /*&& !Object.hasOwnProperty(myClass.prototype, methodName)*/ ) {
            myClass[methodName] = obj[methodName];
        }
    }
    // Make sure actual vars are own copies
    myClass.eventHandlers = {};
    myClass.listeningList = [];
};

oj.Events._onceInternal = function(eventType, callback, context, listenTo) {
    var eventArray, e, event, attr, eventMap, prop;
    
    eventMap = this._getEventMap(eventType, callback, context);

    for (prop in eventMap) {
        if (eventMap.hasOwnProperty(prop)) {
            eventArray = this._getEvents(prop);
    
            for (e = 0; e < eventArray.length; e=e+1) {
               event = eventArray[e].event;
               attr = eventArray[e].attribute;
               if (this.eventHandlers === undefined) {
                   this.eventHandlers = [];
               }
               if (this.eventHandlers[event] === undefined) {
                   this.eventHandlers[event] = [];
               }

               this.eventHandlers[event].push({callback: eventMap[prop], context: context, attribute: attr, once: true, fired: false, listen:listenTo});    
            }
        }
   }
   return this;
};

oj.Events._shouldFire = function(handler) {
    if (handler.once) {
        if (!handler.fired) {
            handler.fired = true;
            return true;
        }
        return false;
    }
    return true;
};

oj.Events.TriggerInternal = function(silent, eventType) {
    var eventArray = this._getEvents(eventType), e, event, attr, eventsToFire, handlers, i, args, allHandlers, callback;
                  
    eventsToFire = [];                  
    for (e = 0; e < eventArray.length; e=e+1) {  
        event = eventArray[e].event;
        attr = eventArray[e].attribute;
        // Do specific event...
        eventsToFire.push({event:event, attribute:attr});
    }
    for (e = 0; e < eventsToFire.length; e=e+1) {
      allHandlers = this._getHandlers(this.eventHandlers, oj.Events.EventType['ALL']);
      handlers = oj.Events._getHandlers(this.eventHandlers, eventsToFire[e].event, false);
      for (i=0; i < (handlers ? handlers.length : 0); i=i+1) {
            if (handlers[i].attribute === eventsToFire[e].attribute && handlers[i].callback) {
                args = Array.prototype.slice.call(arguments);                
                if (handlers && handlers[i] && handlers[i].once) {
                      // Remove it: only want to fire once--make sure we remove it from the original
                      //oj.Events._getHandlers(this.eventHandlers, eventsToFire[e].event, true).splice(i, 1);
                      this._removeHandler(oj.Events._getHandlers(this.eventHandlers, eventsToFire[e].event, true), handlers[i]);
                }
                if (handlers && handlers[i] && this._shouldFire(handlers[i])) {
                  callback = handlers[i].callback;
                  // If this isn't a silent firing or this handler always wants to be called, make the call
                  if (!silent || handlers[i].ignoreSilent) {
                    callback.apply(handlers[i].context || this, args.slice(2));
                  }
                }
            }
      }
            // Handle all
         for (i=0; i < (allHandlers ? allHandlers.length : 0); i=i+1) {
               args = Array.prototype.slice.call(arguments);
               if (args.length > 0) {
                   if (eventsToFire[e].attribute) {
                       args[1] = eventsToFire[e].event + ":" + eventsToFire[e].attribute;
                   }
                   else {
                      args[1] =  eventsToFire[e].event;
                   }
               }
               // All case--make sure to pass event name
               if (allHandlers && allHandlers[i] && allHandlers[i].callback && this._shouldFire(allHandlers[i])) {
                   callback = allHandlers[i].callback;
                   // If this isn't a silent firing or this handler always wants to be called, make the call
                   if (!silent || allHandlers[i].ignoreSilent) {
                      callback.apply(allHandlers[i].context || this, args.slice(1));
                   }
               }
               if (allHandlers && allHandlers[i] && allHandlers[i].once) {
                   // Remove it: only want to fire once
                   //this._getHandlers(this.eventHandlers, oj.Events.EventType['ALL'], true).splice(i, 1);
                   this._removeHandler(this._getHandlers(this.eventHandlers, oj.Events.EventType['ALL'], true), allHandlers[i]);
               }
           }

    }
    return this;    
};

oj.Events.OnInternal = function(eventType, callback, context, listenTo, ignoreSilent) {
    var eventMap, prop, eventArray, i, event, attr, eventObj;

    eventMap = this._getEventMap(eventType, callback, context);

    for (prop in eventMap) {
        if (eventMap.hasOwnProperty(prop)) {
            eventArray = this._getEvents(prop);

            for (i = 0; i < eventArray.length; i=i+1)
            {
                event = eventArray[i].event;
                attr = eventArray[i].attribute;
                if (this.eventHandlers === undefined) {
                    this.eventHandlers = [];
                }
                if (this.eventHandlers[event] === undefined) {
                    this.eventHandlers[event] = [];
                }

                eventObj = {callback: eventMap[prop], context: context, attribute:attr, listen: listenTo, ignoreSilent:ignoreSilent};
                if (this._checkForHandler(this.eventHandlers[event], eventObj, oj.Events._handlersIdentical) === -1) {
                    this.eventHandlers[event].push(eventObj);    
                }
            }
        }
    }
    return this;
};

oj.Events._offInternal = function(eventType, callback, context, listen) {
    var eventMap, prop;
     if (arguments == null || arguments.length == 0) {
         // Remove everything
         this.eventHandlers = {};
         return this;
     }

     if (eventType == null) {
         this._removeEvent(eventType, callback, context, listen);
         return this;
     }

     eventMap = this._getEventMap(eventType, callback, context);

     for (prop in eventMap) {
         if (eventMap.hasOwnProperty(prop)) {
             this._removeEvent(prop, eventMap[prop], context, listen);
         }
     }
     return this;
};
 


oj.Events._getEventMap = function(eventType, callback, context) {
    var eventMap = {};
    
    if (eventType.constructor === String) {
        // Create a map out of it
        eventMap[eventType] = callback;
    }
    else {
        eventMap = eventType;
        // If eventType is a map of events->callbacks, then the callback argument is now context
        context = callback;
    }
    return eventMap;
};

oj.Events._removeEvent = function(eventType, callback, context, listen) {
    var eventArray = [], e, i, event, attr, handlers, callbacks, contexts, attrs, listenEq;
    
    if (eventType) {
        eventArray = oj.Events._getEvents(eventType);
    }
    else {
        // Walk entire eventHandlers property list
        if (this.eventHandlers !== undefined) {
            for (event in this.eventHandlers) {
                if (this.eventHandlers.hasOwnProperty(event)) {
                    eventArray.push({event:event});
                }
            }
        }
    }
    
    for (e = 0; e < eventArray.length; e=e+1) {
        event = eventArray[e].event;
        attr = eventArray[e].attribute;
        if (this.eventHandlers !== undefined && this.eventHandlers[event] instanceof Array) {
            handlers = this.eventHandlers[event];
            for (i=handlers.length-1; i >= 0; i=i-1){
                callbacks = (callback === undefined || callback === null || handlers[i].callback == callback);

                contexts = (context === undefined || context === null || handlers[i].context == context);
                attrs = (attr === undefined || attr === null || handlers[i].attribute == attr);
                listenEq = (listen === undefined || listen === null || handlers[i].listen == listen);
                if (callbacks && contexts && attrs && listenEq){
                    handlers.splice(i, 1);
                    //break;
                }
            }
            if (handlers.length === 0) {
                // Delete the entry
                delete this.eventHandlers[event];
            }
        }
    }   
};

oj.Events._removeHandler = function(handlers, handler) {
    var i, callbacks, contexts, attrs, listenEq, onceEq;
    
    for (i=handlers.length-1; i >= 0; i=i-1){
        callbacks = (handler.callback === undefined || handler.callback === null || handlers[i].callback == handler.callback);

        contexts = (handler.context === undefined || handler.context === null || handlers[i].context == handler.context);
        attrs = (handler.attribute === undefined || handler.attribute === null || handlers[i].attribute == handler.attribute);
        listenEq = (handler.listen === undefined || handler.listen === null || handlers[i].listen == handler.listen);
        onceEq = (handler.once === undefined || handler.once === null || handlers[i].once == handler.once);
        if (callbacks && contexts && attrs && listenEq && onceEq){
            handlers.splice(i, 1);
        }
    }    
};

oj.Events._getEvents = function(eventString) {    
    var eventList = eventString ? eventString.split(" ") : [], retList = [], i, eventWithAttr, name, attr;
    for (i = 0; i < eventList.length; i=i+1) {
        eventWithAttr = eventList[i].split(":");
        name = eventWithAttr[0];
        attr = eventWithAttr.length > 1 ? eventWithAttr[1] : null;
        retList.push({event:name, attribute:attr});
    }
    return retList;
};

oj.Events._handlersIdentical = function(handler1, handler2) {
   return (handler1.callback === handler2.callback) && (handler1.attribute === handler2.attribute) && (handler1.context === handler2.context) && (handler1.listen === handler2.listen) && (handler1.once === handler2.once);
};

oj.Events._listenersIdentical = function(listener1, listener2) {
   return (listener1.event === listener2.event) && (listener1.attribute === listener2.attribute) && (listener1.context === listener2.context) && (listener1.object === listener2.object);    
};

oj.Events._checkForHandler = function(handlerList, handler, handlerTest) {
    var i;
    if (handlerList === undefined) {
        return -1;        
    }
    
    for (i = 0; i < handlerList.length; i=i+1) {
        if (handlerTest(handlerList[i], handler)) {
            return i;
        }
    }
    return -1;
};

oj.Events._getHandlers = function(handlers, eventType, original) {
    if (handlers && handlers[eventType] instanceof Array) {
        if (original) {
            return handlers[eventType];
        }
        // Make a copy
        var handlerReturn = [], i;
        for (i = 0; i < handlers[eventType].length; i++) {
            handlerReturn.push(handlers[eventType][i]);
        }
        return handlerReturn;
    }
    return null;
};

/**
 * Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.Model
 * @classdesc Object representing name/value pairs for a data service record
 *
 * @param {Object=} attributes Initial set of attribute/value pairs with which to seed this Model object 
 * @param {Object=} options 
 *                  collection: collection for this model
 * @constructor
 * @mixes oj.Events
 */
oj.Model = function (attributes, options) {
    oj.Model._init(this, attributes, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.Model, oj.Object, "Model.Model");
  
oj.Model.prototype.Init = function()
{
    oj.Model.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Model.
 * 
 * @type Object
 */
oj.Model.prototype.attributes = {};

/**
 * @export
 * @desc The set of attribute/value pairs that serve as default values when new Model objects are created.
 * 
 * @type Object
 */
oj.Model.prototype.defaults = {};

/**
 * @export
 * @desc The Model's unique ID.  This can be set by the application or retrieved from the data service. This ID will be appended to the URL for single-record data operations (update, delete). 
 * 
 * @type String
 */
oj.Model.prototype.id = null;

/**
 * @export
 * @desc The name of the model property to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type String
 */
oj.Model.prototype.idAttribute = null;

/**
 * @export
 * @desc The base url on the data service used to perform CRUD operations on models.  If not defined, the Model will look to its collection.  One or the other must be defined before CRUD operations can succeed.
 * 
 * @type String
 */
oj.Model.prototype.urlRoot = null;

/**
 * @export
 * @desc A callback to allow users to completely customize the data service URLs
 * The callback has the following parameters:
 * operation (String): one of create, read, update, patch, or delete indicating the type of operation for which to return the URL<p>
 * model (Object): the oj.Model object requesting the URL<p>
 * options (Object) : one or more of the following properties:<p>
 * recordID : id of the record involved, if relevant<p>
 * 
 * customURL functions should return either: null, in which case the default will be used; a string, which will be used with the standard
 * HTTP method for the type of operation, or an Object with any ajax attributes.  This must at minimum include the URL:<p>
 *  url: giving the custom URL string<p>
 *  type: (optional) a string indicating the type of HTTP method to use (GET, POST, DELETE, etc.)<p>
 *  (other): (optional) any other ajax attributes to pass in the ajax call
 *  
 * @type (function(string,Object):(string|null)|null)
 */
oj.Model.prototype.customURL = null;

oj.Model._idCount = 0;

oj.Model._init = function(model, attributes, options, properties) {
    var prop = null, parse, attrCopy;

    if (oj.Model._justExtending) {
        return;
    }

    model.Init();
    
    // Augment with Event
    oj.Events.Mixin(model);

    model._clearChanged();
    model.previousAttrs = {};
    model.nestedSet = false;
    model.index = -1;

    options = options || {};

    // Deep copy actual data if found

    model.attributes = {};
    if (model['defaults']) {
        model.attributes = oj.Model._cloneAttributes(oj.Model.IsFunction(model['defaults']) ? model['defaults']() : model['defaults'], null);
    }

    // First, copy all properties passed in
    for (prop in properties) {
        if (properties.hasOwnProperty(prop)) {
            model[prop] = properties[prop]; 
        }
    }

    if (attributes) {
        parse = options['parse'];
        if (oj.Model.IsFunction(parse)) {
            model['parse'] = parse;
        }
 
        attrCopy = oj.Model._cloneAttributes(attributes, model.attributes);
        
        attrCopy = parse ? model['parse'](attrCopy) : attrCopy;
        if (attrCopy == null || attrCopy === undefined) {
            // Reset it
            model.attributes = {};
        }
        else {
            // Move them in
            for (prop in attrCopy) {
                if (attrCopy.hasOwnProperty(prop)) {
                    model._setProp(prop, attrCopy[prop], false, false, options);
                }
            }
        }
    }

    model.SetCid();

    // Grab collection option, if there
    model.SetCollection(options['collection']);

    if (options['customURL']) {
        model['customURL'] = options['customURL'];
    }
    
    // If URL is set, use that
    if (options['url']) {
        model['url'] = options['url'];
    }

    if (options['urlRoot']) {
        model['urlRoot'] = options['urlRoot'];
    }

    if (model['initialize']) {
        model['initialize'](attributes, options);
    }
    
    model.SetupId();
};


/**
 * Create a new, specific type of Model object to represent single records from a JSON data set.
 * @param {Object=} properties Properties for the new Model class.<p>
 *                  defaults: an Object containing starting attribute/value pairs for some or all of the record's potential attributes<p>
 *                  parse: a user callback function to allow parsing of JSON record objects as they are returned from the data service<p>
 *                  parseSave: a user callback function to allow conversion of Models back into a format appropriate for the data service on save calls<p>
 *                  urlRoot: the URL to use to get records from the data service in the abscence of a collection (when an id is appended)<p>
 *                  initialize: a user callback function to be called when this model is created<p>
 *                  validate: a user callback function that will be called before a save to the data service occurs. The callback is passed the current set of attributes and save options. 
 * @param {Object=} classProperties properties that attach to the whole class
 * @return {function(new:Object, ...)} new Model object
 * @export
 * @this {Object}
 */
oj.Model.extend = function (properties, classProperties) {
    oj.Model._justExtending = true;
    var obj, prop;

    obj = new oj.Model();
    oj.Model._justExtending = false;

    // Add regular properties from this "parent"
    oj.Events.Mixin(obj, this.prototype);

    // Grab properties
    properties = properties || {};
    for (prop in properties) {
        if (properties.hasOwnProperty(prop)) {
            obj[prop] = properties[prop];
        }
    }

    var Model;
    
    if (properties && properties['constructor'] && properties.hasOwnProperty('constructor')) {
        Model =  properties['constructor'];
    }
    else {
        Model = function(attributes, options) {
            oj.Model._init(this, attributes, options, properties);
        }
    }

    Model.prototype = obj;
    
    // Allow extending resulting obj
    Model.extend = oj.Model.extend;

    Model.prototype.constructor = Model;
    

    // Add class properties from this
    oj.Events.Mixin(Model, this);
    
    if (classProperties) {
        for (prop in classProperties) {
            if (classProperties.hasOwnProperty(prop)) {
                Model[prop] = classProperties[prop];
            }
        }
    }

        
    return Model;
};

// Placeholder for event mixins
oj.Model.prototype.TriggerInternal = function (silent, event, arg1, arg2, options) {};

oj.Model.prototype.SetCid = function () {
    // Create cid property if necessary
    if (!this.GetCid()) {
        this['cid'] = 'id' + oj.Model._idCount;
        oj.Model._idCount = oj.Model._idCount+1;
    }
};

oj.Model.prototype.GetCid = function () { 
    return this['cid'];
};

// Index within collection
oj.Model.prototype.SetIndex = function(index) {
    this.index = index;
};

oj.Model.prototype.GetIndex = function() {
    return this.index;
};

// LRU functions
oj.Model.prototype.SetNext = function(model) {
    var retVal = this.nextModel;
    this.nextModel = model;
    return retVal;
};

oj.Model.prototype.GetNext = function() {
    return this.nextModel;
};

oj.Model.prototype.SetPrevious = function(model) {
    var retVal = this.previousModel;
    this.previousModel = model;
    return retVal;
};

oj.Model.prototype.GetPrevious = function() {
    return this.previousModel;
};

// Merge the given model's attributes with this model's attributes
oj.Model.prototype.Merge = function(model, comparator, silent) {
    var prop, needSort = false, isStringComparator = oj.StringUtils.isString(comparator),
        valueChange, changes = false;
    
    for (prop in model.attributes) {
        if (model.attributes.hasOwnProperty(prop)) {
            valueChange = (this.attributes[prop] != model.attributes[prop]);
            if (isStringComparator) {
                // We have a string comparator--does it match this property?  If we hit a property that doesn't match, we need sort
                if (prop === comparator) {
                    // The property matches the comparator property: are we changing the value?
                    if (valueChange) {
                        needSort = true;
                    }
                }
            }
            else {
                if (valueChange) {
                    needSort = true;
                }
            }
            if (valueChange) {
                changes = true;
                this.attributes[prop] = model.attributes[prop];
                this._addChange(prop, model.attributes[prop]);
                this._fireAttrChange(prop, this.attributes[prop], null, silent);
            }                
        }
    }
    this.SetupId();
    // Only fire master change if there were any changes
    if (changes) {
        this._fireChange(null, silent);
    }
    return needSort;
};

oj.Model._hasProperties = function(object) {
    var prop;
    if (object && object instanceof Object) {
        for (prop in object) {
            if (object.hasOwnProperty(prop)) {
                return true;
            }
        }
    }
    return false;
};

oj.Model.prototype.SetCollection = function(coll) {
    if (coll == null) {
        delete this['collection'];
        return;
    }
    this['collection'] = coll;
};

oj.Model.prototype.GetCollection = function() {
    return this['collection'];
};

oj.Model.prototype._fireAttrChange = function(prop, value, options, silent) {
    if (prop != null) {
        this.TriggerInternal(silent, oj.Events.EventType['CHANGE'] + ":" + prop, this, value, options);    
    }    
};

oj.Model.prototype._fireChange = function(options, silent) {
    var coll;
    
    this.TriggerInternal(silent, oj.Events.EventType['CHANGE'], this, options, null);        
};
    
oj.Model.prototype.SetupId = function() {
    // Replicate id attribute at top level
    var idAttr = this._getIdAttr();
    // Supposedly this should always be model.id...who knew?
    this['id'] = this.attributes != null ? this.attributes[idAttr] : null;
};

oj.Model.prototype._setPropInternal = function(prop, value, copyRegardless) {
    var equality = oj.Object.__innerEquals(this.attributes[prop], value);
    if (copyRegardless || !equality) {
        this.attributes[prop] = value;
        this.SetupId();
        // Return value management here seems bizarre due to backbone tests: do the direct set if copyRegardless, but only return if the
        // inner equals was different
        return !equality;
    }
    return false;
};

oj.Model.prototype._clearChanged = function() {
    this['changed'] = {};
};

oj.Model.prototype._addChange = function(property, value) {
    this['changed'][property] = value;
};

/**
 * @ignore
 * @param {Object||string} prop
 * @param {Object} value
 * @param {boolean} copyRegardless
 * @param {boolean} propertyBag
 * @param {Object=} options
 * @returns {boolean}
 */
oj.Model.prototype._setProp = function(prop, value, copyRegardless, propertyBag, options) {
    if (prop == null) {
        return true;
    }
    
    var attrs = {}, p, isNested = this.nestedSet, opts;
    opts = oj.Model._copyOptions(options);

    if (!propertyBag) {
        attrs[prop] = value;
    }
    else {
        // We've passed in a whole property bag at once: validate all together
        for (p in prop) {
            if (prop.hasOwnProperty(p)) {
                attrs[p] = prop[p];
            }
        }
    }
    opts = opts || {};    
    
    if (!this._checkValid(attrs, {'validate':opts['validate']}, false)) {
        return false;
    }
    
    if (!isNested) {
        this._clearChanged();
        this.changes = [];
    }
    
    // Store old value
    if (!this.nestedSet) {
        this.previousAttrs = oj.Model._cloneAttributes(this.attributes, null);
    }
    
    this.nestedSet = true;
    for (p in attrs) {
        if (attrs.hasOwnProperty(p)) {
            if (this._setPropInternal(p, attrs[p], copyRegardless)) {    
                // Trigger changes
                this._addChange(p, attrs[p]);
                this.changes.push(p);
            }
            else {
                delete attrs[p];
            }
        }
    }
    // Fire events: don't fire if silent 
    var silent = opts['silent'];
    for (p in attrs) {
        if (attrs.hasOwnProperty(p)) {
            if (!silent && (this.changes.length > 0 || (isNested && this.changes.indexOf(p) === -1))) {
                this.pendingChanges = true;
            }
            this._fireAttrChange(p, attrs[p], opts, silent);
        }
    }
    
    if (isNested) {
        return true;
    }
    if (!silent && !isNested) {
        while (this.pendingChanges) {
            this.pendingChanges = false;
            this._fireChange(opts, silent);
        }
    }    
    
    this.nestedSet = false;
    return true;
};

oj.Model.prototype._areTherePendingChanges = function() {
};

/**
 * @export
 * Clears all attributes from the model and fires a change event.  A change event is fired for each property and then an overall change event is fired.
 * @param {Object=} options silent: if true, do not fire the change event
 *                          validate: if true, validate the unsetting of all properties
 * @return {Object||boolean} the Model, or false if validation on clear fails
 */
oj.Model.prototype.clear = function(options) {
    // Use unset to silently clear, to track changes to attributes
    var prop, unsetOpt = {'silent':true}, silent;
    options = options || {};
    silent = options['silent'];
    unsetOpt['validate'] = options['validate'];
    this._clearChanged();
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            if (!this._unsetInternal(prop, unsetOpt, true)) {
                return false;
            }
            this.TriggerInternal(silent, oj.Events.EventType['CHANGE'] + ":" + prop, this, undefined, null);    
        }
    }
    this.attributes = {};
    this.SetupId();
    
    this._fireAttrChange(null, null, null, silent);
    this._fireChange(null, silent);
    return this;
};

oj.Model._cloneAttributes = function(oldData, newData) {    
    var prop;
    if (oldData === null) {
        return null;
    }
    newData = newData || {};
    var props = false;
    for (prop in oldData) { 
        props = true;
        if (oldData.hasOwnProperty(prop)){// && oldData[prop] !== undefined) {
            if (typeof(oldData[prop]) !== 'object') {
                // Only overwrite if not undefined
                if (newData.hasOwnProperty(prop)) {
                    if (oldData[prop] !== undefined) {
                        newData[prop] = oldData[prop];
                    }
                }
                else {
                    newData[prop] = oldData[prop];
                }
            }
            else {
                if (oj.Model.IsArray(oldData[prop])) {
                    // Handle arrays
                    if (oldData[prop] === null) {
                        newData[prop] = null;
                    }
                    else {
                        newData[prop] = [];
                        // Special case zero length array because of backbone unit test checking actual object value--strange
                        if (oldData[prop].length === 0) {
                            newData[prop] = oldData[prop];
                        }
                        else {
                            for (var i = 0; i < oldData[prop].length; i++) {
                                newData[prop].push(oj.Model._cloneAttributes(oldData[prop][i], null));
                            }
                        }
                    }
                }
                else {
                    newData[prop] = oj.Model._cloneAttributes(oldData[prop], null);
                }
            }
        }
    }
    if (props) {
        return newData;
    }
    if (typeof(oldData) === 'object') {
        return newData;
    }
    // Not an object: no-op
    return oldData;
};

/**
 * @export
 * Return a copy of the Model with identical attributes and settings
 */
oj.Model.prototype.clone = function() {
    var c = new this.constructor(), prop;
    
    for (prop in this) {
        // Shallow copy all but data
        if (this.hasOwnProperty(prop) && this[prop] !== this.attributes) {
            c[prop] = this[prop];
        }
    }
    // Deep copy data
    c.attributes = oj.Model._cloneAttributes(this.attributes, null);

    // Remove the cid--this should be unique
    delete c['cid'];    
    // Set a new cid
    c.SetCid();
    
    c.SetupId();
    
    return c;
};

// Does this model match the given id or cid?
oj.Model.prototype.Match = function(id, cid) {
    var modId = this.GetId(), modCid;
    if (modId !== undefined && modId == id) {
        return true;          
    }
    modCid = this['cid'];
    if (modCid !== undefined && modCid == cid) {
        return true;
    }
    return false;
};

/**
 * Set the value(s) of one or more attributes of the model, and fire events.
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in including "silent" to prevent events from firing, or "unset" to delete all the properties passed in rather than setting them
 * @returns {Object||boolean} the model itself, false if validation failed on set
 * @export
 */
oj.Model.prototype.set = function (property, value, options) {
    var opts = {}, ignoreLastArg = false, prop, i, valid = true;
    
    if (arguments) {
        if (arguments.length > 0) {
            // Check if the last argument is not the first argument
            if (arguments.length > 1) {
                if (arguments[arguments.length-1]) {
                    // Last arg is options: ignore later
                    ignoreLastArg = true;
                    opts = arguments[arguments.length-1] || {};
                }
            }
            // Check if first arg is property bag
            if (oj.Model._hasProperties(property)) {
                // For set, pass entire thing to setProp
                if (opts['unset']) {
                    for (prop in property) {
                        if (property.hasOwnProperty(prop)) {
                            this._unsetInternal(prop, null, false);
                        }
                    }
                }
                else {
                    if (!this._setProp(property, null, true, true, opts)) {
                        valid = false;
                    }
                }
            }
            else {
                // Not a property bag?  We assume it's a series of property/value arguments
                for (i = 0; i < arguments.length; i+=2) {
                    // Process the arg as long as its: defined, and isn't the last argument where we're supposed to ignore the last argument
                    // due to it being 'options'
                    if (arguments[i] !== undefined || i < arguments.length-1 || (!ignoreLastArg && i === arguments.length-1)) {
                        if (opts['unset']) {
                            this._unsetInternal(arguments[i], null, false);
                        }
                        else {
                            if (!this._setProp(arguments[i], arguments[i+1], false, false, opts)) {
                                valid = false;
                            }
                        }
                    }
                }
            }
        }
    }
    if (valid) {
        return this;
    }
    return false;
};

/**
 * Deletes the given property from the Model.
 * @param {string} property Property to remove from model 
 * @param {Object=} options do not fire change events if "silent" is set to true
 * @returns {boolean} false if validation of the unset fails
 * @export
 */
oj.Model.prototype.unset = function (property, options) {
    return this._unsetInternal(property, options, false);
};


oj.Model.prototype._unsetInternal = function (property, options, clear) {
    options = options || {};
    var silent = options['silent'], attrs = {};
    
    if (this.has(property)) {
        if (!this._checkValid(attrs, options, false)) {
            return false;
        }
        if (!clear) {
            this._clearChanged();
        }
        
        //attrs[property] = undefined;
        delete this.attributes[property];
        this._addChange(property, undefined);
        //if (!silent) {
            this._fireAttrChange(property, null, null, silent);
            this._fireChange(null, silent);
        //}
    }
    this.SetupId();
    return true;    
};

/**
 * Returns the value of the property from the Model.
 * @param {string} property Property to get from model 
 * @return {Object} value of property
 * @export
 */
oj.Model.prototype.get = function (property) {
    return this.attributes[property];
};

/**
 * Determines if the Model has a certain property set, vs. undefined.
 * @param {string} property Property to check for
 * @return {boolean} true if the model contains the given property
 * @export
 */
oj.Model.prototype.has = function (property) {
    return this.attributes[property] !== undefined && this.attributes[property] !== null;
};

/**
 * Loads the Model object from the data service URL. Performs a data "read."
 * @param {Object=} options Options to control fetch<p>
 * success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Model object, raw response, and the fetch options argument.<p>
 * error: a user callback function called if the fetch fails. The callback is called passing the model object, xhr, and options arguments. 
 * @export
 */
oj.Model.prototype.fetch = function (options) { 
    options = options || {};
    var success = options['success'], userErr = options['error'], self = this, opts;

    opts = oj.Model._copyOptions(options);
    opts['error'] = function(xhr, status, err) {
                        // Trigger an error event
                        self.TriggerInternal(false, oj.Events.EventType['ERROR'], self, xhr, options);

                        if (userErr) {
                            userErr.call(self, arguments);
                        }
                    };

    opts['success'] = function (response) {
            oj.Model._fireSyncEvent(self, response, opts, false);
            
            if (oj.Model.IsFunction(this['parse'])) {
                this.set(this['parse'](response), opts);
            }
             if (success) {
                 success.call(self, this, response, options);
             }};
    oj.Model._internalSync("read", this, opts);
};

oj.Model.prototype['parse'] = function (rawData) {
    return rawData;
};

/**
 * @export
 * Return the URL used to access this model in the data source
 * 
 * @returns {string|null} url to access this model in the data source
 */
oj.Model.prototype.url = function() {
    var urlRoot = this._getUrlRoot(), id = this.GetId(), coll, collUrl, slash;
    if (urlRoot) {
        return id ? urlRoot + '/' + encodeURIComponent(id) : urlRoot;
    }
    
    coll = this['collection'];
    if (coll) {
        if (oj.Model.IsFunction(coll['url'])) {
            collUrl = coll['url']();
        }
        else {
            collUrl = coll['url'];
        }
        if (id && collUrl) {
            slash = oj.Model._getLastChar(collUrl) == '/' ? '' : '/';
            return collUrl + slash + encodeURIComponent(this.GetId());
        }
        return collUrl;
    }
    
    throw "No URL defined";
};

/**
 * @export
 * Return all of the model's attributes as an array
 * 
 * @returns {Array} array of all the model's attributes
 */
oj.Model.prototype.keys = function() {
    var prop, retArray = [];
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            retArray.push(prop);
        }
    }
    return retArray;
};


/**
 * @export
 * Return all of the model's attributes values as an array
 * 
 * @returns {Array} array of all the model's attributes values
 */
oj.Model.prototype.values = function() {
    var prop, retArray = [];
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            retArray.push(this.get(prop));
        }
    }
    return retArray;
};

/**
 * @export
 * Return an array of attributes/value pairs found in the model 
 * 
 * @returns {Object} returns the model's attribute/value pairs as an array
 */
oj.Model.prototype.pairs = function() {
    var prop, retObj = [], item;
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            item = [];
            item.push(prop);
            item.push(this.get(prop));
            retObj.push(item);;
        }
    }
    return retObj;
};

/**
 * @export
 * Return attribute/value pairs for the model minus those attributes listed in keys
 * 
 * @param {Array||Object} keys keys to exclude from the returned attribute/value pairs
 * 
 * @returns {Object} array of the model's attribute/value pairs except those listed in keys
 */
oj.Model.prototype.omit = function(keys) {
    var keyArr = [], i, prop, retObj = {};
    
    if (keys instanceof Array) {
        keyArr = keys;
    }
    else {
        for (i = 0; i < arguments.length; i++) {
            keyArr.push(arguments[i]);
        }
    }
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            if (keyArr.indexOf(prop) == -1) {
                retObj[prop] = this.get(prop);
            }
        }
    }
    return retObj;
};

/**
 * @export
 * Return attribute/value pairs for the model for the keys
 * 
 * @param {Array||Object} keys keys for which to return attribute/value pairs
 * 
 * @returns {Object} array of the model's attribute/value pairs filtered by keys
 */
oj.Model.prototype.pick = function(keys) {
    var keyArr = [], i, retObj = {};
    
    if (keys instanceof Array) {
        keyArr = keys;
    }
    else {
        for (i = 0; i < arguments.length; i++) {
            keyArr.push(arguments[i]);
        }
    }
    for (i = 0; i < keyArr.length; i++) {
        if (this.attributes.hasOwnProperty(keyArr[i])) {
            retObj[keyArr[i]] = this.get(keyArr[i]);
        }
    }
    return retObj;
};

/**
 * @export
 * Return an array of value/attribute pairs found in the model 
 * 
 * @returns {Object} returns the model's value/attribute pairs as an array
 */
oj.Model.prototype.invert = function() {
    var prop, retObj = {}, val;
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            val = this.get(prop);
            retObj[val] = prop;
        }
    }
    return retObj;
};

oj.Model._getLastChar = function(str) {
    return str.charAt(str.length-1);
};

oj.Model.prototype._saveUrl = function() {
    var urlRoot = this._getUrlRoot();
    if (urlRoot) {
        return urlRoot;
    }
    
    if (this.GetCollection()) {
        return this.GetCollection()['url'];
    }
    
    return null;
    
};

oj.Model.prototype._getUrlRoot = function() {
    if (oj.Model.IsFunction(this['urlRoot'])) {
        return this['urlRoot']();
    }
    return this['urlRoot'];
};

oj.Model.prototype['parseSave'] = function (modelData) {
    return modelData;
};

/**
 * @export
 * Check to see if the model is valid by running the validate callback, if it exists
 * 
 * @returns {boolean} true if validate passes or if no validate callback
 */
oj.Model.prototype.isValid = function() {
    var options = {};
    options['validate'] = this['validate'];
    return this._checkValid(this.attributes, options, false);
};

oj.Model._isValidateSet = function(options, save) {
    options = options || {};
    if (options['validate'] !== undefined && options['validate'] !== null) {
        return options['validate'];
    }
    // The "default" is different for save vs. set
    return save;
};

oj.Model.prototype._checkValid = function(attributes, options, save) {  
    options = options || {};    
    var validate = this['validate'];
    if (validate && oj.Model._isValidateSet(options, save)) {
        // If we have a validate override and it returns something, don't save
        this['validationError'] = validate.call(this, attributes, options);
        if (this['validationError']) {
            this.TriggerInternal(false, oj.Events.EventType['INVALID'], this, this['validationError'], options);
            return false;
        }
    }        
    return true;
};

oj.Model._processArgs = function(args) {
    var ignoreLastArg = false, options = {}, prop, attributes = {}, i;
    
    if (args) {
        if (args.length > 0) {
            // Check if the last argument is not the first argument
            if (args.length > 1) {
                if (args[args.length-1] && oj.Model._hasProperties(args[args.length-1])) {
                    // Last arg is options: ignore later
                    ignoreLastArg = true;
                    options = args[args.length-1] || {};
                }
            }
            if (args[0] == null) {
                return {attributes:null,options:options};
            }
            
            // Check if first arg is property bag
            if (oj.Model._hasProperties(args[0])) {
                for (prop in args[0]) {
                    if (args[0].hasOwnProperty(prop)) {
                        attributes[prop] = args[0][prop];
                    }
                }
            }
            else {
                // Not a property bag?  We assume arguments are a series of attr/values
                for (i = 0; i < args.length; i+=2) {
                    // Process the arg as long as its: defined, and isn't the last argument where we're supposed to ignore the last argument
                    // due to it being 'options'
                    if (args[i] !== undefined || i < args.length-1 || (!ignoreLastArg && i === args.length-1)) {
                        attributes[args[i]] = args[i+1];
                    }
                }
            }
        }
    }    
    return {attributes:attributes, options:options};
};

oj.Model._copyOptions = function(options) {
    var optReturn = {}, prop;
    options = options || {};
    
    for (prop in options) {
        if (options.hasOwnProperty(prop)) {
            optReturn[prop] = options[prop];
        }
    }
    return optReturn;
};

/**
 * Saves the current Model object to the data service. Performs a data "update."
 * @param {Object=} attributes One or more attribute name/value pairs to set on the Model before the save. 
 * @param {Object=} options Options to control save<p>
 * success: a user callback called when the save has completed successfully. This makes the save an asynchronous process. The callback is called passing the Model object, response from the AJAX call, and the fetch options argument.<p>
 * error: a user callback function called if the save fails. 
 * contextType: in case the user's REST service requires a different POST content type than the default, 'application/json'
 * validate: should the validation routine be called if available
 * patch: should only changed attributes be sent via a PATCH?
 * @return {Object|boolean} returns false if validation failed
 * @export
 */
oj.Model.prototype.save = function (attributes, options) {    
    var forceNew, success, callback, self, userErr, patch, argResults = oj.Model._processArgs(arguments), opts, oldAttrs, attrArgs;
    attrArgs = attributes === undefined ? undefined : argResults.attributes;
    opts = oj.Model._copyOptions(argResults.options);

    if (!opts['wait']) {
        this.set(attrArgs);
    }
    
    if (!this._checkValid(this.attributes, opts, true)) {
        return false;
    }
    
    forceNew  = opts['forceNew'] === undefined ? false : opts['forceNew'];
    self = this;
    userErr = opts['error'];
    patch = opts['patch'];

    opts['error'] = function(xhr, status, err) {
                            // Trigger an error event
                            self.TriggerInternal(false, oj.Events.EventType['ERROR'], self, xhr, options);

                            if (userErr) {
                                userErr.call(self, arguments);
                            }
                        };
                        
    opts['saveAttrs'] = opts['wait'] ? this._attrUnion(attrArgs) : this.attributes;
    
    // Must temporarily at least set attrs for toJSON()
    oldAttrs = this.attributes;
    // Swap in what's to be saved and call toJSON()
    this.attributes = opts['saveAttrs'];
    opts['saveAttrs'] = this.toJSON();    
    this.attributes = oldAttrs;
    
    if (!forceNew && !this.isNew()) {
        success = opts['success'];
        opts['success'] = 
            function (resp, textStatus, jqXHR) {
                var attrs;
                
                if (resp) {
                    if (oj.Model.IsFunction(this['parse'])) {
                        attrs = this['parse'](resp);
                    }
                    else {
                        attrs = resp;
                    }
                    
                    self.attributes = attrs;
                    self.SetupId();
                }
                
                oj.Model._fireSyncEvent(self, resp, opts, false);
                if (success) {
                     success.call(oj.Model.GetContext(opts, self), self, resp, options);
                }
                self._clearChanged();
            };        
        if (attrArgs === undefined) {
            opts['attrs'] = undefined;
        }
        else {
            opts['attrs'] = patch ? attrArgs : opts['saveAttrs'];
        }
        return oj.Model._internalSync(patch ? "patch" : "update", this, opts);
    }
    
    callback = oj.Model._getSuccess(opts);
    opts['success'] = function(resp, status, xhr) {
       var attrs;
       if (resp) {
            if (oj.Model.IsFunction(self['parse'])) {
                attrs = self['parse'](resp);
            }
            else {
                attrs = resp;
            }
            if (!self._checkValid(attrs, opts, true)) {
                return;
            }
            self.attributes = attrs;
            self.SetupId();
       }
       if (opts['wait']) {
           self.set(attrArgs);
       }
       oj.Model._fireSyncEvent(self, resp, opts, false);
       
        if (callback) {
            callback.call(oj.Model.GetContext(opts, self), self, resp, options);
        }
        self._clearChanged();        
    };

    opts['attrs'] = opts['saveAttrs'];
    
    // Turn on parse flag
    opts['parse'] = true;

    return oj.Model._internalSync("create", this, opts);
};

oj.Model.prototype._attrUnion = function(attrs) {
    var attrReturn = {}, prop;
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            attrReturn[prop] = this.attributes[prop];
        }
    }
    for (prop in attrs) {
        if (attrs.hasOwnProperty(prop)) {
            attrReturn[prop] = attrs[prop];
        }
    }
    return attrReturn;
};

oj.Model.IsArray = function(obj) {
    return obj != null && obj.constructor === Array;
};

oj.Model.IsFunction = function(obj) {
    return obj instanceof Function;
};

oj.Model.IsComplexValue = function(val) {
    return val && val.hasOwnProperty("value") && val.hasOwnProperty("comparator");
};
    
// Does this model contain all of the given attribute/value pairs?
oj.Model.prototype._hasAttrs = function(attrs) {
    var prop;
    for (prop in attrs) {
        if (attrs.hasOwnProperty(prop)) {
            if (!this.attributes.hasOwnProperty(prop)) {
                return false;
            }

            var val = oj.Model.IsArray(attrs[prop]) ? attrs[prop] : [attrs[prop]];
            for (var i = 0; i < val.length; i++) {
                if (oj.Model.IsComplexValue(val[i])) {
                    var comparator = val[i]['comparator'];
                    var value = val[i]['value'];
                    if (oj.StringUtils.isString(comparator)) {
                        throw new Error("String comparator invalid for local where/findWhere");
                    }
                    if (!comparator(this, prop, value)) {
                        return false;
                    }
                } else {
                    // Array case meaningless here.  Model can't be == value1 and value2
                    if (attrs[prop] !== this.attributes[prop]) {
                        return false;
                    }
                }
            }
        }
    }    
    return true;
};

// See if this model contains any of the given attribute/value pairs 
oj.Model.prototype.Contains = function(attrs) {
    var attrList = (attrs.constructor === Array) ? attrs : [attrs], i;
    
    for (i = 0; i < attrList.length; i++) {
        if (this._hasAttrs(attrList[i])) {
            return true;
        }
    }
    return false;
};

oj.Model._getSuccess = function(options) {
    return options != null && options['success'] ? options['success'] : null;
};

oj.Model.GetContext = function(options, model) { 
    if (options !== undefined && options['context'] !== undefined) {
        return options['context'];
    }
    return model;
};

/**
 * Determines if this Model object has been assigned an id value yet. This indicates whether or not the Model's data has been saved to or fetched from the data service at any point.
 * @returns {boolean} true if the Model object has not had its id set yet, false if not.
 * @export
 */
oj.Model.prototype.isNew = function() {
    return this.GetId() == undefined;
};

oj.Model.prototype._getIdAttr = function () {
    return this['idAttribute'] || 'id';
};

oj.Model.prototype.GetId = function () {
    return this['id'];
};

/**
 * Return the set of attributes and values that have changed since the last fetch, or since the Model object was created. If attribute/value pairs are passed in, check those to see if they're different than the model.
 * Return false if there were no changes
 * @param {Object=} attributes One or more attribute/value pairs to check against the model for changes 
 * @return {Object||boolean} the set of all attribute value pairs that have changed since last update or save, if no attributes passed in; the set of all attribute value pairs that are different than those listed in the attributes parameter, if present.  False if no changes
 * @export
 */
oj.Model.prototype.changedAttributes = function(attributes) {
    if (attributes) {
        var internalChanges = {}, prop;
        for (prop in attributes) {
            if (attributes.hasOwnProperty(prop)) {
                if (!oj.Object.__innerEquals(attributes[prop], this.attributes[prop])) {
                    internalChanges[prop] = attributes[prop];
                }
            }
        }
        return oj.Object.isEmpty(internalChanges) ? false : internalChanges;
    }
    return oj.Object.isEmpty(this['changed']) ? false : this['changed'];
};

/**
 * Return true if the Model object has had any changes made to its values, or if any changes have been made to the optional set of attributes passed in.
 * @param {Array=} attribute One or more attributes to check for changes 
 * @returns {boolean} true if the Model object has had any changes since retrieval or last update at all (if no attributes parameter); true if the Model object has had changes to one or more of the passed-in attributes since retrieval or last update (if attributes parameter present).
 * @export
 */
oj.Model.prototype.hasChanged = function(attribute) {
    if (attribute !== undefined) {
        return oj.Model._hasProperties(this['changed']) && this['changed'].hasOwnProperty(attribute);
    }
    return oj.Model._hasProperties(this['changed']);
};


/**
 * Delete the record represented by this Model object from the data service.
 * @param {Object=} options Options for the destroy operation. They include success and/or error callback function upon the delete or failure of the delete. 
 * @export
 */
oj.Model.prototype.destroy = function (options) {
    options = options || {};
    var isWait = options['wait'], callback, context, userErr = options['error'], self = this, xhr, opts;
    
    opts = oj.Model._copyOptions(options);
    callback = oj.Model._getSuccess(opts);
    context = oj.Model.GetContext(opts, this);
    
    opts['success'] = function(data, status, xhr) {
        if (isWait) {
            self._fireDestroy(false);
        }
        oj.Model._fireSyncEvent(self, data, opts, false);
    
        if (callback) {
            callback.call(oj.Model.GetContext(opts, self), self, data, options);
        }
    };
    opts['error'] = function(xhr, status, err) {
                            // Trigger an error event
                            self.TriggerInternal(false, oj.Events.EventType['ERROR'], self, xhr, opts);

                            if (userErr) {
                                userErr.call(self, arguments);
                            }
                        };

    if (!this.isNew()) {
        xhr = oj.Model._internalSync("delete", this, opts);
        if (!isWait) {
            this._fireDestroy(false);
        }
        return xhr;
    }
    if (!isWait) {
        this._fireDestroy(false);
    }
    if (callback) {
        callback.call(oj.Model.GetContext(opts, self), self, null, options);
    }
    return false;
};

// Fire request event
oj.Model.prototype._fireRequest = function(model, xhr, options, silent) {
    this.TriggerInternal(silent, oj.Events.EventType['REQUEST'], model, xhr, options);
};
    
// Fire destroy event to all listeners
oj.Model.prototype._fireDestroy = function (silent) {
    this.TriggerInternal(silent, oj.Events.EventType['DESTROY'], this, this['collection'], null);
};

// Fire sync event to all listeners
oj.Model._fireSyncEvent = function(model, resp, options, silent) {
    model.TriggerInternal(silent, oj.Events.EventType['SYNC'], model, resp, options);
};

/**
 * Return a copy of Model's current attribute/value pairs
 * @return {Object} a copy of the Model's current set of attribute/value pairs.
 * @export
 */
oj.Model.prototype.toJSON = function() {
    var retObj = {}, prop;
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            if (Array.isArray(this.attributes[prop])) {
                retObj[prop] = this.attributes[prop].slice(0);
            }
            else {
                retObj[prop] = this.attributes[prop];
            }
        }
    }
    return retObj;
};

/**
 * @export
 * Return the previous value of the given attribute, if any.
 * 
 * @param {string} attr
 * @returns {Object} previous value of attr, if any.  If the attribute has not changed, returns undefined
 */
oj.Model.prototype.previous = function(attr) {
    return this.previousAttrs[attr];
};

/**
 * @export
 * Return a copy of the model's previously set attributes
 * 
 * @returns {Object} a copy of the model's previous attributes
 */
oj.Model.prototype.previousAttributes = function() {
    return this.previousAttrs;
};

/**
 * Performs communications with the server.  Can be overridden/replaced by clients
 * 
 * @param {string} method "create", "read", "update", or "delete"
 * @param {Object} model Model to be read/saved/deleted/created
 * @param {Object=} options to control sync
 * success: called if sync succeeds
 * error: called if sync fails
 * others are passed to jQuery
 * 
 * @return {Object} xhr object
 * @alias oj.Model.protoype.sync
 */
oj.Model.prototype['sync'] = function(method, model, options) {    
    return window['oj']['sync'](method, model, options);
};

// Internal processing before sync-- we want this stuff to happen even if user replaces sync
oj.Model._internalSync = function(method, model, options) {
    options = options || {};
    // If Model/Collection has OAuth object, then create Authorization header (see oj.RestImpl.addOptions)
    if(model['oauth']) {
            options['oauthHeader'] = model['oauth']['getHeader']();
    }
    	
	// Make sure to transfer the data type if it's set on the calling object
    if (!options['dataType'] && model['dataType']) {
        options['dataType'] = model['dataType'];
    }
    if (!options['jsonpCallback'] && model['jsonpCallback']) {
        options['jsonpCallback'] = model['jsonpCallback'];
    }
    
    // Do parsing if necessary and tuck it on options
    if (method === "create" || method === "patch" || method === "update") {
        options.parsedData = model['parseSave'].call(model, method==="patch" ? model['changed'] : options['saveAttrs']);
    }
    return model['sync'](method, model, options);
};

/**
 * @export
 * Master server access method for all models and collections
 * @param {string} method "create", "read", "update", "patch", or "delete"
 * @param {Object} model Model (or Collection to be read) to be read/saved/deleted/created
 * @param {Object=} options to control sync
 * success: called if sync succeeds
 * error: called if sync fails
 * others are passed to jQuery
 * 
 * @return {Object} xhr object
 */
oj.sync = function(method, model, options) {
    function _fireAndReturn(xhr) {
        model._fireRequest(model, xhr, options, options['silent']);
        return xhr;        
    };
    
    options = options || {};
    var restService, success = options['success'], error = options['error'], cors, customURL, xhr;
    
    cors = options['dataType'] === 'jsonp' ? false : true;
    customURL = model['customURL'];
    
    if (method.valueOf() === "create") {
      restService = new oj.RestImpl(model._saveUrl(), customURL);
      return _fireAndReturn(restService.addRecord(options.parsedData, error, options, model));
    }

    if (method.valueOf() === "read") {
        if (model instanceof oj.Model) {
            restService = new oj.RestImpl(model.url(), customURL);
            return _fireAndReturn(restService.getRecord(success, error, model.GetId(), options, oj.Model.GetContext(options, model)));
        }
        // Collection fetch
        restService = new oj.RestImpl(model.GetCollectionFetchUrl(options), customURL);
        return _fireAndReturn(restService.getRecords(success, error, options, model));
    }
    
    restService = new oj.RestImpl(model.url(), customURL);
    var recordId = null;
    if (model instanceof oj.Model) {
        recordId = model.GetId();
    }
    if (method.valueOf() === "update") {
        return _fireAndReturn(restService.updateRecord(success, recordId, options.parsedData, error, options, model, false));
    }
    if (method.valueOf() === "patch") {
        return _fireAndReturn(restService.updateRecord(success, recordId, options.parsedData, error, options, model, true));
    }
    if (method.valueOf() === "delete") {
        return _fireAndReturn(restService.deleteRecord(recordId, error, options, model));
    }
    return null;
};


oj.Model._urlError = function(ajaxOptions) {
    if (!ajaxOptions['url']) {
        throw new Error('The url property or function must be specified');
    }
};

oj.ajax = function() {
    if (arguments && arguments.length > 0) {
        oj.Model._urlError(arguments[0]);
    }
    return $.ajax.apply(window['oj'], arguments);
};
/**
 * Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
/*jslint browser: true*/

/**
 * @export
 * @class oj.Collection 
 * @classdesc Collection of Model objects 
 * 
 * @param {Array=} models Set of model objects to put into collection at construction time 
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 * @mixes oj.Events
 */
oj.Collection = function(models, options) {
    if (oj.Collection._justExtending) {
        return;
    }

    // Initialize
    oj.Collection._init(this, models, options, null);
};

/**
 * @export
 * @desc Property specifying the model class object contained/used by the collection
 * 
 * @type Object
 */
oj.Collection.prototype.model = null;


/**
 * @export
 * @desc Total number of models in the collection (note that when the collection is virtual, not all may be available or currently fetched)
 * 
 * @type number
 */
oj.Collection.prototype.length = 0;

/**
 * @export
 * @desc Direct access to the Collection's list of Models.<br/>
 * Note that this property should not be used directly when a collection is paging (virtual).<br/>
 * Automatic fetches will not be triggered for undefined elements in the model.  Use at() instead.
 * 
 * @type Array 
 */
oj.Collection.prototype.models = [];

/**
 * @export
 * @desc The data service's URL on the server.
 * 
 * @type String
 */
oj.Collection.prototype.url = null;

/**
 * A callback to allow users to completely customize the data service URLs
 * @param {String} operation one of create, read, update, patch, or delete indicating the type of operation for which to return the URL<p>
 * @param {Object} collection the oj.Collection object requesting the URL<p>
 * @param {Object} options any of the following properties:<p>
 * recordID : id of the record involved, if relevant<p>
 * fetchSize : how many records to return.  If not set, return all.<p>
 * startIndex: Starting record number of the set to return.<p>
 * startID: Retrieve records starting with the record with the given unique ID. <p>
 * since: Retrieve records with timestamps after the given timestamp.<p>
 * until: Retrieve records with timestamps up to the given timestamp.  Default is "until"<p>
 * sort:  field(s) by which to sort, if set<p>
 * sortDir: sort ascending or descending (asc/dsc) <p>
 * query: a set of attributes indicating filtering that should be done on the server.  @see (@link where) for complete documentation of query values<p>
 * all: true (along with 'query', above) indicates that this is a findWhere or where type call that is expecting all models meeting the query condition to be returned<p>
 * 
 * @return {(function(string,Object,Object):(string|Object|null))|null} customURL callbacks should return either: null, in which case the default will be used; a string, which will be used with the standard
 * HTTP method for the type of operation, or an Object with any ajax attributes.  This must at minimum include the URL:<p>
 *  url: giving the custom URL string<p>
 *  type: (optional) a string indicating the type of HTTP method to use (GET, POST, DELETE, etc.)<p>
 *  (other): (optional) any other ajax attributes to pass in the ajax call
 * @export
 */
oj.Collection.prototype.customURL = function(operation, collection, options) {
    return null;
};

/**
 * A callback allowing users to extract their own paging/virtualization return values from their response
 * The callback is made with the raw data response to the collection fetch
 * @param {Object} response the raw data response coming back from the fetch
 * 
 * @return {(function(Object):(Object|null)|null)} customPagingOptions callbacks should return either null, in which case the Collection will look for the simple default properties, or
 * an object containing the one or more of the following attribute/value pairs (note that the Collection will look back to the response for default paging return properties if 
 * not returned in this object):<p>
 * 
 *                  totalResults: the total number of records available on the server side, not just in the current result.  Default is "totalResults"<p>
 *                  limit: the actual fetchSize used by the server in generating the result.  This may not be the client's fetchSize or the number of records in the current result.  Default is "limit".  This becomes the collection's "lastFetchSize" property<p>
 *                  count: the actual number of records returned by the server in the last result.  This becomes the collection's "lastFetchCount"<p>
 *                  offset: the actual starting record number of the current result.  Default is "offset"<p>
 *                  hasMore: boolean indicating whether or not there are more records available beyond the current result.  Default is "hasMore"<p>
 *                  
 * 
 * @export
 */
oj.Collection.prototype.customPagingOptions = function(response) {
    return null;
};


/**
 * @export
 * @desc The number of records brought back on the last fetch.
 * 
 * @type number
 */
oj.Collection.prototype.lastFetchSize = 0;

/**
 * @export
 * @desc Indicates whether or not there are more records available on the server, beyond the latest fetch.
 * 
 * @type boolean
 */
oj.Collection.prototype.hasMore = false;

/**
 * @export
 * @desc The total number of records available for this collection regardless of whether they have been fetched or not.  For non-virtual collections this will equal the length.
 * 
 * @type number
 */
oj.Collection.prototype.totalResults = 0;

/**
 * 
 * @export
 * @desc The number of records actually fetched the last time the collection went to the server.  This may or may not match fetchSize or limit
 * 
 * @type number
 */
oj.Collection.prototype.lastFetchCount = 0;

/**
 * @export
 * @desc The number of records to be kept in memory at any one time.  The default of -1 indicates that no records are thrown out
 * 
 * @type number
 */
oj.Collection.prototype.modelLimit = -1;

/**
 * @export
 * @desc The actual starting record number of the last fetch from the server.
 * 
 * @type number
 */
oj.Collection.prototype.offset = 0;

/**
 * @export
 * @desc The number of records to be fetched from the server in any one round trip.  The server's fetch size comes back as the "limit" property.  The default value of -1 indicates that virtualization/paging is not being used or is not available, and all records will be fetched.
 * and the number of records actually fetched comes back as "count"
 * 
 * @type number
 */
oj.Collection.prototype.fetchSize = -1;

/**
 * @export
 * @desc Sort direction for string-based field comparators.  A value of 1 (the default), indicates ascending sorts, -1 indicates descending.  Users should call sort() after changing sort direction to ensure that models in the collection are sorted correctly, or that there are no left over models sorted in a different sort order in the virtual case.
 *       
 * 
 * @type number
 */
oj.Collection.prototype.sortDirection = 1;

/**
 * @export
 * @desc If set, sort the collection using the given attribute of a model (if string); function(Model) returning a string attribute
 * by which the sort should take place; function(Model1, Model2) if a user-defined function comparing Model1 and Model2 (see the
 * JavaScript array.sort() for details)<p>
 * In the virtual case, comparator must be a string-based field comparator.  Users should call sort() after making any changes to the comparator to ensure that the models are correctly sorted, or that there are no leftover models sorted incorrectly in the virtual case.
 * 
 * @type {String|function(Object)|function(Object,Object)}
 */
oj.Collection.prototype.comparator = null;

/**
 * @export
 * @desc Set to true if sort is supported.  This will only be false if the collection is connected to a paging REST service that does 
 * not support sorting
 * 
 * @type boolean
 */
oj.Collection.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.Collection, oj.Object, "Collection.Collection");

oj.Collection.prototype.Init = function()
{
    oj.Collection.superclass.Init.call(this);
};

/**
 * Create a new, specific type of Collection object to represent a collection of records from a JSON data set.
 * @param {Object=} properties Properties for the new Collection class.<p>
 *                  parse: a user callback function to allow parsing of the JSON collection after it's returned from the data service<p>
 *                  model: the specific type of Model object to use for each member of the Collection<p>
 *                  url: the URL to use to get the record collection from the data service<p>
 *                  initialize: a user callback function to be called when this collection is created<p>
 *                  comparator: a user callback used on sort calls. May also be set to false to prevent sorting.<p>
 *                  fetchSize: the number of records to be fetched on each round trip to the server.  If not set, none of the paging/virtualization API will be invoked<p>
 *                  modelLimit: the number of records to be held in memory at any one time, if virtualization is in force.  The default is all records.  This uses an LRU algorithm to determine which to roll off as more records are added.<p>
 * @return {function(new:Object, ...)} new Collection object
 * @export
 */
oj.Collection.extend = function(properties)
{
    oj.Collection._justExtending = true;
    var obj = new oj.Collection();
    oj.Collection._justExtending = false;
          
    var Collection;
    if (properties && properties['constructor'] && properties.hasOwnProperty('constructor')) {
        Collection =  properties['constructor'];
    }
    else {
        Collection = function(models, options) {
                        oj.Collection._init(this, models, options, properties);
                    }
    }

    Collection.prototype = obj;
    
    Collection.prototype.constructor = Collection;
    return Collection;    
};


oj.Collection._init = function(collection, models, options, properties) {
    var prop, i, optionlist, modelList;

    collection.Init();
    
    // Augment with Event    
    oj.Events.Mixin(collection);

    // First, copy all properties passed in
    if (properties) {
        for (prop in properties) {
            if (properties.hasOwnProperty(prop)) {
                collection[prop] = properties[prop];
            }
        }        
    }

    // Check options
    options = options || {};
    optionlist = ["url", "comparator", "model", oj.Collection._FETCH_SIZE_PROP, "modelLimit", "customURL"];
    for (i = 0; i < optionlist.length; i++) {            
        if (options.hasOwnProperty(optionlist[i]) && options[optionlist[i]] !== undefined) {
            collection[optionlist[i]] = options[optionlist[i]];            
        }
    }
    if (collection._getFetchSize(null) === undefined) {
        collection.setFetchSize(-1);
    }
    if (collection['modelLimit'] === undefined) {
        collection.setModelLimit(-1);
    }
    collection['hasMore'] = false;
    collection.lruCount = 0;

    collection._setModels([]);
    if (options['parse']) {
        models = collection['parse'](models);
    }
    if (models != null && models !== undefined) {
        modelList = (models instanceof Array) ? models : [models];    
        for (i = 0; i < modelList.length; i=i+1) {
            collection.add(modelList[i], options);
        }
    }
    collection._setLength();
    
    if (properties && properties['initialize']) {
        properties['initialize'].call(collection, models, options);
    }    
};


// Placeholder for event mixins
oj.Collection.prototype.on = function (event, callback) {};
oj.Collection.prototype.OnInternal = function(event, callback, context, listenTo, ignoreSilent) {};
oj.Collection.prototype.TriggerInternal = function (silent, event, arg1, arg2, options) {};

// Fire request event
oj.Collection.prototype._fireRequest = function(collection, xhr, options, silent) {
    this.TriggerInternal(silent, oj.Events.EventType['REQUEST'], collection, xhr, options);
};

oj.Collection.prototype._setModels = function(models) {
    this['models'] = models;
};

oj.Collection.prototype._getModels = function() {
    return this['models'];
};

oj.Collection.prototype._getModelsLength = function() {
    return this._getModels().length;
};

// Designed to check if index exceeds the length of the models.  If we're in a virtual and "no totalResults" case, we're never over the upper limit
oj.Collection.prototype._overUpperLimit = function(index) {
    if (index < this._getModelsLength()) {
        return false;
    }
    if (this.__isVirtual()) {
        if (!this._hasTotalResults() || this._getModelsLength() === 0) {
            return false;
        }
    }
    return true;
};

oj.Collection.prototype._hasTotalResults = function() {
    return this['totalResults'] !== undefined && this['totalResults'] != null;
}

oj.Collection.prototype._pushModels = function(model) {
    // Model is being added to the end, it should be made the head
    this._makeModelHead(model);
    this._getModels().push(model);
    this.lruCount++;
    model.SetIndex(this._getModelsLength()-1);
};

oj.Collection.prototype._reduceLRU = function(removed) {
    if (removed) {
        for (var i = 0; i < removed.length; i++) {
            if (removed[i]) {
                this.lruCount--;
            }
        }
    }    
};

/**
 * @private
 * @param {number} start
 * @param {number} count
 * @param {Object=} model
 */
oj.Collection.prototype._spliceModels = function(start, count, model) {
    // Clean up prev/next links for models being removed
    for (var i = start; i < start + count; i++) {
        this._removePrevNext(this._getModels()[i]);
    }
    if (model === undefined) {
        this._reduceLRU(this._getModels().splice(start, count));
    }
    else {
        this._reduceLRU(this._getModels().splice(start, count, model));
        this._makeModelHead(model);
    }
    if (this.lruCount < 0) {
        this.lruCount = 0;
    }
    this._realignModelIndices(start);
};

oj.Collection.prototype._getModel = function(index) {
    return this._getModels()[index];
};

// Realign all the indices of the models (after sort for example)
oj.Collection.prototype._realignModelIndices = function(start) {
//    for (var i = start; i < this._getModelsLength(); i++) {
    this._getModels().forEach(function(model, i) {
        if (i >= start) {
            if (model) {
                model.SetIndex(i);
            }
        }
    });
};

// Update next/prev pointers as though the given model were being removed
oj.Collection.prototype._removePrevNext = function(model) {
    if (!model) {
        return;
    }
    
    var oldPrev = model.GetPrevious();
    var oldNext = model.GetNext();
    // Link the two surrounding previous/next elements to each other, because this one is being replaced and moved
    // to the head
    if (oldPrev) {
        oldPrev.SetNext(oldNext);        
    }
    else {
        // This element used to be the head
        this.head = oldNext;
    }
    if (oldNext) {
        oldNext.SetPrevious(oldPrev);
    }
    else {
        // This element used to be the tail
        this.tail = oldPrev;
    }    
};

oj.Collection.prototype._makeModelHead = function(model) {
    // Make this new model the most recently used: the head
    model.SetNext(this.head);
    if (this.head) {
        this.head.SetPrevious(model);
    }
    else {
        // No head: list is empty-->make tail the same element
        this.tail = model;
    }
    model.SetPrevious(null);
    this.head = model;    
};

oj.Collection.prototype._setModel = function(index, model) {
    var oldModel = this._getModels()[index];
    this._removePrevNext(oldModel);
    if (!oldModel) {
        // Newly "inserted" model
        this.lruCount++;
    }
    this._getModels()[index] = model;
    model.SetIndex(index);
    this._makeModelHead(model);
};

// Clean off n models from tail (oldest) of prev/next list
oj.Collection.prototype._clearOutModels = function(n) {
    var current = this.tail, index, model;
    var i = 0;
    this.tail = null;
    while (current && i < n) {
        // Erase this model from collection, iff it hasn't changed
        index = current.GetIndex();
        model = this._getModels()[index];
        if (!(model && model.hasChanged())) {
            this.lruCount--;
            if (index > -1) {
                this._getModels()[index] = undefined;
            }

            // Clear its pointers
            current.SetNext(null);
            current = current.SetPrevious(null);
            i++;
        }
        else {
            // Lock down the tail to this one we're not deleting
            if (!this.tail) {
                this.tail = current;
            }
            current = current.GetPrevious();
        }
    }
    // Make sure we set tail if not already set
    if (!this.tail) {
        this.tail = current;
    }
    if (this.lruCount < 0) {
        this.lruCount = 0;
    }
    if (this.lruCount === 0) {
        this.head = null;
        this.tail = null;
    }
};


// Reset the LRU list
oj.Collection.prototype._resetLRU = function() {
    this.lruCount = 0;
    this.head = null;
    this.tail = null;
};

// Make sure we have room in the LRU
oj.Collection.prototype._manageLRU = function(incoming) {
    if (this.__isVirtual()) {
        var limit = this._getModelLimit();
        if (limit > -1) {
            if (this.lruCount + incoming > limit) {
                // Must flush the amount over the limit
                this._clearOutModels(this.lruCount + incoming - limit);
            }
        }
    }
};

/**
 * @export
 * Return a copy of the Collection 
 * @return {Object} copy of the Collection
 */
oj.Collection.prototype.clone = function() {
    return this._cloneInternal(true);
};

oj.Collection.prototype._cloneInternal = function(withProperties) {
    var c = new this.constructor(), i;

    // Only copy locally if virtual
    var model;
    if (this.__isVirtual()) {
        c = this._copyProperties(c);
        c._resetModelsToFullLength();
    }
        
    if (withProperties) {
        // Try to copy models only if told to--we may only need the shell of the collection with properties
        for (i = 0; i < this._getLength(); i=i+1) {
            model = this._atInternal(i, null, true, false);
            if (model) {
                c._addInternal(model.clone(), {'at':i}, true, false);
            }
        }
    }
    return c;
};
    
// Copy critical properties in clone
oj.Collection.prototype._copyProperties = function(collection) {
    var props = ['totalResults', 'hasMore', oj.Collection._FETCH_SIZE_PROP], prop, i;
    for (i = 0; i < props.length; i++) {
        prop = props[i];
        collection[prop] = this[prop];
    }
    return collection;
};

oj.Collection.prototype._getLength = function() {
    return this['length'];
};

oj.Collection.prototype._setLength = function()
{
    var modelsLen = this._getModelsLength();
    this['length'] = modelsLen;    
    if (!this.__isVirtual()) {
        this['totalResults'] = modelsLen;
    }
};


oj.Collection.prototype._newModel = function(m, parse, options) {
    var newModel = null, validationValue;
    var opt = options || {};
    
    opt.noparse = !parse;

    if (m instanceof oj.Model) {
        newModel = m;
    }
    else {
        if (this['model']) {
            // model is defined
            if (oj.Model.IsFunction(this['model'])) {
                newModel = new this['model'](m, opt);
            }
            else {
                newModel = new this['model'].constructor(m, opt);
            }
        }
        else {
            newModel = new oj.Model(m, opt);
        }
    }    
    // Validate
    if (opt['validate'] && newModel['validate']) {
        validationValue = newModel['validate'](newModel.attributes);
        if (validationValue) {
            opt['validationError'] = validationValue;
            this.TriggerInternal(false, oj.Events.EventType['INVALID'], newModel, validationValue, opt);
            return null;
        }
    }
    return newModel;
};

/**
 * Add an instance of this collection's model(s) to the end of the collection.
 * Note that for virtual collections, if a new model is added after being saved up to the server, no add event will be fired as the 
 * collection will already "see" the model as existing.  Note that a warning will be logged if this add is not a force, not merging, and duplicate IDs are found.
 * @param {Object|Array} m Model object (or array of models) to add. These can be already-created instance of the oj.Model object, or sets of attribute/values, which will be wrapped by add() using the collection's model.
 * @param {Object=} options silent: if set, do not fire an add event<p>
 *                          at: splice the new model into the collection at the value given (at:index) <p>
 *                          merge: if set, and if the given model already exists in the collection (matched by id), then merge the attribute/value sets, firing change events<p>
 *                          sort: if set, do not re-sort the collection even if the comparator is set. <p>
 *                          force: if set to true, do an add to the collection no matter whether the item is found or not <p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * 
 * @returns {Object|Array} The model or models added to the collection (or found/merged if appropriate).  If deferred or virtual, return the model or models added in a promise when the set has completed
 * @export
 */
oj.Collection.prototype.add = function(m, options) {    
    this._manageLRU(1);
    var opt = options || {};
    return this._addInternal(m, options, false, opt['deferred']);
};

// fillIn: true indicates that we're just trying to use add() after a fetch to 
// insert into a preallocated list of models, not truly do an add/merge from the API
oj.Collection.prototype._addInternal = function(m, options, fillIn, deferred) {
    // Get options
    options = options || {};
    var modelArray = [], 
        at = options['at'],
        silent = options['silent'],
        force = options['force'],
        i, index, cid,
        merge = options['merge'] || false,
        sort = options['sort'], needSort = true, added = false,
        modelReturnList = [];

    if (m instanceof Array) {
        modelArray = m;
    }
    else {
        modelArray.push(m);
    }
    
    function addToCollection(collection, newModel) {
        if (at === undefined) {
            collection._pushModels(newModel);
            index = collection._getModelsLength()-1;
            collection._getModel(index).SetCid();
        }
        else {
            index = at;
            if (collection.__isVirtual() && fillIn) {
                // Array has been preallocated in this case
                collection._setModel(index, newModel);
            }                        
            else {
                collection._spliceModels(index, 0, newModel);
            }
            collection._getModel(index).SetCid();
            // Increment at so that later models will be added right after their predecessors, if an array is passed in
            at = at + 1;
        }
        if (newModel.GetCollection() === undefined) {
            newModel.SetCollection(collection);
        }
        collection._setLength();
        collection._listenToModel(newModel);
        added = true;
    }

    function resortAndFireEvents(collection, existingModel, modelFoundInCollection, newModel, deferred) {
        // Now resort if required (don't resort if either told not to, or if 'at' option is set) and if there's more than one model
        if (fillIn) {
            options = options || {};
            options['fillIn'] = true;
        }
        if (needSort && existingModel === undefined && !sort && at === undefined && collection._getLength() > 1) {
            if (index > -1) {
                cid = collection._getModel(index)['cid'];
            }
            var sortOpt = {};
            oj.CollectionUtils.copyInto(sortOpt, options);            
            sortOpt['add'] = true;
            collection.sort(sortOpt);
            // Reset index
            if (index > -1) {
                index = collection.indexOf(collection.getByCid(cid), deferred);
            }
        }

        if (/*!silent && */added) {
            if (newModel) {
                newModel.TriggerInternal(silent, oj.Events.EventType['ADD'], newModel, collection, options);
            }
            else {
                modelFoundInCollection.TriggerInternal(silent, oj.Events.EventType['ADD'], modelFoundInCollection, collection, options);
            }
        }    
    }
    
    function mergeAttrs(collection, modelToTryAndMerge, modelFoundInCollection, newModel, deferred) {
        var existingModel, modelAdded = null;
        
        if (!force && merge && modelFoundInCollection) {
            // Try to merge the attributes--we're merging and the model (by id) was already in the collection
            needSort = modelFoundInCollection.Merge(modelToTryAndMerge, collection['comparator'], silent);
            modelAdded = modelFoundInCollection;
        }
        else {
            // Make sure model is not already in there
            if (!force) {
                existingModel = collection._getLocal(newModel);
                if (existingModel && fillIn && at !== existingModel.index) {
                    // We're filling in a virtual collection: we should *not* be finding the new model already in the collection
                    // if we're not merging and not forcing: this indicates duplicate ids
                    //throw new Error("Duplicate IDs fetched or added without merging");
                    oj.Logger.warn("Duplicate ID fetched or added without merging, the id = " + existingModel.GetId());
                }
            }

            if (existingModel === undefined) {
                addToCollection(collection, newModel);
                modelAdded = newModel;
            }
            else {
                modelAdded = existingModel;
            }
        }        

        resortAndFireEvents(collection, existingModel, modelFoundInCollection, newModel, deferred);
        
        return modelAdded;
    }

    function doAdd(collection, model, deferred) {
        var newModel = collection._newModel(model, true, options), modelToTryAndMerge = null, modelFoundInCollection = null;
        if (newModel != null) {
            index = -1;
            // Make sure ID is up to date
            newModel.SetupId();

            // Use original model array not cloned model if merging--otherwise we won't find the model in the collection
            modelToTryAndMerge = model instanceof oj.Model ? model : newModel;
            if (deferred) {
                if (force) {
                    return oj.Object.__getPromise(function(resolve, reject) {
                        mergeAttrs(collection, modelToTryAndMerge, undefined, newModel, deferred);
                        resolve();
                    });
                }
                return collection._getInternal(modelToTryAndMerge, null, deferred, true).then(function (modInfo) {
                                                                    modelFoundInCollection = modInfo['m'];
                                                                    var mod = mergeAttrs(collection, modelToTryAndMerge, modelFoundInCollection, newModel, deferred);
                                                                    modelReturnList.push(mod);
                                                                 });
            }
            if (!force && merge) {
                // Grab the actual model we want to merge from the collection, if the caller has indicated that we aren't
                // forcing an add and we want to merge
                modelFoundInCollection = fillIn ? collection._getLocal(modelToTryAndMerge) : collection.get(modelToTryAndMerge);
            }
            var modelAdded = mergeAttrs(collection, modelToTryAndMerge, modelFoundInCollection, newModel, deferred);
            if (modelAdded) {
                modelReturnList.push(modelAdded);
            }
        }
    }
    
    if (!fillIn && (this.__isVirtual() || deferred)) {
        var self = this;
        return oj.Object.__getPromise(function(allResolve, allReject) {
            var doTask = function(index) {
                            return oj.Object.__getPromise(function(resolve, reject) {
                                doAdd(self, modelArray[index], true).then(function() {
                                    resolve(index);
                                });
                            });
            };

            var currentStep = doTask(0);
            var nextTask = function(j) {
                                return doTask(j+1);
            };

            for (i = 1; i < modelArray.length; i++) {
                currentStep = currentStep.then(nextTask);
            }
            currentStep.then(function() {
                allResolve(oj.Collection._returnModels(modelReturnList));
            });
        });
    }
    
    for (i = 0; i < modelArray.length; i++) {
        doAdd(this, modelArray[i], false);
    }
    return oj.Collection._returnModels(modelReturnList);
};

oj.Collection._returnModels = function(modelReturnList) {
    if (modelReturnList.length === 1) {
        return modelReturnList[0];
    }
    return modelReturnList;    
};
    
oj.Collection.prototype._hasComparator = function() {
    var comparator = this['comparator'];
    return comparator !== undefined && comparator !== null;
};

/**
 * @export
 * Sort the models in the collection
 * 
 * @param {Object=} options silent: if true, do not fire the sort event
 */
oj.Collection.prototype.sort = function(options) {
    options = options || {};
    var silent = options['silent'], comparator = this['comparator'], self;
    
    // Check for comparator
    if (!this._hasComparator()) {
        return;
    }
    
    // This is a no-op in case of virtualization: we should just clear things out so that
    // any elements will be refetched
    if (this.__isVirtual()) {        
        var totalResults =  this['totalResults'];
        if (totalResults !== undefined) {
            // Make sure to set up the array if the length changes (i.e., from 0 to totalResults--need to preallocate)
            this._setModels(new Array(totalResults));
        }
        else {
            // No totalresults
            this._setModels([]);
            this._resetLRU();
            this._setLength();
        }
        var eventOpts = options['add'] ? {'add':true} : null;
        this.TriggerInternal(silent, oj.Events.EventType['SORT'], this, eventOpts, null);
        return;
    }
    
    self = this;
    this._getModels().sort(function(a, b) {
                            return oj.Collection.SortFunc(a, b, comparator, self, self);
                        });
    this._realignModelIndices(0);
    // Indicate this sort is due to an add
    var eventOpts = options['add'] ? {'add':true} : null;
    this.TriggerInternal(silent, oj.Events.EventType['SORT'], this, eventOpts, null);
};

oj.Collection._getKey = function(val, attr) {
    if (val instanceof oj.Model) {
        return val.get(attr);
    }
    if (oj.Model.IsFunction(val[attr])) {
        return val[attr]();
    }
    return val[attr];
};

oj.Collection.SortFunc = function(a, b, comparator, collection, self) {
    var keyA, keyB, i, retVal;
    
    if (oj.Model.IsFunction(comparator)) {        
        // How many args?
        if (comparator.length === 1) {
            // "sortBy" comparator option
            keyA = comparator.call(self, a);
            keyB = comparator.call(self, b);
            var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(",") : [keyA];
            var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(",") : [keyB];
            for (i = 0; i < attrs1.length; i++) {                
                retVal = oj.Collection._compareKeys(attrs1[i], attrs2[i], collection['sortDirection']);
                if (retVal !== 0) {
                    return retVal;
                }
            }
        }
        // "sort" comparator option
        return comparator.call(self, a, b);
    }
    // String option
    if (oj.StringUtils.isString(comparator)) {
        var attrs = comparator.split(",");
        
        for (i = 0; i < attrs.length; i++) {
            keyA = oj.Collection._getKey(a, attrs[i]);
            keyB = oj.Collection._getKey(b, attrs[i]);
            retVal = oj.Collection._compareKeys(keyA, keyB, collection['sortDirection']);            
            if (retVal !== 0) {
                return retVal;
            }
        }
    }
    return 0;    
};

/**
 * @export
 * Return the index at which the given model would be inserted, using the collection comparator
 * 
 * @param {Object} model model for which to determine the insert point
 * @param {String|Object=} comparator optional comparator to override the default
 * @returns {number} index at which model would be inserted.  -1 if no comparator
 */
oj.Collection.prototype.sortedIndex = function(model, comparator) {
    var comp = comparator ? comparator : this['comparator'], self, test;
    
    // Check for comparator
    if (!comp) {
        return -1;
    }
    
    this._throwErrIfVirtual("sortedIndex");
    
    self = this;
    test = function(a, b) {
            var keyA, keyB;

            if (oj.Model.IsFunction(comp)) {        
                // How many args?
                if (comp.length === 1) {
                    // "sortBy" comparator option
                    keyA = comp.call(self, a);
                    keyB = comp.call(self, b);
                    var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(",") : [keyA];
                    var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(",") : [keyB];
                    var retVal, i;
                    for (i = 0; i < attrs1.length; i++) {                
                        retVal = oj.Collection._compareKeys(attrs1[i], attrs2[i], self['sortDirection']);
                        if (retVal !== 0) {
                            return retVal;
                        }
                    }
                }
                // "sort" comparator option
                return comp.call(self, a, b);
            }
            // String option
            if (oj.StringUtils.isString(comp)) {
                keyA = a.get(comp);
                keyB = b.get(comp);
                return oj.Collection._compareKeys(keyA, keyB, self['sortDirection']);            
            }
            return 0;
        };
    return oj.Collection._find(this._getModels(), model, test);
};


// Binary search and return the index at which model would be inserted into sorted modelArray
oj.Collection._find = function(modelArray, model, comparator) {
    function search(min, max) {
        var cid, id, mid;
        
        if (min > max) {
            return -1;
        }
        
        cid = model.GetCid();
        id = model.GetId();
        if (modelArray[min].Match(id, cid)) {
            return min;
        }
        if (modelArray[max].Match(id, cid)) {
            return max;
        }
        
        mid = Math.floor((max+min)/2);
        if (comparator(modelArray[mid], model) === -1) {
            return search(min+1, mid);
        }
        if (comparator(modelArray[mid], model) === 1) {
            return search(mid, max-1);
        }
        return mid;
    }
    
    return search(0, modelArray.length-1);
};

oj.Collection._compareKeys = function(keyA, keyB, sortDirection) {
    if (sortDirection === -1) {
        if (keyA < keyB) {        
            return 1;
        }
        if (keyB < keyA) {
            return -1;
        }
    }
    else {
        if (keyA > keyB) {        
            return 1;
        }
        if (keyB > keyA) {
            return -1;
        }
    }
    return 0;    
};


/**
 * @export
 * Add the given model to the front of the collection
 * @param {Object} m model to add to the beginning of the collection
 * @param {Object=} options see add
 * @return {Object} If this is a paging/virtual collection, this will return a Promise that will be called when the
 *                  operation is done.  Otherwise undefined
 */
oj.Collection.prototype.unshift = function(m, options) {
    // Like an add but set 'at' to zero if not specified
    var opt = {};
    oj.CollectionUtils.copyInto(opt, options || {});
    if (!opt['at']) {
        opt['at'] = 0;
    }
    this._manageLRU(1);
    return this._addInternal(m, opt, false, opt['deferred']);
};

/**
 * @export
 * Remove the first model from the collection and return it
 * @param {Object=} options same as remove, plus: <p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} model that was removed.  If this is a paging/virtual collection, this will return a Promise
 *                  which will call its done function, passing the model value that was removed
 */
oj.Collection.prototype.shift = function(options) {
    var deferred = this._getDeferred(options);
    if (this.__isVirtual() || deferred) {
        var self = this;
        return this.at(0, options).then(function (model) {             
            return self._removeInternal(model, 0, options);
        });
    }
    return this._removeInternal(this.at(0), 0, options);
};

/**
 * @export
 * Return an array of models found in the Collection, excepting the last n.
 * @param {number=} n number of models to leave off the returned array; defaults to 1
 * @return {Object} array of models from 0 to the length of the collection - n - 1
 */
oj.Collection.prototype.initial = function(n) {
    if (n === undefined) {
        n = 1;
    }
    
    var array = [], i;
    for (i = 0; i < this._getLength() - n; i=i+1) {
        array.push(this.at(i));
    }
    return array;
};

oj.Collection.prototype._getDeferred = function(options) {
   var opt = options || {};
   return opt['deferred'];
};

/**
 * @export
 * Return the last model in the Collection.  If n is passed in, then the last n models are returned as an array
 * Note that if the collection is virtual, and totalResults is not returned by the server, the results returned by last can be
 * difficult to predict.  They depend on the fetch sizes, last known offset of a fetch, etc.  If code is using a server that does not return
 * totalResults the use of last is not recommended.
 * @param {number=} n number of models to return.  Defaults to 1
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object|Array|null} array of n models from the end of the Collection.  If this is a paging/virtual collection,
 *                             this will return a Promise which will call its done function, passing the array or single model
 */
oj.Collection.prototype.last = function(n, options) {
    var deferred = this._getDeferred(options);
    if (n === undefined) {
        n = 1;
    }
    
    if (n === 1) {
        var len = this._getModelsLength();
        if (len === 0) {
            len = n;
        }
        if (len > 0) {
            return this.at(len-1, deferred);
        }
        return null;
    }
    
    var array = [], i;
    var len = this._getLength();    
    if (deferred || this.__isVirtual()) {
        // Loop using deferred
        var start = len-n;        
        
        // Handle edge or no totalResults cases
        if (start < 0) {
            start = 0;
        }
        if (len === 0) {
            // No totalresults, probably
            len = n;
        }

        return this.IterativeAt(start, len);
    }
                    
    for (i = len - n; i < len; i=i+1) {
        array.push(this.at(i));
    }
    return array;
};

// Loop calling at() in a deferred way and return a promise to be resolved when all the elements are sequentially fetched
oj.Collection.prototype.IterativeAt = function (start, end) {
    var array = [], i;
    var self = this;
    return oj.Object.__getPromise(function(allResolve, allReject) {
        var doTask = function(index) {
                        return oj.Object.__getPromise(function(resolve, reject) {
                            self._deferredAt(index, null).then(function(model) {
                                array.push(model);
                                resolve(index);
                            });
                        });
        };

        var currentStep = doTask(start);
        var nextTask = function(j) {
                            return doTask(j+1);
        };

        for (i = start+1; i < end; i++) {
            currentStep = currentStep.then(nextTask);
        }
        currentStep.then(function() {
                            allResolve(array);
                        });
    });
};

oj.Collection.prototype._getDefaultFetchSize = function(n) {
    if (n === undefined || n === null) {
        return this[oj.Collection._FETCH_SIZE_PROP];
    }
    else {
        return n;
    }
};

oj.Collection.prototype._calculateNextStart = function() {
    var lastFetch = this['lastFetchCount'];
    if (lastFetch === undefined || lastFetch === null) {
        lastFetch = this[oj.Collection._FETCH_SIZE_PROP];
    }
    if (this['offset'] === undefined || this['offset'] === null) {
        // Assume zero offset (0+lastFetch)
        return lastFetch;
    }
    return this['offset'] + lastFetch;   
};

/**
 * @export
 * Fetch the next set of models from the server.
 * 
 * @param {number} n number of models to fetch.  If undefined or null, the collection will attempt to use the overall fetchSize property value
 * @param {Object=} options Options to control next<p>
 *                  success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Collection object, raw response, and the options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the collection object, xhr, and options arguments.<p>
 * @return {Object} xhr object; null if nothing to fetch (the success callback will still be called)
 */
oj.Collection.prototype.next = function(n, options) {
    options = options || {};
    options[oj.Collection._FETCH_SIZE_PROP] = this._getDefaultFetchSize(n);
    
    var start = this._calculateNextStart();
    var length = this._getLength();
    if (length === 0 && options[oj.Collection._FETCH_SIZE_PROP] > 0) {
        // If we have a fetch size and we have no length let next() do a fetchSize fetch starting at zero to kick things off
        start = 0;
    } else if (start >= length) {
        // No op -- still call success because the items are already fetched.  
        var self = this;
        if (options['success']) {
            options['success'].call(oj.Model.GetContext(options, self), self, null, options);
        }
        
        return null;
    }
    options['startIndex'] = start;
    return this.fetch(options);
};

oj.Collection.prototype._calculatePrevStart = function(n) {
    if (this['offset'] === undefined || this['offset'] === null) {
        // Assume zero: we can't back up beyond that so if the offset wasn't set there's nothing to do
        return 0;
    }
    return this['offset'] - n;
};

/**
 * @export
 * Fetch the previous set of models from the server.
 * 
 * @param {number} n number of models to fetch.  If undefined or null, the collection will attempt to use the overall fetchSize property value
 * @param {Object=} options Options to control previous<p>
 *                  success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Collection object, raw response, and the options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the collection object, xhr, and options arguments.<p>
 * @return {Object} xhr object, or null if there is nothing earlier to fetch (no fetch has happened or the last fetch started at 0).  The success callback will still be called
 */
oj.Collection.prototype.previous = function(n, options) {
    options = options || {};
    if (this['offset'] === 0) {
        // No op -- still call success (if we've fetched before--lastFetchCount is other than zero) because the items are already fetched.  
        var self = this;
        if (options['success'] && this['lastFetchCount']) {
            options['success'].call(oj.Model.GetContext(options, self), self, null, options);
        }
        
        return null;
    }
    options[oj.Collection._FETCH_SIZE_PROP] = this._getDefaultFetchSize(n);
    var start = this._calculatePrevStart(options[oj.Collection._FETCH_SIZE_PROP]);
    if (start < 0) {
        // Only fetch from 0 to the last fetch's starting point...
        options[oj.Collection._FETCH_SIZE_PROP] = this['offset'];
        start = 0;
    }
    options['startIndex'] = start;
    return this.fetch(options);
};


/**
 * @export
 * Set or change the number of models held at any one time
 * 
 * @param {number} n maximum number of models to keep at a time
 */
oj.Collection.prototype.setModelLimit = function(n) {
    this['modelLimit'] = n;
    // Clean out down to the new limit, if necessary
    this._manageLRU(0);
};

oj.Collection.prototype._getModelLimit = function() {
    return this['modelLimit'];
};

/**
 * Set or change the number of models to fetch with each server request
 * 
 * @param {number} n number of models to fetch with each request
 * @export
 */
oj.Collection.prototype.setFetchSize = function(n) {
    this[oj.Collection._FETCH_SIZE_PROP] = n;
};



/**
 * @export
 * Return the array of models found in the Collection starting with index n.
 * @param {number=} n index at which to start the returned array of models.  Defaults to 1.
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} array of models from the Collection
 */
oj.Collection.prototype.rest = function(n, options) {
    var deferred = this._getDeferred(options);
    if (n === undefined) {
        n = 1;
    }
    
    var array = [], i;
    if (this.__isVirtual() || deferred) {
        return this.IterativeAt(n, this._getLength());
    }
    
    for (i = n; i < this._getLength(); i=i+1) {
        array.push(this.at(i));
    }
    return array;
};

/**
 * Remove a model from the collection, if found.  Will fire an allremoved event once all the models have been removed.
 * @param {Object|Array} m Model object or array of Models to remove. 
 * @param {Object=} options silent: if set, do not fire destroy or allremoved events 
 * @export
 */
oj.Collection.prototype.remove = function(m, options)
{
    options = options || {};
    var modArray = [], mod;
    
    if (m instanceof Array) {
        modArray = m;
    }
    else {
        modArray.push(m);
    }
    
    for (mod = modArray.length-1; mod >= 0; mod=mod-1) {
        this._removeInternal(modArray[mod], -1, options);
    }
    this.TriggerInternal(options['silent'], oj.Events.EventType['ALLREMOVED'], this, modArray, options);
};

oj.Collection.prototype._removeInternal = function(model, index, options) {
    options = options || {};
    var modInfo = index == -1 ? this._getInternal(model) : oj.Collection._getModinfo(index, model), 
        silent = options['silent'];
    
    index = modInfo.index;
    if (index > -1) {
        var mod = modInfo['m'];
        // only unset the collection setting if it's mine
        if (mod !== undefined && mod.GetCollection() === this) {
            mod.SetCollection(null);
        }
        this._spliceModels(index, 1);
        this._setLength();
        //if (!silent) {
            var opt = {};
            oj.CollectionUtils.copyInto(opt, options);
            opt['index'] = index;
            if (mod !== undefined) {
                mod.TriggerInternal(silent, oj.Events.EventType['REMOVE'], mod, this, opt);
            }
      //  }
        // Unlisten after event fired
        this._unlistenToModel(mod);        
    }
    return modInfo['m'];
};


oj.Collection.prototype._unlistenToModel = function(m) {
    if (m !== undefined) {
        m.off(null, null, this);
    }
};

oj.Collection.prototype._listenToModel = function(m) {
    m.OnInternal(oj.Events.EventType['ALL'], this._modelEvent, this, false, true);
};

// Handle model destroyed events via the all listener
oj.Collection.prototype._modelEvent = function(event, model, collection, options) {
    var args;
    
    if (event === oj.Events.EventType['DESTROY']) {
        this.remove(model);
    }
    
    // Don't process general events if we're not the target
    if (collection !== undefined && collection instanceof oj.Collection && collection !== this) {
        return;
    }

    // Throw up to the collection
    args = Array.prototype.slice.call(arguments);
    var silent = options && options['silent'];
    this.TriggerInternal(silent, event, model, collection, options);
};

/**
 * Clear all data from the collection and refetch (if non-virtual).  If virtual, clear all data.  In both cases, fire a refresh event
 * if silent is not set
 * @param {Object=} options user options<p>
 *                          silent: if set, do not fire a refresh event<p>
 * @return {Object} promise object triggering done when complete (in case there is a fetch for non-virtual mode)
 * @export
 */
oj.Collection.prototype.refresh = function(options)
{
    options = options || {};
    
    var self = this;
    return oj.Object.__getPromise(function(resolve, reject) {
        if (!self.__isVirtual()) {
            // Do a reset, with silent
            self.reset(null, {'silent':true});
            // Local: do a fetch to fill back up
            self.fetch({'success': function (collection, response, options) {
                            var silent = options['silent'] !== undefined && options['silent'];
                            self.TriggerInternal(silent, oj.Events.EventType['REFRESH'], self, options, null);
                            resolve({'collection':collection, 'response':response, 'options':options});                                    
                        },
                        'error': function (xhr, status, error) {
                            reject({'collection':self, 'xhr':xhr, 'status':status, 'error':error});
                        }
                        });
            return;        
        }
        // Virtual
        var totalResults =  self['totalResults'];
        if (totalResults !== undefined) {
            self._setModels(new Array(totalResults));
            self._resetLRU();
        }
        var silent = options['silent'] !== undefined && options['silent'];
        self.TriggerInternal(silent, oj.Events.EventType['REFRESH'], self, options, null);
        resolve();        
    });
};

/**
 * Remove and replace the collection's entire list of models with a new set of models, if provided. Otherwise, empty the collection.
 * @param {Object=} data Array of model objects or attribute/value pair objects with which to replace the collection's data. 
 * @param {Object=} options user options, passed to event, unless silent<p>
 *                          silent: if set, do not fire events<p>
 * @export
 */
oj.Collection.prototype.reset = function(data, options)
{
    options = options || {};    
    options['previousModels'] = this._getModels();

//    for (i = 0; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model) {
        if (model) {
            this._unlistenToModel(model);
            model.SetCollection(null);
        }
    }, this);
    this._setModels([]);
    this._resetLRU();
    
    if (data) {
        // Parse collection
        if (options['parse']) {
            data = this['parse'](data);
        }
        
        if (data instanceof Array) {
            this._manageLRU(data.length);
            for (var i = 0; i < data.length; i=i+1) {
                this._addInternal(data[i], options, true, false);
            }
        }
        else {
            this._manageLRU(1);
            this._addInternal(data, options, true, false);
        }
    }
    this._setLength();
    
    var silent = options['silent'] !== undefined && options['silent'];
    this.TriggerInternal(silent, oj.Events.EventType['RESET'], this, options, null);
};

/**
 * Return the model object found at the given index of the collection, or a promise object that will return the model to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the model object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the collection is virtual
 * @return {Object} Model object located at index. If index is out of range, returns null.  If this is a paging/virtual collection or
 *                  if deferred is specified and true, at will return a Promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 */
oj.Collection.prototype.at = function(index, options)
{
    var deferred = this._getDeferred(options);
    return this._atInternal(index, options, false, deferred);
};

// Local indicates that only what's stored locally should be returned (if true)--no fetching
oj.Collection.prototype._atInternal = function(index, options, local, deferred) {
    if (index < 0 || this._overUpperLimit(index)) {
        return null;
    }
    if (!local && (this.__isVirtual() || deferred)) {
        return this._deferredAt(index, options);
    }
    return this._getModel(index);
};

oj.Collection.prototype._deferredAt = function(index, options) {
    var self = this;
    // If it's virtual, we need to see if this item has been fetched or not: if not, we need to fetch it + fetchSize
    var model = self._getModel(index);
    if (model === undefined) {
        return oj.Object.__getPromise(function(resolve, reject) {
            // Go fetch
            var opts = {};
            oj.CollectionUtils.copyInto(opts, options || {});
            opts['context'] = self;
            opts['startIndex'] = index;
            opts['error'] = function(collection, error, options) {
                // Handle potential errors
                reject(error);
                return;
            }

            self._fetchInternal(opts, -1, false).then(function () {
                    resolve(self._getModel(index));
               }, function(e) { reject(e);});
        });
    }
    return oj.Object.__getPromise(function(resolve, reject) {
        resolve(model);                   
    });
};

/**
 * Return the first model object from the collection whose client ID is the given model cid
 * @param {string} clientId Client ID (see Model cid) for which to return the model object, if found. 
 * @return {Object} First model object in the collection where model.cid = clientId. If none are found, returns null.
 * 
 * @throws {Error} when called on a virtual/paging Collection if the item isn't found in memory
 * @export
 */
oj.Collection.prototype.getByCid = function(clientId)
{
//    for (i = 0; i < this._getModelsLength(); i=i+1)
    var foundModel = null;
    this._getModels().some(function(model) {
        if (model !== undefined && clientId === model['cid']) {
            foundModel = model;
            return true;
        }
        return false;
    });
    if (foundModel) {
        return foundModel;
    }
    if (this.__isVirtual()) {
        throw new Error("Not found locally and not supported by server for virtual collections");
    }
    return null;
};


/**
 * Return the first model object from the collection whose model id value is the given id or cid, or the id or cid from a passed in model
 * Note this method will not function as expected if the id or cid is not set
 * @param {Object|string} id ID, cid, or Model (see Model id or cid) for which to return the model object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} First model object in the collection where model.id = id or model.cid = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the model when done
 * @export
 */
oj.Collection.prototype.get = function(id, options)
{
    var deferred = this._getDeferred(options);
    var internalGet = this._getInternal(id, options, deferred);
    if (internalGet) {
        // Is this a deferred object?
        if ($.isFunction(internalGet.then)) {
            return oj.Object.__getPromise(function(resolve, reject) {
                internalGet.then(function(modInfo) {
                    resolve(modInfo['m']);
                });
            });
        }
        if (this.__isVirtual()) {
            return oj.Object.__getPromise(function(resolve, reject) {
                resolve(internalGet['m']);
            });
        }
        if (internalGet.hasOwnProperty('m')) {
            return internalGet['m'];
        }
    }
    return null;
};

oj.Collection.prototype._getLocal = function(id) {
    var internalGet = this._getLocalInternal(id);
    if (internalGet) {
        return internalGet['m'];
    }
    return null;
};

oj.Collection.prototype._getLocalInternal = function(id) {
    var cid = id;
    if (id instanceof oj.Model) {
        // Get the cid
        cid = id.GetCid();
        // Get the id
        id = id.GetId();
    }
    else if (id !== undefined && id != null && id['id'] !== undefined) {
        id = id['id'];
    }
//    for (i = 0; i < len; i=i+1)
    var foundObj = null;
    this._getModels().some(function(model, i) {
        if (model !== undefined && model.Match(id, cid)) {
            foundObj = oj.Collection._getModinfo(i, model);
            return true;
        }
        return false;
    });
    if (foundObj) {
        return foundObj;
    }
    return oj.Collection._getModinfo(-1, undefined);
};

/**
 * @private
 * @param {Object|null|string} id
 * @param {Object=} options
 * @param {boolean=} deferred
 * @param {boolean=} fillIn
 * @returns {Object}
 */
oj.Collection.prototype._getInternal = function(id, options, deferred, fillIn) {
    var cid = id;
    if (fillIn === undefined) {
        fillIn = false;
    }
    if (id instanceof oj.Model) {
        // Get the cid
        cid = id.GetCid();
        // Get the id
        id = id.GetId();
    }
    else if (id !== undefined && id != null && id['id'] !== undefined) {
        id = id['id'];
    }
    
//    for (i = 0; i < this._getModelsLength(); i=i+1)
    var foundObj = null;
    this._getModels().some(function(model, i) {
        if (model !== undefined && model.Match(id, cid)) {
            var retObj =  oj.Collection._getModinfo(i, model);
            foundObj = retObj;
            return true;
        }
        return false;
    });
    
    if (foundObj) {
        if (deferred) {
            return oj.Object.__getPromise(function(resolve, reject) {
                resolve(foundObj);
            });
        }
        return foundObj;
    }
    // If virtual, might be undefined because it needs to be fetched
    if (this.__isVirtual()) {
        // Try to fetch using start ID.  cid not supported
        if (id === undefined && cid !== undefined) {
            return oj.Object.__getPromise(function(resolve, reject) {
                resolve(oj.Collection._getModinfo(-1, undefined));
            });
        }
        var self = this;
        return oj.Object.__getPromise(function(resolve, reject) {
            var resp = function (resp) {
                            if (resp != null) {                            
                                var index = self._getOffset();
                                // Check that the model at index is the right one
                                var model = self._getModel(index);
                                if (model !== undefined && model.Match(id, cid)) {
                                    resolve(oj.Collection._getModinfo(index, model));
                                }
                                else {
                                    resolve(oj.Collection._getModinfo(-1, undefined));
                                }
                            }
                            else {
                                resolve(oj.Collection._getModinfo(-1, undefined));
                            }
                       };

            // Go fetch
            var opts = {};
            oj.CollectionUtils.copyInto(opts, options || {});
            opts['context'] = self;
            opts['startID'] = id;
            opts['error'] = function(collection, error, options) {
                // Handle potential errors
                reject(error);
            }

            self._fetchInternal(opts, -1, fillIn).then(resp, function(e) { reject(e);});
        });
    }
    
    var undefinedModInfo = oj.Collection._getModinfo(-1, undefined);
    if (deferred) {
        return oj.Object.__getPromise(function(resolve, reject) {
            resolve(undefinedModInfo);
        });
    }
    return undefinedModInfo;
};
    
oj.Collection._getModinfo = function(index, model) {
    return {index: index, 'm': model};
};

oj.Collection.prototype['parse'] = function (response) {
    var prop;
    
    // Try to interpret ADFbc like controls where a collection is hanging off a property
    if (response instanceof Array) {
        return response;
    }
    
    if (!response) {
        return response;
    }
    
    // See if any of the properties contain arrays
    for (prop in response) {
        if (response.hasOwnProperty(prop)) {
            if (response[prop] instanceof Array) {
                return response[prop];
            }
        }
    }
    return response;
};

/**
 * 
 * @export
 * Tell the Collection to try and ensure that the given range is available locally.  
 * 
 * @param {number} start starting index to make local
 * @param {number} count number of elements to make local
 * @return {Object} a promise Object that calls done upon completion.  The promise will be passed an Object containing start and count properties that represent
 * the *actual* starting position and count of the items fetched, which may be fewer than what was requested
 */
oj.Collection.prototype.setRangeLocal = function(start, count) {
    var actual = this._getLocalRange(start, count);
    if (actual.start === start && actual.count === count) {
        return oj.Object.__getPromise(function (resolve, reject) {
            resolve(actual);
        });
    }
    
    // Manage the LRU - set model limit at least as high as the count we're trying to fetch
    var modelLimit = this._getModelLimit();
    if (modelLimit > -1 && modelLimit < count) {
        this['modelLimit'] = count;
    }
    var self = this;
    return oj.Object.__getPromise(function (resolve, reject) {
        self._setRangeLocalInternal(start, count, -1, {start:start, count:count}, resolve, reject, true);
    });
}
  
oj.Collection.prototype._setRangeLocalInternal = function(start, count, placement, original, resolve, reject, fill) {
    var self = this;
    var resp = function () {
                    var actual = self._getLocalRange(original.start, original.count);
                    if (fill && self._hasTotalResults() && actual.count < original.count) {
                        // The range wasn't fulfilled: try again                       
                        var newPlacement = actual.start + actual.count;
                        // Try the next block...don't repeat the request
                        var newStart = start + count;
                        if (newStart < self['totalResults']) {
                            self._setRangeLocalInternal(newStart, count, newPlacement, original, resolve, reject, fill);
                        }
                        else {
                            // Can't go any further
                            resolve(actual);
                        }
                    }
                    else {
                        resolve(actual);
                    }
               };
               
    // Go fetch
    var limit = this._getMaxLength(start, count);   
    // Get the greater of the limit-start or fetchSize
    if (this[oj.Collection._FETCH_SIZE_PROP] && this[oj.Collection._FETCH_SIZE_PROP] > limit-start) {
        limit = this[oj.Collection._FETCH_SIZE_PROP] + start;
    }
    // Adjust for no totalResults
    if (!this._hasTotalResults() && limit < start + count) {
        // We shouldn't be limited by the size of the current storage
        limit = start+count;
    }    

    // Now, to optimize, move start up to the first undefined model in the sequence
    var newStart = this._getFirstMissingModel(start, limit);
    if (newStart > start) {
        start = newStart;
        // Recheck the limit
        limit = this._getMaxLength(newStart, count);
    }
    var opts = this.__isVirtual() ? {'context': this, 'startIndex': start, 'fetchSize': limit-start} : {'context': this};
    opts['error'] = function(collection, error, options) {
        // Handle potential errors
        reject(error);
        return;
    }
    this._fetchInternal(opts, placement, placement > -1).then(resp, function(e) { reject(e);});
};

oj.Collection.prototype._getMaxLength = function(start, count) {
    var len = this._getModelsLength();
    if (len === 0) {
        // This is an exception: could be uninitialized
        return start + count;
    }
    return start + count > len ? len : start + count;    
};

/**
 * @export
 * Determine if every element of the given range is filled in locally
 * 
 * @param {number} start starting index to make local
 * @param {number} count number of elements to make local
 * @return {boolean} true if all elements are local, false otherwise
 */
oj.Collection.prototype.isRangeLocal = function(start, count) {
    var localRange = this._getLocalRange(start, count);
    return start === localRange.start && count === localRange.count;
};

// For a given range of models, return the actual range which are local within that set.  
oj.Collection.prototype._getLocalRange = function(start, count) {
    // Not virtual, local if there are any models
    if (!this.__isVirtual()) {
        if (this._getModelsLength() > 0) {
            return {start:start, count:count};
        }
        return {start:start, count:0};
    }
    var limit = this._getMaxLength(start, count);
    // Adjust for no totalResults
    if (!this._hasTotalResults() && limit < start + count) {
        // We don't know if it's local or not
        return {start:start, count:0};
    }
    if (limit === 0) {
        // There nothing here
        return {start:start, count:0};
    }
    var firstMissingModel = this._getFirstMissingModel(start, limit);
    if (firstMissingModel > -1) {
        return {start:start, count:(firstMissingModel-start)};
    }
    return {start:start,count:count};
};

// Return the first model between start and limit that's undefined
oj.Collection.prototype._getFirstMissingModel = function(start, limit) {
    for (var i = start; i < limit; i++) {
        if (this._getModel(i) === undefined) {
            return i;
        }
    }
    return -1;
};

/**
 * Loads the Collection object from the data service URL. Performs a data "read."
 * @param {Object=} options Options to control fetch<p>
 *                  success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Collection object, raw response, and the fetch options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the collection object, xhr, and options arguments.<p>
 *                  add: if set, new records retrieved from the data service will be added to those models already in the collection. If not set, the records retrieved will be passed to the reset() method, effectively replacing the previous contents of the collection with the new data.  Not supported for virtual/paging cases.<p>
 *                  set: if true, fetch will try to use the set function to try and merge the fetched models with those already in the collection, on the client.  The default behavior is to reset the collection before adding back in the fetched models.  This default is the reverse of Backbone's current default.
 *                  startIndex: numeric index with which to start fetching Models from the server.  The page setting controls the number of Models to be fetched.  startID takes precedence over startIndex if both are specified.  If both are specified and startID isn't supported then startIndex will be used instead.<p>
 *                  startID: unique ID of the Model to start fetching from the server.  The page setting controls the number of Models to be fetched.  Note if this is not supported by the server then startID will be ignored.<p>
 *                  since: fetch records having a timestamp since the given UTC time
 *                  until: fetch records having a timestamp up to the given UTC time
 *                  fetchSize: use specified page size instead of collection's setting
 * @return {Object} xhr object
 * @export
 */
oj.Collection.prototype.fetch = function (options) {
    return this._fetchInternal(options, -1, false);
};

// fillIn is used to indicate that this fetch is just the result of a get() or part of an add(), etc., when virtual
oj.Collection.prototype._fetchInternal = function(options, placement, fillIn) {
    function doReset(collection, opt, fillIn) {
        if (!collection.__isVirtual()) {
           // If we're not doing a "fetch add", delete all the current models
           if (!opt['add'] && !opt.useset) {
                // Reset with internal model
                collection.reset();
            }
        }
        else {
            // If we're not infilling based on an at, get, etc., delete all the current local models
            if (!fillIn) {
               collection._resetModelsToFullLength();
            }
        }
    }
    
    var opt = options || {}, success = opt['success'], self;

    if (opt['set']) {
        opt.useset = opt['set'] ? true : false;
    }
 
    // Set up the parsing option
    if (opt['parse'] === undefined) {
        opt['parse'] = true;
    }
    self = this;
    
    opt['success'] = function (response, status, xhr) {
        // Pull any virtualization properties out of the response
        self._setPagingReturnValues(response, options);
        
        // Run the entire returned dataset through the collection's parser (either default no-op or user specified)
        var data = self['parse'](response, options);
        var dataList = null;
                
        if (!opt['add'] && !self['model']) {
             // We're not doing a "fetch add" and we don't have a model set on the collection
             if (!fillIn) {
                if (self.__isVirtual()) {
                    // Virtual case only
                    // Clean out the collection
                    doReset(self, opt, fillIn);
                    
                    var manageLRU = false;
                    // Check for passed in offset
                    if (placement === -1) {
                        manageLRU = true;
                        placement = self._getOffset();
                    }
                    // Put the new data in
                    dataList = self._putDataIntoCollection(data, placement, manageLRU);
                }
                else {
                    // New backbone option to not reset
                    if (opt.useset) {
                        self._setInternal(data, false, opt, false);
                    }
                    else {
                        // Replace the data in the collection with a new set (non virtual)
                        self.reset(data);             
                    }
                }
             }
         }
         else {     
             // We have a model and/or we're doing a "fetch add"
             // Clean out the old models if we're not "adding" or infilling for virtual
             doReset(self, opt, fillIn);
             
             // Parse each returned model (if appropriate), and put it into the collection, either from the zeroth offset if non-virtual
             // or using the appropriate offset if virtual
             try {
                var manageLRU = false;
                // Check for passed in offset
                if (placement === -1) {
                    manageLRU = true;
                    placement = self._getOffset();
                }
                dataList = self._fillInCollectionWithParsedData(data, placement, manageLRU, opt);
             }
             catch (e) {
                 if (opt['error']) {
                     opt['error'].call(oj.Model.GetContext(options, self), self, e, options);
                 }
                 return;
             }
         }
         if (self.__isVirtual()) {
             // Take in the number of records actually fetched
             if (dataList) {
                 self['lastFetchCount'] = dataList.length;
             }
         }
         
         // Fire the sync event
         self.TriggerInternal(false, oj.Events.EventType['SYNC'], self, response, opt);
         // Call the caller's success callback, if specified
         if (success) {
              success.call(oj.Model.GetContext(options, self), self, response, opt);
         }
     };
     // Make the actual fetch call using ajax, etc.
     return this._fetchCall(opt);
};

// Puts server data into an empty virtual collection using a "silent add"
oj.Collection.prototype._putDataIntoCollection = function(data, placement, manageLRU) {
    var dataList;
    
    if (data) {
       dataList = (data instanceof Array) ? data : [data];  
            
       var addOpt = {};
       // Only manage the LRU if we're not trying to achieve a range
       if (manageLRU) {
            this._manageLRU(dataList.length);
       }
       var insertPos = placement;
       var virtual = this.__isVirtual();
       var prevItem = null;
       for (var i = 0; i < dataList.length; i=i+1) {
           if (virtual) {
               addOpt = {'at': insertPos};
               prevItem = this._atInternal(insertPos, null, true, false);
           }
           // Don't fire add events
           addOpt['silent'] = true;           
           this._addInternal(dataList[i], addOpt, true, false);
           // If virtual, make sure the item was really added where we thought--in other words, what's there now shouldn't match what was there
           // otherwise could be duplicate id and don't increment counter
           if (this._atInternal(insertPos, null, true, false) !== prevItem) {
               insertPos++;
           }
       }
    }           
    return dataList;
};

// Parse each model returned, if appropriate, and push them into the (empty) collection with appropriate offsets if virtual
oj.Collection.prototype._fillInCollectionWithParsedData = function(data, placement, manageLRU, opt) {
    opt = opt || {};
    var parse = opt['parse'];
    var modelInstance = oj.Collection._createParsingModel(this);

    if (data) {
       var dataList = (data instanceof Array) ? data : [data];  

       var addOpt = {}, parsedModel;
       
       // Only manage the LRU if we're not trying to achieve a range
       if (manageLRU) {
            this._manageLRU(dataList.length);
       }
       var virtual = this.__isVirtual();
       if (opt.useset && !virtual) {
           // New backbone option
           for (var i = 0; i < dataList.length; i=i+1) {
               if (modelInstance && parse) {
                   parsedModel = modelInstance.parse(dataList[i]);
               }
               else {
                   parsedModel = dataList[i];
               }

               dataList[i] = parsedModel;
           }
           this._setInternal(dataList, false, opt, false);
       }
       else {
            var prevItem = null;
            var insertPos = placement;
            for (var i = 0; i < dataList.length; i=i+1) {
                if (modelInstance && parse) {
                    parsedModel = modelInstance.parse(dataList[i]);
                }
                else {
                    parsedModel = dataList[i];
                }

                if (virtual) {
                    addOpt = {'at': insertPos};
                    prevItem = this._atInternal(insertPos, addOpt, true, false);
                }
                // Don't fire add events
                addOpt['silent'] = true;
                this._addInternal(parsedModel, addOpt, true, false);
                // If virtual, make sure the item was really added where we thought--in other words, what's there now shouldn't match what was there
                // otherwise could be duplicate id and don't increment counter
                if (this._atInternal(insertPos, null, true, false) !== prevItem) {
                    insertPos++;
                }           
            }
        }    
    }
    return dataList;
};
    
// Used in virtualization to conduct server-based searches: returns list of fetched models via a promise but does not add them to the collection
// model list
oj.Collection.prototype._fetchOnly = function(options) {
    var opt = options || {},
        success = opt['success'], 
        parsedModel, self;

    if (opt['parse'] === undefined) {
        opt['parse'] = true;
    }
    self = this;
    
    opt['success'] = function (response, status, xhr) {
        var i, modelInstance;
        
        var data = self['parse'](response, options), dataList = null, fetchedModels = [];
                
        if (!opt['add'] && !self['model']) {
            dataList = (data instanceof Array) ? data : [data];              
         }
         else {
             modelInstance = oj.Collection._createParsingModel(self);
             
             if (data) {
                dataList = (data instanceof Array) ? data : [data];  
                
                for (i = 0; i < dataList.length; i=i+1) {
                    if (modelInstance && opt['parse']) {
                        parsedModel = modelInstance.parse(dataList[i]);
                    }
                    else {
                        parsedModel = dataList[i];
                    }
                    fetchedModels.push(self._newModel(parsedModel));
                }
             }
         }
         
         self.TriggerInternal(false, oj.Events.EventType['SYNC'], self, response, opt);
         if (success) {
              success.call(oj.Model.GetContext(options, self), self, fetchedModels, opt);
         }
     };
     return this._fetchCall(opt);
};

oj.Collection._createParsingModel = function(collection) {
    if (collection['model']) {
        // Create model instance to use for parsing
        if (oj.Model.IsFunction(collection['model'])) {
           return new collection['model']();
        }
        return new collection['model'].constructor();
    }
};

oj.Collection.prototype._fetchCall = function(opt) {
     try {
        return oj.Model._internalSync("read", this, opt);
     }
     catch (e) {
         // Some kind of error: trigger an error event
        this.TriggerInternal(false, oj.Events.EventType['ERROR'], this, null, opt);
        throw e;
     }
 };

oj.Collection.prototype._resetModelsToFullLength = function() {
    var totalResults =  this['totalResults'];
    if (totalResults !== undefined && this._getModelsLength() !== totalResults) {
        // Make sure to set up the array if the length changes (i.e., from 0 to totalResults--need to preallocate)
        this._setModels(new Array(totalResults));
        this._resetLRU();
        this._setLength();
        return true;
    }
    return false;
};

oj.Collection.prototype._getFetchSize = function(options) {
    options = options || {};
    return options[oj.Collection._FETCH_SIZE_PROP] || this[oj.Collection._FETCH_SIZE_PROP];
};

// Are we doing virtualization/paging?
oj.Collection.prototype.__isVirtual = function() {
    return this._getFetchSize(null) > -1;
};

oj.Collection.prototype._getReturnProperty = function(customObj, response, property, optionValue, defaultValue) {
    var value = parseInt(oj.Collection._getProp(customObj, response, property), 10);
    if (value === undefined || value === null || isNaN(value)) {
        // use fetchsize            
        return optionValue ? optionValue : defaultValue;
    }
    return value;
};

// Parse out some of the paging return values we might expect in a virtual response
oj.Collection.prototype._setPagingReturnValues = function(response, options) {
    var customObj = {};
    // See if there's a custom call out
    if (this['customPagingOptions']) {
        customObj = this['customPagingOptions'].call(this, response);
        if (!customObj) {
            customObj = {};
        }
    }
    // What limit was actually used to generate this response?
    options = options || {};
    this['lastFetchSize'] = this._getReturnProperty(customObj, response, 'limit', options['fetchSize'], this['fetchSize']);
    
    // What offset was actually used to generate this response?
    this['offset'] = this._getReturnProperty(customObj, response, 'offset', options['startIndex'], 0);

    // How many records actually came back?
    this['lastFetchCount'] = this._getReturnProperty(customObj, response, 'count', this['lastFetchCount'], this['lastFetchCount']);
    
    // What is the total number of records possible for this collection?
    this['totalResults'] = this._getReturnProperty(customObj, response, 'totalResults', this['totalResults'], this['totalResults']);
    
    // Is there more?
    this['hasMore'] = this._getHasMore(oj.Collection._getProp(customObj, response, 'hasMore'), 
                                       this['offset'], this['lastFetchSize'], this['totalResults']);
                              
    // Was fetchSize set?  If not, set it to limit
    if (!this.__isVirtual() && this['totalResults'] && this['totalResults'] !== this['lastFetchCount'] && this['lastFetchSize']) {
        this.setFetchSize(this['lastFetchSize']);
    }
};

oj.Collection.prototype._getHasMore = function(hasMore, offset, lastFetchSize, totalResults) {
    if (hasMore && hasMore !== undefined) {
        return hasMore;        
    }
    // Not there: figure it out.  It's true unless we're walking off the end
    return (offset + lastFetchSize > totalResults) ? false : true;
};

oj.Collection._getProp = function(custom, response, prop) {
    if (custom.hasOwnProperty(prop)) {
        return custom[prop];
    }
    return response ? response[prop] : undefined;
};

oj.Collection.prototype._getOffset = function() {
    return (this['offset'] !== undefined ? this['offset'] : 0);
};

/**
 * Creates a new model, saves it to the data service, and adds it on to the collection.
 * @param {Object=} attributes Set of attribute/value pairs with which to initialize the new model object, or a new Model object
 * @param {Object=} options Options to control save (see oj.Model.save).  Plus:<p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object|boolean} new model or false if validation failed.  If virtual, returns a promise that calls with the new model
 * @export
 */
oj.Collection.prototype.create = function (attributes, options) {
    function doSave(collection, newModel, validate, opt) {
/*        if (newModel.save(attributes instanceof oj.Model ? null : attributes, opt) === false) {
            // Invalid
            options['validationError'] = newModel['validationError'];
            collection.TriggerInternal(false, oj.Events.EventType['INVALID'], collection, newModel['validationError'], opt);
            if (validate) {
                collection._unlistenToModel(newModel);
                collection.remove(newModel);
                return false;
            }
        }*/
        newModel.save(attributes instanceof oj.Model ? null : attributes, opt);
        
        return newModel;
    }
    
    var deferred = this._getDeferred(options);
    options = options || {};
    // Save the user's context and callback, if any
    var newModel = this._newModel(attributes, true, options),
        callback = options['success'],
        context = options['context'], validate = options['validate'];
    options['context'] = this;
    options['success'] = function(model, resp, options) {
            if (callback) {
                callback.call(context != null ? context : this, model, resp, options);
            }
        };
        
    // Did validation pass?
    if (newModel == null) {       
        return false;
    }
    
    // Force a save in case user has set value of idAttribute on the new Model
    options['forceNew'] = newModel.GetId() != null;
    
    newModel.SetCollection(this);
    var self = this;
    if (deferred || this.__isVirtual()) {
        return oj.Object.__getPromise(function (resolve, reject) {
            self.add(newModel, {'merge':true, 'deferred':true})
                    .then(function() {
                            options['success'] = function(model, resp, options) {
                                    if (callback) {
                                        callback.call(context != null ? context : self, model, resp, options);
                                    }
                                    resolve(model);
                                };
                                var model = doSave(self, newModel, validate, options);
                                // make sure that success is called first if successful...promise resolved
                                // second
                                if (!model) {
                                    // Failed: make sure we resolve the promise.  Otherwise promise will
                                    // be resolved by success call, above
                                    resolve(model);
                                }
                            });
                        });
    }
    
    this.add(newModel, {merge:true});
    return doSave(this, newModel, validate, options);
};

/**
 * @export
 * Return a list of all the values of attr found in the Collection
 * 
 * @param {string} attr attribute to return
 * @return {Object} array of values of attr
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.pluck = function(attr) {
    var arr = [], i;
    
    this._throwErrIfVirtual("pluck");
    
    for (i = 0; i < this._getLength(); i=i+1) {
        arr.push(this.at(i).get(attr));
    }
    return arr;
};

/**
 * @export
 * Return an array of models that contain the given attribute/value pairs.  Note that this function, along with findWhere, expects server-resolved
 * filtering to return *all* models that meet the criteria, even in virtual cases.  The fetchSize will be set to the value of totalResults for this call to indicate that
 * all should be returned.
 * 
 * @param {Object|Array} attrs attribute/value pairs to find.  The attribute/value pairs are ANDed together.  If attrs is an array of attribute/value pairs, then these are ORed together
 *                             If the value is an object (or an array of objects, in which case the single attribute must meet all of the value/comparator conditions), then if it has both 'value' and 'comparator' parameters these will be interpreted as
 *                             expressions needing custom commparisons.  The comparator value may either be a string or a comparator callback function.
 *                             Strings are only valid where the filtering is sent back to the data service (virtual collections).  In the case of a comparator
 *                             function, the function always takes the signature function(model, attr, value), and for non-virtual collections, is called for each 
 *                             Model in the collection with the associated attribute and value.  The function should return true if the model meets the attribute/value
 *                             condition, and false if not.  For cases where the filtering is to be done on the server, the function will be called once per attr/value pair
 *                             with a null model, and the function should return the string to pass as the comparison in the expression for the filtering parameter
 *                             in the URL sent back to the server.  Note that the array of value object case is really only meaningful for server-evaluated filters where
 *                             a complex construction on a single attribute might be needed (e.g., x>v1 && x <=v2)
 *                             For example:<p>
 *                             {Dept:53,Name:'Smith'}<p>
 *                             will return an array of models that have a Dept=53 and a Name=Smith, or, for server-filtered
 *                             collections, a ?q=Dept=53+Name=Smith parameter will be sent with the URL.<p>
 *                             [{Dept:53},{Dept:90}]<p>
 *                             will return all models that have a Dept of 53 or 90.  Or, ?q=Dept=53,Dept=90 will be sent to the server.<p>
 *                             {Dept:{value:53,comparator:function(model, attr, value) { return model.get(attr) !== value;}}}<p>
 *                             will return all models that do not have a Dept of 53.<p>
 *                             {Dept:{value:53,comparator:'<>'}}<p>
 *                             For server-evaluated filters, a parameter ?q=Dept<>53 will be sent with the URL.  This form is an
 *                             error on locally-evaluated colleection filters<p>
 *                             {Dept:{value:53,comparator:function(model, attr, value) { return "<>";}}}<p>
 *                             expresses the same thing for server-evaluated filters<p>
 *                             {Dept:[{value:53,comparator:'<'},{value:90,comparator:'<'}]}<p>
 *                             For server-evaluated filters, a parameter ?q=Dept>53+Dept<93 will be sent to the server<p>
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not<p>
 * 
 * @return {Object} array of models.  If virtual or deferred, a promise that calls with the returned array from the server
 */
oj.Collection.prototype.where = function(attrs, options) {
    options = options || {};
    var deferred = this._getDeferred(options);
    var self = this;
    if (this.__isVirtual()) {
        return oj.Object.__getPromise(function(resolve, reject) {
            var success = function(collection, fetchedModels, options) {
                resolve(fetchedModels);
            };
            // Send the attributes for a server-based filter; also indicate that we need *all* the attributes.  In the standard
            // REST URL construction this is accomplished by leaving off fetchSize/start indices, etc.
            var opt = {'query':attrs,  
                       'all': true,
                       'success': success,
                       'error': function(collection, xhr, error) {
                           reject({'collection':collection,'xhr':xhr,'error':error});
                       }};
            self._fetchOnly(opt);
        });
    }
    
    var arr = [], i, m;
    for (i = 0; i < this._getLength(); i=i+1) {
        m = this.at(i);
        if (m.Contains(attrs)) {
            arr.push(m);
        }
    }
    if (deferred) {
        return oj.Object.__getPromise(function(resolve, reject) {
            resolve(arr);
        });
    }
    return arr;
};

/**
 * @export
 * Return a collection only containing models that contain the given attribute/value pairs
 * Note that this returns a non-virtual collection with all the models returned by the server
 * even if the original collection is virtual.  Virtual collections doing filtering on the server should return all models that meet
 * the critera.  @see (@link where)
 * @see (@link where) for complete documentation of the parameters
 *
 * @return {Object} A collection, or if virtual or deferred, a promise that calls with the Collection
 */
oj.Collection.prototype.whereToCollection = function(attrs, options) {
    options = options || {};
    var deferred = this._getDeferred(options);
    var self = this;
    if (this.__isVirtual() || deferred) {
        return oj.Object.__getPromise(function(resolve, reject) {
            return self.where(attrs, options).then(function (models) {
                                                var collection = self._makeNewCollection(models);
                                                resolve(collection);
                                            });
                                        });
    }
    else {
        var models = this.where(attrs, options);
        var newCollection = this._makeNewCollection(models);
        newCollection[oj.Collection._FETCH_SIZE_PROP] = -1;
        newCollection._setLength();
        return newCollection;
    }
};
    
oj.Collection.prototype._makeNewCollection = function(models) {
    var collection = this._cloneInternal(false);
    collection._setModels(models);
    collection._resetLRU();
    collection._setLength();
    return collection;
};

oj.Collection.prototype._throwErrIfVirtual = function(func) {
    if (this.__isVirtual()) {
        throw new Error(func + " not valid on a virtual Collection");
    }
};

/**
 * @export
 * Return an array whose entries are determined by the passed-in iterator function.  The iterator will be called for each model in the collection
 * 
 * @param {function(Object)} iterator function to determine the mapped value for each model
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Array} array of values determined by calls to iterator for each model
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.map = function(iterator, context) {
    var retArr = [], value;
    
    this._throwErrIfVirtual("map");
    
//    for (i = 0; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model) {
        value = iterator.call(context || this, model);
        retArr.push(value);
    });
    return retArr;
};

/**
 * @export
 * Iterates over the models in the collection and calls iterator
 * 
 * @param {function(Object)} iterator function to call for each model
 * @param {Object=} context context with which to make the calls on iterator
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.each = function(iterator, context) {
    this._throwErrIfVirtual("each");
    
    this._getModels().forEach(iterator, context);
};

/**
 * @export
 * Return the length of the collection
 * @returns {number} length of the collection
 */
oj.Collection.prototype.size = function() { 
    return this._getLength();
};

/**
 * @export
 * Return the models sorted determined by the iterator function (or property, if a string value)
 * 
 * @param {String|function(Object)} iterator method called or property used to get the sorting value
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} models sorted using iterator
 */
oj.Collection.prototype.sortBy = function(iterator, context) {
    var retArr = [], self;

    this._throwErrIfVirtual("sortBy");
    
//    for (i = 0; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model) {
        retArr.push(model);
    });
    self = this;
    
    retArr.sort(function(a, b) {
            var keyA, keyB;

            if (oj.Model.IsFunction(iterator)) {        
                // "sortBy" comparator option
                keyA = iterator.call(context || self, a);
                keyB = iterator.call(context || self, b);
                return oj.Collection._compareKeys(keyA, keyB, self['sortDirection']);
            }
            // String option
            keyA = a.get(iterator);
            keyB = b.get(iterator);
            return oj.Collection._compareKeys(keyA, keyB, self['sortDirection']);            
        });

    return retArr;
};

/**
 * @export
 * Return the collection with models grouped into sets determined by the iterator function (or property, if a string value)
 * 
 * @param {String|function(Object)} iterator method called or property used to get the group key
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} models grouped into sets
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.groupBy = function(iterator, context) {
    var retObj = {}, groupVal;
    
    this._throwErrIfVirtual("groupBy");
    
//    for (i = 0; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model) {
        if (oj.Model.IsFunction(iterator)) {
            groupVal = iterator.call(context || this, model);
        }
        else {
            groupVal = model.get(iterator);
        }
        if (retObj[groupVal] === undefined) {
            retObj[groupVal] = [];
        }
        retObj[groupVal].push(model);
    }, this);
    return retObj;    
};

/**
 * @export
 * Return the "minimum" model in the collection, as determined by calls to iterator.  The return value of iterator (called with a model passed in) will be compared against the current minimum
 * 
 * @param {function(Object)} iterator function to determine a model's value for checking for the minimum
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} "Minimum" model in the collection
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.min = function(iterator, context) { 
    var minModel = {}, minModelValue, currValue;
    
    this._throwErrIfVirtual("min");
    
    if (this._getModelsLength() == 0) {
        return null;        
    }
    // Get vals started
    minModel = this._getModel(0);
    minModelValue = iterator.call(context || this, this._getModel(0));
    
    //for (i = 1; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model, i) {
        if (i >= 1) {
            currValue = iterator.call(context || this, model);
            if (currValue < minModelValue) {
                minModel = model;
                minModelValue = currValue;
            }
        }
    }, this);
    return minModel;
};

/**
 * @export
 * Return the "maximum" model in the collection, as determined by calls to iterator.  The return value of iterator (called with a model passed in) will be compared against the current maximum
 * 
 * @param {function(Object)} iterator function to determine a model's value for checking for the maximum
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} "Maximum" model in the collection
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.max = function(iterator, context) { 
    var maxModel = {}, maxModelValue, currValue;
    
    this._throwErrIfVirtual("max");
    if (this._getModelsLength() == 0) {
        return null;        
    }
    // Get vals started
    maxModel = this._getModel(0);
    maxModelValue = iterator.call(context, this._getModel(0));
    
//    for (i = 1; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model, i) {
        if (i >= 1) {
            currValue = iterator.call(context || this, model);
            if (currValue > maxModelValue) {
                maxModel = model;
                maxModelValue = currValue;
            }
        }
    }, this);
    return maxModel;
};

/**
 * @export
 * Return an array of models that cause iterator to return true
 * 
 * @param {function(Object)} iterator function to determine if a model should be included or not
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Array} array of models that cause iterator to return true
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.filter = function(iterator, context) {
    var retArr = [];
    
    this._throwErrIfVirtual("filter");
    
//    for (i = 0; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model) {
        if (iterator.call(context || this, model)) {
            retArr.push(model);
        }
    });
    return retArr;
};

/**
 * @export
 * Return an array of models minus those passed in as arguments
 * @param {...Object} var_args models models to remove from the returned array
 * @returns {Array} array of models from the collection minus those passed in to models
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.without = function(var_args) {
    var retArr = [], j, id, cid, add;
    
    this._throwErrIfVirtual("without");
    
    var model;
    for (var i = 0; i < this._getModels().length; i++) {
        add = true;
        model = this._getModels()[i];
        for (j = 0; j < arguments.length; j=j+1) {
            // Get the cid
            cid = arguments[j].GetCid();
            // Get the id
            id = arguments[j].GetId();             
            if (model.Match(id, cid)) {
                add = false;
                break;
            }
        }
        if (add) {
            retArr.push(model);
        }
    }
    return retArr;    
};

/**
 * @export
 * Determine if the collection has any models
 * 
 * @returns {boolean} true if collection is empty
 */
oj.Collection.prototype.isEmpty = function() {
    return this._getLength() === 0;
};

/**
 * @export
 * Return true if any of the models in the collection pass the test in the iterator function
 * 
 * @param {function(Object)} iterator function to determine if a model 'passes'
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {boolean} true if any of the models cause the iterator function to return true
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.any = function(iterator, context) {
    this._throwErrIfVirtual("any");
    
    var model;
    for (var i = 0; i < this._getModelsLength(); i=i+1) {
        model = this._getModel(i);
        if (iterator.call(context || this, model)) {
            return true;
        }
    }
    return false;
};

/**
 * @export
 * A version of where that only returns the first element found
 * 
 * @param {Object|Array} attrs attribute/value pairs to find.  
 * @see (@link where) for more details and examples.
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not<p>
 * 
 * @returns {Object} first model found with the attribute/value pairs.  If virtual or deferred, a promise that calls with the returned array from the server
 */
oj.Collection.prototype.findWhere = function(attrs, options) {
    var deferred = this._getDeferred(options);
    var self = this;
    if (this.__isVirtual() || deferred) {
        return oj.Object.__getPromise(function(resolve, reject) {
            self.where(attrs, options).then(function(modelList) {
                                                        if (modelList && modelList.length > 0) {
                                                            resolve(modelList[0]);
                                                        }
                                                        resolve(null);
                                                    });
                                                });
    }
    
    var arr = this.where(attrs);
    if (arr.length > 0) {
        return arr[0];
    }
    return null;
};

/**
 * @export
 * Return a shallow copy of the models from start to end (if specified), in an array
 * 
 * @param {number} start model to start the return array with
 * @param {number=} end model to end the return array with, if specified (not inclusive).  If not, returns to the end of the collection
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Array} array of model objects from start to end, or a promise that calls specifying the returned array when done
 */
oj.Collection.prototype.slice = function(start, end, options) {
    var deferred = this._getDeferred(options);
    var ret = [], i;
    if (end === undefined) {
        if (this._isVirtual && !this._hasTotalResults()) {
            // We can't set the end: throw an error
            throw new Error("End must be set for virtual collections with no totalResults");
        }
        end = this._getModelsLength();
    }

    if (deferred || this.__isVirtual()) {
        // Loop using deferred
        return this.IterativeAt(start, end);
    }

    for (i = start; i < end; i=i+1) {
        ret.push(this._getModel(i));
    }
    return ret;
};

/**
 * @export
 * Update the collection with a model or models.  Depending on the options, new models will be added, existing models will be merged, and unspecified models will be removed.
 * The model cid is used to determine whether a given model exists or not.
 * 
 * @param {Object} models an array of or single model with which to update the Collection
 * @param {Object=} options add:false stops the addition of new models<p>
 *                          remove: false stops the removal of missing models<p>
 *                          merge:false prevents the merging of existing models<p>
 *                          silent: true prevents notifications on adds, removes, etc.<p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * 
 * @returns {Object|null} if deferred or virtual, return a promise when the set has completed
*/
oj.Collection.prototype.set = function(models, options) {
    var deferred = this._getDeferred(options);
    return this._setInternal(models, true, options, deferred || this.__isVirtual());
};

oj.Collection._removeAfterSet = function(collection, remove, foundModels, options) {
    // Now remove models that weren't found
    // get an array of all models
    if (remove) {    
        for (var i = collection._getModelsLength()-1; i >= 0; i=i-1) {
            if (foundModels.indexOf(i) == -1) {
                collection._removeInternal(collection._getModel(i), i, options);
            }
        }
    }       
};

oj.Collection.prototype._setInternal = function(models, parse, options, deferred) {
    // Determine if any of the options are set
    options = options || {};
    var add = options['add'] === undefined ? true : options['add'],
        remove = options['remove'] === undefined ? true : options['remove'],
        merge = options['merge'] === undefined ? true : options['merge'],
        foundModels = [], currModel = null, i, modelList;        

    if (parse) {
        models = this['parse'](models);
    }

    modelList = oj.Model.IsArray(models) ? models : [models];

    if (deferred) {
        return this._deferredSet(modelList, options, remove, add, merge, parse);
    }
    
    // Go through the passed in models and determine what to do
    for (i = 0; i < modelList.length; i=i+1) {
        currModel = this._updateModel(this._newModel(modelList[i], parse, options), add, merge, deferred);
        if (currModel !== -1) {
            foundModels.push(currModel);
        }
    }
        
    oj.Collection._removeAfterSet(this, remove, foundModels, options);
};

// Handle the updates/removes on virtual collections
oj.Collection.prototype._deferredSet = function(modelList, options, remove, add, merge, parse) {
    var foundModels = [], i;
      
    // Go through the passed in models and determine what to do
    var self = this;
    return oj.Object.__getPromise(function(allResolve, allReject) {
        var doTask = function(index) {
                        return oj.Object.__getPromise(function(resolve, reject) {
                            self._updateModel(self._newModel(modelList[index], parse, options), add, merge, true).then(function (currModel) {
                                                if (currModel !== -1) {
                                                    foundModels.push(currModel);
                                                }
                                                resolve(index);                                        
                                            });
                                        });
        };

        var currentStep = doTask(0);
        var nextTask = function(j) {
                            return doTask(j+1);
        };

        for (i = 1; i < modelList.length; i=i+1) {
           currentStep = currentStep.then(nextTask);
        }
        currentStep.then(function() {
            oj.Collection._removeAfterSet(self, remove, foundModels, options);
            allResolve();
        });
    });
};


// Return the index of the given model after updating it, if it was found.  Otherwise it is added and a -1 is returned
oj.Collection.prototype._updateModel = function(model, add, merge, deferred) {
    function update(collection, found, deferred) {
        var index = found ? found.index : -1;
        var foundModel = found ? found['m'] : null;

        if (foundModel) {
            if (merge) {
                // Do merge if not overridden
                var opt = {'merge':merge};
                if (deferred) {
                    return oj.Object.__getPromise(function(resolve, reject) {                    
                        collection._addInternal(model, opt, false, true).then(function() {
                            resolve(index);
                        });
                    });
                }
                collection.add(model, opt);
            }
        }
        else if (add) {
            if (deferred) {
                return oj.Object.__getPromise(function(resolve, reject) {
                    collection.add(model, {'deferred':true}).then(function() {
                        resolve(collection._getLength()-1);
                    });
                });
            }
            collection.add(model);
            index = collection._getLength()-1;
        }
        return index;
    }
    
    // Check to see if this model is in the collection
    if (deferred || this.__isVirtual()) {
        var self = this;
        
        return oj.Object.__getPromise(function(resolve, reject) {
            self._getInternal(model, null, deferred).then(function(found) {

                update(self, found, true).then(function (index) {
                    resolve(index);
                });
            });
        });
    }
    
    var found = this._getInternal(model);
    return update(this, found, false);
};

/**
 * Return a copy of the Collection's list of current attribute/value pairs.
 * @return {Object} a copy of all the Collection's current sets of attribute/value pairs.
 * 
 * @throws {Error} when called on a virtual/paging Collection
 * @export
 */
oj.Collection.prototype.toJSON = function() {
    var retArr = [];
    
    this._throwErrIfVirtual("toJSON");
    
    //for (i = 0; i < this._getModelsLength(); i=i+1) {
    this._getModels().forEach(function(model) {
        retArr.push(model.toJSON());
    });
    return retArr;
};

/**
 * Return the first model object in the collection, or an array of the first n model objects from the collection.
 * @param {number=} n Number of model objects to include in the array, starting with the first. 
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Array|null} An array of n model objects found in the collection, starting with the first. If n is not included,
 *                      returns all of the collection's models as an array.  Returns a promise that returns the array or model if deferred or virtual
 * @export
 */
oj.Collection.prototype.first = function(n, options) {
    var deferred = this._getDeferred(options);
    var elementCount = this._getLength(),
        retArray = [], 
        i;

    if (n) {
        elementCount = n;
    }
    else {
        n = 1;
    }
    
    var virtual = this.__isVirtual() || deferred;
    
    if (n === 1) {
        if (virtual) {
            return this._deferredAt(0, null);
        }
        
        if (this._getModelsLength() > 0) {
            return this._getModel(0);
        }
        return null;
    }
   
    if (elementCount > this._getModelsLength()) {
        if (this.__isVirtual() && !this._hasTotalResults()) {
            // Virtual, no total results: don't restrict elementCount
        }
        else {
            elementCount = this._getModelsLength();
        }
    }
    
    if (virtual) {
        return this.IterativeAt(0, elementCount);
    }
    
    for (i = 0; i < elementCount; i=i+1) {
        retArray.push(this._getModel(i));
    }
    return retArray;
};

/**
 * Return the array index location of the given model object.
 * @param {Object} model Model object (or Model id) to locate 
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not

 * @return {number} The index of the given model object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 */
oj.Collection.prototype.indexOf = function(model, options) {
    var location;
    var deferred = this._getDeferred(options);
    
    if (this.__isVirtual() || deferred) {
        return this._getInternal(model, null, true).then(function(loc) {
                                                            return loc.index;
                                                        });
    }
    location = this._getInternal(model);
    
    return location.index;
};

// Only look on models already fetched
oj.Collection.prototype._localIndexOf = function(model) {
    var location = this._getLocalInternal(model);
    
    return location !== undefined ? location.index : -1;
};

/**
 * @export
 * Remove the last model in the collection and return it
 * @param {Object=} options silent: if set, do not fire a remove event <p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} the model that was removed, or a promise that will call with the model that was removed when complete
 */
oj.Collection.prototype.pop = function(options) {
    var deferred = this._getDeferred(options);
    if (this.__isVirtual() || deferred) {
        var self = this;
        return this.at(this._getLength()-1, {'deferred':deferred}).then(function (model) {             
            self.remove(model, options);
            return model;
        });        
    }
    
    var m = this.at(this._getLength()-1);
    this.remove(m, options);
    return m;
};

/**
 * @export
 * Add the given model to the end of the Collection
 * @param {Object} m model to add to the end of the Collection
 * @param {Object=} options same options as add<p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} if deferred or virtual, a promise that will be called when the function is done.  Otherwise undefined
 */
oj.Collection.prototype.push = function(m, options) {
    var deferred = this._getDeferred(options);
    this._manageLRU(1);
    return this._addInternal(m, options, false, deferred);
};

/**
 * @export
 * Returns the index of the last location of the given model.  Not supported in virtual cases.
 * @param {Object} model Model object to locate
 * @param {number=} fromIndex optionally start search at the given index
 * @return {number} The last index of the given model object.  If the object is not found, returns -1.
 */
oj.Collection.prototype.lastIndexOf = function(model, fromIndex) {
    var i;
    
    this._throwErrIfVirtual("lastIndexOf");
    
    if (fromIndex === undefined) {
        fromIndex = 0;
    }
    
    for (i = this._getLength()-1; i >= fromIndex; i=i-1) {
        if (oj.Object.__innerEquals(model, this.at(i))) {
            return i;
        }
    }
    return -1;
};

oj.Collection.prototype._getSortAttrs = function(sortStr) {
    if (sortStr === undefined) {
        return [];
    }
    return sortStr.split(",");
};

// Return a URL query string based on an array of or a single attr/value pair set
oj.Collection._getQueryString = function(q) {
    function expression(left, right, compare) {
        return left + compare + right;
    }
    
    var queries = oj.Model.IsArray(q) ? q : [q];
    var str = "", query, exp, i, prop;
    for (i = 0; i < queries.length; i++) {
        query = queries[i];
        for (prop in query) {
            if (query.hasOwnProperty(prop)) {
                var val = oj.Model.IsArray(query[prop]) ? query[prop] : [query[prop]];
                for (var j = 0; j < val.length; j++) {
                    if (oj.Model.IsComplexValue(val[j])) {
                        var value = val[j]['value'];
                        var compare = null;
                        var comparator = val[j]['comparator'];
                        if (oj.Model.IsFunction(comparator)) {
                            compare = comparator(null, prop, value);
                        }
                        else {
                            compare = comparator;
                        }
                        exp = expression(prop, value, compare);
                    }
                    else {
                        exp = expression(prop, query[prop], "=");
                    }
                    str += exp + "+";
                }
            }
        }
        // Remove trailing '+'
        str = str.substring(0, str.length-1) + ",";
    }
    // Remove trailing ','
    if (str.substring(str.length-1) === ",") {
        return str.substring(0, str.length-1);
    }
    return str;
};

oj.Collection.prototype.ModifyOptionsForCustomURL = function(options) {
    var opt = {};
    for (var prop in options) {
        if (options.hasOwnProperty(prop)) {
            opt[prop] = options[prop];
        }
    }
    var comparator = this['comparator'];
    if (comparator && oj.StringUtils.isString(comparator)) {
        var attrs = this._getSortAttrs(comparator);        
        for (var i = 0; i < attrs.length; i++) {
            if (i === 0) {
                opt['sort'] = attrs[i];
            }
            else {
                opt['sort'] += "," + attrs[i];
            }
        }
        opt['sortDir'] = this._getSortDirStr();
    }
    // Put fetchSize on if appropriate, and not already set
    if (this.__isVirtual()) {
        opt[oj.Collection._FETCH_SIZE_PROP] = this._getFetchSize(opt);
    }
    return opt;
};

// Build a URL with parameters for the collection fetch
oj.Collection.prototype.GetCollectionFetchUrl = function(options) {
    var url = oj.Model.IsFunction(this['url']) ? this['url']() : this['url'];
    
    // Adorn it with options, if any
    if (this.__isVirtual()) {
        var all = options['all'];
        
        // Put in page size
        var limit = null;
        if (all) {
            var totalResults = this['totalResults'];
            limit = totalResults ? totalResults : this._getFetchSize(options);
        }
        else {
            limit = this._getFetchSize(options);
        }
        url += "?limit=" + limit;

        if (!all) {
            if (options['startIndex']) {
                url += "&offset=" + options['startIndex'];
            }
            if (options['startID']) {
                url += "&fromID=" + options['startID'];
            }
            if (options['since']) {
                url += "&since=" + options['since'];
            }
            if (options['until']) {
                url += "&until=" + options['until'];
            }
        }
        // Query
        if (options['query']) {
            var queryString = oj.Collection._getQueryString(options['query']);
            if (queryString && queryString.length > 0) {
                url += "&q=" + queryString;
            }
        }
        
        // Add sorting
        var comparator = this['comparator'];
        if (comparator) {
            var attrs = this._getSortAttrs(comparator);
            var sortDirStr = this._getSortDirStr(), i;
            for (i = 0; i < attrs.length; i++) {
                if (i === 0) {
                    url += "&orderBy=" + attrs[i] + ":" + sortDirStr;
                }
                else {
                    url += "," + attrs[i] + ":" + sortDirStr;
                }
            }
        }
        // Always ask for totalresults
        url +="&totalResults=true";        
    }
    return url;
};

oj.Collection.prototype._getSortDirStr = function() {
    if (this['sortDirection'] === -1) {
        return "desc";
    }
    return "asc";
};

/**
 * Called to perfrom server interactions, such as reading the collection.  Designed to be overridden by users
 * 
 * @param {string} method "read"
 * @param {Object} collection the Collection to be read
 * @param {Object=} options to control sync
 * success: called if sync succeeds
 * error: called if sync fails
 * others are passed to jQuery
 * @return {Object} xhr response
 * @alias oj.Collection.prototype.sync
 */
oj.Collection.prototype['sync'] = function(method, collection, options) {
    return window['oj']['sync'](method, collection, options);
};

// Constants
oj.Collection._FETCH_SIZE_PROP = 'fetchSize';

/**
 * Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true*/
/*global jQuery:false*/
/**
 * @private
 * @constructor
 */
oj.RestImpl = function(rootURL, custom) {
    this.rootURL = rootURL;
    this.customURL = custom;
    $.support['cors'] = true;    
};

oj.RestImpl._HEADER_PROP = "headers";

// Add the properties in options to starter, if not already there
oj.RestImpl.addOptions = function(starter, options, customOptions) {
    var prop;
    starter = $.extend(true, starter, customOptions);
    for (prop in options) {
        if (options.hasOwnProperty(prop) && prop !== 'oauthHeader') {
            if (!starter.hasOwnProperty(prop)) {
                starter[prop] = options[prop];
            }
            if (prop === oj.RestImpl._HEADER_PROP) {
                // Deep merge
                starter[prop] = $.extend(true, starter[prop], options[prop]);
            }
        }
    }
	
	if(options['oauthHeader']) {
		// if there are no any headers then create a new one.
		if(!starter[oj.RestImpl._HEADER_PROP]) starter[oj.RestImpl._HEADER_PROP] = {}; 	
		for (prop in options['oauthHeader']) {
			if (options['oauthHeader'].hasOwnProperty(prop)) {
				if (!starter[oj.RestImpl._HEADER_PROP].hasOwnProperty(prop)) {
					starter[oj.RestImpl._HEADER_PROP][prop] = options['oauthHeader'][prop];
				}
			}
		}
	}
		
    return starter;
};

oj.RestImpl.prototype.getRecords = function(callback, errFunc, options, context) {
        options = options || {};
        var isJsonp = options['dataType'] === 'jsonp';
        var urlInfo = this._getURL("read", this.rootURL, this.customURL, null, context, options);
        var ajaxOptions = {
                'crossDomain': options['crossDomain'] || !isJsonp,
		'dataType': options['dataType'] || "json",
                'jsonpCallback' : options['jsonpCallback'],
                'context': context !== null ? context : this,
		'success':  callback,
                'error': errFunc
	};
        ajaxOptions = this._addHeaderProp(ajaxOptions);
        ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
	options.xhr = this.ajax(ajaxOptions);
        return options.xhr;
};

oj.RestImpl.prototype._addHeaderProp = function(options) {
    options[oj.RestImpl._HEADER_PROP] = {'Accept-Language': this.getLocale()};
    return options;
};

oj.RestImpl.prototype.getRecord = function(success, error, recordID, options, context) {
        options = options || {};
        var isJsonp = options['dataType'] === 'jsonp';
        var urlInfo = this._getURL("read", this.rootURL, this.customURL, recordID, context, options);
        var ajaxOptions = {
                'crossDomain': options['crossDomain'] || !isJsonp,
		'dataType': options['dataType'] || "json",
                'jsonpCallback' : options['jsonpCallback'],
                'context': context !== null ? context : this,
		'success': success,
                'error': error
	};
        ajaxOptions = this._addHeaderProp(ajaxOptions);
        ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
	options.xhr = this.ajax(ajaxOptions);    
        return options.xhr;
};


oj.RestImpl.prototype.updateRecord = function(callback, recordID, record, error, options, context, patch) {
    options = options || {};
    var isJsonp = options['dataType'] === 'jsonp';
    var urlInfo = this._getURL(patch ? "patch": "update", this.rootURL, this.customURL, recordID, context, options);
    var ajaxOptions = {
        'crossDomain': options['crossDomain'] || !isJsonp,
        'contentType': options['contentType'] || 'application/json',
        'dataType': options['dataType'] || "json",
        'jsonpCallback' : options['jsonpCallback'],
        'data': JSON.stringify(record),
        'success': callback,
        'error': error,
        'context': context !== null ? context : this
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
    options.xhr = this.ajax(ajaxOptions);
    return options.xhr;
};

oj.RestImpl.prototype._getHTTPMethod = function(operation, options) {
    if (options['type']) {
        return options['type'];
    }
    if (operation === "create") {
        return "POST";
    }
    if (operation === "delete") {
        return "DELETE";
    }
    if (operation === "patch") {
        return "PATCH";
    }
    if (operation === "update") {
        return "PUT";
    }
    return "GET";
};

oj.RestImpl.prototype._setCustomURLOptions = function(recordID, context, opt) {
    var options = context instanceof oj.Collection ? context.ModifyOptionsForCustomURL(opt) : {};
    if (recordID) {
        options['recordID'] = recordID;
    }
    return options;
};

oj.RestImpl.prototype._getURL = function(operation, rootURL, customURL, recordID, context, options) {
   if (oj.Model.IsFunction(customURL)) {
       var result = customURL.call(this, operation, context, this._setCustomURLOptions(recordID, context, options));
       if (oj.StringUtils.isString(result)) {
           return {'url': result, 'type' : this._getHTTPMethod(operation, options)};
       }
       else if (result) {
           result['url'] = result.hasOwnProperty('url') ? result['url'] : rootURL;
           result['type'] = result.hasOwnProperty('type') ? result['type'] : this._getHTTPMethod(operation, options);
           return result;
       }
    }
    var http = this._getHTTPMethod(operation, options);
    return {'url': rootURL, 'type': http};
};

oj.RestImpl.prototype.deleteRecord = function(recordID, error, options, context) {
    options = options || {};
    var isJsonp = options['dataType'] === 'jsonp';
    var urlInfo = this._getURL("delete", this.rootURL, this.customURL, recordID, context, options);

    var ajaxOptions = {
        'crossDomain': options['crossDomain'] || !isJsonp,
        'success': options.success,
        'error': error,
        'context': context !== null ? context : this
    };
    ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
    options.xhr = this.ajax(ajaxOptions);
    return options.xhr;
};

oj.RestImpl.prototype.addRecord = function(record, error, options, context) {
    options = options || {};
    var recordStr = JSON.stringify(record), isJsonp = options['dataType'] === 'jsonp';
    var urlInfo = this._getURL("create", this.rootURL, this.customURL, null, context, options);

    var ajaxOptions = {
        'crossDomain': options['crossDomain'] || !isJsonp,
        'contentType': options['contentType'] || 'application/json',
        'dataType': options['dataType'] || "json",
        'jsonpCallback' : options['jsonpCallback'],
        'data': recordStr,
        'success': options.success,
        'error': error,
        'context': context !== null ? context : this
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
    options.xhr = this.ajax(ajaxOptions);  

    return options.xhr;
};

oj.RestImpl.prototype.getLocale = function() {
    return oj.Config.getLocale();
};

oj.RestImpl.prototype.ajax = function(settings) {
    return window['oj']['ajax'](settings);
};


/**
 * Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true*/
/*global jQuery:false*/

/**
 * @export
 * @class oj.OAuth
 * @classdesc Object representing name/value pairs for a data service record
 *
 * @param {Object} attributes Initial set of attribute/value pairs with which to seed this OAuth object 
 * @param {string} header Actual name for the Authorization header (default 'Authorization') 
 * @example <caption>Initialize OAuth with client credentials</caption>
 * var myOAuth = new oj.OAuth('X-Authorization', {...Clent Credentials ...});
 * 
 * @example <caption>Initialize OAuth with access_token</caption>
 * var myOAuth = new oj.OAuth('X-Authorization', {...Access Token...});
 * 
 * @example <caption>Initialize empty OAuth and set access_token</caption>
 * var myOAuth = new oj.OAuth();
 * myOAuth.setAccessTokenResponse({...Access Token...});
 *
 * @constructor
 */
oj.OAuth = function(header, attributes) 
{
	attributes = attributes || {};
	header = header || 'Authorization';
	oj.OAuth._init(this, attributes, header);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.OAuth, oj.Object, "OAuth.OAuth");
oj.OAuth.prototype.Init = function()
{
    oj.OAuth.superclass.Init.call(this);
};

/**
 * Calculates Authorization header based on client credentials or access_token
 * @return {Object} OAuth 2.0 Authorization header
 * @example <caption>Get Authorization header</caption>
 * myOAuth.getHeader();
 *
 * @export
 */
oj.OAuth.prototype.getHeader = function() 
{
	var headers = {};
	if(!this.accessTokenResponse['access_token']) {
		this.clientCredentialGrant();
	}
	headers[this.accessTokenRequest.auth_header]='Bearer '+this.accessTokenResponse['access_token'];
	return headers;
}

/**
 * Check is OAuth initialized (not null access_token).
 * @return {boolean} true/false
 * @example <caption>Check if OAuth initialized</caption>
 * if(myOAuth.isInitialized()) console.log('Initialized');
 *
 * @export
 */
oj.OAuth.prototype.isInitialized = function() 
{
	return (this.accessTokenResponse.access_token) ? true : false;
}

/**
 * Request for access_token(bearer token) using Client Credential Authorization Grant.
 * Initialize response part of the OAuth object (access_token, e.t.c.)
 * @example <caption>Set/Re-set response part of the OAuth object using Client Credentials</caption>
 * myOAuth.clientCredentialGrant();
 *
 * @export
 */
oj.OAuth.prototype.clientCredentialGrant = function() 
{
	var headers = {}, self = this;
	headers[self.accessTokenRequest.auth_header] = 'Basic ' + 
		oj.OAuth._base64_encode(self.accessTokenRequest['client_id']+':'+self.accessTokenRequest['client_secret']);
		
	$.ajax({
		type: 'POST',
		async: false,
		url: this.accessTokenRequest['bearer_url'],
		data: 'grant_type=client_credentials',
		headers: headers,
		success:function(data) {
			oj.OAuth._initAccessToken(self.accessTokenResponse, data);
		},
		error: function(jqXHR, textStatus, errorThrown) {
			throw new Error(jqXHR.responseText);
		}
	});	

}

/**
 * Set response part of the OAuth object (access_token, e.t.c.)
 * @param {Object} data current response
 * @example <caption>'Initialize' response part of the OAuth object with access_token</caption>
 * myOAuth.setAccessTokenResponse({...Access Token...});
 *
 * @export
 */
oj.OAuth.prototype.setAccessTokenResponse = function(data) 
{
	oj.OAuth._initAccessToken(this.accessTokenResponse, data);
}

/**
 * Get response part of the OAuth object (access_token, e.t.c.)
 * @return {Object} cached response
 * @export
 */
oj.OAuth.prototype.getAccessTokenResponse = function()
{
	return this.accessTokenResponse;
}

/**
 * Clean response part of the OAuth object (access_token, e.t.c.)
 * Null and remove all data from response part of the OAuth object
 * @export
 */
oj.OAuth.prototype.cleanAccessTokenResponse = function()
{
	oj.OAuth._cleanAccessToken(this.accessTokenResponse);
}

/**
 * Set request part of the OAuth object (client credentials, uri endpoint)
 * @param {Object} data current client credentials and uri
 * @example <caption>'Initialize' request part of the OAuth object with client credentials and calculate access_token</caption>
 * myOAuth.setAccessTokenRequest({...Clent Credentials ...});
 * myOAuth.clientCredentialGrant();
 *
 * @export
 */
oj.OAuth.prototype.setAccessTokenRequest = function(data) 
{
	oj.OAuth._initAccessToken(this.accessTokenRequest, data);
}

/**
 * Get request part of the OAuth object (client credentials, uri endpoint)
 * @return {Object} cached request
 * @export
 */
oj.OAuth.prototype.getAccessTokenRequest = function()
{
	return this.accessTokenRequest;
}

/**
 * Clean request part of the OAuth object (client credentials, uri endpoint)
 * Null and remove all data from request part of the OAuth object
 * @export
 */
oj.OAuth.prototype.cleanAccessTokenRequest = function()
{
	oj.OAuth._cleanAccessToken(this.accessTokenRequest);
}

/**
 * @private
 * @param {Object} oauth
 * @param {Object} attributes
 * @param {string||null} header
 */
oj.OAuth._init = function(oauth, attributes, header) 
{
	oauth.Init();
	oauth.accessTokenRequest = {};
	oauth.accessTokenResponse = {};
	
	if(attributes['access_token']) { // access_token has higher preference
		oj.OAuth._initAccessToken(oauth.accessTokenResponse, attributes);
	} else if(attributes['client_id'] && attributes['client_secret'] && attributes['bearer_url']) { // Client Credential Grant		
		oj.OAuth._initAccessToken(oauth.accessTokenRequest, attributes);
	}
	oauth.accessTokenRequest.auth_header = header;
}

/**
 * @private
 * @param {Object} oauthObj - Request/Response object to deal with
 * @param {Object} data - object to populate
 */
oj.OAuth._initAccessToken = function(oauthObj, data) {
	var prop;
	data = data || {};
	for (prop in data) {
		oauthObj[prop] = data[prop];
	}
}

/**
 * @private
 * @param {Object} oauthObj - Request/Response object to deal with
 */
oj.OAuth._cleanAccessToken = function(oauthObj) {
	var key;
	for (key in oauthObj) {
		if (oauthObj.hasOwnProperty(key)) {
			if(key !== 'auth_header') {
				oauthObj[key] = null;
				delete oauthObj[key];
			}
		}
	}
}

/**
 * @private
 * @param {string} a The data to calculate the base64 representation from
 * @return {string} The base64 representation
 */
 oj.OAuth._base64_encode = function (a) {
	var d, e, f, b, g = 0,
		h = 0,
		i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
		c = [];
	do {
		d = a.charCodeAt(g++);
		e = a.charCodeAt(g++);
		f = a.charCodeAt(g++);
		b = d << 16 | e << 8 | f;
		d = b >> 18 & 63;
		e = b >> 12 & 63;
		f = b >> 6 & 63;
		b &= 63;
		c[h++] = i.charAt(d) + i.charAt(e) + i.charAt(f) + i.charAt(b);
	} while (g < a.length);
	c = c.join("");
	d = a.length % 3;
	return (d ? c.slice(0, d - 3) : c) + "===".slice(d || 3);	
}

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Constructs a message object 
 * .
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text 
 * @param {number|string=} severity - An optional severity for this message. Use constants 
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default 
 * is SEVERITY_ERROR if no severity is specified
 * @constructor
 * @export
 * @since 0.6
 */
oj.Message = function(summary, detail, severity)
{
  this.Init(summary, detail, severity);
};

/**
 * Indicates the type of severity that the message represents. 
 * @enum {string}
 * @export 
 */
oj.Message.SEVERITY_TYPE = {
  /**
   * Indicates a confirmation that an operation or task was completed. This is the lowest severity 
   * level.
   */
  'CONFIRMATION': 'confirmation',

  /**
   * Indicates information or operation messages. This has a lower severity level than warning.
   */
  'INFO':'info',

  /**
   * Indicates an application condition or situation that might require users' attention. This has a 
   * lower severity than error.
   */
  'WARNING': 'warning',

  /**
   * Used when data inaccuracies occur when completing a field and that needs fixing before user can 
   * continue. This has a lower severity level than fatal.
   * fatal.
   */
  'ERROR': 'error',

  /**
   * Used when a critical application error or an unknown failure occurs. This is the highest 
   * severity level. 
   * @const
   * @export 
   */
  'FATAL': 'fatal'
};


/**
 * Message severity level
 * @enum {number}
 * @export
 */
oj.Message.SEVERITY_LEVEL = {
  'FATAL' : 5,
  'ERROR' : 4,
  'WARNING' : 3,
  'INFO' : 2,
  'CONFIRMATION' : 1
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.Message, oj.Object, "oj.Message");

/**
 * Localized summary text.
 * 
 * @member
 * @name summary
 * @memberof oj.Message
 * @instance
 * @type {string}
 * @default <code class="prettyprint">""</code>
 */

/**
 * Localized detail text.
 * 
 * @member
 * @name detail
 * @memberof oj.Message
 * @instance
 * @type {string}
 * @default <code class="prettyprint">""</code>
 */

/**
 * Severity type of message. See oj.Message.SEVERITY_TYPE.
 * 
 * @member
 * @name detail
 * @memberof oj.Message
 * @instance
 * @type {string}
 * @default <code class="prettyprint">oj.Message.SEVERITY_TYPE.ERROR</code>
 */

/**
 * Initializes Message instance with the set options
 * @param {string} summary a localized summary message text
 * @param {string} detail a localized detail message text 
 * @param {number|string=} severity - An optional severity for this message.  Use constants 
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types.
 *                   
 * @export
 */
oj.Message.prototype.Init = function(summary, detail, severity) 
{
  oj.Message.superclass.Init.call(this);
  this['summary'] = summary;
  this['detail'] = detail;
  this['severity'] = severity || oj.Message.SEVERITY_TYPE.ERROR; // defaults to ERROR
};

/**
 * Whether a message can display on the UI. 
 * 
 * @memberof! oj.Message
 * @returns {boolean} always returns true; 
 * @instance
 * @protected 
 * @since 0.7
 */
oj.Message.prototype.canDisplay = function ()
{
  return true;
};

/**
 * Indicates whether some other oj.Message instance - msg,  is "equal to" this one.
 * Method is equivalent to java ".equals()" method.
 * 
 * @param {Object} msg 
 * @export
 */
oj.Message.prototype.equals = function (msg)
{
  if (msg)
  {
    if ((oj.Message.getSeverityLevel(this['severity']) === 
            oj.Message.getSeverityLevel(msg['severity'])) && 
        this['summary'] === msg['summary'] && 
        this['detail'] === msg['detail'])
    {
      return true;
    }
  }
  
  return false;
};

/**
 * Returns an Object that is a clone of this message. 
 * 
 * @return {Object} instance of oj.Message
 * @export
 * @since 0.7
 */
oj.Message.prototype.clone = function ()
{
  return new oj.Message(this['summary'], this['detail'], this['severity']);
};

/**
 * A convenience method that returns the severity level when given either a severity level of type 
 * number or a severity type of string. 
 * If severity level is not provided or is not valid this returns a severity error.
 * @param {string|number|undefined} severity 
 * @return {number}
 * @export
 */
oj.Message.getSeverityLevel = function (severity)
{
  var index;
  if (severity)
  {
    if (typeof severity === "string")
    {
      index = oj.Message._LEVEL_TO_TYPE.indexOf(severity, 1);
      if (index === -1)
      {
        severity = oj.Message.SEVERITY_LEVEL['ERROR'];
      }
      else
      {
        severity = index;
      }
    }
    else if (typeof severity === "number" && (severity < oj.Message.SEVERITY_LEVEL['CONFIRMATION'] && 
          severity > oj.Message.SEVERITY_LEVEL['FATAL']))
    {
      severity = oj.Message.SEVERITY_LEVEL['ERROR'];
    }
  }
  
  return !severity ? oj.Message.SEVERITY_LEVEL['ERROR'] : severity;
};

/**
 * A convenience method that returns the severity type when given either a severity level of type 
 * number or a severity type of string. 
 * If severity level is not provided or is not valid this return a severity error.
 * @param {string|number|undefined} level 
 * @return {string}
 * @export
 */
oj.Message.getSeverityType = function (level) 
{
  var index;
  if (level)
  {
    if (typeof level === "string")
    {
      index = oj.Message._LEVEL_TO_TYPE.indexOf(level, 1);
      if (index === -1)
      {
        // when given an unrecognized type return "error"
        level = oj.Message.SEVERITY_TYPE['ERROR'];
      }
    }
    else if (typeof level === "number")
    {
      if (level < oj.Message.SEVERITY_LEVEL['CONFIRMATION'] && 
          level > oj.Message.SEVERITY_LEVEL['FATAL'])
      {
        level = oj.Message.SEVERITY_TYPE['ERROR'];
      }
      else
      {
        level = oj.Message._LEVEL_TO_TYPE[level];
      }
    }
  }
  return level || oj.Message.SEVERITY_TYPE['ERROR'];
};

/**
 * Returns the max severity level in a array of message objects. 
 * 
 * @param {Array} messages an array of message instances
 * @returns {number} -1 if none can be determined; otherwise a severity level as defined by 
 * oj.Message.SEVERITY_LEVEL.
 * @export
 */
oj.Message.getMaxSeverity = function (messages)
{
  var maxLevel = -1, currLevel, message, i;
  if (messages && messages.length > 0)
  {
    $.each(messages, function (i, message)
      {
        if (message)
        {
          currLevel = oj.Message.getSeverityLevel(message['severity']);
        }
        maxLevel = maxLevel < currLevel ? currLevel : maxLevel;
      });
    
  }
  
  return maxLevel;
};

/**
 * Returns false if messages are of severity error or greater.
 * 
 * @param {Array} messages an array of message instances
 * @returns {boolean} true if none of the messages are of severity error or greater. false otherwise
 * @export
 */
oj.Message.isValid = function (messages)
{
  var maxSeverity = oj.Message.getMaxSeverity(messages);
  if (maxSeverity >= oj.Message.SEVERITY_LEVEL.ERROR)
  {
    return false;
  }
  
  return true;
};

/**
 * @private
 * @type Array
 */
oj.Message._LEVEL_TO_TYPE = ['none', // this can never be set
                             oj.Message.SEVERITY_TYPE['CONFIRMATION'], 
                             oj.Message.SEVERITY_TYPE['INFO'],
                             oj.Message.SEVERITY_TYPE['WARNING'],
                             oj.Message.SEVERITY_TYPE['ERROR'],
                             oj.Message.SEVERITY_TYPE['FATAL']];

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Extends oj.Message to represent a component specific message, this defines options that control 
 * how the message will display.
 * 
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text 
 * @param {number|string} severity - An optional severity for this message. Use constants 
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default 
 * is SEVERITY_ERROR if no severity is specified
 * @param {Object} options - an Object literal that defines the following properties
 * @property {string} display - whether the message needs to be displayed immediately or not. 
 * Accepted values are 'immediate', 'deferred'. The default is 'immediate'.
 * @property {string} context - the context the component was in when the validation messages was 
 * added.<p>
 * 
 * NOTE: messages added to the component directly by applications are unknown context and always 
 * shown {display: 'immediate', context: ''}. </p>
 * @private
 * @constructor
 * @since 0.7
 */
oj.ComponentMessage = function (summary, detail, severity, options) 
{
  this.Init(summary, detail, severity, options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.ComponentMessage, oj.Message, "oj.ComponentMessage");

/**
 * Determines whether the message is displayed immediately or not. Deferred messages are not shown 
 * to the user right away but are deferred until component explicitly does. See 
 * {@link oj.editableValue#showMessages}.
 * @private
 * @const
 * @type {Object}
 */
oj.ComponentMessage.DISPLAY = {SHOWN: 'shown', HIDDEN: 'hidden'};

/**
 * The default display options to use when none set.
 * 
 * @type {Object}
 * @private
 */
oj.ComponentMessage._DEFAULT_OPTIONS = {
  'display': oj.ComponentMessage.DISPLAY.SHOWN, 
  'context' : ''};

/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that 
 * will be displayed by this strategy.
 * 
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text 
 * @param {number|string} severity - An optional severity for this message. Use constants 
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default 
 * is SEVERITY_ERROR if no severity is specified
 * @param {Object} options - an Object literal that defines the following properties
 * @memberof! oj.ComponentMessage
 * @instance
 * @protected
 * @ignore
 */
oj.ComponentMessage.prototype.Init = function (summary, detail, severity, options)
{
  oj.ComponentMessage.superclass.Init.call(this, summary, detail, severity);
  
  this._options = $.extend({}, oj.ComponentMessage._DEFAULT_OPTIONS, options);
};
  
/**
 * Indicates whether some other oj.Message instance - msg,  is "equal to" this one.
 * Method is equivalent to java ".equals()" method.
 * 
 * @param {Object} msg 
 * @memberof! oj.ComponentMessage
 * @instance
 * @protected
 * @ignore
 */
oj.ComponentMessage.prototype.equals = function (msg)
{
  var result = oj.ComponentMessage.superclass.equals.call(this, msg);

  // we don;t care what context the messages was added in, as long as they are the same display type
  return result && (this._options['display'] === msg._options['display']);
};

/**
 * Clones this and returns the new instance.
 * 
 * @memberof! oj.ComponentMessage
 * @instance
 * @protected
 * @ignore
 * @returns {Object} 
 */
oj.ComponentMessage.prototype.clone = function ()
{
  return new oj.ComponentMessage(this['summary'], this['detail'], this['severity'], this._options);
};

/**
 * Whether a message can display on the UI.
 * 
 * @memberof! oj.ComponentMessage
 * @returns {boolean} true if messages can be displayed; false if marked as deferred by component.
 * @instance
 * @protected 
 * @ignore
 */
oj.ComponentMessage.prototype.canDisplay = function ()
{
  return !(this._options && this._options['display'] ? 
            this._options['display'] === oj.ComponentMessage.DISPLAY.HIDDEN : false);
};

/**
 * 
 * Called by framework when the message needs to be shown
 * 
 * @returns {boolean} true if shown; false if message display was already shown
 * 
 * @memberof! oj.ComponentMessage
 * @instance
 * @private
 */
oj.ComponentMessage.prototype._forceDisplayToShown = function ()
{
  if (this._options && oj.ComponentMessage.DISPLAY.HIDDEN === this._options['display'])
  {
    this._options['display'] = oj.ComponentMessage.DISPLAY.SHOWN;
    return true;
  }
  
  return false;
};

/**
 * Called by framework to determine if message was added by component versus app.
 * 
 * @returns {boolean} true if messages was added by component. Usually the context is set.
 * 
 * @memberof! oj.ComponentMessage
 * @instance
 * @private
 */
oj.ComponentMessage.prototype._isMessageAddedByComponent = function ()
{
  if (this._options && this._options['context'])
  {
    return true;
  }
  
  return false;
};
/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/


/**
 * @class JET Component services
 * @export
 */
oj.Components = {};


/**
 * Sets default options values for JET components.
 * @param {Object} options - property values that will be merged into the values
 * that were previously set using this method. The options object is expected to have the format demonstrated
 * by the following example:
 * <pre>
 * {
 *   'default': // properties for all JET components 
 *   {
 *     'option1': 'somevalue'
 *   },
 *   'editableValue': // properties for editableValue components 
 *   {
 *     'option1': 'somevalue1',
 *     'option2': oj.Components.createDynamicPropertyGetter(function(context){
 *                                 return context['containers'].indexOf('ojTable') >= 0 ? 'tableValue' : 'normalValue'})
 *   },
 *   'ojText': // properties for instances of ojText 
 *   {
 *     'option1': 'somevalue2'
 *   }
 * }
 * </pre>
 * To specify a dynamic getter for the property, pass your callback to oj.Components.createDynamicPropertyGetter(). Note
 * that dynamic getters nested within a complex property value are not supported
 * @see oj.Components.createDynamicPropertyGetter
 * @export
 */
oj.Components.setDefaultOptions = function(options)
{
  oj.Components._defaultProperties = $.widget.extend(oj.Components._defaultProperties || {}, options);
};

/**
 * Retrieves default option values for JET components.
 * @return {Object} default option values
 * @see oj.Components.setDefaultOptions
 * @export
 */
oj.Components.getDefaultOptions = function()
{
  return (oj.Components._defaultProperties || {});
};


/**
 * Creates a dynamic getter that can be used as a property value in oj.Components.setDefaultOptions()
 * @param {!Function} callback - dynamic property callback. The callback will receive a context object as a parameter.
 * The following properties are currently supported on the context object:
 * <ul>
 * <li>containers - an array of component names of the current component's containers that require special behavior from
 * their children</li>
 * </ul>
 * The callback should return the computed property value
 * 
 * @return {Object} - dynamic property getter
 * @see oj.Components.setDefaultOptions
 * @export
 */
oj.Components.createDynamicPropertyGetter = function(callback)
{
  return new __ojDynamicGetter(callback);
};

/**
 * Retrieves widget constructor associated with the HTML element
 * or null if none is found. The returned constructor is already bound to the associated 
 * JQuery element, so it can be invoked as a function directly. For example:
 * <pre>
 * widgetConstructor("option", "label", "custom"); // sets label option
 * </pre>
 * If widgetName is not specified, and if more than one widget is associated with the element, 
 * the method will a return the widget that was created first.
 * @param {Element} element - HTML element
 * @param {string=} widgetName - optional widget name
 * @return {Function|null} widget constructor
 * @export
 */
oj.Components.getWidgetConstructor = function(element, widgetName)
{
  var jelem = $(element);
  
  if (widgetName == null)
  {
    var data = jelem.data(_OJ_WIDGET_NAMES_DATA);
    if (data)
    {
      widgetName = data[0]; 
    }
  }
  
  if (widgetName != null)
  {
    var func = jelem[widgetName];
    if ((typeof func) === "function")
    {
      return func.bind(jelem);
    }
  }
  
  return null;
};

/**
 * Notifies JET framework that a subtree possibly containing JET components has been inserted
 * into the document programmatically.
 *
 * Note that there is no need to call this method when the new DOM is being inserted by the template engine
 * in Knockout.js 
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeDetached
 * @export
 */
oj.Components.subtreeAttached = function(node)
{
  oj.DomUtils.fixResizeListeners(node);
  _applyToComponents(node,
    function(instance)
    {
      instance._NotifyAttached();
    }
  );
};

/**
 * Notifies JET framework that a subtree possibly containing JET components has been removed
 * from the document programmatically.
 * 
 * Note that calling this method is not needs after calling JQuery's .remove() because all JET components would have been 
 * already destroyed in that case. Similarly, there is no need to call this method after the subtree has been removed by 
 * Knockout.js
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeAttached
 * @export
 */
oj.Components.subtreeDetached = function(node)
{
  _applyToComponents(node,
    function(instance)
    {
      instance._NotifyDetached();
    }
  );
};

/**
 * Notifies JET framework that a subtree possibly containing JET components is no longer hidden with display:none style
 * This method should be called by the application if the 'display' style is being changed from 'hidden' programmatically,
 * such as when JQuery's .show() method is called
 * 
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeHidden
 * @export
 */
oj.Components.subtreeShown = function(node)
{
  oj.DomUtils.fixResizeListeners(node);
  
  _applyToComponents(node,
    function(instance)
    {
      instance._NotifyShown();
    }
  );
};


/**
 * Notifies JET framework that a subtree possibly containing JET components has been hidden  with display:none style
 * This method should be called by the application after the subtree has been hidden programmatically, such as 
 * when JQuery's .hide() method is called.
 * 
 * @param {!Element} node - the root of the subtree
 * @see oj.Components.subtreeShown
 * @export
 */
oj.Components.subtreeHidden = function(node)
{
  _applyToComponents(node,
    function(instance)
    {
      instance._NotifyHidden();
    }
  );
};

/**
 * @private
 */
function _applyToComponents(subtreeRoot, callback)
{
  $(subtreeRoot).find('.' + _OJ_COMPONENT_NODE_CLASS).each(
    function(index, elem) 
    {
      var jelem =  $(elem);
      var names = jelem.data(_OJ_WIDGET_NAMES_DATA);
      if (names != null)
      {
        for (var i=0; i < names.length; i++)
        {
          var instance =  jelem.data("oj-" + names[i]);
          if (instance != null)
          {
            callback(instance);
          }
        }
      }
    }
  );
}


/**
 * @constructor
 * @param {!Function} callback
 * @private
 */
function __ojDynamicGetter(callback)
{
  this.getCallback = function()
  {
    return callback;
  }
};



/**
 * @private
 */
oj.Components._OJ_CONTAINER_ATTR = "data-oj-container";

/**
 * @private
 */
var _OJ_WIDGET_NAMES_DATA = "oj-component-names";

/**
 * @private
 */
var _OJ_COMPONENT_NODE_CLASS = "oj-component-initnode";
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true*/

/**
 * @class
 * @abstract
 * @name oj.baseComponent
 * @since 0.6
 */
$.widget('oj.baseComponent', 
{
  options: 
  {
    /**
     * JQ selector identifying the JET Menu that the component should launch as a context menu on right-click or <kbd>Shift-F10</kbd>. If specified, 
     * the browser's native context menu will be replaced by the specified JET Menu.
     * 
     * <p>To specify a JET context menu on a DOM element that is not a JET component, see the <code class="prettyprint">ojContextMenu</code> binding.  
     * 
     * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the context menu via the standard 
     * HTML5 syntax shown in the below example.  When the component is initialized, the context menu thus specified will be set on the component.
     * 
     * <p>The JET Menu should be initialized before any component using it as a context menu.
     * 
     * @expose
     * @memberof! oj.baseComponent
     * @instance
     * @type {Object}
     * @default <code class="prettyprint">null</code>
     * 
     * @example <caption>Initialize a JET component with a context menu:</caption>
     * // via recommended HTML5 syntax:
     * &lt;div id="myComponent" contextmenu="myMenu" data-bind="ojComponent: { ... }>
     * 
     * // via JET initializer (less preferred) :
     * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
     * $( ".selector" ).ojFoo({ "contextMenu": "#myMenu" });
     * 
     * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option, after initialization:</caption>
     * // getter
     * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
     * var menu = $( ".selector" ).ojFoo( "option", "contextMenu" );
     * 
     * // setter
     * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
     * $( ".selector" ).ojFoo( "option", "contextMenu", ".my-marker-class" );
     * 
     * @example <caption>Set a JET context menu on an ordinary HTML element:</caption>
     * &lt;a href="#" id="myAnchor" contextmenu="myMenu" data-bind="ojContextMenu: {}">Some text</a>
     */
    contextMenu: null,
    
    /**
     * <p>Attributes specified here will be set on the component's root DOM element at creation time.
     * This is particularly useful for components like Dialog that wrap themselves in a root element
     * at creation time.
     * 
     * <p>The supported attributes are <code class="prettyprint">id</code>, which overwrites any existing value, 
     * and <code class="prettyprint">class</code> and <code class="prettyprint">style</code>, which are appended 
     * to the current class and style, if any.
     * 
     * <p>Setting this option after component creation has no effect.  
     *
     * @example <caption>Initialize a JET component, specifying a set of attributes to be set
     * on the component's root DOM element:</caption>
     * // Foo is the component, e.g., Menu, Button, InputText, InputNumber, Select, etc.
     * $( ".selector" ).ojFoo({ "rootAttributes": {
     *   'id': 'myId', 
     *   'style': 'max-width:100%; color:blue;', 
     *   'class': 'my-class'
     * }});
     * 
     * @expose
     * @memberof oj.baseComponent
     * @instance
     * @type {Object|undefined}
     * @default <code class="prettyprint">null</code>
     */
    rootAttributes: undefined
    
    /**
     * <p>A collection of translated resources from the translation bundle, or <code class="prettyprint">null</code> if this
     * component has no resources.  Resources may be accessed and overridden individually or collectively, as seen in the examples.
     * 
     * <p>If this component has (or inherits) translations, their documentation immediately follows this doc entry.
     * 
     * @member
     * @name translations
     * @memberof oj.baseComponent
     * @instance
     * @type {Object}
     * @default an object containing all resources relevant to the component and all its superclasses, or <code class="prettyprint">null</code> if none
     * 
     * @example <caption>Initialize the component, overriding some translated resources.  This syntax leaves the other translations intact at create
     * time, but not if called after create time:</caption>
     * // Foo is InputDate, InputNumber, etc.
     * $( ".selector" ).ojFoo({ "translations": { someKey: "someValue",
     *                                            someOtherKey: "someOtherValue" } });
     * 
     * @example <caption>Get or set the <code class="prettyprint">translations</code> option, after initialization:</caption>
     * // Get one.  (Foo is InputDate, InputNumber, etc.)
     * var value = $( ".selector" ).ojFoo( "option", "translations.someResourceKey" );
     * 
     * // Get all.  (Foo is InputDate, InputNumber, etc.)
     * var values = $( ".selector" ).ojFoo( "option", "translations" );
     * 
     * // Set one, leaving the others intact.  (Foo is InputDate, InputNumber, etc.)
     * $( ".selector" ).ojFoo( "option", "translations.someResourceKey", "someValue" );
     * 
     * // Set many.  Any existing resource keys not listed are lost.  (Foo is InputDate, InputNumber, etc.)
     * $( ".selector" ).ojFoo( "option", "translations", { someKey: "someValue",
     *                                                     someOtherKey: "someOtherValue" } );
     * 
     */
    // translations option is initialized programmatically, so this top-level API doc lives in this virtual comment.
    // Translations for all components are listed and JSDoc'ed in rt\src\main\resources\nls\root\ojtranslations.js.
    // That JSDoc appears in the same generated doc page as this top-level doc.

    
  },
  
  /**
   * Refreshes the component.
   * 
   * @expose
   * @memberof! oj.baseComponent
   * @instance
   */
  refresh: function()
  {
    this._propertyContext = null;
  },
  
  /**
   * Overridden to save off component's default options and the options passed into the constructor (to be passed into
   * the _InitOptions() call)
   * @private
   */
  _createWidget: function(options, element)
  {
    // Thereis no need to clone these objects since they are not modified by the _createWidget() in the base class
    this._originalDefaults = this.options || {};
    this._constructorOptions = options || {};
    
    this._super(options, element);
  },
  
  /**
   * Reads the <code class="prettyprint">rootAttributes</code> option, and sets the root attributes on the 
   * component's root DOM element.  See <a href="#rootAttributes">rootAttributes</a> for the set of supported 
   * attributes and how they are handled.
   * 
   * @memberof oj.baseComponent
   * @instance
   * @protected
   * @throws if unsupported attributes are supplied.
   */
  _SetRootAttributes : function () 
  {
    var value = this.options.rootAttributes;
    if (value)
    {
      var widget = this.widget();
      if (widget == null)
        return;
      
      var classValue = value["class"];
      
      if (classValue)
      {
        widget.addClass(classValue);
      }
      
      var styleValue = value["style"];
      
      if (styleValue)
      {
        var currStyle = widget.attr('style');
        
        if (currStyle)
        {
          widget.attr('style', currStyle + ';' + styleValue);
        }
        else
        {
          widget.attr('style', styleValue);
        }
      }
      
      // make shallow copy, remove class and style from the copy, and set all 
      // remaining attrs on the element.  Currently id is the only remaining attr 
      // that we support.
      value = $.extend({}, value); 
      delete value['class'];
      delete value['style'];
      
      widget.attr(value);
      
      delete value['id']; // remove the remaining supported value
      var unsupportedAttrs = Object.keys(value);
      if (unsupportedAttrs.length)
        throw new Error("Unsupported values passed to rootAttributes option: " + unsupportedAttrs.toString());
    }
  },

  /*
   * It's recommended that you override oj.baseComponent#_ComponentCreate and 
   * oj.baseComponent#_AfterCreate, instead of this method to render your component. This 
   * method saves off all element attributes (retrieved using 
   * oj.baseComponent#_GetSavedAttributes) and then calls _InitOptions(), _ComponentCreate(),
   * _AfterCreate() in that order.
   * 
   * TODO: JSDoc!!  (with at-protected tag, at-final, etc.)
   * memberof! oj.baseComponent
   * instance
   * protected
   */
  _create : function()
  {
    this._SaveAttributes(this.element);
    this._InitOptions(this._originalDefaults, this._constructorOptions);
    
    delete this._originalDefaults; 
    delete this._constructorOptions;
    
    this._ComponentCreate();
    this._AfterCreate();
  },

  /**
   * <p>This method is called before <code class="prettyprint">_ComponentCreate</code>, at which 
   * point the component has not yet been rendered.  Component options should be initialized in this 
   * method, so that their final values are in place when 
   * <code class="prettyprint">_ComponentCreate</code> is called. 
   * 
   * <p>This includes getting option values from the DOM, where applicable, and coercing option 
   * values (however derived) to their appropriate data type.  No other work should be done in this 
   * method.  See below for details.
   * 
   * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
   * 
   * <p>Usage:
   * 
   * <ul>
   * <li>If the component has an option like <code class="prettyprint">disabled</code> that can be set from the DOM 
   * at create time, then the "get from DOM" logic should live in this method.  E.g. a typical override might say "if 
   * the <code class="prettyprint">disabled</code> option still has its initial value of <code class="prettyprint">undefined</code>
   * (i.e., the option has not been set), then get the DOM property and set it on the option." (See also next bullet.)</li>
   * 
   * <li>For attributes that live on the component's root node, keep in mind that anything specified via 
   * the <code class="prettyprint">rootAttributes</code> option will not be placed on the DOM until 
   * <code class="prettyprint">_AfterCreate</code>.  So when getting attributes from the root node, components must first look in the 
   * <code class="prettyprint">rootAttributes</code> option, and then, only if the attribute is not found there, look on the component 
   * root (if it already exists).</li>
   * 
   * <li>For options that, unlike <code class="prettyprint">disabled</code>, have no corresponding DOM property, and are not otherwise 
   * set from the DOM, there is nothing to do in this method.</li>
   * 
   * <li>Do NOT set anything on the DOM in this method (like the resolved <code class="prettyprint">disabled</code> value, or any 
   * <code class="prettyprint">rootAttributes</code> values). The resolved option values should be set on the DOM later, in 
   * <code class="prettyprint">_ComponentCreate</code>, and the <code class="prettyprint">rootAttributes</code> values are set in 
   * <code class="prettyprint">baseComponent._AfterCreate</code>.</li>
   * </ul> 
   * 
   * @param {!Object} originalDefaults - original default options defined on the component and its ancestors
   * @param {?Object} constructorOptions - options passed into the wiget constructor
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _InitOptions : function (originalDefaults, constructorOptions)
  {
    this._setupDefaultOptions(originalDefaults, constructorOptions);
  },
  
  /**
   * <p>All component create-time initialization lives in this method, except the logic that specifically 
   * needs to live in <code class="prettyprint">_InitOptions</code> or <code class="prettyprint">_AfterCreate</code>, 
   * per the documentation for those methods.  All DOM creation must happen here, since the intent of 
   * <code class="prettyprint">_AfterCreate</code> is to contain superclass logic that must run after that DOM is created.  
   * 
   * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _ComponentCreate : function ()
  {
    this['activeable'] = $();
    
    // marker class for all JET components on the init node (as opposed to the outer node)
    this.element.addClass(_OJ_COMPONENT_NODE_CLASS);
    
    // Store widget name, so that oj.Components.getWidgetConstructor() can get widget from the element
    _storeWidgetName(this.element, this.widgetName);
  },
          
  /**
   * This method is called after <code class="prettyprint">_ComponentCreate</code>.  The JET base component does 
   * tasks here that must happen after the component (subclass) has created itself in its override of 
   * <code class="prettyprint">_ComponentCreate</code>.  Notably, the base component handles the 
   * <code class="prettyprint">rootAttributes</code> and <code class="prettyprint">contextMenu</code> options here, 
   * since those options operate on the component root node, which for some components is created in their override 
   * of <code class="prettyprint">_ComponentCreate</code>. 
   * 
   * <p>Subclasses should override this method only if they have tasks that must happen after a superclass's 
   * implementation of this method, e.g. tasks that must happen after the context menu is set on the component.
   * 
   * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _AfterCreate : function ()
  {
    this._SetRootAttributes(); // do first, since has no dependencies, but other stuff might care about these attrs
    
    // namespace facilitates removing contextMenu handlers separately, if app clears the "contextMenu" option
    this.contextMenuEventNamespace = this.eventNamespace + "contextMenu";
    this._setupContextMenu(); 
  },
  
  /**
   * Saves the element's attributes within an internal variable to be reset during the destroy function
   *
   * The JSON variable will be held as :
   * [
   *   {
   *   "element" : element[i], 
   *   "attributes" : 
   *     {
   *       attributes[m]["name"] : {"attr": attributes[m]["value"], "prop": $(element[i]).prop(attributes[m]["name"])
   *     }
   *   }
   * ]
   *
   * @param {Object} element - jQuery selection to save attributes for
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _SaveAttributes : function (element)
  {
    var self = this;
    this._savedAttributes = [];

    $.each(element, function (index, ele)
    {
      //need to be able to save for multiple elements 
      var saveAttributes = {},
          save = { "element" : ele, "attributes" : saveAttributes },
          attributes = ele.attributes;
      
      self._savedAttributes.push(save);
      
      $.each(attributes, function (index, attr)
      {
        // for proper access certain so called attributes should be accessed as properties 
        // [i.e. required, disabled] so fetch them initially
        var attrName = attr["name"];
        
        saveAttributes[attrName] = { "attr" : attr["value"], "prop" : $(ele).prop(attrName) };
      });
  
    });
  
  },
  
  /**
   * Gets the saved attributes for the provided element. This is usually the original list of 
   * attributes set on the element.
   *
   * @param {Object} element - jQuery selection, should be a single entry
   * @return {Object} savedAttributes - attributes that were saved for this element. 
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _GetSavedAttributes : function (element)
  {
    var savedAttributes = this._savedAttributes;
  
    element = element[0];
  
    for (var i = 0, j = savedAttributes.length;i < j;i++)
    {
      var curr = savedAttributes[i];
      
      if (curr["element"] === element)
      {
        return curr["attributes"];
      }
    }
  
    return {};
  },
  
  /**
   * Restores the saved element's attributes
   *
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _RestoreAttributes : function ()
  {
    
    $.each(this._savedAttributes, function (index, savedAttr)
    {
      var element = $(savedAttr["element"]), 
          attributes = savedAttr["attributes"];
      
      //sanity check
      if (element.length === 1)
      {
        var currAttr = savedAttr["element"].attributes,
            removeAttr = [];

        //request is to remove any attributes that didn't exist previously
        //need to store the attributes in an array and remove them afterwards as otherwise there are side affects
        for(var i=0, j=currAttr.length; i < j; i++) 
        {
          if(!(currAttr[i]["name"] in attributes)) 
          {
            removeAttr.push(currAttr[i]["name"]);
          }
        }

        for(var i=0, j=removeAttr.length; i < j; i++) 
        {
          element.removeAttr(removeAttr[i]);
        }

        for (var attribute in attributes)
        {
          element.attr(attribute, attributes[attribute]["attr"]);
        }
      }

    });
    
  },
    
  
  /**
   * Determines the name of the translation bundle section for this component
   * @return {string} the name of this component's translations section
   * 
   * @memberof! oj.baseComponent
   * @protected
   */
  _GetTranslationsSectionName: function()
  {
    return this.widgetFullName;
  },
  
  
  /**
   * Retrieves a translated string after inserting optional parameters
   * @param {string} key the translations resource key
   * The key is used to retrieve a format pattern from the component options, or if none
   * is found - from the translated resource bundle.
   * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
   * for the optional parameters.  Token strings should not contain comma (,) 
   * or space characters, since they are reserved for future format type enhancements.
   * The reserved characters within a pattern are:
   * $ { } [ ]  
   * These characters will not appear in the formatted output unless they are escaped
   * with a dollar character ('$').
   * 
   * @param {...string|Object|Array} var_args  - optional parameters to be inserted into the 
   * translated pattern.
   * 
   * If more than one var_args arguments are passed, they will be treated as an array 
   * for replacing positional tokens like {0}, {1}, etc.
   * If a single argument is passed, it will be treated as a Javascript Object whose
   * keys will be matched to tokens within the pattern. Note that an Array is just
   * a special kind of such an Object.
   * 
   * For backward compatibility, a var_args argument whose type is neither 
   * Object or Array will be used to replace {0} in the pattern.
   * @return formatted translated string or the key argument if the resource for the
   * key was not found
   * @private
   */
  getTranslatedString : function (key, var_args)
  {
    var params = {}, pattern;
  
    if (arguments.length > 2)
    {
      params = Array.prototype.slice.call(arguments, 1);
    }
    else if (arguments.length == 2)
    {
      params = arguments[1];
      if (typeof params !== 'object' && !(params instanceof Array))
      {
        params = [params];
      }
        
    }
    pattern = this.option(_OJ_TRANSLATIONS_PREFIX + key);
    // pattern could be undefined
    return (pattern == null) ? key : oj.Translations.applyParameters(pattern.toString(), params);
  },
  
  /**
   * <p>Returns the component DOM node indicated by the <code class="prettyprint">locator</code> parameter.
   * 
   * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is 
   * <code class="prettyprint">null</code>, then this method returns the element on which this component was initalized.
   * 
   * <p>If a <code class="prettyprint">subId</code> was provided but no corresponding node 
   * can be located, then this method returns <code class="prettyprint">null</code>.
   * 
   * @expose
   * @memberof oj.baseComponent
   * @instance
   * 
   * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code> 
   * property, whose value is a string that identifies a particular DOM node in this component.  
   * 
   * <p>If this component has (or inherits) any subIds, then they are documented in the 
   * "Sub-ID's" section of this document.
   * 
   * <p>Subclasses of this component may support additional fields of the 
   * <code class="prettyprint">locator</code> Object, to further specify the desired node.
   * 
   * @returns {Element|null} The DOM node located by the <code class="prettyprint">subId</code> string passed in 
   * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
   * 
   * @example <caption>Get the node for a certain subId:</caption>
   * // Foo is ojInputNumber, ojInputDate, etc.
   * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-some-sub-id'} );
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null || locator['subId'] == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  },
  
  /**
   * Returns the subId string for the given child DOM node.  For more details, see 
   * <a href="#getNodeBySubId">getNodeBySubId</a>.
   * 
   * @expose
   * @memberof oj.baseComponent
   * @instance
   * 
   * @param {!Element} node - child DOM node
   * @return {string|null} The subId for the DOM node, or <code class="prettyprint">null</code> when none is found.
   * 
   * @example <caption>Get the subId for a certain DOM node:</caption>
   * // Foo is ojInputNumber, ojInputDate, etc.
   * var subId = $( ".selector" ).ojFoo( "getSubIdByNode", nodeInsideComponent );
   * @private
   */
  getSubIdByNode: function(node)
  {
    return null;
  },
  
  /**
   * Overridden to set oj-hover and oj-focus classes
   * @private
   */
  'destroy': function()
  {
    this._unbindContextMenu();
    this._super();
    
    // clean up states
    this.element.removeClass(_OJ_COMPONENT_NODE_CLASS);
    this.widget().removeClass( "oj-disabled" );
    this['hoverable'].removeClass( "oj-hover" );
    this['focusable'].removeClass( "oj-focus" );
    this['activeable'].removeClass( "oj-active" );
    
    _removeWidgetName(this.element, this.widgetName);
    
    //this._RestoreAttributes();
  },
  
  /*
   * Internal notes:
   * Overridden to pass extra flags to _setOption
   * param {...Object} var_args - key (or map), value, flags
   */
  /**
   * This method has several overloads, which get and set component options and their fields.  The functionality is unchanged from 
   * that provided by JQUI.  See the examples for details on each overload.
   * 
   * @expose
   * @memberof! oj.baseComponent
   * @instance
   * 
   * @param {string|Object=} optionName the option name (string, first two overloads), or the map (Object, last overload).
   *        Omitted in the third overload.
   * @param {Object=} value a value to set for the option.  Second overload only.
   * @return {Object|undefined} The getter overloads return the retrieved value(s).  When called via the public jQuery syntax, the setter overloads 
   *         return the object on which they were called, to facilitate method chaining.
   * 
   * @example <caption>First overload: get one option:
   * <p>This overload accepts a (possibly dot-separated) <code class="prettyprint">optionName</code> param as a string, and returns 
   * the current value of that option.</caption>
   * var isDisabled = $( ".selector" ).ojFoo( "option", "disabled" ); // Foo is Button, Menu, etc.
   * 
   * // For object-valued options, dot notation can be used to get the value of a field or nested field.
   * var startIcon = $( ".selector" ).ojButton( "option", "icons.start" ); // icons is object with "start" field
   * 
   * @example <caption>Second overload: set one option:
   * <p>This overload accepts two params: a (possibly dot-separated) <code class="prettyprint">optionName</code> string, and a new value to 
   * which that option will be set.</caption>
   * $( ".selector" ).ojFoo( "option", "disabled", true ); // Foo is Button, Menu, etc.
   * 
   * // For object-valued options, dot notation can be used to set the value 
   * // of a field or nested field, without altering the rest of the object.
   * $( ".selector" ).ojButton( "option", "icons.start", myStartIcon ); // icons is object with "start" field
   * 
   * @example <caption>Third overload: get all options:
   * <p>This overload accepts no params, and returns a map of key/value pairs representing all the component 
   * options and their values.</caption>
   * var options = $( ".selector" ).ojFoo( "option" ); // Foo is Button, Menu, etc.
   * 
   * @example <caption>Fourth overload: set one or more options:
   * <p>This overload accepts a single map of option-value pairs to set on the component.  Unlike the first two 
   * overloads, dot notation cannot be used.</caption>
   * $( ".selector" ).ojFoo( "option", { disabled: true, bar: 42 } ); // Foo is Button, Menu, etc.
   */
  option: function(optionName, value) // actually varArgs per comment above the JSDoc, but GCC warns unless matches the @param that we wish to doc
  {
    if (arguments.length === 0)
    {
      // don't return a reference to the internal hash
      return $.widget.extend({}, this.options);
    }
    
    var key = arguments[0];
    
    var options = key;
    var subkey = null;
    
    var flags = {};

    if (typeof key === "string")
    {
      // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
      options = {};
      var parts = key.split(".");
      key = parts.shift();
      if (parts.length)
      {
        subkey = parts.join(".");
        
        var curOption; 
        try
        {
          // Inform dynamic getters that the subkey is being set
          if (arguments.length > 1)
          {
            this._settingNestedKey = subkey;
          }
          
          curOption = options[key] = $.widget.extend({}, this.options[key]);
        }
        finally
        {
          this._settingNestedKey = null;
        }
        
        for (var i = 0; i < parts.length - 1; i++)
        {
          curOption[parts[i]] = curOption[parts[i]] || {};
          curOption = curOption[parts[i]];
        }
        
        key = parts.pop();
        if (arguments.length === 1)
        {
          return curOption[key] === undefined ? null : curOption[key];
        }
        
        curOption[key] = value;
      }
      else 
      {
        if (arguments.length === 1)
        {
          return this.options[key] === undefined ? null : this.options[key];
        }
        options[key] = value;
      }
      
      flags = arguments[2] || flags;
    }
    else
    {
      flags = arguments[1] || flags;
    }
    
    // Store subkey on the flags to let _setOption() know that dot notation was used
    if (subkey != null)
    {
      flags = $.widget.extend({}, flags, {'subkey': subkey});
    }

    this._setOptions(options, flags);

    return this;
  
  },
  
  /**
   * Overridden to pass extra flags to _setOption
   * @private
   */
  _setOptions : function (options, flags)
  {
  
    for (var key in options)
    {
      this._setOption(key, options[key], flags);
    }

    return this;
  },
        
  /**
   * Overridden to set oj-hover and oj-focus classes
   * @private
   */
  _setOption: function(key, value, flags)
  {
    if ( key === "disabled" )
    {
      // The JQUI superclass method has hard-coded style classes in the 'if key === "disabled"' block, so unfortunately 
      // we must copy that logic here with updated style classes, and NOT call _super() for the disabled case.
      // TBD: keep this logic updated if superclass method changes.  
      this.options[ key ] = value;
      
      // TBD: widget() is not always the thing that should have aria-disabled on it.  E.g. for the checkbox/radio flavors of ojButton, 
      // widget() returns the root node, but aria-disabled belongs on the <input>.  We fixed this JQUI bug in ojButton by having ojButton
      // override this method to remove it from the root node and add it to the input.  Would be better for each component to know which 
      // element to apply that to, e.g. an overridable method returning that element, or copying "hoverable" paradigm if appropriate.  
      // In the cases where this.element is different than widget(), this.element is more likely to be the right thing, so maybe change 
      // default to that.
      // Update: this issue is getting even more awkward now that we have "effectively disabled".  Probably need to refactor this code!
      this.widget()
	  .toggleClass( "oj-disabled", !!value )
	  .attr( "aria-disabled", value );
      
      if (value) 
      {
          this['hoverable'].removeClass( "oj-hover" );
          this['focusable'].removeClass( "oj-focus" );
          // TODO: when we have worked out the 'create' super code change,
          // this this check should not be necessary. Right now, this gets
          // called before _create for radioset (and possibly others) when
          // we create a component like ojRadioset({disabled: true});
          if (!this['activeable'])
            this['activeable'] = $(); 
          this['activeable'].removeClass( "oj-active" );
      }
    }
    else {
      // disabled is the only key for which we don't call _super()
      
      try
      {
        var subkey = (flags == null)? null :flags['subkey'];
        if (subkey != null)
        {
          this._settingNestedKey = subkey;
        }
        
        this._super(key, value);
      }
      finally
      {
        this._settingNestedKey = null;
      }
      
      if ( key === "contextMenu" )
        this._setupContextMenu();
    }
    
    return this;
  },
  
  /*
   * Private.  Do not override.
   * 
   * This method adds/removes a contextMenu listener on the component, based on the component's "contextMenu" option.
   * It is private since the logic that is likely to vary by component is encapsulated in the protected callee
   * <code class="prettyprint">_OpenContextMenu()</code>.
   */
  _setupContextMenu: function()
  {
    this._unbindContextMenu();
    
    var menu = this.options.contextMenu;
    // menu is selector like "#myMenuId", or null, or some malformed thing.
    
    // TODO: move this part to _InitOptions, in the trxn that handles that refactoring
    if (!menu)
    {
        menu = this.element.attr("contextmenu");
        if (menu)
            menu = "#" + menu;
    }
    
    if ( menu )
        menu = $(menu).data( "oj-ojMenu" ); // if selector finds >1 element, .data() uses the first one.
                                            // if selector finds 0 elements, .data() returns nothing.
    if ( menu )
    {
        var self = this;
        
        // TODO: remove this "widget &&" null-check when create-time changes have all been made.  Until then, want to make 
        // sure we don't NPE if this runs before the subclass has created the root node returned by widget().
        var widget = this.widget();
        widget && widget.on( "keydown" + this.contextMenuEventNamespace + " " + "contextmenu" + this.contextMenuEventNamespace, function( event ) {
            if (event.type === "contextmenu" || (event.which == 121 && event.shiftKey)) // right-click or Shift-F10
            {
                self._OpenContextMenu(menu, event);
                return false; // don't show native context menu
            }

            return true;
        });
    }
  },
  
  /* 
   * This method removes contextMenu functionality from the component.
   * 
   * TODO: all API doc at-tags, including @private, then add 2nd star at top.
   */
  _unbindContextMenu: function()
  {
    // TODO: remove this "widget &&" null-check when create-time changes have all been made.  Until then, want to make 
    // sure we don't NPE if this runs before the subclass has created the root node returned by widget().
    var widget = this.widget();
    widget && widget.off( this.contextMenuEventNamespace );
  },
  
  /**
   * <p>When the <code class="prettyprint">contextMenu</code> option is set, this method is called when the user invokes the context menu.
   * The default implementation simply calls <code class="prettyprint">menu.open(event, {"launcher": this.element, "initialFocus": "menu"})</code>.
   * 
   * <p>This method may be overridden by components needing to configure the menu specially, typically to customize the <code class="prettyprint">launcher</code>.
   * 
   * <p>Depending on individual component needs, any focusable element within the component can be the appropriate launcher.  By default it's the component root, 
   * but (e.g.) Toolbar uses the currently focused toolbar button.
   * 
   * <p>Focus returns to the launcher on menu dismissal, so the launcher must at least be focusable.  Typically a tabbable (not just 
   * focusable) element is safer, since it just focuses something the user could have focused on their own anyway.  
   * 
   * <p>In particular, components with a "roving tabstop" (like Toolbar) should typically choose the current tabstop as their launcher.
   * 
   * <p>The [:focusable]{@link http://api.jqueryui.com/focusable-selector/} and [:tabbable]{@link http://api.jqueryui.com/tabbable-selector/} selectors 
   * may come in handy for choosing a launcher, e.g. something like <code class="prettyprint">this.element.find(".my-class:tabbable").first()</code>.
   * 
   * <p>Subclasses should specify <code class="prettyprint">initialFocus:"menu"</code> in the call to <code class="prettyprint">menu.open()</code>.
   * 
   * @expose
   * @memberof oj.baseComponent
   * @instance
   * @protected
   * 
   * @param {Object} menu The JET Menu to open as a context menu
   * @param {Event} event What triggered the menu launch
   */
  _OpenContextMenu: function(menu, event)
  {
    menu.open(event, {"launcher": this.element, "initialFocus": "menu"});
  },
    
  /**
   * Overridden to set oj-hover class
   * @private
   */
  _hoverable: function( element )
  {
    // The JQUI superclass method has hard-coded style classes, so unfortunately 
    // we must copy that logic here with updated style classes, and NOT call _super().
    // TBD: keep this logic updated if superclass method changes.  
    this['hoverable'] = this['hoverable'].add( element );
    this._on( element, {
      mouseenter: function( event ) {
        $( event.currentTarget ).addClass( "oj-hover" );
      },
      mouseleave: function( event ) {
        $( event.currentTarget ).removeClass( "oj-hover" );
      }
    });
  },
  
  /**
   * Overridden to set oj-focus class
   * @private
   */
  _focusable: function( element )
  {
    // The JQUI superclass method has hard-coded style classes, so unfortunately 
    // we must copy that logic here with updated style classes, and NOT call _super().
    // TBD: keep this logic updated if superclass method changes.  
    this['focusable'] = this['focusable'].add( element );
    this._on( element, {
      focusin: function( event ) {
	  $( event.currentTarget ).addClass( "oj-focus" );
	},
	focusout: function( event ) {
	  $( event.currentTarget ).removeClass( "oj-focus" );
	}
    });
  },      
  
  /**
   * Set oj-active class on mousedown  and remove it on mouseup.
   * oj-active is one of JET's 'marker' style classes. It emulates 
   * the css :active pseudo-class.
   * @private
   */
  _activeable: function( element )
  {
    this['activeable'] = this['activeable'].add( element );
    
    this._on( element, {
    mousedown: function( event ) 
    {
      $( event.currentTarget ).addClass( "oj-active" );
    },
    mouseup: function( event ) 
    {
      $( event.currentTarget ).removeClass( "oj-active" );
    }
    });
  },
  
  /**
   * Retrieves a translated resource for a given key
   * @param {string} key
   * @return {Object} resource associated with the key or null if none was found
   * @private
   */
  getResource : function (key)
  {
    return this.option(_OJ_TRANSLATIONS_PREFIX + key);
  },
  
  /**
   * <p>Determines whether the component is LTR or RTL.
   * 
   * <p>Component responsibilities:
   * 
   * <ul>
   * <li>All components must determine directionality exclusively by calling this protected superclass method.
   *     (So that any future updates to the logic can be made in this one place.)</li>
   * <li>Components that need to know the directionality must call this method from <code class="prettyprint">_create()</code> 
   *     and <code class="prettyprint">refresh()</code>, and cache the value.  
   * <li>Components should not call this at other times, and should instead use the cached value.  (This avoids constant DOM 
   *     queries, and avoids any future issues if directional islands and component reparenting (e.g. popups) should coexist.)</li>
   * </ul>
   * 
   * <p>App responsibilities:
   * 
   * <ul>
   * <li>The app specifies directionality by setting the HTML <code class="prettyprint">"dir"</code> attribute on the 
   *     <code class="prettyprint">&lt;html></code> node.  When omitted, the default is <code class="prettyprint">"ltr"</code>.  
   *     (Per-component directionality / directional islands are not currently supported due to inadequate CSS support.)</li>
   * <li>As with any DOM change, the app must <code class="prettyprint">refresh()</code> the component if the directionality changes dynamically. 
   *   (This provides a hook for component housekeeping, and allows caching.)</li>
   * </ul>
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   * @return {string} the reading direction, either <code class="prettyprint">"ltr"</code> or <code class="prettyprint">"rtl"</code>
   * @default <code class="prettyprint">"ltr"</code>
   */
  _GetReadingDirection: function( )
  {
    var dir = document.documentElement.getAttribute("dir");
    if (dir)
      dir = dir.toLowerCase();
    return (dir === "rtl") ? "rtl" : "ltr";
  },
  
  /**
   * Notifies the component that its subtree has been connected to the document programmatically after the component has
   * been created
   * @memberof! oj.baseComponent
   * @instance
   * @protected 
   */
  _NotifyAttached: function()
  {
    this._propertyContext = null;
  },
  
  /**
   * Notifies the component that its subtree has been removed from the document programmatically after the component has
   * been created
   * @memberof! oj.baseComponent
   * @instance
   * @protected 
   */
  _NotifyDetached: function()
  {
    this._propertyContext = null;
  },
  
  /**
   * Notifies the component that its subtree has been made visible programmatically after the component has
   * been created
   * @memberof! oj.baseComponent
   * @instance
   * @protected 
   */
  _NotifyShown: function()
  {
    
  },
  
  /**
   * Notifies the component that its subtree has been made hidden programmatically after the component has
   * been created
   * @memberof! oj.baseComponent
   * @instance
   * @protected 
   */
  _NotifyHidden: function()
  {
    
  },
  
  /**
   * Determines whether this component is effectively disabled, i.e. it has its 'disabled' atrribute set to true
   * or it has been disabled by its ancestor  component
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   * @return {boolean} true of the component has been effectively disabled, false otherwise
   */
  _IsEffectivelyDisabled: function()
  {
    return (this.options['disabled'] || this._ancestorDisabled) ? true : false;
  },
  
  /**
   * Sets the ancestor-provided disabled state on this component 
   * @memberof! oj.baseComponent
   * @instance
   * @private
   * @param {boolean} disabled - true if this component is being disabled by its ancestor component, false otherwise
   */
  __setAncestorComponentDisabled: function(disabled)
  {
    this._ancestorDisabled = disabled;
  },
  
  
  /**
   * @private
   */
  _getTranslationSectionLoader: function()
  {
    var sectionNames = [];
    
    var self = this;
    
    var index = 0;
    
    this._traverseWidgetHierarchy(
      function(proto)
      {
        // retrive translation section name for the widget and all of its ancestors
        
        // Since _GetTranslationsSectionName() is a protected method, we can only call it on the widget instance.
        // For superclases, we will assume that their section names can only be their full widget name 
        
        var name = (index == 0) ? self._GetTranslationsSectionName() : proto.widgetFullName;
        index++;
        
        var section = oj.Translations.getComponentTranslations(name);
        
        if (section != null && !$.isEmptyObject(section))
        {
          sectionNames.push(name);
        }
      }
    );
    
    var count = sectionNames.length;
    
    if (count > 0)
    {
      return function()
            {
              // Optimize for the most common case where superclasses do not define translations
              if (count == 1)
              {
                return oj.Translations.getComponentTranslations(sectionNames[0]);
              }
              else
              {
                var trs = {};
                
                for (var i = count-1; i>=0; i--)
                {
                  $.widget.extend(trs, oj.Translations.getComponentTranslations(sectionNames[i]));
                }
                
                return trs;
              }
            };
    }
    return null;
  },
  
  /**
   * @private
   */
  _getDynamicPropertyContext: function()
  {
    if (!this._propertyContext)
    {
      var c = {};
      this._propertyContext = c;
      c['containers'] = _getSpecialContainerNames(this.element[0]);
    }
    return this._propertyContext;
  },
  
  /**
   * @private
   */
  _setupDefaultOptions: function(originalDefaults, constructorOptions)
  {
    var options = this.options;
    
    // Load component translations
    var translationLoader = this._getTranslationSectionLoader();
    
    var currVal = constructorOptions[_OJ_TRANSLATIONS_OPTION];
    
    if (translationLoader != null && (currVal === undefined || $.isPlainObject(currVal) ))
    {
      _defineDynamicProperty(this, undefined, constructorOptions[_OJ_TRANSLATIONS_OPTION], 
                             options,  _OJ_TRANSLATIONS_OPTION, translationLoader);
    }
    
    
    // Load options specified with oj.Components.setDefaultOptions()
    this._loadGlobalDefaultOptions(originalDefaults, constructorOptions)
    
  },
  
  /**
   * @private
   */
  _loadGlobalDefaultOptions: function(originalDefaults, constructorOptions)
  {
    var options = this.options;
    
    var defaults = {};
    
    var widgetHierNames = [];
    
    // walk up the widget hierarchy
    this._traverseWidgetHierarchy( 
              function(proto)
              {
                 widgetHierNames.push(proto.widgetName);
              }
    );
    
    var allProperties = oj.Components.getDefaultOptions();
    widgetHierNames.push('default');
    
    
    // merge properties applicable to this component
    for (var i = widgetHierNames.length-1; i>=0; i--)
    {
      var name = widgetHierNames[i];
      var props = allProperties[name];
      if (props !== undefined)
      {
        defaults = $.widget.extend(defaults, props);
      }
    }
    
    if ($.isEmptyObject(defaults))
    {
      return;
    }
    
    var self = this;
    
    var contextCallback = function()
    {
      return self._getDynamicPropertyContext();
    };
    
    
    for (var prop in defaults)
    {
      var val = constructorOptions[prop];
      
      if (val === undefined || $.isPlainObject(val))
      {
        var defaultVal = defaults[prop];
        
        if (defaultVal != null && defaultVal instanceof __ojDynamicGetter)
        {
          var callback = defaultVal.getCallback();
          if ($.isFunction(callback))
          {
            _defineDynamicProperty(this, originalDefaults[prop], val, options, prop, callback, contextCallback);
          }
          else 
          {
            oj.Logger.error("Dynamic getter for property %s is not a function", prop);
          }
        }
        else
        {
          options[prop] = _mergeOptionLayers([originalDefaults[prop], defaultVal, val]);
        }
      }
    }
  },
  
  /**
   * @private
   */
  _traverseWidgetHierarchy: function(callback)
  {
    var proto = this.constructor.prototype;
    while (proto != null && 'oj' === proto['namespace'])
    {
      callback(proto);
      proto = Object.getPrototypeOf(proto);
    }
  }
});

/**
 * This method is our version of $.widget, i.e. the static initializer of a component such as ojButton.
 * It calls that method, plus does any other static init we need.
 * 
 * TODO: 
 * - Consider moving this method into its own file.
 * - For base param, make the type oj.baseComponent rather than Object, but need to declare that as a type first.  Review how that's done.
 * 
 * @private
 * @param {string} name typically of the form "oj.ojMenu"
 * @param {Object} base NOT optional (unlike JQUI) 
 * @param {Object} prototype
 */
oj.__registerWidget = function( name, base, prototype )
{
  $.widget( name, base, prototype );

  // create single-OJ pseudo-selector for component, e.g. ":oj-menu", in addition to the ":oj-ojMenu" that $.widget() creates.
  // for private components it will begin with an underscore, e.g.,  ":_oj-radio"
  if (name.substring(0, 5) === "oj.oj" || name.substring(0, 6) === "oj._oj")
  { 
    var nameArray = name.split( "." ); // ["oj", "ojMenu"], ["oj", "_ojRadio"]
    var namespace = nameArray[ 0 ];    // "oj"
    var simpleName = nameArray [ 1 ];  // "ojMenu", "_ojRadio"
    var fullName = namespace + "-" + simpleName; // "oj-ojMenu", "oj-_ojRadio"
    var isPrivate = simpleName.substring(0, 1) === "_";
    // if private, make the single-oj pseudo-selector start with an underscore, like this -> "_oj-radio"
    var modifiedFullName; // "oj-Menu", "_oj-Radio".  Lowercased below.
    if (isPrivate)
    {
      modifiedFullName = "_" + namespace + "-" + simpleName.substring(3); 
    }
    else
    {
      modifiedFullName = namespace + "-" + simpleName.substring(2);
    }

    // Capitalization doesn't seem to matter with JQ pseudos, e.g. for the existing double-oj pseudo, both $(":oj-ojMenu") and $(":oj-ojmenu") work.
    // So, follow JQUI's pattern of using toLowerCase here, which will lowercase not only the "M' in "Menu", but also any camelcased chars after that.
    $.expr[ ":" ][ modifiedFullName.toLowerCase() ] = function( elem ) {
      return !!$.data( elem, fullName );
    };
  }
};



/**
 * @param {Object} self
 * @param {Object|undefined} originalDefaultValue
 * @param {?Object} constructorValue
 * @param {!Object} options
 * @param {string} prop
 * @param {Function} getter
 * @param {Function=} contextCallback
 * @private
 */
 function _defineDynamicProperty(self, originalDefaultValue, constructorValue, options, prop, getter, contextCallback)
 {
   var override = constructorValue;
   var replaced = false;
   var overriddenSubkeys = {};
   
   delete options[prop];
   
   Object.defineProperty(options, prop,
     {
       'get': function()
              {
                // Once the option is replaced, we no longer merge in defaults
                if (replaced)
                {
                  return override;
                }
                
                if (self._settingNestedKey != null)
                {
                  // The getter is getting called from the option() method that will be mutating the current
                  // object. We need to return only the override portion in this case to avoid the defaults being
                  // reapplied as an override
                  
                  return override;
                  
                }
                 
                var defaultVal = getter(contextCallback? contextCallback() : prop);
                
                return _mergeOptionLayers([originalDefaultValue, defaultVal, override], overriddenSubkeys)
              },
       'set': function(value)
              {
                override = value;
                
                if (self._settingNestedKey != null) 
                {
                  overriddenSubkeys[self._settingNestedKey] = true;
                }
                else // The entire option has been replaced
                {
                  replaced = true;
                }
              },
       'enumerable' : true
     }
   );
 };
 
 /**
  * @private
  */
 function _getSpecialContainerNames(elem)
 {
    var containers = [];
    while (elem)
    {
      var ga =  elem.getAttribute;
      var name = ga ? ga.call(elem, oj.Components._OJ_CONTAINER_ATTR) : null;
      if (name != null)
      {
        containers.push(name);
      }
      elem = elem.parentNode;
    }
    
    return containers;
 };
 
 /**
  * @private
  */
 function _storeWidgetName(element, widgetName)
 {
   var data = element.data(_OJ_WIDGET_NAMES_DATA);
   if (!data)
   {
     data = [];
     element.data(_OJ_WIDGET_NAMES_DATA, data);
   }
   if (data.indexOf(widgetName) < 0)
   {
     data.push(widgetName);
   }
 }
 
 /**
  * @private
  */
 function _removeWidgetName(element, widgetName)
 {
   var data = element.data(_OJ_WIDGET_NAMES_DATA);
   if (data)
   {
     var index = data.indexOf(widgetName);
     if (index >= 0)
     {
       data.splice(index, 1);
       if (data.length === 0)
       {
         element.removeData(_OJ_WIDGET_NAMES_DATA);
       }
     }
   }
 }
 
 /**
  * @private
  * @param {Array} values - values to merge
  * @param {Object=} overriddenSubkeys subkeys where the merging should not occur, i.e.
  * the value from corresponsing subkey on the last element of values array should win
  */
 function _mergeOptionLayers(values, overriddenSubkeys)
 {
   var result = undefined;
   for (var i=0; i<values.length; i++) 
   {
      var value = values[i];
      if (value !== undefined )
      {
        if ($.isPlainObject(value)) 
        {
          var input =  $.isPlainObject(result) ? [result, value] : [value];
          // The last object (overrides) is always fully merged in
          result = _mergeObjectsWithExclusions({}, input, (i == values.length - 1)? null: overriddenSubkeys, null);
        } 
        else 
        {
          result = value;
        }
      }
    }
    return result;
 }
 
 /**
 * @private
 */
function _mergeObjectsWithExclusions(target, input, ignoreSubkeys, basePath)
{
  var inputLength = input.length;
  
  for (var inputIndex = 0; inputIndex < inputLength; inputIndex++)
  {
    var source = input[inputIndex];
    var keys = Object.keys(source); 
    for (var i=0; i<keys.length; i++)
    {
      var key = keys[i];
      var path = (ignoreSubkeys == null)? null:  (basePath == null ? key : basePath + '.' + key);
      // Ignore all sources when the current path is registered in ignoreSubkeys
      if (ignoreSubkeys == null || !ignoreSubkeys[path])
      {
        var value = source[key];
        if (value !== undefined)
        {
          if ($.isPlainObject(value))
          {
            var params = $.isPlainObject(target[key])? [target[key], value]: [value];
            target[key] = _mergeObjectsWithExclusions({}, params, ignoreSubkeys, path);
          }
          else 
          {
            target[key] = value;
          }
        }
      }
    }
  }
  return target;
}

 
 /**
  * @private
  */
  var _OJ_TRANSLATIONS_OPTION = "translations";
  var _OJ_TRANSLATIONS_PREFIX = _OJ_TRANSLATIONS_OPTION + ".";
/*jslint browser: true*/
/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/
/**
 * DOM utilities.
 * @ignore
 */
oj.DomUtils = {};

oj.DomUtils._HTML_START_TAG = "\x3chtml\x3e";
oj.DomUtils._HTML_END_TAG = "\x3c/html\x3e";
oj.DomUtils._LEGAL_ELEMENTS = {"SPAN":1, "B":1, "A":1, "I":1, "EM":1, "BR":1, "HR":1, "LI":1, "OL":1, "UL":1, "P":1, "TT":1, "BIG":1, "SMALL":1, "PRE":1};
oj.DomUtils._LEGAL_ATTRIBUTES = {"class":1, "style":1, "href":1};
oj.DomUtils.SURROGATE_ID = "data-oj-surrogateid";
/**
 * Returns true if the value is null or if the trimmed value is of zero length.
 * 
 * @param {string|null} content
 * @return {boolean} true if the string is wrapped in <html> tag.
 */        
oj.DomUtils.isHTMLContent = function(content)
{    
  if (content.indexOf(oj.DomUtils._HTML_START_TAG) === 0 && 
      content.lastIndexOf(oj.DomUtils._HTML_END_TAG) === content.length - 7) 
  {
    return true;
  }

  return false;
};

oj.DomUtils.cleanHtml = function (value) 
{
  var offSpan = $(document.createElement("span")).get(0);
  offSpan.innerHTML = value;
  if (value && value.indexOf("\x3c") >= 0) 
  {
    oj.DomUtils._cleanElementHtml(offSpan);
  }
  return offSpan;
}; 

oj.DomUtils._cleanElementHtml = function(node) 
{
  var children = node.childNodes, child, attrs, attr, childHasAttr, i;
  var count = children.length - 1;
  while (count >= 0) 
  {
    child = children.item(count);
    if (child && child.nodeType === 1) 
    {
      if (oj.DomUtils._LEGAL_ELEMENTS[child.nodeName]) 
      {
        attrs = child.attributes;
        for (i = attrs.length - 1;i >= 0;i--) 
        {
          attr = attrs[i];
          // jquery - the .attr() method returns undefined for attributes that have not been set.
          childHasAttr = $(child).attr(attr.name) !== undefined;
          if (childHasAttr) 
          {
            if (!oj.DomUtils._LEGAL_ATTRIBUTES[attr.name]) 
            {
              child.removeAttribute(attr.nodeName);
            }
          }
        }
        oj.DomUtils._cleanElementHtml(child);       
      }
      else 
      {
        if (child)
        {
          node.removeChild(child);
        }
      }      
    }

    count--;
  }
};

/**
 * Checks to see if the "ancestorNode" is a ancestor of "node".
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node".
 */
oj.DomUtils.isAncestor = function (ancestorNode, node) 
{
  oj.Assert.assertDomElement(ancestorNode);
  oj.Assert.assertDomElement(node);

  var surrogateId;
  var jump;
  var parentNode;

  // Some popups are reparented when open.  An attribute on the root popup dom points to
  // their associated placeholder element.  This link provides logical traversal
  // of the dom tree.
  if (node.nodeType === 1 && node.hasAttribute(oj.DomUtils.SURROGATE_ID))
  {
    surrogateId = node.getAttribute(oj.DomUtils.SURROGATE_ID);
    jump = $("#" + surrogateId);
    if (jump.length > 0)
      parentNode = jump[0];
    else
      parentNode = node.parentNode;
  }
  else
    parentNode = node.parentNode;

  while (parentNode) {
    if (parentNode == ancestorNode)
      return true;

    if (parentNode.nodeType === 1 && parentNode.hasAttribute(oj.DomUtils.SURROGATE_ID))
    {
      surrogateId = parentNode.getAttribute(oj.DomUtils.SURROGATE_ID);
      jump = $("#" + surrogateId);
      if (jump.length > 0)
        parentNode = jump[0];
      else
        parentNode = parentNode.parentNode;
    }
    else
      parentNode = parentNode.parentNode;

  }

  return false;
}

/**
 * Checks to see if the "ancestorNode" is a ancestor of "node" or if they are the same.
 *
 * @param {!Element} ancestorNode dom subtree to check to see if the target node exists
 * @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
 * @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node" or if they are the same
 */
oj.DomUtils.isAncestorOrSelf = function (ancestorNode, node) 
{
  oj.Assert.assertDomElement(ancestorNode);
  oj.Assert.assertDomElement(node);

  return (node == ancestorNode) ?
          true :
          oj.DomUtils.isAncestor(ancestorNode, node);
};


/**
 * Adds a resize listener for a block or inline-block element
 * @param {!Element} elem - node where the listener should be added
 * @param {!Function} listener - listener to be added. The listener will receive
 * two parameters: 1) the new width in pixels; 2) the new height in pixels
 */
oj.DomUtils.addResizeListener = function(elem, listener)
{
  var jelem = $(elem);
  var tracker = jelem.data(oj.DomUtils._RESIZE_TRACKER_KEY);
  if (tracker == null)
  {
    tracker = new oj.DomUtils._ResizeTracker(elem);
    jelem.data(oj.DomUtils._RESIZE_TRACKER_KEY, tracker);
    tracker.start();
  }
  tracker.addListener(listener);
}

/**
 * Removes a resize listener
 * @param {!Element} elem - node whose listener should be removed
 * @param {!Function} listener - listener to be removed
 */
oj.DomUtils.removeResizeListener = function(elem, listener)
{
  var jelem = $(elem);
  var tracker = jelem.data(oj.DomUtils._RESIZE_TRACKER_KEY);
  if (tracker != null)
  {
    tracker.removeListener(listener);
    if (tracker.isEmpty())
    {
      tracker.stop();
      jelem.removeData(oj.DomUtils._RESIZE_TRACKER_KEY);
    }
  }
};


/**
 * Fixes resize listeners after a subtree has been connected to the DOM or after
 * its display:none stayle has been removed
 * @param {!Element} subtreeRoot - subtree root
 */
oj.DomUtils.fixResizeListeners = function(subtreeRoot)
{  
  $(subtreeRoot).find(".oj-helper-detect-expansion").parent().each(
    function(index, div) 
    {
      var tracker = $(div).data(oj.DomUtils._RESIZE_TRACKER_KEY);
      if (tracker != null)
      {
        tracker.checkSize(false);
      }
    }
  );
};

/**
 * Determines whether a special 'meta' key was pressed when the event was fired.
 * For Mac OS, the 'meta' key is mapped to the 'Command' key, for all other platforms it is mapped
 * to the 'Control' key.
 * Note that this method will only work for the events that support .ctrlKey and .metaKey fields.
 * @param {!Object} evt - the event
 * @return true if the meta key is pressed, false otherwise
 */
oj.DomUtils.isMetaKeyPressed = function(evt)
{
  if (oj.DomUtils._isMac === undefined)
  {
    oj.DomUtils._isMac = (navigator && navigator.userAgent) ? 
          navigator.userAgent.toLowerCase().indexOf('mac os') >= 0: false;
  }
  
   return (oj.DomUtils._isMac ? evt.metaKey : evt.ctrlKey);
};



/**
 * @private
 */
oj.DomUtils._invokeAfterPaint =  (window['requestAnimationFrame'] || window['mozRequestAnimationFrame'] || 
                                  window['webkitRequestAnimationFrame'] || 
                                  function(fn){ return window.setTimeout(fn, 0); }
                                  ).bind(window);

/**
 * @private
 */                                  
oj.DomUtils._cancelInvokeAfterPaint =  (window['cancelAnimationFrame'] || window['mozCancelAnimationFrame'] || 
                                  window['webkitCancelAnimationFrame'] || 
                                  function(id){ return window.clearTimeout(id); }
                                  ).bind(window);

/**
 * Utility class for tracking resize events for a given element and  sispatching them
 * to listeners
 * @constructor
 * @ignore
 */
oj.DomUtils._ResizeTracker = function(div)
{
  this._listeners = $.Callbacks();
  
  this.addListener = function(listener)
  {
    this._listeners.add(listener);    
  };
  
  this.removeListener = function(listener)
  {
    this._listeners.remove(listener);    
  };
  
  this.isEmpty = function()
  {
    return this._listeners.empty();
  };
  
  this.start = function()
  {
    this._scrollListener = this._handleScroll.bind(this);
    
    // bug 19422383: Use native onresize support on teh DIV in IE9/10 and  since no scroll events are fired on the
    // contraction/expansion DIVs in IE9
    if (div.attachEvent)
    {
      this._resizeListener = this._handleResize.bind(this);
      div.attachEvent('onresize', this._resizeListener);
    }
    
    else
    {
      var firstChild = div.childNodes[0]; // could be undefined, but insertBefore() will deal with it
      
      // This child DIV will track expansion events. It is meant to be 1px taller and wider than the DIV
      // whose resize events we are tracking. After we set its scrollTop and scrollLeft to 1, any increate in size
      // will fire a scroll event
      var expDiv = this._detectExpansion = document.createElement("div");
      expDiv.className = "oj-helper-detect-expansion";
      var expansionChild = document.createElement("div");
      expDiv.appendChild(expansionChild);
      div.insertBefore(expDiv, firstChild);
       
      expDiv.addEventListener("scroll", this._scrollListener, false);
        
      // This child DIV will track contraction events. Its height and width are set to 200%. After we set its scrollTop and 
      // scrollLeft to the current height and width of its parent, any decrease in size will fire a scroll event
      var cotrDiv = this._detectContraction = document.createElement("div");
      cotrDiv.className = "oj-helper-detect-contraction";
      
      var contractionChild = document.createElement("div");
      contractionChild.style.width = "200%";
      contractionChild.style.height = "200%";
      cotrDiv.appendChild(contractionChild);
      div.insertBefore(cotrDiv, firstChild);
       
      cotrDiv.addEventListener("scroll", this._scrollListener, false);
      
      //Size child DIVs adn recored the current size of the tracked DIV
      if (expDiv.offsetParent != null)
      {
        this._adjust(expDiv.offsetWidth, expDiv.offsetHeight);
      }
    }
  };
  
  this.stop = function()
  {
    if (this._detectExpansion != null)
    {
      this._detectExpansion.removeEventListener("scroll", this._scrollListener);
      this._detectContraction.removeEventListener("scroll", this._scrollListener);
      div.removeChild(this._detectExpansion);
      div.removeChild(this._detectContraction);
    }
    else
    {
      // assume IE9/10
      div.detachEvent('onresize', this._resizeListener);
    }
  };
  
  
  this.checkSize = function(checkScrollPos)
  {
    var expDiv = this._detectExpansion;
    
    if (expDiv.offsetParent == null)
    {
      return;
    }
    
    var newWidth = expDiv.offsetWidth;
    var newHeight = expDiv.offsetHeight;
    if (this._oldWidth !== newWidth || this._oldHeight !== newHeight)
    {
      this._retrySetScroll = 2;
      this._adjust(newWidth, newHeight);
      
      if (this._invokeId !== undefined)
      {
        oj.DomUtils._cancelInvokeAfterPaint(this._invokeId);
      }
      
      var self = this;
      var listeners = this._listeners;
      
      this._invokeId = oj.DomUtils._invokeAfterPaint(
        function()
        {
          self._invokeId = undefined;
          listeners.fire(newWidth, newHeight);
        }
      );
    }
    // Workaround for the WebKit issue where scrollLeft gets reset to 0 without the DIV being expanded
    // We will retry to the set the scrollTop only twice to avoid infinite loops
    else if (checkScrollPos && this._retrySetScroll > 0 && (expDiv.scrollLeft == 0 || expDiv.scrollTop == 0))
    {
      this._retrySetScroll--;
      this._adjust(newWidth, newHeight);
    }
  };
  
  this._handleScroll = function(evt)
  {
    evt.stopPropagation();
    this.checkSize(true);
  };
  
  this._handleResize = function()
  {
     this._listeners.fire(div.offsetWidth, div.offsetHeight);
  };
  
  this._adjust = function(width, height)
  { 
    this._oldWidth = width;
    this._oldHeight = height;
    
    var expansionChild = this._detectExpansion.firstChild;
    expansionChild.style.width = width + 1 + 'px';
    expansionChild.style.height = height + 1 + 'px';
    
    this._detectExpansion.scrollLeft = 1;
    this._detectExpansion.scrollTop = 1;
    
    this._detectContraction.scrollLeft = width;
    this._detectContraction.scrollTop = height;
  };
}

oj.DomUtils._RESIZE_TRACKER_KEY = "_ojResizeTracker";
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Component Messaging Utilities.
 * @param {Object} component instance
 * @protected
 * @constructor
 * @since 0.6
 */
oj.ComponentMessaging = function (component) 
{
  this.Init(component);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.ComponentMessaging, oj.Object, "oj.ComponentMessaging");

/**
 * Default display types supported for component messaging.
 * Future: support for inline 
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 */
oj.ComponentMessaging._DISPLAY_TYPE = {
  NONE: "none",
  NOTEWINDOW: "notewindow", 
  PLACEHOLDER: "placeholder"
};

/**
 * Tracks the messaging strategy callback function by type, used to instantiate messaging strategies.
 * Implementations register by type. 
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 */
oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK = {};
  
/**
 * Stores the constructor function callback object used to constuct a strategy object for the 
 * specified type.
 * 
 * @param {string} type
 * @param {Function} strategyConstructorCallback a constructor callback that can be used to constuct
 * a strategy object for the specified type
 * @returns {undefined}
 */
oj.ComponentMessaging.registerMessagingStrategy = function (type, strategyConstructorCallback)
{
  if (type && typeof strategyConstructorCallback === "function")
  {
    oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK[type] = strategyConstructorCallback;
  }
};

/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that 
 * will be displayed by this strategy.
 * 
 * @param {Object} component widget instance
 * @memberof! oj.ComponentMessaging
 * @instance
 * @protected
 */
oj.ComponentMessaging.prototype.Init = function (component)
{
  oj.ComponentMessaging.superclass.Init.call(this);
  
  this._component = component;
  this._activated = false;
  
  this._initializeMessagingStrategies();
};

/**
 * Utility function that activates messaging on the component using the strategy provided.
 * @param {Object} launcher element(s) to which messaging applies
 * @param {Object} content 
 * @private
 */
oj.ComponentMessaging.prototype.activate = function (launcher, content)
{
  var that = this;
  oj.Assert.assertObject(content);
  this._launcher = launcher;
  
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);
  
  // if already active, reinitialize strategies based on new messagingDisplay preferences.
  if (!this._isActive())
  {
    $.each(this._strategies, function(i, strategy) 
    {
      strategy.activate(that);
    });
    this._activated = true;
  }
  else
  {
    this._reactivate();
  }
};

/**
 * Utility function that updates messaging on the component for the content provided, using the 
 * strategies.
 * 
 * @param {Object} content 
 * @private
 */
// TODO: component messaging could take the component instance
oj.ComponentMessaging.prototype.update = function (content)
{
  oj.Assert.assertObject(content);
  oj.Assert.assertBoolean(this._activated);
  
  this._messagingContent = oj.CollectionUtils.copyInto(this._messagingContent || {}, content);

  if (this._activated)
  {
    $.each(this._strategies, function(i, strategy) 
      {
        strategy.update();
      });
  }
};

/**
 * Utility function that deactivates messaging on the component using the strategy provided.
 * @private
 */
oj.ComponentMessaging.prototype.deactivate = function ()
{
  $.each(this._strategies, function(i, strategy) 
    {
      strategy.deactivate();
    });
    
  this._activated = false;
  this._component = null;
  this._launcher = null;
  this._strategies = {};
};

/**
 * Creates a messaging strategy for the specified type, initializing it with the options provided.
 * @param {string|number} type defined by oj.ComponentMessaging._DISPLAY_TYPE
 * @param {Array|undefined} options
 * 
 * @private
 * @instance
 * @memberOf !oj.ComponentMessaging
 */
oj.ComponentMessaging.prototype._createMessagingStrategy = function (type, options)
{
  var callback = oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK[type] || 
          oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK[oj.ComponentMessaging._DISPLAY_TYPE.NONE];
  
  // dynamically instantiate the strategy objects
  return new callback(options);
},

/**
 * Returns the component instance or null
 * 
 * @return {Object|null} 
 * @private
 * @instance
 * @memberOf !oj.ComponentMessaging
 */
oj.ComponentMessaging.prototype._getComponent = function ()     
{
  return this._component || null;
};

/**
 * Returns the launcher jquery element. This is the element on the component to which messaging 
 * applies. 
 * 
 * @return {Object|null} null if messaging is not activated.
 * @private
 * @instance
 * @memberOf !oj.ComponentMessaging
 */
oj.ComponentMessaging.prototype._getLauncher = function ()     
{
  return this._launcher || null;
};

/**
 * Returns the last saved messagingContent object.
 * 
 * @return {Object} 
 * @private
 * @instance
 * @memberOf !oj.ComponentMessaging
 */
oj.ComponentMessaging.prototype._getMessagingContent = function ()     
{
  return this._messagingContent || {};
};

/**
 * Whether the component messaging is activated. 
 * @return {boolean}
 * @private
 */
oj.ComponentMessaging.prototype._isActive = function ()
{
  return this._activated;
};

oj.ComponentMessaging.prototype._getResolvedMessagingDisplayOptions = function ()
{
    var artifactsByDisplayType = {}, artifactDisplayTypeResolved = false, displayTypes, displayType,
      compPH = this._component.options['placeholder'], artifact, keys, key, i, j,
      messagingPreferences = this._component.options['displayOptions'] || {},
      $messagingPreferences = {}, self = this;
      
    // first resolve primary display options for each artifact.
    // E.g. at the end of this loop you should have something like this
    // {messages: 'notewindow', converterHint: 'placeholder', validatorHint: 'notewindow', title: 'none'}
    keys = Object.keys(messagingPreferences);
    for (i = 0; i < keys.length; i++)
    {
      key = keys[i];
      displayTypes = messagingPreferences[key];
      // loop over array of displayTypes preferred for artifact.
      // artifacts are 'messages', 'converterHint', 'validatorHint', 'title'
      artifactDisplayTypeResolved = false;
      artifact = key + "";
      // we take either array or string values for displayOptions.
      if (Array.isArray(displayTypes))
      {
        for (j = 0; j < displayTypes.length; j++) 
        {
          displayType = displayTypes[j];
          if (!artifactDisplayTypeResolved)
          {
            artifactDisplayTypeResolved = 
              self._resolveDisplayTypeForArtifact(artifact, displayType, compPH, $messagingPreferences);
          }
        }
      }
      else if (typeof displayTypes === "string")
      {
        if (!artifactDisplayTypeResolved)
        {
          artifactDisplayTypeResolved = 
            self._resolveDisplayTypeForArtifact(artifact, displayTypes, compPH, $messagingPreferences);
        }
      }

      // if we couldn't resolve then use "none". E.g., validationHint: ['placeholder']
      if (!artifactDisplayTypeResolved)
      {
        $messagingPreferences[artifact] = oj.ComponentMessaging._DISPLAY_TYPE.NONE;
      }
    }
    
    // collate by displayType -> artifact. but first reset 
    $.each(oj.ComponentMessaging._DISPLAY_TYPE, function(type, name){
      artifactsByDisplayType[name] = [];
    });
    
    $.each($messagingPreferences, function(artifact, displayType)
    {
      // an artifact eventually resolves to one displayType. 
      artifactsByDisplayType[displayType].push(artifact);        
    });
    
    return artifactsByDisplayType;
},
        
oj.ComponentMessaging.prototype._resolveDisplayTypeForArtifact = function(
  artifact, 
  displayType, 
  compPH,
  $messagingPreferences)
{
  var artifactDisplayTypeResolved = false;
  switch (displayType)
  {
    // placeholder display is special in that it's only supported on 'converterHint'.
    case oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER :

      if (artifact === "converterHint")
      {
        // if placeholder is the first preference for converterHint, it's used under certain 
        // conditions
        // if options.placeholder is not set then use 'converterHint' as the default 
        // 'placeholder'
        // alternately if (options.placeholder), i.e., a custom placeholder is set, then 
        // ignore the placeholder displayType and use the next display type as the default 
        // for the artifact. We may have a fallback displayType in which case we use it, 
        // otherwise we use 'none'. E.g., 
        // {'converterHint': ['placeholder', 'notewindow']} // use notewindow
        // {'converterHint': ['placeholder']}               // use none

        if (!artifactDisplayTypeResolved)
        {
          if (!compPH)
          {
            $messagingPreferences[artifact] = displayType;
            artifactDisplayTypeResolved = true;
            
          }
        }
      }
      else
      {
        // displayType 'placeholder' is not supported on other artifacts
        // ignore if present
        // TODO: In the future we may want to support configuring validatorHint ot title as 
        // placeholder as well.
      }

      break;

    default:
      if (!artifactDisplayTypeResolved)
      {
        $messagingPreferences[artifact] = displayType;
        artifactDisplayTypeResolved = true;
      }
      break;
  }
  
  return artifactDisplayTypeResolved;
  
},

/**
 * Creates messaging strategies for the component based on the displayOptions.
 * @private
 */
oj.ComponentMessaging.prototype._initializeMessagingStrategies = function ()
{
  var artifactsByDisplayType = this._getResolvedMessagingDisplayOptions(), 
    displayInNoteWindow = artifactsByDisplayType[oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW], 
    displayNone = artifactsByDisplayType[oj.ComponentMessaging._DISPLAY_TYPE.NONE], 
    displayInPlaceholder = artifactsByDisplayType[oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER],
    messagingStrategies = {};
    
  if (displayInNoteWindow.length > 0)
  {
    messagingStrategies[oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW] = 
      this._createMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW, displayInNoteWindow);
  }
  
  if (displayInPlaceholder.length > 0)
  {
    messagingStrategies[oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER] = 
      this._createMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER, displayInPlaceholder);
  }
  
  messagingStrategies[oj.ComponentMessaging._DISPLAY_TYPE.NONE] = 
    this._createMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NONE, displayNone);

  this._strategies = messagingStrategies;
};

/**
 * Reinitializes component messaging with new messagingDisplayOptions.
 * 
 * @private
 */
oj.ComponentMessaging.prototype._reactivate = function ()
{
  var artifactsByDisplayType = this._getResolvedMessagingDisplayOptions(), strategy, cm = this; 
  
  // for every displayType being requested either create the messaging strategy for the type or 
  // reuse existing strategy if it has already been created. 
  $.each(artifactsByDisplayType, function(type, artifactsForType) 
    {
      type = type + ""; // coerce to avoid GCC warning
      strategy = cm._strategies[type];
      if (artifactsForType && artifactsForType.length > 0)
      {
        if (!strategy)
        {
          // create a strategy if one doesn't exist for the type
          strategy = cm._createMessagingStrategy(type, artifactsForType);
          cm._strategies[type] = strategy;
          strategy.activate(cm);
        }
        else if (strategy)
        {
          // update strategy with the latest displayOptions if already present. we don;t 
          // want to remove it once activated.
          strategy.reactivate(artifactsForType);
        }
      }
      else
      {
        if (strategy && oj.ComponentMessaging._DISPLAY_TYPE.NONE !== type)
        {
          // if we have no artifacts to show for a type, then remove the strategy.
          // only if its other than the DefaultMessagingStrategy as it's always needed to theme 
          // component.
          strategy.deactivate();
          delete cm._strategies[type];
        }
      }
    });
};

/**
 * A base messaging strategy class that is initialized with a set of displayOptions. This object 
 * also provides helper methods for its subclasses.
 * 
 * @param {Array} displayOptions an array of messaging artifacts displayed.
 * 
 * @constructor
 * @class oj.MessagingStrategy
 * @private
 */
oj.MessagingStrategy = function (displayOptions)
{
  this.Init(displayOptions);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.MessagingStrategy, oj.Object, "oj.MessagingStrategy");

/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that 
 * will be displayed by this strategy.
 * 
 * @param {Array} displayOptions an array of messaging artifacts displayed.
 * @private
 */
oj.MessagingStrategy.prototype.Init = function (displayOptions)
{
  oj.Assert.assertArray(displayOptions);
  oj.MessagingStrategy.superclass.Init.call(this);
  
  this._displayOptions = displayOptions;
};

oj.MessagingStrategy.prototype.activate = function (cm)
{
  this._componentMessaging = cm;
};

/**
 * Updates component with instance using the content provided.
 * 
 * @private
 */
oj.MessagingStrategy.prototype.update = function ()
{
};

/**
 * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any 
 * widgets it created, removes styles added etc.
 * 
 * @private
 */
oj.MessagingStrategy.prototype.deactivate = function ()
{
};

/**
 * Reinitializes with the new display options and updates component messaging using the new content. 
 * 
 * @param {Array} newDisplayOptions
 * @private
 */
oj.MessagingStrategy.prototype.reactivate = function (newDisplayOptions)
{
  this.Init(newDisplayOptions);
};

// P R O T E C T E D  M E T H O D S 
/**
 * Gets the launcher element for which the messaging is applied.
 * @return {Object} the jquery element of the form element.
 * @private
 */
oj.MessagingStrategy.prototype.GetLauncher = function ()
{
  return this._componentMessaging._getLauncher();
};

/**
 * Gets the component (widget).
 * @return {Object} the jet component instance
 * @private
 */
oj.MessagingStrategy.prototype.GetComponent = function ()
{
  return this._componentMessaging._getComponent();
};

/**
 * Returns an array of messages.
 * 
 * @return {Array} of messages each an instance of oj.Message
 * @private
 */
oj.MessagingStrategy.prototype.GetMessages = function ()
{
  return this.GetValidityState().getMessages();
};

oj.MessagingStrategy.prototype.GetMaxSeverity = function ()
{
  return this.GetValidityState().getMaxSeverity();
};

/**
 * Gets the converter hint.
 * 
 * @return {Array} an array of hints, each a string.
 * @private
 */
oj.MessagingStrategy.prototype.GetConverterHint = function ()
{
  var hints = [], converterHint = this._getMessagingContent()['converterHint'], hint;
  if (converterHint)
  {
    hints.push(converterHint);
  }
  
  return hints;
};

oj.MessagingStrategy.prototype.GetValidatorHints = function ()
{
  var hints = [], vHints = this._getMessagingContent()['validatorHint'] || [];
  $.each(vHints, function (index, hint)
    {
      hints.push(hint);
    }
  );
  
  return hints;
};


/**
 * Gets the short description.
 * @return {string} title or ""
 * @private
 */
oj.MessagingStrategy.prototype.GetTitle = function ()
{
  return this._getMessagingContent()['title'] || ""; 
};

/**
 * Gets the validityState.
 * @private
 */
oj.MessagingStrategy.prototype.GetValidityState = function ()
{
  return this._getMessagingContent()['validityState'];
};

/**
 * Whether the strategy is displaying messages or not.
 * @return {boolean} true if strategy has messages to display
 * @private
 */
oj.MessagingStrategy.prototype.HasMessages = function ()
{
  var messages = this.GetMessages();
  return (messages && messages.length > 0) ? true: false;
};

oj.MessagingStrategy.prototype.ShowMessages = function ()
{
  return this._displayOptions.indexOf('messages') !== -1 ? true : false;
};

oj.MessagingStrategy.prototype.ShowConverterHint = function ()
{
  return this._displayOptions.indexOf('converterHint') !== -1 ? true : false;
};

oj.MessagingStrategy.prototype.ShowValidatorHint = function ()
{
  return this._displayOptions.indexOf('validatorHint') !== -1 ? true : false;
};

oj.MessagingStrategy.prototype.ShowTitle = function ()
{
  return this._displayOptions.indexOf('title') !== -1 ? true : false;
};

/**
 * Returns true if we have invalid messages; false otherwise.
 * 
 * @return {boolean}
 * @private
 */
oj.MessagingStrategy.prototype.IsInvalid = function ()
{
  return this.GetValidityState().isInvalid();
};


/**
 * Gets the messagingContent stored in ComponentMessaging instance
 * @return {Object}
 * @private
 */
oj.MessagingStrategy.prototype._getMessagingContent = function ()
{
  if (this._componentMessaging)
  {
    return this._componentMessaging._getMessagingContent();
  }
  
  return {};
};


/**
 * A messaging strategy that updates the component theming and accessibility attributes.
 * 
 * @param {Array} displayOptions .
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
oj.DefaultMessagingStrategy = function(displayOptions)
{
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NONE, 
                                                oj.DefaultMessagingStrategy);

// TODO: Need to retrieve style selectors from a Style Manager
oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID = "oj-invalid";
oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING = "oj-warning";

oj.Object.createSubclass(oj.DefaultMessagingStrategy, oj.MessagingStrategy, "oj.DefaultMessagingStrategy");

/**
 * Updates component theming, a11y attributes using the latest component state and its messaging 
 * content.
 * 
 * @private
 */
oj.DefaultMessagingStrategy.prototype.update = function ()
{
  oj.DefaultMessagingStrategy.superclass.update.call(this);

  var launcher = this.GetLauncher(), maxSeverity = this.GetMaxSeverity(), removeClasses = [], 
      addClasses=[], invalid = false, component = this.GetComponent(), jqRoot = component.widget();
  
  if (!launcher)
  {
    return;
  }
  
  // apply element error styling if invalid
  if (this.IsInvalid())
  {
    // enable tooltip; set invalid class and aria invalid
    // TODO: oj classes should be set on the root DOM
    removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    addClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
    invalid = true;
  }
  else
  {
    // TODO: add warning or other severity state
    if (this.HasMessages() && maxSeverity === oj.Message.SEVERITY_LEVEL['WARNING'])
    {
      removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
      addClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    }
    else
    {
      // for all other messages we remove selectors
      removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID);
      removeClasses.push(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
    }
  }
  
  jqRoot.removeClass(removeClasses.join(" "))
          .addClass(addClasses.join(" ")); // classes added to root
  launcher.attr({"aria-invalid": invalid}); // aria attrs added to the launcher element
  
};

/**
 * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any 
 * widgets it created, removes styles added etc.
 * 
 * @private
 */
oj.DefaultMessagingStrategy.prototype.deactivate = function ()
{
  var jqRoot = this.GetComponent().widget();
  
  jqRoot.removeClass(oj.DefaultMessagingStrategy._SELECTOR_STATE_INVALID)
                  .removeClass(oj.DefaultMessagingStrategy._SELECTOR_STATE_WARNING);
  this.GetLauncher().removeAttr("aria-invalid");
  oj.DefaultMessagingStrategy.superclass.deactivate.call(this);
};


/**
 * A messaging strategy that uses html5 placeholder (for now) to set/remove placeholder content.
 * 
 * @param {Array} displayOptions an array of messaging artifacts displayed in the placeholder.
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
oj.PlaceholderMessagingStrategy = function(displayOptions)
{
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER, 
                                                oj.PlaceholderMessagingStrategy);

// Subclass from oj.MessagingStrategy 
oj.Object.createSubclass(oj.PlaceholderMessagingStrategy, oj.MessagingStrategy, "oj.PlaceholderMessagingStrategy");

/**
 * Initializer
 *  
 * @param {Array} displayOptions an array of messaging artifacts displayed in the notewindow.
 * @private
 */
oj.PlaceholderMessagingStrategy.prototype.Init = function (displayOptions) 
{
  oj.PlaceholderMessagingStrategy.superclass.Init.call(this, displayOptions);
};

/**
 * Sets up a placeholder for the component instance using the converter hint.
 * 
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to 
 * the latest messaging content.
 * 
 * @private
 */
oj.PlaceholderMessagingStrategy.prototype.activate = function (cm)
{
  oj.PlaceholderMessagingStrategy.superclass.activate.call(this, cm);
  this._refreshPlaceholder();
};

oj.PlaceholderMessagingStrategy.prototype.reactivate = function (newDisplayOptions)
{
  oj.PlaceholderMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);
  this._refreshPlaceholder();
};

oj.PlaceholderMessagingStrategy.prototype.deactivate = function ()
{
  oj.PlaceholderMessagingStrategy.superclass.deactivate.call(this);
};

// a default placeholder is set on the component, and that is typically the converter hint
oj.PlaceholderMessagingStrategy.prototype._refreshPlaceholder = function()
{
  var launcher = this.GetLauncher(), jqRoot = this.GetComponent().widget(), content, hints;
  
  if (this.ShowPlaceholderContent() && launcher)
  {
    hints = this.GetConverterHint();
    content = hints.length ? hints[0] : "";
    if (content)
    {
      var values = {}, flags = {};
      values['placeholder'] = content;
      flags['_oj_messaging_update'] = true; // to indicate to component that placeholder is being 
                                             // set from messaging module 

      this.GetComponent().option(values, flags);
    }
  }
};

oj.PlaceholderMessagingStrategy.prototype.ShowPlaceholderContent = function ()
{
  // we have a placeholder to set/show if we have converterHint set.
  return this.ShowConverterHint();
};

/**
 * The ComponentValidity object represent a component's current validity state. The instance 
 * provides specific methods to retrieve info such as <p>
 *  - whether the component is valid <p>
 *  - the messages currently tracked on the component.<p>
 *  - the max severity level of the messages, e.g., fatal, error etc. See oj.Message for details
 * 
 * @param {boolean} valid
 * @param {Array} messages
 * @constructor
 * @private
 */
oj.ComponentValidity = function(valid, messages)
{
  // TODO: provide methods that allow model implementations to instruct the elements to showMessages, 
  // especially the ones marked for 'lazy' notification. 
  this.Init(valid, messages);
};

/**
 * whether there are invalid messages among the list of messages.
 * 
 * @param {Array} messages list of messages
 * @returns {boolean} true if we have invalid messages; false otherwise
 */
oj.ComponentValidity.isInvalid = function (messages)
{
  var maxLevel = oj.Message.getMaxSeverity(messages);
  if (maxLevel >= oj.Message.SEVERITY_LEVEL['ERROR'])
  {
    return true;
  }

  return false;
  
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.ComponentValidity, oj.Object, "oj.ComponentValidity");

/**
 * The jquery element whose validity this object describes
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 */
oj.ComponentValidity.prototype.Init = function (valid, messages) 
{
  oj.ComponentValidity.superclass.Init.call(this);
  this._initialize(valid, messages);
};

/**
 * Returns a boolean true if valid; false if element not valid
 * @returns {boolean}
 * @private
 */
oj.ComponentValidity.prototype.isInvalid = function () 
{
  return this._invalid;
};

/**
 * Returns a boolean true if has messages to show; false if no messages to show
 * @returns {boolean}
 * @private
 */
oj.ComponentValidity.prototype.hasMessages = function () 
{
  return this._messages.length > 0;
};

/**
 * Returns an Array or messages that we are marked for immediate display or an empty array.
 * @private
 * @returns {Array}
 */
oj.ComponentValidity.prototype.getMessages = function () 
{
  return this._messages;
};

/**
 * Returns the max severity level.
 * @return {number}
 * @private
 */
oj.ComponentValidity.prototype.getMaxSeverity = function () 
{
  return this._maxSeverity;
};

/**
 * Updates the validity state for the component.
 * 
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 * @private
 */
oj.ComponentValidity.prototype.update = function (valid, messages)
{
  this._initialize(valid, messages);
};

oj.ComponentValidity.prototype._initialize = function (valid, messages)
{
  this._compValid = valid;
  this._compMessages = messages;
  
  this._messages = this._getImmediateMessages(); // messages currently showing
  this._maxSeverity = oj.Message.getMaxSeverity(this._messages); // max severity of messages currently showing
  this._invalid = oj.ComponentValidity.isInvalid(this._messages); 
};

/**
 * Returns an array of messages that are marked for immediate display.
 * 
 * @return {Array} of messages each an instance of oj.Message
 * @private
 */
oj.ComponentValidity.prototype._getImmediateMessages = function ()
{
  var messages = this._compMessages || [], immediateMsgs = [], msg;
  for (var index in messages)
  {
    msg = messages[index];
    // gather component messages marked for immediate display 
    if (msg instanceof oj.ComponentMessage && !msg.canDisplay())
    {
      continue;
    }
    immediateMsgs.push(msg);
  }
  
  return immediateMsgs;
};

// Copyright (c) 2013, Oracle and/or its affiliates. 
// All rights reserved.

/*jslint browser: true*/

/**
 * @export
 * @class
 * Common test support in JavaScript
 */ 
oj.Test = {}; 


/**
 * @export
 * @type {boolean} 
 * A global application flag that can be set by a test to indicate that all page startup processing is done
 * and an external automated test can begin
 */
oj.Test.ready = false;

/**
 * @export
 * Return the node found given the locator
 * @param {Object|string} locator A locator which is either a JSON string (to be parsed using $.parseJSON), or an Object with the following properties:
 *                                             element: the component's selector, determined by the test author when laying out the page
 *                                             component: optional - in the future there may be more than one component contained within a page element
 *                                             subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
 *  @returns {Object} the subcomponent located by the subId string passed in locator, if found.
 */
oj.Test.domNodeForLocator = function(locator) {   
    var locObj = locator;
    if (oj.StringUtils.isString(locator)) {
        var locStr = /** @type {string} */ (locator);
        try {
            locObj = $.parseJSON(locStr);
        }
        catch (e) {
            return null;
        }
    }
    if (locObj && locObj['element']) {
        var element = $(locObj['element']);
        if (element) {
            var widgetConst = oj.Components.getWidgetConstructor(element[0], locObj['component']);
            return widgetConst("getNodeBySubId", {'subId' : locObj['subId']});
        }
    }
    return null;
};




/*jslint browser: true*/
/**
 * in some OS/browser combinations you can attempt to detect high contrast mode
 * in javascript, go to the url below and look for "High Contrast"
 * http://www.w3.org/TR/wai-aria-practices/
 * 
 * This function uses a variation of the code in the "High Contrast" section of  
 * the site above to try and detect high contrast mode
 * by script, but it by no means definitively tells you whether or not you
 * are actually in high contrast mode. As discussed at the url above you 
 * may need to have a user preference setting for high contrast.
 * 
 * If the script is able to detect high contrast mode it sets the class 
 * "oj-hicontrast" on the body tag. When "oj-high-contrast" is present 
 * JET provides alternate informational images that are specially designed 
 * for high contrast users. 
 * @private
 */
function _ojHighContrast()
{
  // using a data uri, I googled for shortest uri to get this one since 
  // I don't care about the actual image, but I do want a legit image
  // otherwise I see an error in chrome and I don't want users to be
  // confused by seeing any error.

  var div = $("<div style='border: 1px solid;border-color:red green;position: absolute;top: -999px;background-image: url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=);'></div>"), bki;
  div.appendTo("body");

  bki = div.css("backgroundImage");
  //console.log("background-image:" + bki);
  //console.log("borderTopColor == borderRightColor: ", div.css("borderTopColor") == div.css("borderRightColor"));
  if (div.css("borderTopColor") == div.css("borderRightColor") ||
      (bki != null && (bki == 'none' || bki == 'url (invalid-url:)')))
  {
    $('body').addClass("oj-hicontrast");
  }

  div.remove();
}

$(document).ready(function() {
  _ojHighContrast();
});
/*jslint browser: true*/
/**
 * @private
 */
function _ojSlowCSS()
{
  if (navigator.appName == 'Microsoft Internet Explorer')
  {
    $('html').addClass("oj-slow-borderradius oj-slow-cssgradients oj-slow-boxshadow");
  }

}

$(document).ready(function() {
  _ojSlowCSS();
});
/*jslint browser: true*/
/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/
/**
 * Utilities used in conjunction with the jquery positon utility.
 * @ignore
 */
oj.PositionUtils = {};

/**
 * Of the properties on the position object, "my" and "at" are of intrest. The base jquery
 * horizontal alignment mnemonics are "right", "center" and "left". For better Jet RTL
 * support we have added "start" and "end".  Depending on the rtl direction, "start" and
 * "end" will be replaced with "left" or "right". The resultant postion object will
 * be a new instance that extends the postion passed as the first argument.
 * 
 * @param {Object} position source position object
 * @param {boolean} isRtl 
 * @return {Object} position object that has normalized jquery horizontal mnemonics.
 */        
oj.PositionUtils.normalizeHorizontalAlignment = function(position, isRtl)
{
  oj.Assert.assertObject(position, "position");
  var target = $.extend({}, position);  
  for (var i = 0; i < oj.PositionUtils._ALIGN_RULE_PROPERTIES.length; i++)
  {
    var propName = oj.PositionUtils._ALIGN_RULE_PROPERTIES[i];
    var align = target[propName];
    if (align)
      target[propName] = align.replace("start", (isRtl ? "right" : "left"))
                              .replace("end", (isRtl ? "left" : "right"));
  } 

  return target;
};

oj.PositionUtils._ALIGN_RULE_PROPERTIES = ['my', 'at'];
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true*/

/**
 * A messaging strategy that uses an instance of ojPopup component to show and hide messaging content.
 * 
 * @param {Array} displayOptions an array of messaging artifacts displayed in the popup.
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
oj.PopupMessagingStrategy = function (displayOptions)
{
  this.Init(displayOptions);
};

/**
 * Registers the PopupMessagingStrategy constructor function with oj.ComponentMessaging. 
 * 
 * @private
 */
oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW, 
                               oj.PopupMessagingStrategy);
                               
// Subclass from oj.MessagingStrategy 
oj.Object.createSubclass(oj.PopupMessagingStrategy, oj.MessagingStrategy, "oj.PopupMessagingStrategy");

/**
 * Messaging popup defaults for components, by component type. A special 'default' type defines the 
 * defaults for most editableValue components. 
 * The following properties are available - 
 * 'events' - these specify the on handlers for events that are setup to open and close popups
 * 'position' - specifies the type of element the popup is positioned against.
 * @private
 */
oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT = 
{
  "ojRadioset": 
  {
    position: 'launcher', 
    events: {open: "focusin mouseover", close: "mouseout"}
  },
  "ojCheckboxset": 
  {
    position: 'launcher', 
    events: {open: "focusin mouseover", close: "mouseout"}
  },
  "default": 
  {
    events: {open: "focusin"}
  }
};

oj.PopupMessagingStrategy._DEFAULT_STATUS_ICON_SELECTORS = "oj-component-icon oj-message-status-icon ";

oj.PopupMessagingStrategy._SELECTOR_MESSAGE = "oj-message";
oj.PopupMessagingStrategy._SELECTOR_MESSAGE_SUMMARY = "oj-message-summary";
oj.PopupMessagingStrategy._SELECTOR_MESSAGE_DETAIL = "oj-message-detail";
oj.PopupMessagingStrategy._SELECTOR_MESSAGE_CONTENT = "oj-message-content";

oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT = "oj-form-control-hint";
oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_CONVERTER = "oj-form-control-hint-converter";
oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_VALIDATOR = "oj-form-control-hint-validator";
oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_TITLE = "oj-form-control-hint-title";

oj.PopupMessagingStrategy._SELECTOR_MESSAGE_ERROR_ICON = "oj-message-error-icon";
oj.PopupMessagingStrategy._SELECTOR_MESSAGE_WARNING_ICON = "oj-message-warning-icon";
oj.PopupMessagingStrategy._SELECTOR_MESSAGE_INFO_ICON = "oj-message-info-icon";
oj.PopupMessagingStrategy._SELECTOR_MESSAGE_CONFIRMATION_ICON = "oj-message-confirmation-icon";

/**
 * Sets up a tooltip for the component instance using the messaging content provided. 
 * 
 * @param {Object} cm a reference to an instance of oj.ComponentMessaging that provides access to 
 * the latest messaging content.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype.activate = function (cm)
{
  oj.PopupMessagingStrategy.superclass.activate.call(this, cm);
  this._initMessagingPopup();
};

/**
 * Reinitializes with the new display options and updates component messaging using the new content. 
 * 
 * @param {Array} newDisplayOptions
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 * 
 */
oj.PopupMessagingStrategy.prototype.reactivate = function (newDisplayOptions)
{
  oj.PopupMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);
  this._updatePopupIfOpen();
};

oj.PopupMessagingStrategy.prototype.update = function ()
{
  oj.PopupMessagingStrategy.superclass.update.call(this);
  this._updatePopupIfOpen();
};

/**
 * Cleans up messages on the component and destroys any widgets it created.
 * 
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype.deactivate = function ()
{
  var self = this, compDefaults = 
    oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName],
      events = compDefaults ? compDefaults.events : 
                  oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT["default"].events;
  
  // Remove event handlers setup on launcher
  if (events['open'])
  {
    this.GetLauncher().off(events['open'], self._openPopup);
    this.GetLauncher().off(events['open'], self._wireUpPopupOnFirstLauncherFocus);

  }
  
  if (events['close'])
  {
    this.GetLauncher().off(events['close'], self._closePopup);
  }
  this._destroyTooltip();
  oj.PopupMessagingStrategy.superclass.deactivate.call(this);
};


oj.PopupMessagingStrategy.prototype._closePopup = function (event)
{
  // window.console.log(event.type + " called; tooltip closed");
  //$(this).tooltip("disable").tooltip('close');
  var self = event.data && event.data['strategy'];
  self.$messagingContentRoot.ojPopup("close", self.GetLauncher());
};


oj.PopupMessagingStrategy.prototype._initMessagingPopup = function ()
{
  var self = this, jqLauncher = this.GetLauncher(),
    compDefaults = oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[self.GetComponent().widgetName],
    events = compDefaults ? compDefaults.events : 
                  oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT["default"].events;
  
  // delay popup creation until laucher gets first focus or hover
  if (!this._isPopupInitialized())
  {
    jqLauncher.on(events['open'], {'strategy': self}, self._wireUpPopupOnFirstLauncherFocus);
  }
};

/**
 * Opens a popup. This handler is called in the context of the launcher usually the this.element or 
 * some relevant node the messaging popup is associated to.
 * 
 * @param {Event=} event 
 * @property {Object=} event.data.strategy the strategy object 
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype._openPopup = function (event)
{
  var self = event.data && event.data['strategy'];
  self._doOpenPopup();
};

oj.PopupMessagingStrategy.prototype._doOpenPopup = function()
{
  var self = this, domNode, latestContent;
  
  if (this._canOpenPopup())
  {
    latestContent = this._buildPopupHtml();
    if (this._isPopupInitialized() && latestContent)
    {
      // replace popup messaging content with new content
      domNode = this.$messagingContentRoot[0];
      
      // @HTMLUpdateOK
      // latestContent is includes content that may come from app. It is scrubbed for illegal tags 
      // before setting to innerHTML
      domNode.innerHTML = "";
      domNode.innerHTML = latestContent;

      var launcher = self.GetLauncher();

      // since the popup is reparented to the body, it looses associate in the dom.
      // establish linkage between the popup and the associated component.
      var surrogateId = !launcher.is("[id]") ? launcher.uniqueId().attr("id") : launcher.attr("id");
      this.$messagingContentRoot.ojPopup("widget").attr(oj.DomUtils.SURROGATE_ID, surrogateId);

      this.$messagingContentRoot.ojPopup("open", launcher);
    }
  }
};

// whether the messaging popup can be opened
oj.PopupMessagingStrategy.prototype._canOpenPopup = function ()
{
  var options = this.GetComponent().options, isDisabled = options['disabled'] || false, 
          isReadOnly = options['readOnly'] || false;
  
  return !(isDisabled || isReadOnly);
};

/**
 * If the popup is already open its contents need to updated when update() or reactivate() is called.
 * 
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype._updatePopupIfOpen = function()
{
  var domNode, isPopupOpen = false, contentToShow, isLauncherActiveElement;
  if (this._isPopupInitialized())
  {
    isPopupOpen = this.$messagingContentRoot.ojPopup("isOpen");
    contentToShow = this._buildPopupHtml();
    isLauncherActiveElement = document.activeElement === this.GetLauncher()[0] ? true : false;
    if (isPopupOpen)
    {  
      if (contentToShow)
      {
        // push new content into popup 
        domNode = this.$messagingContentRoot[0];

      // @HTMLUpdateOK
      // contentToShow is includes content that may come from app. It is scrubbed for illegal tags 
      // before setting to innerHTML
        domNode.innerHTML = "";
        domNode.innerHTML = contentToShow;
        this.$messagingContentRoot.ojPopup("refresh");
      }
      else
      {
        // if there is no content to show and popup is currently open, close it.
        this.$messagingContentRoot.ojPopup("close", this.GetLauncher());
      }
    }
    else if (isLauncherActiveElement && contentToShow)
    {
      // if popup is closed but focus is on activeElement re-open it
      this._doOpenPopup();      
    }
  }  
};

oj.PopupMessagingStrategy.prototype._wireUpPopupOnFirstLauncherFocus = function (event)
{
  var self = event.data && event.data['strategy'];
  if (!self._isPopupInitialized())
  {
    var jqLauncher = self.GetLauncher(), popupOptions, jPositionOf = self._getPopupPosition(),
        compDefaults = oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[self.GetComponent().widgetName],
        events = compDefaults ? compDefaults.events : 
                  oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT["default"].events,
                  jqRoot = self.GetComponent().widget(),
        eventData;
    
    // 1. associate the ojPopup component to wrapper <div> for popup content
    // 2. remember the popup content root
    // 3. wire up on() event handlers for registered events that open and close popup. E.g., focusin.
    // 4. autoDismissal happens automatically when focus leaves component. For other events like 
    // mouseover it's required to call off() 
    
    self.$messagingContentRoot = $(self._getPopupContentHtml());
    // append to body instead of component root as styles set on it can bleed through
    $("body").append(self.$messagingContentRoot);
    // jqRoot.append(self.$messagingContentRoot);
    popupOptions = {'rootAttributes' : {'class' : 'oj-messaging-popup'},
                    'initialFocus': 'none', 
                    'tail': 'simple', 
                    'autoDismiss': 'focusLoss', 
                    'position': {my: 'start bottom', at: 'end top', collision: 'flip',
                                 of: jPositionOf}};
               
    self.$messagingContentRoot.ojPopup(popupOptions);
    eventData = {'strategy': self};  
    if (events['open'])
    {
      jqLauncher.on(events['open'], eventData, self._openPopup);
    }
    if (events['close'])
    {
      jqLauncher.on(events['close'], eventData, self._closePopup);
    }
    
    // remove the focus event listener used for wiring up popup
    self.GetLauncher().off(events['open'], self._wireUpPopupOnFirstLauncherFocus);
    // call open popup the very first time since this method was called on focus
    self._doOpenPopup();    
  }
};

/**
 * Returns the jquery element popup should be position on. We always position on tip of component 
 * root unless specifically overridden. Components like radion and checkboxset use the launcher, 
 * which in the inputs
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype._getPopupPosition = function()
{
  var compDefaults = 
    oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName];
  
  if (compDefaults)
  {
    if (compDefaults.position && compDefaults.position === "launcher")
    {
      return this.GetLauncher();
    }
  }
  
  return this.GetComponent().widget();
};

oj.PopupMessagingStrategy.prototype._getPopupContentHtml = function ()
{
  return "" + "<div class='oj-messaging-popup-container'></div>"; 
};

oj.PopupMessagingStrategy.prototype._destroyTooltip = function ()
{
  if (this._isPopupInitialized())
  {
    if (this.$messagingContentRoot)
    {
      this.$messagingContentRoot.ojPopup("destroy");
      this.$messagingContentRoot.remove();
    }
  }
};

/**
 * Returns the content to show inside popup.
 * @private
 * @return {String|string} content
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype._buildPopupHtml = function ()
{
  var nwHtml = "", component = this.GetComponent(), jDocument = component.document, 
          document = jDocument[0], nwContent = [], addSeparator = false, that = this; 
  
  if (this.ShowMessages()) 
  {
    nwContent.push(this._buildMessagesHtml(document));
  }
  
  if (this.ShowConverterHint() || this.ShowValidatorHint() || this.ShowTitle())
  {
    nwContent.push(this._buildHintsHtml(document));
  }
  
  // TODO: Add support for shortDesc, instrcution text etc.
  $.each(nwContent, function(i, content) 
    {
      if (content)
      {
        if (addSeparator)
        {
          nwHtml = nwHtml.concat(that._getSeparatorHtml(document));
        }
        else
        {
          addSeparator = true; 
        }
        
        nwHtml = nwHtml.concat(content);
      }
    });
    
  return nwHtml;
};

/**
 * Returns the content to show inside tooltip.
 * @param {Document} document
 * 
 * @private
 * @return {string} content
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype._buildMessagesHtml = function (document)
{
  var messages, content = "", i, j, severityStr,severityLevel,
          message, maxSeverity = this.GetMaxSeverity(), summary, detail, messageObj, 
          messagesByTypes={}, messagesByType = [];

  if (this.HasMessages())
  {
    messages = this.GetMessages();
    
    // Step1: build an indexed array of messages by severity level.
    for (i = 0; i < messages.length; i++)
    {
      message = messages[i];
      
      if (!(message instanceof oj.Message))
      {
        messageObj = new oj.Message(message['summary'], message['detail'], message['severity']);
      }
      else
      {
        messageObj = message;
      }
      
      severityLevel = oj.Message.getSeverityLevel(messageObj['severity']);
      if (!messagesByTypes[severityLevel])
      {
        messagesByTypes[severityLevel] = [];
      }
      
      messagesByTypes[severityLevel].push(messageObj);
    }
    
    // Step 2: starting with maxSeverity level build messages with decreasing severity
    for (i = maxSeverity; i >= oj.Message.SEVERITY_LEVEL['CONFIRMATION']; i--)
    {
      messagesByType = messagesByTypes[i] || [];
      
      for (j = 0; j < messagesByType.length; j++)
      {
        message = messagesByType[j];
        oj.Assert.assertPrototype(message, oj.Message);

        severityLevel = oj.Message.getSeverityLevel(message['severity']);
        severityStr = this._getSeverityTranslatedString(severityLevel);
        summary = message['summary'] || severityStr;
        
        // if detail is empty we don't care to duplicate summary. also detail if present can be 
        // formatted html content (ADF feature)
        detail = message['detail'] || "";
        content = content.concat(this._buildMessageHtml(document, summary, detail, severityLevel));
      }
    }
  }
  return content;
};

// Builds the HTML content for a single message
oj.PopupMessagingStrategy.prototype._buildMessageHtml = function (document, summary, detail, severityLevel)
{
  var $msgDom, $msgIcon, $msgContent, $msgSummary, $msgDetail, 
          severityStr = this._getSeverityTranslatedString(severityLevel);
  
  // build message
  // (x) <Summary Text>
  // <Detail Text>
  $msgDom = $(document.createElement("div"));
  $msgDom.addClass(oj.PopupMessagingStrategy._SELECTOR_MESSAGE);
  
  // build msg icon
  $msgIcon = $(document.createElement("span"));
  $msgIcon.addClass(this._getSeverityIconSelector(severityLevel))
          .attr("title", severityStr)
          .attr("role", 'img');
  $msgDom.append($msgIcon);
  
  // build mesg content which includes summary and detail
  $msgContent = $(document.createElement("span"));
  $msgContent.addClass(oj.PopupMessagingStrategy._SELECTOR_MESSAGE_CONTENT);
  
  $msgSummary = $(document.createElement("div"));
  $msgSummary.addClass(oj.PopupMessagingStrategy._SELECTOR_MESSAGE_SUMMARY).text(summary);
  $msgContent.append($msgSummary);

  if (detail)
  {
    // detail text allows html content. So scrub it before setting it.
    detail = this._getTextDom(document, detail, true);
    $msgDetail = $(document.createElement("div"));
    $msgDetail.addClass(oj.PopupMessagingStrategy._SELECTOR_MESSAGE_DETAIL).append(detail);
    $msgContent.append($msgDetail);
  }
  $msgDom.append($msgContent);

  return $msgDom ? $msgDom.get(0).outerHTML : "";
};

/**
 * All hints including title
 * @param {Document} document
 * @return {string} html content for all hints.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype._buildHintsHtml = function (document)
{
  var hints = [], i, hintsHtml = "", hint;
  
  if (this.ShowConverterHint())
  {
    hints = this.GetConverterHint();
    hint = hints.length ? hints[0] : "";
    hintsHtml += this._buildHintHtml(document, 
                                     oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_CONVERTER, 
                                     hint);
  }
  
  if (this.ShowValidatorHint())
  {
    hints = this.GetValidatorHints();
    for (i = 0; i < hints.length; i++)
    {
      hintsHtml += this._buildHintHtml(document, 
                                       oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_VALIDATOR, 
                                       hints[i]);
    }
  }

  if (this.ShowTitle())
  {
    hintsHtml += this._buildHintHtml(document, 
                                     oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_TITLE, 
                                     this.GetTitle(), true);
  }
  
  return hintsHtml ? "<div class='oj-form-control-hints'>" + hintsHtml + "</div>": "";
};

/**
 * Renders the html content for a single hint.
 * @param {Document} document
 * @param {string} selector
 * @param {string} hintText
 * @param {boolean=} htmlAllowed
 * 
 * @return {string} html content for a single hint.
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 */
oj.PopupMessagingStrategy.prototype._buildHintHtml = function (document, selector, hintText, htmlAllowed)
{
  var jTitleDom, classes = oj.PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT;
  if (hintText)
  {
    jTitleDom = $(document.createElement("div"));
    classes += " " + selector;
    jTitleDom.addClass(classes);
    jTitleDom.append(this._getTextDom(document, hintText, htmlAllowed));
  }
  
  return jTitleDom ? jTitleDom.get(0).outerHTML : "";
};


/**
 *  if content is html clean html by allowing only legal tags before returning, to safeguard from 
 *  script injection errors.

 * @param {Document} document
 * @param {string} value
 * @param {boolean=} htmlAllowed if value can have html content
 * 
 * @return {Element} dom node containing the scrubbed hint
 * @private
 * @memberof oj.PopupMessagingStrategy
 * @instance
 * 
 */
oj.PopupMessagingStrategy.prototype._getTextDom = function(document, value, htmlAllowed) 
{
  var textDom = null;
  
  if (htmlAllowed && oj.DomUtils.isHTMLContent(value)) 
  {
    // strip out html start/end tags
    textDom = oj.DomUtils.cleanHtml(value.substring(6, value.length - 7));
  }
  else if (oj.StringUtils.isString(value))
  {
    textDom = document.createElement("span");
    textDom.textContent = value;
  }
    
  return textDom;
}; 

oj.PopupMessagingStrategy.prototype._getSeparatorHtml = function (document)
{
  var jSeparatorDom; 
  jSeparatorDom = $(document.createElement("hr"));
  
  return jSeparatorDom ? jSeparatorDom.get(0).outerHTML : "";
};


oj.PopupMessagingStrategy.prototype._getSeverityTranslatedString = function (severity)
{
  var sevTypeStr;
  // get the translated string for the severity
  switch (severity)
  {
    case oj.Message.SEVERITY_LEVEL['FATAL']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.fatal');
      break;
    case oj.Message.SEVERITY_LEVEL['ERROR']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.error');
      break;
    case oj.Message.SEVERITY_LEVEL['WARNING']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.warning');
      break;
    case oj.Message.SEVERITY_LEVEL['INFO']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.info');
      break;
    case oj.Message.SEVERITY_LEVEL['CONFIRMATION']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.confirmation');
      break;
  }
  
  return sevTypeStr;
  
};

oj.PopupMessagingStrategy.prototype._getSeverityIconSelector = function (severity)
{
  var sevIconStr;
  // get the icon selector for the severity
  switch (severity)
  {
    case oj.Message.SEVERITY_LEVEL['FATAL']:
      sevIconStr = oj.PopupMessagingStrategy._SELECTOR_MESSAGE_ERROR_ICON;
      break;
    case oj.Message.SEVERITY_LEVEL['ERROR']:
      sevIconStr = oj.PopupMessagingStrategy._SELECTOR_MESSAGE_ERROR_ICON;
      break;
    case oj.Message.SEVERITY_LEVEL['WARNING']:
      sevIconStr = oj.PopupMessagingStrategy._SELECTOR_MESSAGE_WARNING_ICON;
      break;
    case oj.Message.SEVERITY_LEVEL['INFO']:
      sevIconStr = oj.PopupMessagingStrategy._SELECTOR_MESSAGE_INFO_ICON;
      break;
    case oj.Message.SEVERITY_LEVEL['CONFIRMATION']:
      sevIconStr = oj.PopupMessagingStrategy._SELECTOR_MESSAGE_CONFIRMATION_ICON;
      break;
  }
  
  return oj.PopupMessagingStrategy._DEFAULT_STATUS_ICON_SELECTORS + sevIconStr;
};

oj.PopupMessagingStrategy.prototype._isPopupInitialized = function ()
{
  return (this.$messagingContentRoot) ? 
    this.$messagingContentRoot.is(":oj-popup") : false;
};


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

// S T A T I C    V A R S   
/**
 * The various contexts under which validation can be run by component.
 * @ignore
 */ 
var _sValidationContext = {
  COMPONENT_CREATE : 1,
  CONVERTER_OPTION_CHANGE : 2,
  DISABLED_OPTION_CHANGE : 3,
  READONLY_OPTION_CHANGE: 4,
  REFRESH_METHOD: 5,
  REQUIRED_OPTION_CHANGE : 6,
  RESET_METHOD : 7,
  USER_ACTION: 8,
  VALIDATE_METHOD: 9,
  VALIDATORS_OPTION_CHANGE : 10,
  VALUE_OPTION_CHANGE: 11
};

/**
 * Default validation options used by validate method.
 * @ignore
 */ 
var _sValidateMethodOptions = {doValueChangeCheck: false,
                               validationContext: _sValidationContext.VALIDATE_METHOD};

/**
 * Default validation options used when converter option changes
 * @ignore
 */
var _sConverterOptionOptions = {doNotClearMessages: true,
                                validationContext: _sValidationContext.CONVERTER_OPTION_CHANGE};
                              
/**
 * Default validation options used when disabled option changes
 * @ignore
 */
var _sDisabledOptionOptions = {doNotClearMessages: true,
                               validationContext: _sValidationContext.DISABLED_OPTION_CHANGE};

/**
 * Default validation options used when required option changes
 * @ignore
 */
var _sRequiredOptionOptions = {doNotClearMessages: true,
                               validationContext: _sValidationContext.REQUIRED_OPTION_CHANGE};

/**
 * Default validation options used when readOnly option changes
 * @ignore
 */
var _sReadOnlyOptionOptions = {doNotClearMessages: true,
                               validationContext: _sValidationContext.READONLY_OPTION_CHANGE};

/**
 * Default validation options used when refresh method is called.
 * @ignore
 */
var _sRefreshMethodOptions = {doNotClearMessages: true,
                               validationContext: _sValidationContext.REFRESH_METHOD};
/**
 * Default validation options used when validators option changes
 * @ignore
 */
var _sValidatorsOptionOptions = {doNotClearMessages: true,
                                 validationContext: _sValidationContext.VALIDATORS_OPTION_CHANGE};                      
/**
 * The various validation modes
 * @ignore
 */ 
var _sValidationMode = {
  FULL : 1, 
  VALIDATORS_ONLY : 2, 
  REQUIRED_VALIDATOR_ONLY : 3
};

// E D I T A B L E V A L U E    A B S T R A C T   W I D G E T  
/**
 * @class
 * @abstract
 * @name oj.editableValue
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * Abstract base class for all editable components that are value holders and that require 
 * validation and messaging capabilities. <br/>
 * 
 * <p>
 * <h3 id="validation-section">
 * Validation and Messaging
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
 * </h3>
 * An editable component runs validation (normal or deferred) based on the action performed on it 
 * (either by end-user or page author), and the state it was in when the action occurred. Examples 
 * of actions are - creating a component, user changing the value of the component by interacting 
 * with it, the app setting a value programmatically, the app calling the validate() method etc. At 
 * the time the action occurs, the component could already be showing errors, or can have a deferred 
 * error or have no errors. 
 * <p>
 * These factors also determine whether validation errors/messages get shown to the user immediately 
 * or get deferred. The following sections highlight the kinds of validation that are run and how 
 * messages get handled.
 * </p>
 * 
 * <h4 id="normal-validation-section">Normal Validation 
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a></h4>
 * Normal validation is run in the following cases on the display value, using the converter and 
 * validators set on the component, and validation errors are reported to user immediately.
 * <ul>
 * <li>When value changes as a result of user interaction all messages are cleared, including custom 
 * messages added by the app, and full validation is run on the UI value. The steps performed are 
 * outlined below.
 * <ol> 
 * <li>All messages options are cleared - 
 * <code class="prettyprint">messagesShown</code>, <code class="prettyprint">messagesHidden</code> 
 * and <code class="prettyprint">messagesCustom</code> options. </li>
 * <li>If no converter is present then processing continues to next step. If a converter is 
 * present, the UI value is first converted (i.e., parsed). If there is a parse error then 
 * the <code class="prettyprint">messagesShown</code> option is updated and processing returns.</li>
 * <li>If there are no validators setup for the component then the value is set on the component. 
 * Otherwise all validators are run in sequence using the parsed value from the previous step. The 
 * implicit required is run first if the component is marked required. When a validation error is 
 * encountered it is remembered and the next validator in the sequence is run. 
 * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
 * </li>
 * <li>At the end of the validation run if there are errors, the <code class="prettyprint">messagesShown</code> 
 * option is updated and processing returns. If there are no errors, then the 
 * <code class="prettyprint">value</code> option is updated and the formatted value displayed on the 
 * UI.</li>
 * </ol>
 * </li>
 * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are 
 * cleared and full validation run using the display value. See <a href="#validate">validate</a> 
 * method for details.</li>
 * <li>When certain options change through programmatic intervention by app, the component 
 * determines whether it needs to run normal validation based on the state the component is in. 
 * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
 * </ul>
 * 
 * <h4 id="deferred-validation-section">Deferred Validation
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
 * </h4>
 * Deferred validation is run in the following cases on the component value using the implicit 
 * required validator, and validation errors are deferred, i.e., not shown to user immediately. 
 * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to 
 * understand how deferred messages can be shown.
 * <ul>
 *  <li>When a component is created deferred validation is run and no messages options are cleared 
 *  prior to running validation. Refer to the <a href="#deferred-validators-section">Validators 
 *  Participating in Deferred Validation</a> section for details.</li> 
 *  <li>When the <code class="prettyprint">value</code> option changes due to programmatic 
 *  intervention deferred validation is run, after all messages options - 
 *  <code class="prettyprint">messagesShown</code>, <code class="prettyprint">messagesHidden</code> 
 *  and <code class="prettyprint">messagesCustom</code> - are cleared.</li>  
 *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run 
 *   after all messages options - <code class="prettyprint">messagesShown</code>, 
 *   <code class="prettyprint">messagesHidden</code> and <code class="prettyprint">messagesCustom</code> 
 *   - are cleared.</li>  
 *  <li>When certain options change through programmatic intervention by app, the component 
 *  determines whether it needs to run deferred validation based on the state the component is in. 
 *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
 * </ul>
 * 
 * <h4 id="mixed-validation-section">Mixed Validation
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
 * </h4>
 * Either deferred or normal validation is run in the following cases based on the state the 
 * component is in and any validation errors encountered are either hidden or shown to user.
 * <ul>
 *  <li>when converter option changes. See <a href="#converter">converter</a> option for details.</li>
 *  <li>when disabled option changes. See <a href="#disabled">disabled</a> option for details.</li>
 *  <li>when required option changes. See <a href="#required">required</a> option for details.</li>
 *  <li>when validators option changes. See <a href="#validators">validators</a> option for details.</li>
 *  <li>when refresh method is called. See <a href="#refresh">refresh</a> method for details.</li>  
 * </ul>
 * </p>
 * 
 * <p>
 * <h3 id="deferred-messages-section">
 * Showing Deferred Messages
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
 * </h3>
 * Deferred validation messages are displayed only when page author requests for it explicitly in 
 * one of the following ways: 
 * <ul>
 * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component or</li>
 * <li>calls the helper methods <code class="prettyprint">showMessages</code> using the 
 * {@link oj.InvalidComponentTracker}</li>
 * </ul>
 * </p>
 * 
 * <p>
 * <h3 id="deferred-validators-section">
 * Validators Participating in Deferred Validation
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
 * </h3>
 * The required validator is the only validator type that participates in deferred validation. 
 * </p> 
 * 
 * <p>
 * <h3 id="declarative-binding-section">
 * Declarative Binding 
 * <a class="bookmarkable-link" title="Bookmarkable Link" href="#declarative-binding-section"></a>
 * </h3>
 * When the component's <code class="prettyprint">value</code> option is bound to a Knockout 
 * observable and when the value changes, whether the observable is updated or not, iow whether a 
 * 'writeback' to the observable happens or not, depends on the action that caused the value to 
 * change.
 * <ul>
 * <li>when the value changes as a result of user interaction </li>
 * <li>when the value changes because normal validation was run as a result of these options 
 * being changed by the app - <code class="prettyprint">converter</code>, <code class="prettyprint">disabled</code>, 
 * <code class="prettyprint">required</code>, <code class="prettyprint">validators</code>, then the 
 * value is written to the observable. See the specific option docs for details.</li>
 * <li>when the value changes because normal validation was run as a result of these methods being 
 * called by the app - 
 * <code class="prettyprint">refresh</code>, <code class="prettyprint">validate</code>, 
 * then the value is written to the observable. See the specific method docs for details.</li>
 * <li>when the value changes due to programmatic intervention by app then the value is not written 
 * back to observable. This is based on the assumption that the app has mutated the observable 
 * already. In this case updating the component's <code class="prettyprint">value</code> option 
 * alone will not propagate the change automatically to the observable. Updating the observable is 
 * recommended as this will propagate the change automatically to the component.
 * </li>
 * </ul>
 * </p>
 * 
 * @example <caption>Initialize component</caption>
 * &lt;input id="foo" type="text"/&gt;
 * &lt;script&gt;
 * &nbsp;&nbsp;$('#foo").ojInputText({'value': 'abc'});
 * &lt;/script&gt;
 * // using knockout ojComponent binding
 * &lt;input id="foo" data-bind="ojComponent: {component: 'ojInputText', value: 'abc'}"/&gt;
 * @example <caption>Initialize component value using ko observable</caption>
 * &lt;input id="foo" data-bind="ojComponent: {component: 'ojInputText', value: salary}"/&gt;
 * &lt;script&gt;
 * &nbsp;&nbsp;var salary = ko.observable('abc');
 * &lt;/script&gt;
 * @example <caption>Initialize component value using element value</caption>
 * &lt;input id="foo" data-bind="ojComponent: {component: 'ojInputText'}" value='abc'/&gt;
 */
oj.__registerWidget('oj.editableValue', $['oj']['baseComponent'], 
{
  widgetEventPrefix: "oj",
  
  options: 
  {
    /** 
     * Whether the component is disabled. 
     *  
     * <p>The 2-way <code class="prettyprint">disabled</code> binding offered by 
     * the <code class="prettyprint">ojComponent</code> binding 
     * should be used instead of Knockout's built-in <code class="prettyprint">disable</code> 
     * and <code class="prettyprint">enable</code> bindings, 
     * as the former sets the API, while the latter sets the underlying DOM attribute.
     * </p>
     * 
     * <p>
     * When the <code class="prettyprint">disabled</code> option changes due to programmatic 
     * intervention, the component may clear messages and run validation in some cases. </br>
     * <ul>
     * <li>when a required component is initialized as disabled <code class="prettyprint">{value: null, required:true, disabled: true}</code>, 
     * deferred validation is skipped.</li>
     * <li>when a disabled component is enabled, 
     *  <ul>
     *  <li>if component is invalid and showing messages then all component messages are cleared, 
     *  and full validation run using the display value.
     *   <ul>
     *    <li>if there are validation errors, they are pushed to <code class="prettyprint">messagesShown</code>
     *    option. </li>
     *    <li>if no errors result from the validation, the <code class="prettyprint">value</code> 
     *    option is updated. Page authors can listen to the <code class="prettyprint">optionChange</code> 
     *    event on the <code class="prettyprint">value</code> option to clear custom errors.</li>
     *   </ul>
     *  </li>
     *  
     *  <li>if component is valid and has no errors then deferred validation is run.
     *    <ul>
     *    <li>if there is a deferred validation error, then 
     *    <code class="prettyprint">messagesHidden</code> option is updated. </li>
     *    </ul>
     *  </li>
     *  <li>if component is invalid and deferred errors then component messages are cleared and 
     *  deferred validation re-run.
     *    <ul>
     *    <li>if there is a deferred validation error, then 
     *    <code class="prettyprint">messagesHidden</code> option is updated. </li>
     *    </ul>
     *  </li>
     *  </ul>
     * </li>
     * <li>when enabled component is disabled then no validation is run and the component appears 
     * disabled.</li>
     * </ul>
     * </p>
     * 
     * @example <caption>Initialize component with <code class="prettyprint">disabled</code> option:</caption>
     * $(".selector").ojFoo({"disabled": true}); // Foo is InputText, InputNumber, Select, etc.
     * 
     * @expose 
     * @type {boolean}
     * @default <code class="prettyprint">false</code>. The element's disabled property is used as 
     * its initial value if it exists, when the option is not explicitly set. When neither is set, 
     * disabled defaults to false.
     * @public
     * @instance
     * @memberof oj.editableValue
     */
    disabled : false,
    
    /**
     * Display options that determine where auxilliary content gets displayed in relation to the 
     * component. 
     * 
     * <p>
     * The types of content for which display options can be configured are messaging related and 
     * include <code class="prettyprint">messages</code>, <code class="prettyprint">converterHint</code>, 
     * <code class="prettyprint">validatorHint</code> and <code class="prettyprint">title</code>.<br/>
     * The display options for each type is either an array or string. When an array is specified 
     * the first display option takes precedence over the second and so on. 
     * </p>
     * <p>
     * JET editable components set defaults that applies to the entire app/page. Normally page 
     * authors wouldn't need to change the defaults, but it is possible to override the defaults on 
     * a per instance basis as explained in the examples below or change defaults for the app using 
     * <a href="oj.Components.html#setDefaultOptions"><code class="prettyprint">oj.Components#setDefaultOptions</code></a> method.<br/>
     * </p>
     * <p>
     * When displayOptions changes due to programmatic intervention, the component updates its 
     * display to reflect the updated choices. For example, if 'title' property goes from 
     * 'notewindow' to 'none' then it no longer shows in the notewindow.
     * </p>
     * 
     * @property {Array|string=} converterHint - supported values are <code class="prettyprint">'placeholder'</code>, 
     * <code class="prettyprint">'notewindow'</code>, <code class="prettyprint">'none'</code>. The 
     * default value is <code class="prettyprint">['placeholder', 'notewindow']</code>. When there 
     * is already a placeholder set on the component, the converter hint falls back to display 
     * type of 'notewindow'. To change the default value you can do this - <br/> 
     * E.g. <code class="prettyprint">{'displayOptions: {'converterHint': ['none']}}</code>
     * @property {Array|string=} validatorHint - supported values are <code class="prettyprint">'notewindow'</code>, 
     * <code class="prettyprint">'none'</code>. To change the default value you can do this - <br/>
     * <code class="prettyprint">{'displayOptions: {'validatorHint': ['none']}}</code>
     * @property {Array|string=} messages - supported values are <code class="prettyprint">'notewindow'</code>, 
     * <code class="prettyprint">'none'</code>. To change the default value you can do this - <br/>
     * E.g. <code class="prettyprint">{'displayOptions: {'messages': 'none'}}</code>
     * @property {Array|string=} title - supported values are <code class="prettyprint">'notewindow'</code>, 
     * <code class="prettyprint">'none'</code>. To change the default value you can do this - <br/>
     * E.g. <code class="prettyprint">{'displayOptions: {'title': 'none'}}</code>
     * 
     * @example <caption>Override default values <code class="prettyprint">displayOptions</code> for hints and title:</caption>
     * // Only messages will get shown in the notewindow associated to this component
     * // Foo is InputText, InputNumber, Select, etc.
     * $(".selector").ojFoo("option", "displayOptions", {
     *   'converterHint': 'none',
     *   'validatorHint': 'none',
     *   'title' : 'none'
     * });
     * 
     * @expose 
     * @access public
     * @instance
     * @default <code class="prettyprint">
     * {<br/>
     * &nbsp;&nbsp;'messages': ['notewindow'], <br/>
     * &nbsp;&nbsp;'converterHint': ['placeholder', 'notewindow'], <br/>
     * &nbsp;&nbsp;'validatorHint': ['notewindow'], <br/>
     * &nbsp;&nbsp;'title': ['notewindow']<br/>
     * }</code>
     * @memberof oj.editableValue
     * @type {Object|undefined}
     * @since 0.7
     */
    displayOptions : undefined,    
    
    /**
     * Help information that goes on the label. When help is set on the input component, then 
     * help information is added to the input's label.
     * <p>
     * The properties supported on the <code class="prettyprint">help</code> option are:
     * 
     * @property {string=} definition this is the help definition text. It is what shows up
     * when the user hovers over the label or the help icon. No formatted text is available for 
     * help definition because the help definition renders on <code class="prettyprint">title</code>
     * attribute. 
     * The default value is <code class="prettyprint">null</code>.
     * @property {string=} source this is the help source url. If present, a help icon will
     * render next to the label and the anchor's target is this source. The default value is null.
     * 
     * @expose 
     * @memberof oj.editableValue
     * @instance
     * @type {Object.<string, string>}
     * @default <code class="prettyprint">{help : {definition :null, source: null}}</code>
     * 
     * @example <caption>Initialize the input with the help definition and external url information:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * $( ".selector" ).ojFoo({ "help": {"definition":"some help definition, "source":"some external url" } });
     * 
     * 
     * @example <caption>Set the <code class="prettyprint">help</code> option, after initialization:</caption>
     *
     * // setter
     * // Foo is InputText, InputNumber, Select, etc.
     * $( ".selector" ).ojFoo( "option", "help", {"definition":"fill out the name", "source":"http:\\www.oracle.com" } );
     * 
     */
    help: 
    {
    /**
     * <p>help definition text.  See the top-level <code class="prettyprint">help</code> option for details.
     * 
     * @expose
     * @alias help.definition
     * @memberof! oj.editableValue
     * @instance
     * @type {?string|undefined}
     * @default <code class="prettyprint">null</code>
     * 
     * @example <caption>Get or set the <code class="prettyprint">help.definition</code> sub-option, after initialization:</caption>
     * // getter
     * var definitionText = $( ".selector" ).ojFoo( "option", "help.definition" );
     * 
     * // setter:
     * $( ".selector" ).ojFoo( "option", "help.definition", "Enter your name" );
     */     
      definition: undefined, 
    /**
     * <p>help source url.  See the top-level <code class="prettyprint">help</code> option for details.
     * 
     * @expose
     * @alias help.source
     * @memberof! oj.editableValue
     * @instance
     * @type {?string|undefined}
     * @default <code class="prettyprint">null</code>
     * 
     * @example <caption>Get or set the <code class="prettyprint">help.source</code> sub-option, after initialization:</caption>
     * // getter
     * var helpSource = $( ".selector" ).ojFoo( "option", "help.source" );
     * 
     * // setter:
     * $( ".selector" ).ojFoo( "option", "help.source", "www.abc.com" );
     */      
      source: undefined
    },
    
    /**
     * List of messages an app would add to the component when it has business/custom validation 
     * errors that it wants the component to show. When this option is set the 
     * <code class="prettyprint">messagesShown</code> option is also updated.<br/>
     * Each message in the array is either an instance of oj.Message or an object that duck types it. 
     * See {@link oj.Message} for details.
     * 
     * <p>
     * An optionChange event is triggered every time this option value changes.
     * </p>
     * 
     * @example <caption>Get the current list of app messages using <code class="prettyprint">messagesCustom</code> option:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * var customMsgs = $(".selector").ojFoo("option", "messagesCustom"); 
     * 
     * @example <caption>Clear all app messages set on the component:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * $(".selector").ojFoo("option", "messagesCustom", []); 
     * 
     * @example <caption>Set app messages using the <code class="prettyprint">messagesCustom</code> option:</caption>
     * var msgs = [];
     * msgs.push({'summary': 'Error Summary', 'detail': 'Error Detail'}); 
     * // Foo is InputText, InputNumber, Select, etc.
     * $(".selector").ojFoo("option", "messagesCustom", msgs);
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof oj.editableValue
     * @default empty array when no option is set.
     * @type {Array|undefined}
     * @since 0.7
     * @see #messagesShown
     */    
    messagesCustom : undefined,
    
    /**
     * List of messages currently hidden on component, these are added by component when it runs 
     * deferred validation. Each message in the array is 
     * either an instance of oj.Message or an object that duck types it. See {@link oj.Message} for 
     * details. <br/>
     * 
     * <p>
     * This is a read-only option so page authors cannot set or change it directly.
     * </p>
     * 
     * <p>
     * An optionChange event is triggered every time this option value changes.
     * </p>
     * 
     * <p>
     * These messages are not shown to the end-user by default, but page author 
     * can show hidden messages using the {@link showMessages} method. 
     * </p>
     * 
     * @example <caption>Get <code class="prettyprint">messagesShown</code> for the component:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * var messages = $(".selector").ojFoo("option", "messagesShown"); 
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof oj.editableValue
     * @default empty array when no option is set.
     * @type {Array|undefined}
     * @since 0.7
     * @see #showMessages
     */    
    messagesHidden : undefined,     
    
    /**
     * List of messages currently shown on component, these include messages generated both by the 
     * component and ones provided by app using <code class="prettyprint">messagesCustom</code>. 
     * Each message in the array is either an instance of oj.Message or an object that duck types 
     * it. See {@link oj.Message} for details. <br/>
     * 
     * <p>
     * This is a read-only option so page authors cannot set or change it directly.
     * </p>
     * 
     * <p>
     * An optionChange event is triggered every time its value changes.
     * </p>
     * 
     * <p>
     * Messages retrieved using the <code class="prettyprint">messagesShown</code> option are by 
     * default shown in the notewindow, but this can be controlled using the 'messages' property of 
     * the <code class="prettyprint">displayOptions</code> option. 
     * </p>
     * 
     * @example <caption>Get <code class="prettyprint">messagesShown</code> for the component:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * var messages = $(".selector").ojFoo("option", "messagesShown"); 
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof oj.editableValue
     * @default empty array when no option is set.
     * @type {Array|undefined}
     * @since 0.7
     */    
    messagesShown : undefined,     
    
    /** 
     * Whether the component is required or optional. When required is set to true, an implicit 
     * required validator is created using the validator factory - 
     * <code class="prettyprint">oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED).createValidator()</code>.
     * 
     * Translations specified using the <code class="prettyprint">translations.required</code> option 
     * and the label associated with the component, are passed through to the options parameter of the 
     * createValidator method. 
     * 
     * <p>
     * When <code class="prettyprint">required</code> option changes due to programmatic intervention, 
     * the component may clears messages and run validation, based on the current state it's in. </br>
     *  
     * <h4>Running Validation</h4>
     * <ul>
     * <li>if component is valid when required is set to true, then it runs deferred validation on 
     * the option value. This is to ensure errors are not flagged unnecessarily.
     * <ul>
     *   <li>if there is a deferred validation error, then 
     *   <code class="prettyprint">messagesHidden</code> option is updated. </li>
     * </ul>
     * </li>
     * <li>if component is invalid and has deferred messages when required is set to false, then 
     * component messages are cleared but no deferred validation is run.
     * </li>
     * <li>if component is invalid and currently showing invalid messages when required is set, then 
     * component messages are cleared and normal validation is run using the current display value. 
     * <ul>
     *   <li>if there are validation errors, then <code class="prettyprint">value</code> 
     *   option is not updated and the error pushed to <code class="prettyprint">messagesShown</code>
     *   option. 
     *   </li>
     *   <li>if no errors result from the validation, the <code class="prettyprint">value</code> 
     *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code> 
     *   event on the <code class="prettyprint">value</code> option to clear custom errors.</li>
     * </ul>
     * </li>
     * </ul>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>Only messages created by the component are cleared. These include ones in 
     * <code class="prettyprint">messagesHidden</code> and <code class="prettyprint">messagesShown</code>
     *  options.</li>
     * <li><code class="prettyprint">messagesCustom</code> option is not cleared.</li>
     * </ul>
     * 
     * </p>
     * 
     * @ojvalue {boolean} false - implies a value is not required to be provided by the user. 
     * This is the default.
     * @ojvalue {boolean} true - implies a value is required to be provided by user and the 
     * input's label will render a required icon. Additionally a required validator - 
     * {@link oj.RequiredValidator} - is implicitly used if no explicit required validator is set. 
     * An explicit required validator can be set by page authors using the validators option. 
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">required</code> option:</caption>
     * $(".selector").ojFoo({required: true}); // Foo is InputText, InputNumber, Select, etc.<br/>
     * @example <caption>Initialize <code class="prettyprint">required</code> option from html attribute 'required':</caption>
     * &lt;input type="text" value= "foobar" required/><br/>
     * // retreiving the required option returns true
     * $(".selector").ojFoo("option", "required"); // Foo is InputText, InputNumber, Select, etc.<br/>
     * 
     * @example <caption>Customize messages and hints used by implicit required validator when 
     * <code class="prettyprint">required</code> option is set:</caption> 
     * &lt;!-- Foo is InputText, InputNumber, Select, etc. -->
     * &lt;input type="text" value="foobar" required data-bind="ojComponent: {
     *   component: 'ojFoo', 
     *   value: password, 
     *   translations: {'required': {
     *                 hint: 'custom: enter at least 3 alphabets',
     *                 messageSummary: 'custom: \'{label}\' is Required', 
     *                 messageDetail: 'custom: please enter a valid value for \'{label}\''}}}"/>
     * @expose 
     * @access public
     * @instance
     * @default when the option is not set, the element's required property is used as its initial 
     * value if it exists.
     * @memberof oj.editableValue
     * @type {boolean|undefined}
     * @since 0.7
     * @see #translations
     */
    required: undefined,
    
    /** 
     * Represents advisory information for the component, such as would be appropriate for a tooltip. 
     * 
     * <p>
     * When a title is present it is by default displayed in the notewindow, or as determined by the 
     * 'title' property set on the <code class="prettyprint">displayOptions</code> option. 
     * When the <code class="prettyprint">title</code> option changes the component refreshes to 
     * display the new title. 
     * </p>
     * 
     * <p>
     * To include formatted text in the title, format the string using html tags. For example the 
     * title might look like: 
     * <pre class="prettyprint"><code>&lt;html>Enter &lt;b>at least&lt;/b> 6 characters&lt;/html></code></pre>
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">title</code> option:</caption>
     * &lt;!-- Foo is InputText, InputNumber, Select, etc. -->
     * &lt;input id="username" type="text" data-bind="
     *    ojComponent: {component: 'ojFoo', title : 'enter at least 3 alphanumeric characters', 
     *                  pattern: '[a-zA-Z0-9]{3,}', value: ''}"/><br/>
     * 
     * @example <caption>Initialize <code class="prettyprint">title</code> option from html attribute 'title':</caption>
     * &lt;!-- Foo is InputText, InputNumber, Select, etc. -->
     * &lt;input id="username" type="text" value= "foobar" title="enter at least 3 alphanumeric characters" 
     *           pattern="[a-zA-Z0-9]{3,}"/><br/>
     * $("#username").ojFoo({}); // Foo is InputText, InputNumber, Select, etc. 
     * 
     * // reading the title option will return "enter at least 3 alphanumeric characters"
     * $("#username").ojFoo("option", "title"); // Foo is InputText, InputNumber, Select, etc. <br/>
     * 
     * @expose 
     * @access public
     * @instance
     * @default when the option is not set, the element's title attribute is used as its initial 
     * value if it exists. 
     * @memberof oj.editableValue
     * @type {string|undefined}
     */    
    title: undefined,
    
    /** 
     * List of validators used by component when performing validation. Each item is either an 
     * instance that duck types {@link oj.Validator}, or is an Object literal containing the 
     * properties listed below. Implicit validators created by a component when certain options 
     * are present (e.g. <code class="prettyprint">required</code> option), are separate from 
     * validators specified through this option. At runtime when the component runs validation, it 
     * combines the implicit validators with the list specified through this option. 
     * <p>
     * Hints exposed by validators are shown in the notewindow by default, or as determined by the 
     * 'validatorHint' property set on the <code class="prettyprint">displayOptions</code> 
     * option. 
     * </p>
     * 
     * <p>
     * When <code class="prettyprint">validators</code> option changes due to programmatic 
     * intervention, the component may decide to clear messages and run validation, based on the 
     * current state it is in. </br>
     * 
     * <h4>Steps Performed Always</h4>
     * <ul>
     * <li>The cached list of validator instances are cleared and new validator hints is pushed to 
     * messaging. E.g., notewindow displays the new hint(s).
     * </li>
     * </ul>
     *  
     * <h4>Running Validation</h4>
     * <ul>
     * <li>if component is valid when validators changes, component does nothing other than the 
     * steps it always performs.</li>
     * <li>if component is invalid and is showing messages -
     * <code class="prettyprint">messagesShown</code> option is non-empty, when 
     * <code class="prettyprint">validators</code> changes then all component messages are cleared 
     * and full validation run using the display value on the component. 
     * <ul>
     *   <li>if there are validation errors, then <code class="prettyprint">value</code> 
     *   option is not updated and the error pushed to <code class="prettyprint">messagesShown</code>
     *   option. 
     *   </li>
     *   <li>if no errors result from the validation, the <code class="prettyprint">value</code> 
     *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code> 
     *   event on the <code class="prettyprint">value</code> option to clear custom errors.</li>
     * </ul>
     * </li>
     * <li>if component is invalid and has deferred messages when validators changes, it does 
     * nothing other than the steps it performs always.</li>
     * </ul>
     * </p>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>Only messages created by the component are cleared.  These include ones in 
     * <code class="prettyprint">messagesHidden</code> and <code class="prettyprint">messagesShown</code>
     *  options.</li>
     * <li><code class="prettyprint">messagesCustom</code> option is not cleared.</li>
     * </ul>
     * </p>
     * 
     * @property {string} type - the validator type that has a {@link oj.ValidatorFactory} that can 
     * be retrieved using the {@link oj.Validation} module. For a list of supported validators refer 
     * to {@link oj.ValidatorFactory}. <br/>
     * E.g., <code class="prettyprint">{validators: [{type: 'regExp'}]}</code>
     * @property {Object=} options - optional Object literal of options that the validator expects. 
     * <br/>
     * E.g., <code class="prettyprint">{validators: [{type: 'regExp', options: {pattern: '[a-zA-Z0-9]{3,}'}}]}</code>

     * 
     * @example <caption>Initialize the component with validator object literal:</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * $(".selector").ojFoo({
     *   validators: [{
     *     type: 'numberRange', 
     *     options : {
     *       hint: {min: 'Enter a value greater than {min}'}, 
     *       min: 100
     *     }
     *   }],
     * });
     * 
     * NOTE: oj.Validation.validatorFactory('numberRange') returns the validator factory that is used 
     * to instantiate a range validator for numbers.
     * 
     * @example <caption>Initialize the component with multiple validator instances:</caption>
     * var validator1 = new MyCustomValidator({'foo': 'A'}); 
     * var validator2 = new MyCustomValidator({'foo': 'B'});
     * // Foo is InputText, InputNumber, Select, etc.
     * $(".selector").ojFoo({
     *   value: 10, 
     *   validators: [validator1, validator2]
     * });
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof oj.editableValue
     * @type {Array|undefined}
     */    
    validators: undefined,
    
    /** 
     * The value of the component. 
     * 
     * <p>
     * When <code class="prettyprint">value</code> option changes due to programmatic 
     * intervention, the component always clears all messages - 
     * <code class="prettyprint">messagesHidden</code>, <code class="prettyprint">messagesShown</code>
     *  and <code class="prettyprint">messagesCustom</code>, runs deferred validation, and 
     * always refreshes UI display value.</br>
     * 
     * <h4>Running Validation</h4>
     * <ul>
     * <li>component always runs deferred validation; if there is a validation error the 
     * <code class="prettyprint">messagesHidden</code> option is updated.</li>
     * </ul>
     * </p>
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojFoo({'value': '10'}); // Foo is InputText, InputNumber, Select, etc.<br/>
     * @example <caption>Get or set <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns '10'
     * $(".selector").ojFoo("option", "value");// Foo is InputText, InputNumber, Select, etc.
     * // Setter: sets '20'
     * $(".selector").ojFoo("option", "value", '20'); // Foo is InputText, InputNumber, Select, etc.
     * 
     * @expose 
     * @access public
     * @instance
     * @default When the option is not set, the element's dom value is used as its initial value 
     * if it exists. The type of value is as defined by the component that extends this class. Refer 
     * to specific components for defaults.
     * @memberof oj.editableValue
     * @type {Object|undefined}
     */
    value: undefined,
    
    // Events
    /**
     * Triggered when the following options change. 
     * <ul>
     * <li><code class="prettyprint"><strong>messagesCustom</strong></code></li>
     * <li><code class="prettyprint"><strong>messagesShown</strong></code></li>
     * <li><code class="prettyprint"><strong>messagesHidden</strong></code></li>
     * <li><code class="prettyprint"><strong>value</strong></code></li>
     * </ul>
     * 
     * <p>The event payload has the following properties - </p>
     * @property {Event} event <code class="prettyprint">jQuery</code> event object
     * @property {Object} data event payload
     * @property {Object} data.component the component method (aka widget method) commonly used to 
     * invoke methods on components (widgets) created using widget factory. Normally the event 
     * packages the previous and current values for the option, but to lookup other options in your 
     * listener you can do this - <br/>
     * <code class="prettyprint">
     * $(".selector").on({ <br/>
     * &nbsp;&nbsp;'ojoptionchange': function (event, data) {<br/>
     * &nbsp;&nbsp;&nbsp;&nbsp;var component = data['component'];<br/>
     * &nbsp;&nbsp;&nbsp;&nbsp;var required = component("option", "required");<br/>
     * &nbsp;&nbsp;};<br/>
     * });
     * </code>
     * @property {string} data.option the name of the option that changed.
     * @property {Object} data.previousValue - an Object holding the previous value of the option
     * @property {Object} data.value - an Object holding the current value of the option
     * @property {Object} data.optionMetadata information about the option that changed
     * @property {string} data.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
     *  <code class="prettyprint">"shouldNotWrite"</code>. For use by the JET writeback mechanism, 
     *  'shouldWrite' indicates that the value should be written to the observable.
     *  
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback to be notified of changes to the component's validity</caption>
     * // Foo is InputText, InputNumber, Select, etc.
     * $(".selector").ojFoo({ 
     *   'optionChange': function (event, data) {} 
     * });
     * @example <caption>Bind an event listener to the ojoptionchange event</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @memberof oj.editableValue
     * @expose
     * @event 
     * @access public
     * @instance
     */
    optionChange: undefined
  },
  
  // P U B L I C    M E T H O D S
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values. <br/>
   * If the locator is null or no subId string is provided then this method returns the element that 
   * this component was initalized with. <br/>
   * If a subId was provided but a subcomponent node cannot be located this method returns null.
   * 
   * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is 
   * <code class="prettyprint">null</code>, then this method returns the element on which this component was initalized.
   * 
   * <p>If a <code class="prettyprint">subId</code> was provided but no corresponding node 
   * can be located, then this method returns <code class="prettyprint">null</code>.
   * 
   * @expose
   * @override
   * @memberof oj.editableValue
   * @instance
   * 
   * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code> 
   * property.  See the table for details on its fields.
   * 
   * @property {string=} locator.subId - A string that identifies a particular DOM node in this component.
   * 
   * <p>The supported sub-ID's are documented in the <a href="#subids-section">Sub-ID's</a> section of this document.
   * 
   * @property {number=} locator.index - A zero-based index, used to locate a message content node 
   * or a hint node within the popup. 
   * @returns {Element|null} The DOM node located by the <code class="prettyprint">subId</code> string passed in 
   * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
   * 
   * @example <caption>Get the node for a certain subId:</caption>
   * // Foo is ojInputNumber, ojInputDate, etc.
   * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-some-sub-id'} );
   */
  getNodeBySubId: function(locator)
  {
    return this._super(locator);
  },
           
  /**
   * whether the component is currently valid. 
   * @example <caption>Check whether the component is valid:</caption>
   * var value = $(".selector").ojInputText("isValid");
   * @returns {boolean}
   * @access public
   * @instance
   * @expose
   * @memberof oj.editableValue
   */
  isValid : function ()
  {
    return this._valid === undefined ? true : this._valid;
  },
  
  /**
   * Called when the DOM underneath the component chages requiring a re-render of the component. An 
   * example is when the label for the input changes. <br/>
   * <p>
   * Another time when refresh might be called is when the locale for the page changes. When it 
   * changes, options used by its converter and validator that are locale specific, its hints, 
   * messages and translations will be updated. 
   * </p>
   * 
   * <p>
   * When <code class="prettyprint">refresh</code> method is called, the component may take various 
   * steps such as clearing messages, running validation etc., based on the state it is in. </br>
   * 
   * <h4>Steps Performed Always</h4>
   * <ul>
   * <li>The converter and validators used by the component are reset, and new converter and 
   * validator hints is pushed to messaging. E.g., notewindow displays the new hint(s).
   * </li>
   * </ul>
   *  
   * <h4>Running Validation</h4>
   * <ul>
   * <li>if component is valid when refresh() is called, the display value is refreshed if component 
   * has a converter set.</li>
   * <li>if component is invalid and is showing messages -
   * <code class="prettyprint">messagesShown</code> option is non-empty, when 
   * <code class="prettyprint">refresh()</code> is called, then all component messages are cleared 
   * and full validation run using the display value on the component. 
   * <ul>
   *   <li>if there are validation errors, then <code class="prettyprint">value</code> 
   *   option is not updated and the error pushed to <code class="prettyprint">messagesShown</code>
   *   option. 
   *   </li>
   *   <li>if no errors result from the validation, the <code class="prettyprint">value</code> 
   *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code> 
   *   event on the <code class="prettyprint">value</code> option to clear custom errors.</li>
   * </ul>
   * </li>
   * <li>if component is invalid and has deferred messages when <code class="prettyprint">refresh()</code> 
   * is called, then all component messages are cleared and deferred validation is run.</li>
   * </ul>
   * </p>
   * 
   * <h4>Clearing Messages</h4>
   * <ul>
   * <li>If clearing messages only those created by the component are cleared. These include ones in 
   * <code class="prettyprint">messagesHidden</code> and <code class="prettyprint">messagesShown</code>
   *  options.</li>
   * <li><code class="prettyprint">messagesCustom</code> option is not cleared.</li>
   * </ul>
   * </p>
   * 
   * @example <caption>Refresh component after changing the label DOM.</caption>
   * // Foo is ojInputNumber, ojInputText, etc.
   * $(selector).ojFoo("refresh");<br/>
   * 
   * @access public
   * @instance
   * @expose
   * @memberof oj.editableValue
   * @since 0.7
   */
  refresh : function ()
  {
    this._super();
    this._doRefresh(true);
  },
  
  /**
   * Resets the component by clearing all messages options - <code class="prettyprint">messagesCustom</code>,  
   * <code class="prettyprint">messagesHidden</code> and <code class="prettyprint">messagesShown</code>,
   * and updates the component's display value using the option value. User entered values will be 
   * erased when this method is called.
   * 
   * @example <caption>Reset component</caption>
   * $(selector).ojInputText("reset"); <br/>
   * 
   * @access public
   * @instance
   * @expose
   * @memberof oj.editableValue
   * @since 0.7
   */
  reset : function ()
  {
    this._clearAllMessages();
    // since we are pushing component value to UI, only deferred validation need to be run; this is
    // same as setting value option.
    this._runDeferredValidation(this._VALIDATION_CONTEXT.RESET_METHOD);
    this._refreshComponentDisplayValue(this.options['value'], true);
  },
  
  /**
   * Takes all hidden messages that were marked deferred and shows them. Messages in
   * <code class="prettyprint">messagesHidden</code> option are removed and 
   * <code class="prettyprint">messagesShown</code> option updated. If no messages are present in 
   * <code class="prettyprint">messagesHidden</code> option this method returns. <br/>
   * <p>
   * An <code class="prettyprint">optionChange</code> event is triggered on both 
   * <code class="prettyprint">messagesHidden</code> and <code class="prettyprint">messagesShown</code> 
   * options.
   * </p>
   * To view messages user has to set focus on the component. <br/>
   * 
   * @example <caption>Display all messages including deferred ones.</caption>
   * $(selector).ojInputText("showMessages");
   * @access public
   * @instance
   * @expose
   * @memberof oj.editableValue
   * @since 0.7
   */
  showMessages : function ()
  {
    var msgs = this.options['messagesHidden'], msg, mutated = false, i, clonedMsgs = [];
    
    for (i = 0; i < msgs.length; i++)
    {
      mutated = true;
      msg = msgs[i];
      if (msg instanceof oj.ComponentMessage)
      {
        msg._forceDisplayToShown();
      }
      
      clonedMsgs.push(msg.clone()); // TODO: revisit clone msg??
    }
    
    if (mutated)
    {
      // clear hidden messages. push cloned hidden messages into messagesShown option 
      this._clearMessagesHidden();
      
      this._updateMessagesShownOption(clonedMsgs);
    }
  },
  
  /**
   * Validates the component's display value using the converter and all validators registered on 
   * the component and updates the <code class="prettyprint">value</code> option by performing the 
   * following steps. 
   * 
   * <p>
   * <ol> 
   * <li>All messages are cleared, including custom messages added by the app. </li>
   * <li>If no converter is present then processing continues to next step. If a converter is 
   * present, the UI value is first converted (i.e., parsed). If there is a parse error then 
   * the <code class="prettyprint">messagesShown</code> option is updated and method returns false.</li>
   * <li>If there are no validators setup for the component the <code class="prettyprint">value</code> 
   * option is updated using the display value and the method returns true. Otherwise all 
   * validators are run in sequence using the parsed value from the previous step. The implicit 
   * required validator is run first if the component is marked required. When a validation error is 
   * encountered it is remembered and the next validator in the sequence is run. </li>
   * <li>At the end of validation if there are errors, the <code class="prettyprint">messagesShown</code> 
   * option is updated and method returns false. If there were no errors, then the 
   * <code class="prettyprint">value</code> option is updated and method returns true.</li>
   * </ol>
   * 
   * @returns {boolean} true if component passed validation, false if there were validation errors.
   * 
   * @example <caption>Validate component using its current value.</caption>
   * // validate display value. 
   * $(.selector).ojInputText('validate');
   * 
   * @deprecated param 'requiredOnly' has been deprecated since version 0.7. 
   * 
   * @access public
   * @expose
   * @instance
   * @memberof oj.editableValue
   * @since 0.7
   */
  validate : function ()
  {
    // clear all messages; run full validation on display value
    return this._SetValue(this._GetDisplayValue(), null, this._VALIDATE_METHOD_OPTIONS);
  },
  
  // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

  // *********** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) **********
  
  /**
   * Validation mode specifying the kind of validation that gets run.
   * <ul>
   *   <li>FULL - the default and runs both the converter and all validators. </li>
   *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
   *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
   * </ul>  
   * @protected
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   */       
  _VALIDATION_MODE : _sValidationMode,
  
  /**
   * The context the component can be in when validation is run. 
   * <ul>
   * <li>COMPONENT_CREATE - when component is created and we run validators. usually messages are 
   * not displayed right away, i.e, are 'deferred'. </li>
   * <li>VALUE_OPTION_CHANGE - when component's value is updated programmatically. messages are  
   * deferred.</li>
   * <li>REQUIRED_OPTION_CHANGE - when component's required option is updated programmatically. messages are
   * deferred.</li>
   * <li>USER_ACTION - when component runs validation as a result of user interating with component.
   * messages are displayed immediately.</li>
   * <li>VALIDATE_METHOD - when component's validate() method is called explicitly. messages are 
   * displayed immediately.</li>
   * </ul>
   * 
   * @protected
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   * 
   */
  _VALIDATION_CONTEXT : _sValidationContext,
  
  /**
   * Default options used by validate method. 
   * 
   * @protected
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   * @see #validate
   */  
  _VALIDATE_METHOD_OPTIONS : _sValidateMethodOptions,  
  
  /**
   * Called at component create time primarily to initialize options, often using DOM values. This 
   * method is called before _ComponentCreate is called, so components that override this method 
   * should be aware that the component has not been rendered yet. The element DOM is available and 
   * can be relied on to retrieve any default values. <p>
   * 
   * This method sets defaults for its options that have a DOM namesake. E.g., value, required, 
   * disabled etc. Subclasses can override this method to set their own defaults for these options.
   * Example, the value option is often not set on this.element for components like radioset, which
   * walk the sub-tree to determine the value.
   * 
   * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors
   * @param {?Object} constructorOptions - options passed into the wiget constructor
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _InitOptions : function(originalDefaults, constructorOptions)
  {
    this._super(originalDefaults, constructorOptions);
    
    // tracks options that were initialized from DOM. in AfterCreate these will trigger optionChange 
    // to perform writeback
    this._optionsInitializedFromDom = [];
  },

  /**
   * Initializes options defined by this base class.
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ComponentCreate : function ()
  {
    var node = this.element,
        attrsToRemove = ["required", "title"], //remove attributes that trigger html5 validation + 
                                               // inline bubble
        savedAttributes = this._GetSavedAttributes(node); 
    
    this._super();
    
    this.options['messagesCustom'] = this.options['messagesCustom'] || [];
    this.options['messagesHidden'] = []; 
    this.options['messagesShown'] = this.options['messagesCustom'].length > 0 ? 
      this._cloneMessagesBeforeSet(this.options['messagesCustom']) : [];
    
    // update element DOM for disabled
    if (typeof this.options['disabled'] === "boolean")
    {
      node.prop("disabled", this.options['disabled']);
    }
    
    // we do this here instead of in _InitOptions because here we have the final value.
    //Bug 18926010 - an empty placeholder shows up if data changed after first binding 
    if (this._HasPlaceholderSet())
    {
      // update element placeholder
      this._SetPlaceholder(this.options['placeholder']);
      this._customPlaceholderSet = true;
    }
    
    // remove html5 validation attributes; it's safe to remove these here because components should 
    // have already initialized options based on DOM in _InitOptions().
    $.each(attrsToRemove, function (index, value)
    {
      if (value in savedAttributes)
      {
        node.removeAttr(value);
      }
    });
  },
  
  /**
   * The value option alone is initialized here since it requires the component to be fully
   * created. Calling this.options.value before this method does not guarantee the correct 
   * value to be returned.
   *
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _AfterCreate : function ()
  {
    this._super();
    
    // decorate the label
    this._createOjLabel();
    
    // refresh value, theming and aria attributes
    this._doRefresh(false);

    // initialize component messaging
    this._initComponentMessaging();
    
    // if option was initialized from DOM we track these updates alone and trigger optionChange for 
    // writebacks
    this._applyAfterCreateOptionChanges();
    
    // run deferred validation 
    this._runDeferredValidationAfterCreate();

    this.widget().addClass("oj-form-control");
  },
  
  /**
   * Performs post processing after _SetOption() is called. Different options when changed perform
   * different tasks. 
   * 
   * @param {string} option
   * @param {Object|string=} previous
   * @param {Object=} flags 
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _AfterSetOption : function (option, previous, flags)
  {
    switch (option)
    {
      case "disabled":
        this._AfterSetOptionDisabledReadOnly(option, _sDisabledOptionOptions);
        break;
      
      case "converter":
        this._AfterSetOptionConverter(option);
        break;
      
      case "displayOptions" :
        // clear the cached merged options; the getter setup for this.options['displayOptions']
        // will merge the new value with the defaults
        this._initComponentMessaging();
        break;

      case "help":
        this._Refresh(option, this.options[option]);
        break;
      
      case "messagesCustom":
        this._messagesCustomOptionChanged(previous, flags);
        break; 
        
      case "placeholder":
        this._placeholderOptionChanged(flags);
        break;
        
      case "readOnly":
        this._AfterSetOptionDisabledReadOnly(option, _sReadOnlyOptionOptions);
        break;
        
      case "required":
        this._AfterSetOptionRequired(option);
        break;
        
      case "title":
        // no reason to refresh component when title changes.
        this._titleOptionChanged();
        break;
        
      case "translations": 
        this.refresh();
        break;

      case 'value':
        this._AfterSetOptionValue(option, previous, flags);
        break;
      
      case "validators":
        this._AfterSetOptionValidators(option);
        break;
        
      default:
        break;
    }
    
  },
  
  /**
   * Performs post processing after converter option changes by taking the following steps.
   * 
   * - always push new converter hint to messaging <br/>
   * - if component has no errors -> refresh UI value<br/>
   * - if component is invalid has messagesShown -> clear all component errors and run full 
   * validation using display value. <br/>
   * &nbsp;&nbsp;- if there are validation errors, value is not pushed to model; messagesShown is 
   * updated.<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to 
   * listen to optionChange(value) to clear custom errors.<br/>
   * - if component is invalid has messagesHidden -> refresh UI value. no need to run deferred 
   * validations. <br/>
   * - messagesCustom is never cleared<br/>
   * 
   * @param {String} option
   * 
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
    // called when 'converter' option changed, usually from option/setOption calls
  _AfterSetOptionConverter : function (option)
  {
    var runFullValidation = false;
    
    // clear the cached converter instance and push new hint to messaging
    this._ResetConverter();

    if (this._hasInvalidMessagesShowing())
    {
      runFullValidation = true;
    }
    
    if (runFullValidation)
    {
      this._clearComponentMessages();
      this._updateValue(_sConverterOptionOptions);
    }
    else
    {
      // refresh UI display value when there are no errors or where there are only deferred errors 
      this._Refresh(option, this.options[option], true);
    }
  },
  
  /**
   * Performs post processing after disabled or readOnly option changes by taking the following 
   * steps. (Steps are same for readOnly option).
   * <p>
   * if disabled component is enabled then, <br/>
   * - if there are no errors, run deferred validation. component could have been initialized with 
   * empty value and disabled.<br/>
   * - if component is invalid and showing messages clear component error, grab UI value and run 
   * full validation.<br/>
   * - if component is invalid and has hidden messages; do nothing. <br/>
   * </p>
   * <p>
   * if enabled component is disabled no validation is run.<br/>
   * </p>
   * 
   * @param {String} option
   * @param {Object} validationOptions
   * 
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _AfterSetOptionDisabledReadOnly : function (option, validationOptions)
  {
    var isEnabled = !(this.options[option] || false);
    
    // always refresh
    this._Refresh(option, this.options[option]);
    if (isEnabled)
    {
      this._runMixedValidationAfterSetOption(validationOptions);
    }
  },
  
  /**
   * Performs post processing after required option is set by taking the following steps.
   * 
   * - if component is invalid and has messgesShown -> required: false/true -> clear component errors; 
   * run full validation with UI value (we don't know if the UI error is from a required validator 
   * or something else);<br/>
   * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is 
   * updated<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to 
   * listen to optionChange(value) to clear custom errors.<br/>
   * 
   * - if component is invalid and has messagesHidden -> required: false -> clear component 
   * errors; no deferred validation is run.<br/>
   * - if component has no error -> required: true -> run deferred validation (we don't want to flag 
   * errors unnecessarily)<br/>
   * - messagesCustom is never cleared<br/>
   * 
   * @param {string} option
   * 
   * @protected
   * @memberof oj.editableValue
   * @instance
   */  
  _AfterSetOptionRequired : function (option)
  {
    // refresh hints, theming and aria to reflect new state
    this._Refresh(option, this.options[option]);
    this._runMixedValidationAfterSetOption(_sRequiredOptionOptions);
  },
  
  /**
   * Performs post processing after value option changes by taking the following steps.
   * 
   * - triggers an optionChange and does writeback if required.<br/>
   * - if setOption was from programmatic intervention, <br/>
   * &nbsp;&nbsp;- clear custom messages and component messages; <br/>
   * &nbsp;&nbsp;- run deferred validation. if there is an error, updates messagesHidden. <br/>
   * - always refreshes UI display <br/>
   * 
   * @param {string} option
   * @param {Object|string=} previous
   * @param {Object=} flags
   * 
   * @protected
   * @memberof oj.editableValue
   * @instance
   * 
   */
  _AfterSetOptionValue : function(option, previous, flags)
  {
    var isUIValueChange = false, doNotClearMessages;

    // triggers optionChange and writeback if necessary
    this._valueOptionChanged(previous, flags);

    if (flags)
    {
      isUIValueChange = flags['_oj_originalEvent'] ? true : false;
      doNotClearMessages = flags['_oj_doNotClearMessages'] || false;
    }

    if (!isUIValueChange)
    {
      // value option can be updated directly (i.e., programmatically or through user interaction) 
      // or updated indirectly as a result of some other option changing - e.g., converter, 
      // validators, required etc. See _updateValue() method for details.
      // When value changes directly due to programatic intervention (usually page author does this) 
      // then clear all messages and run deferred validation.
      // If value changes indirectly do not clear custom messages (component messages are already 
      // cleared) and run deferred validation.
      if (!doNotClearMessages) 
      {
        this._clearAllMessages(null);
      }
      this._runDeferredValidation(this._VALIDATION_CONTEXT.VALUE_OPTION_CHANGE);
    }
    
    // refresh UI display value
    this._Refresh(option, this.options[option], true);
  },
  
  /**
   * When validators option changes, take the following steps.
   * 
   * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
   * - if component is valid -> validators changes -> no change<br/>
   * - if component is invalid has messagesShown -> validators changes -> clear all component 
   * messages and re-run full validation on displayValue. if there are no errors push value to 
   * model;<br/>
   * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change 
   * the required-ness of component <br/>
   * - messagesCustom is not cleared.<br/>
   * 
   * NOTE: The behavior applies to any option that creates implicit validators - min, max, pattern, 
   * etc. Components can call this method when these options change.
   * 
   * @returns {undefined}
   * @protected
   * @memberof oj.editableValue
   * @instance
   */
  _AfterSetOptionValidators : function ()
  {
    var runFullValidation = false;
    
    // resets all validators and pushes new hints to messaging
    this._ResetAllValidators();
    
    if (this._hasInvalidMessagesShowing())
    {
      runFullValidation = true;
    }
    
    if (runFullValidation)
    {
      this._clearComponentMessages();
      this._updateValue(_sValidatorsOptionOptions);
    }
  },
  
  /**
   * Whether the a value can be set on the component. If the component is 
   * disabled or readOnly then setting value on component is a no-op. 
   * 
   * @see #_SetValue
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _CanSetValue: function ()
  {
    var disabled = this.options['disabled'] || false, readOnly = this.options['readOnly'] || false;
    return (disabled || readOnly) ? false : true;
  },
  
  /**
   * Detaches the widget from the element and restores element exactly like it was before the widget 
   * was attached.
   * @protected
   * @expose
   * @memberof oj.editableValue
   * @instance
   * 
   */
  _destroy : function ()
  {
    var widget = this.widget();
    
    this._clearAllMessages(null, true);
    this._getComponentMessaging().deactivate();

    if (this.$label)
    {
      this.$label._ojLabel( "destroy" );
    }
    this._RestoreAttributes(); //remove when _RestoreAttributes is uncommented from jqueryui-base

    return this._super();
  },

  /**
   * Sets focus on the element that naturally gets focus. For example, this would be the input 
   * element for input type components. <br/>
   * 
   * @returns {*} a truthy value if focus was set to the intended element, a falsey value 
   * otherwise.
   * @expose
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @since 0.7
   */
  Focus : function ()
  {
    this._GetContentElement().focus();
    return true;
  },
  
  /**
   * Called (by the widget factory) when the option changes, this method responds to the change 
   * by refreshing the component if needed. This method is not called for the options passed in 
   * during the creation of the widget.
   * 
   * @param {string} name of the option
   * @param {Object|string} value
   * @param {Object?} flags - optional flags. The following flags are currently supported:
   * <ul>
   *  <li>changed - true if the caller wants to indicate the value has changed, so no comparison is necessary</li>
   * </ul>
   * 
   * @expose
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _setOption : function (name, value, flags) 
  {
    var retVal, previous, skipSetOption = false;
    
    // Step 1: Remember previous values
    if (typeof name === "string" && value !== undefined)
    {
      switch (name)
      {
        case "messagesCustom":
          previous = this.options['messagesCustom'] || [];
          break;

        case "messagesHidden":
          // this option can never be set programmatically by page author
          skipSetOption = true;
          break;          
          
        case "messagesShown":
          // this option can never be set programmatically by page author
          skipSetOption = true;
          break;
          
        case "value":
          previous = this.options['value'];
          break;
      }
    }
    
    if (skipSetOption)
    {
      oj.Logger.error(name + " option cannot be set");
      return this;
    }
    
    // Step 2: Update option value 
    retVal = this._superApply(arguments);
    
    // Step 3: Do post processing like triggering events, refreshing component DOM etc.
    this._AfterSetOption(name, previous, flags); 
    return retVal;
  },
  
  // *********** END WIDGET FACTORY METHODS **********
  
  /**
   * Returns a jquery object of the element representing the content node. This could be a jQuery 
   * object of the element the widget was invoked on - typically this is an input or select or 
   * textarea element for which a value can be set.
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {Object} the jquery element that represents the editable content. E.g., an input
   */
  _GetContentElement : function ()
  {
    return this.element;
  },

  /**
   * Returns a jquery object of the element representing the primary label node for the input 
   * component. 
   * First we look for the aria-labelledby attribute on the input.
   * If that's not found, we look for the label with 'for' attribute 
   * pointing to input.
   * If that's not found, we walk up the dom looking for aria-labelledby.
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @return {Object} the jquery element that represents the input component's label.
   *  return null if it can't find anything.
   */
  _GetLabelElement : function ()
  {
    // If input has aria-labelledby set, then look for label it is referring to.
    var queryResult = this._getAriaLabelledByElement(this.element);
    if (queryResult !== null && queryResult.length !== 0)
    {
      return queryResult;
    }
    
    // if no aria-labelledby is on the input, then look for a label with 'for'
    // set.
    var id = this.element.prop("id");
    if (id !== undefined)
    {
      var labelQuery = "label[for='" + id + "']";
      queryResult = $(labelQuery);
      if (queryResult.length !== 0)
      {
        return queryResult;
      }
    }
 
    // if no aria-labelledby on input and no label with 'for' pointing to input,
    // then as a final step we walk up the dom to see if aria-labelledby is set.
    // If so, then we find the label it is referring to.
    // This would be the case when you have multiple inputs grouped in a div 
    // <label id="grouplabel">Address</label>
    // <div aria-labelledby="grouplabel"><input/><input/><input/></div>
    var ariaElement = this.element.closest("[aria-labelledby]");
    if (ariaElement.length !== 0)
    {
      // Element has aria-labelledby set, so look for label it is referring to.
      queryResult = this._getAriaLabelledByElement(ariaElement);
      if (queryResult !== null && queryResult.length !== 0)
      {
        return queryResult;
      }
    }
    return null;

  },
  
  
  /**
   * Returns the element's value. Normally, this is a call to this.element.val(), but for some 
   * components, it could be something else. E.g., for ojRadioset the element's value is really the 
   * value of the selected radio in the set. 
   * 
   * @override
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetElementValue : function () 
  {
    return this.element.val();
  },
  

/**
   * Returns a jquery object of the element that triggers messaging behavior. The trigger element 
   * is usually an input or select or textarea element for which a value can be set/retrieved and 
   * validated. 
   * 
   * @return {Object} jquery object 
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetMessagingLauncherElement : function ()
  {
    return this._GetContentElement();
  },
  
  /**
   * Returns the normalized converter instance.
   * 
   * @return {Object} a converter instance or null
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetConverter : function () 
  {
    // this._converter holds the instance
    if (!this._converter)
    {
      var converterOption = this.options['converter'];
      this._converter = oj.IntlConverterUtils.getConverterInstance(converterOption);
    }
    
    return this._converter || null;
  },

  /**
   * Returns an array of implicit validators setup by component. This list contains validators for 
   * the internal use of the component and are not a part of this.options.validators. <br/>
   * E.g., if the pattern attribute or option is set, a RegExpValidator instance is automatically 
   * created and added to this list. <br/>
   * RequiredValidator is tracked separately from the default validators.
   * 
   * @return {Object} a map of string name to the validator instance. 
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetImplicitValidators : function ()
  {
    if (!this._implicitValidators)
    {
      this._implicitValidators = {};
    }
    
    return this._implicitValidators;
  },
          
  /**
   * Returns the display value that is ready to be passed to the converter.
   * 
   * @param {Object} value the stored value if available that needs to be formatted for display
   * @return {string} usually a string display value
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetDisplayValue : function (value) 
  {
    return this._GetContentElement().val();
  },

  /**
   * Returns an array of all validators built by merging the validators option set on the component 
   * and the implicit validators setup by the component. <br/>
   * This does not include the implicit required validator. Components can override to add to this 
   * array of validators.
   * 
   * @return {Array} of validators
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _GetAllValidators : function ()
  {
    if (!this._allValidators)
    {
      var allValidators = [], validatorsOption = this.options['validators'], validator, 
          isValidatorInstance = true, implicitValidatorMap = this._GetImplicitValidators(), 
          implicitValidators = [], vType, vOptions, vTypeStr, normalizedValidators, i;

      // combine public and implicit validators to get the combined list
      var keys = Object.keys(implicitValidatorMap), valType;
      if (keys.length > 0)
      {
        for (var idx in keys) 
        {
          valType = keys[idx];
          implicitValidators.push(implicitValidatorMap[valType]);
        }
        allValidators = allValidators.concat(implicitValidators);
      }
        
      if (validatorsOption)
      {
        normalizedValidators = [];
        // Normalize validators 
        for (i = 0; i < validatorsOption.length; i++)
        {
          validator = validatorsOption[i];
          if (typeof validator === "object") 
          {
            // check if we have an actual validator instance that implements the validate() method
            // oj.Validation.__doImplementsCheck(validator, oj.Validator);
            if (!(validator['validate'] && typeof validator['validate'] === "function"))
            {
              isValidatorInstance = false;
            }
            
            if (!isValidatorInstance)
            {
              // we maybe dealing with an object literal
              // {'type': 'numberRange', 'options': { 'min': 100, 'max': 1000,
              //                                    'hint': {'min': 'some hint about min'}}}
              vTypeStr = validator['type'];
              if (vTypeStr && typeof vTypeStr === "string")
              {
                vType = oj.Validation.validatorFactory(vTypeStr);
                if (vType)
                {
                  vOptions = oj.CollectionUtils.copyInto({}, validator['options']) || {};
                  // we push converter into the options if not provided explicitly. This is to allow
                  // validators to format values shown in the hint and messages
                  vOptions['converter'] = vOptions['converter'] || this._GetConverter();
                  vOptions['label'] = vOptions['label'] || this._getLabelText();
                  validator = vType.createValidator(vOptions);
                }
                else
                {
                  oj.Logger.error("Unable to locate a validatorFactory for the requested type: " + vTypeStr);
                }
              }
            }
            
            normalizedValidators.push(validator);
          }
          else
          {
            oj.Logger.error("Unable to parse the validator provided:" + validator);
          }
        }

        allValidators = allValidators.concat(normalizedValidators);
      }
      
      this._allValidators = allValidators;
    }
    
    return this._allValidators || [];
  },
  
  /**
   * EditableValue caches the validators to be run, within this._allValidators variable.
   * This is great; however when the implicit validator needs to be reset [i.e. min + max changing] 
   * or the validators option changes, then the cached this._allValidators needs to be cleared. 
   * This method also updates the messaging strategies as hints associated with validators could 
   * have changed.
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ResetAllValidators : function () 
  {
    if (this._allValidators)
    {
      this._allValidators.length = 0;
    }
    this._allValidators = null;
    
    // update messagingstrategy as hints associated with validators could have changed
    this._getComponentMessaging().update(this._getMessagingContent(
            this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS));

  },
  
  /**
   * Clears the cached converter stored in _converter and pushes new converter hint to messaging.
   * Called when convterer option changes 
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ResetConverter : function ()
  {
    this._converter = null;
    this._getComponentMessaging().update(
            this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT));
  },

  /**
   * Called during _InitOptions, when the option was initialized from DOM. This 
   * method tracks all these options. In _AfterCreate() each option is written back.
   * 
   * @param {String} option name of the option
   * @param {Object|number|string|boolean|undefined} previousValue
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _InitializedOptionFromDom : function (option, previousValue) 
  {
    this._optionsInitializedFromDom.push({"option": option, "previousValue": previousValue});
  },
  
  /**
   * Whether the component is required.
   * 
   * @return {boolean} true if required; false
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _IsRequired : function () 
  {
    return this.options['required'];
  },
  
  /**
   * Convenience handler for the DOM 'change' event. Subclasses are expected to wire up event 
   * handlers for DOM events that they wish to handle.<br/>
   * 
   * The implementation retrieves the display value for the component by calling _GetDisplayValue() 
   * and calls _SetValue(), with full validation.
   * 
   * @param {Event} event DOM event 
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _HandleChangeEvent : function (event) 
  {
    var submittedValue = this._GetDisplayValue();
    // run full validation
    this._SetValue(submittedValue, event);
  }, 

  /**
   * Called in response to a change in the options set for this component, this method refreshes the 
   * component display value. Subclasses can override to provide custom refresh behavior.
   * 
   * @param {String=} name the name of the option that was changed
   * @param {Object=} value the current value of the option
   * @param {boolean=} forceDisplayValueRefresh
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _Refresh : function (name, value, forceDisplayValueRefresh)
  {
    switch (name)
    {
      case "converter":
        value = this.options['value'];
        this._refreshComponentDisplayValue(value, forceDisplayValueRefresh);
        break;
        
      case "disabled":
        this._refreshTheming("disabled", this.options['disabled']);
        break;
        
      case "help":
        // refresh the help - need to keep the label in sync with the input.
        var helpDef = this.options.help["definition"];
        var helpSource = this.options.help["source"];
        var labelHelpIconWrapper = this._ariaDescribedByHelpIconWrapper(helpSource);

        if (this.$label)
        {
          // Calling option this way calls _setOption in _ojLabel.
          // order matters here. When _ojLabel's help is changed, it removes
          // the help dom, then re-adds it. We need to make sure _ojLabel's  
          // describedById option is there so we can find the dom to remove
          // and recreate if needed.
          this.$label._ojLabel("option", "describedById", labelHelpIconWrapper);
          this.$label._ojLabel("option", "help", 
                          {"definition":helpDef, 
                          "source":helpSource});
        }
        break;
        
      case "required":
        this._refreshTheming("required", this._IsRequired());
        this._RefreshAriaRequired(value);

        // need to keep the label in sync with the input
        if (this.$label)
        {
          this.$label._ojLabel("option", "required", value);
        }
        break;
        
      case "value":
        this._refreshComponentDisplayValue(value, forceDisplayValueRefresh); 
        break;
        
    }
  },
  /**
   * Called when a aria-required attribute needs to be set or removed. 
   * Most inputs/selects need aria-required on the input element (aka 'content')
   * But it is not legal to have aria-required on radio/checkboxes.
   * Subclasses can override to put aria-required where they want.
   * 
   * @param {Object=} value the current value of the required option
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _RefreshAriaRequired : function (value)
  {
    var ariaValue, contentNode = this._GetContentElement();

    ariaValue = value; //(value == "required") ? true : false;
    if (ariaValue && contentNode) 
    {
      contentNode.attr("aria-required", ariaValue);
    }
    else
    {
      contentNode.removeAttr("aria-required");
    }
  },
  

  /**
   * Called anytime the label DOM changes requiring a reset of any dependent feature that caches the 
   * label, including all validators.
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected   
   */
  _ResetComponentState : function ()
  {
    // reset all validators when label changes
    this._implicitReqValidator = null;
    this._converter = null;
    this._ResetAllValidators();
  },  
  
  /**
   * Called when the display value on the element needs to be updated. This method updates the 
   * (content) element value. Widgets can override this method to update the element appropriately. 
   * 
   * @param {String} displayValue of the new string to be displayed
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
  */  
  _SetDisplayValue : function (displayValue) 
  {
    var contentElem = this._GetContentElement();
    contentElem.val(displayValue);
  },

  /**
   * Sets the placeholder text on the content element by default. It sets the placeholder attribute
   * on the element. Component subclasses can override this method to control where placeholder text
   * gets set.
   * @param {string} value
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _SetPlaceholder : function(value)
  {
    this._GetContentElement().attr("placeholder", value);
  },
  
  /**
   * Sets the placeholder option with the value. 
   * 
   * @param {string} value
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */  
  _SetPlaceholderOption : function (value)
  {
    this.options['placeholder'] = value;
  },
  
  /**
   * whether the placeholder option is set
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _HasPlaceholderSet : function()
  {
    //Bug 18926010 - an empty placeholder shows up if data changed after first binding 
    return this.options['placeholder'];
  },  
    
  /**
   * Clear the placeholder option
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ClearPlaceholder : function()
  {
    //Bug 18926010 - an empty placeholder shows up if data changed after first binding 
    this._SetPlaceholderOption("");
    this._SetPlaceholder("");
  },

  /**
   * Runs full validation on the newValue (usually the display value) and sets the parsed value on 
   * the component if value passes basic checks and there are no validation errors. <br/>
   * If the newValue is undefined or if it differs from the last saved displayValue this method 
   * skips validation and does not set value (same as ADF).<br/>
   * 
   * @param {string|Object} newValue the ui value that needs to be parsed before it's set.
   * @param {Object=} event an optional event if this was a result of ui interaction. For user 
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action 
   * causes a 'blur' event.
   * @param {Object=} options an Object literal that callers pass in to determine how validation 
   * gets run. 
   * @param {boolean=} options.doValueChangeCheck - if set to true compare newValue with last 
   * displayValue before running validation; if false, always run validation. E.g., set to false 
   * when validate() is called.
   * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This 
   * is provided for callers that may want to clear only some of the messages. E.g., when required 
   * option changes, it clears only component messages, not custom.
   * @param {number=} options.validationMode - accepted values (defined in _VALIDATION_MODE) are:
   * <ul>
   *   <li>FULL - the default and runs both the converter and all validators. </li>
   *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
   *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
   * </ul>
   * @return {boolean} false if value was not set due to validation error. 
   * @example  <caption>Widget subclasses can use this convention to run full validation</caption>
   * this._SetValue(value, event);
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   * 
   */
  _SetValue : function (newValue, event, options)
  {
    var doValueChangeCheck = (options && typeof options.doValueChangeCheck === "boolean") ? 
                            options.doValueChangeCheck : true, parsed;
    
    // disallow setting a value of undefined by widgets
    if (newValue === undefined)
    {
      oj.Logger.warn("Attempt to set a value of undefined");
      return false;
    }
    
    if (!doValueChangeCheck || newValue !== this._getLastDisplayValue()) 
    {
      parsed = this._Validate(newValue, event, options);
      
      // if validation passed
      if (parsed !== undefined && this.isValid())
      {
        // update value option
        this._updateValueOption(parsed, event, options && options.validationContext);
        return true;
      }
    }
    else
    {
      if (oj.Logger.level > oj.Logger.LEVEL_WARN)
      {
        oj.Logger.info("Validation skipped and value option not updated as submitted value '" + 
                (newValue.toString) ? newValue.toString() : newValue + " same as previous.");
      }
    }
    
    return false;
  },
  
  /**
   * Runs full validation on the value. If value fails basic checks 
   * (see <a href="#_CanSetValue">_CanSetValue</a>, or if value failed validation, this method 
   * returns false. Otherwise it returns true.
   * 
   * <p>
   * Components should call this method if they know UI value has changed and want to set the 
   * new component value. 
   * </p>
   * 
   * @param {string|Object} newValue the actual value to be set. Usually this is the string display value
   * @param {Object=} event an optional event if this was a result of ui interaction. For user 
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action 
   * causes a 'blur' event.
   * @param {{doNotClearMessages:boolean,validationContext:number,validationMode:number}=} options 
   * an Object literal that callers pass in to determine how validation gets run. 
   * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This 
   * is provided for callers that may want to clear only some of the messages. E.g., when required 
   * option changes, it clears only component messages, not custom.
   * @param {number=} options.validationContext - the context this method was called. When not set it 
   * defaults to _VALIDATION_CONTEXT.USER_ACTION.
   * @param {number=} options.validationMode - accepted values defined in _VALIDATION_MODE
   * 
   * @return {Object|string|undefined} the parsed value or undefined if validation failed
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _Validate : function (newValue, event, options)
  {
    var mode = options && options.validationMode ? options.validationMode : 
                this._VALIDATION_MODE.FULL, 
        context = options && options.validationContext ? options.validationContext : 
                this._VALIDATION_CONTEXT.USER_ACTION, 
        doNotClearMessages = options && options.doNotClearMessages || false, result;

    // disallow setting a value of undefined by widgets
    if (newValue === undefined)
    {
      oj.Logger.warn("Attempt to set a value of undefined");
    }
    else if (this._CanSetValue())
    {
      if (!doNotClearMessages)
      {
        this._clearAllMessages(event);
      };
      
      this._setLastSubmittedValue(newValue);
      
      try
      {
        return this._runNormalValidation(newValue, mode, context, event);
      }
      catch(e)
      {
        // validation failed
      }
    }
    else
    {
      if (oj.Logger.level > oj.Logger.LEVEL_WARN)
      {
        oj.Logger.info("Validation skipped and value option not set as component state does not " + 
                " allow setting value. For example if the component is readonly or disabled.");
      }
    }
    
    return result;
  },  

  /**
   * Triggers a 'optionChange' event on the component for these options - 
   * 'value', 'messagesCustom', 'messagesHidden', 'messagesShown'.
   *  
   * @param {string} option name of the option that changed
   * @param {string|number|Object} previousValue an array of the previous 
   * @param {boolean=} shouldWriteback when set to true writeback happens.
   * @param {Event=} originalEvent 
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
   _TriggerOptionChange : function (option, previousValue, shouldWriteback, originalEvent)
  {
    oj.Assert.assertNonEmptyString(option, "");

    var writebackVal = (shouldWriteback || false) ? {'writeback': 'shouldWrite'} : 
            {'writeback': 'shouldNotWrite'},
     dataHash = {
      'option': option,
      'component': oj.Components.getWidgetConstructor(this.element),
      'previousValue': previousValue, 
      'value' : this.options[option],
      'optionMetadata': writebackVal};

    switch(option)
    {
      case 'messagesShown':
      case 'messagesHidden':
      case 'messagesCustom':

       this._trigger('optionChange', originalEvent || null, dataHash);
       break;

     case 'value':
       // users can't cancel the value change event as the event is triggered after the value changes
       this._trigger('optionChange', originalEvent || null, dataHash);
       break;

     default:
       break;
    }

  },
  
  /**
   * Compares 2 values for equality and returns true if they are equal; false otherwise. Calls 
   * oj.Object.compareValues() which works for most Javascript data types.
   * 
   * @param {Object|string|undefined} value1 first value
   * @param {Object|string|undefined} value2 another value
   * @return {boolean}
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   */
  _ValueEquals : function (value1, value2)
  {
    return oj.Object.compareValues(value1, value2);
  },
  
  /**
   * Returns the default styleclass for the component. All input components must override.
   * 
   * @return {string}
   * 
   * @memberof oj.editableValue
   * @instance
   * @protected
   * @abstract
   */
  _GetDefaultStyleClass : function ()
  {
    oj.Assert.failedInAbstractFunction();
    return "";
  },
    
  
  // I N T E R N A L   P R I V A T E   C O N S T A N T S    A N D   M E T H O D S 
  // Subclasses should not override or call these methods
  
  /**
   * Types of messaging content to update.
   * <ul>
   * <li>'ALL' - builds all messaging content</li>
   * <li>'VALIDITY_STATE' - updates only validityState every time validation runs and there are 
   * new messages or when the messages option changes.</li>
   * <li>'CONVERTER_HINT' - updates only converter hints, this is used when converter option 
   * changes</li>
   * <li>'VALIDATOR_HINTS' - updates only validator hints, this is used when validators option 
   * changes</li>
   * <li>'TITLE' - updates only title, when the title property changes</li>
   * </ul>
   * @private
   */
  _MESSAGING_CONTENT_UPDATE_TYPE : {ALL : 1, 
                                    VALIDITY_STATE : 2, 
                                    CONVERTER_HINT : 3, 
                                    VALIDATOR_HINTS : 4, 
                                    TITLE : 5},
                                   
  /**
   * when below listed options are passed to the component, corresponding CSS will be toggled
   * @private
   * @const
   * @type {Object}
   * @memberof oj.editableValue
   */
  _OPTION_TO_CSS_MAPPING: {
    "disabled": "oj-disabled",
    "required": "oj-required"
  },
  
  /**
   * For values that were initialized from DOM, trigger optionChange to ensure writebacks.
   * @private 
   * @memberof oj.editableValue
   * @instance
   * 
   */
  _applyAfterCreateOptionChanges : function ()
  {
    var i, item;
    for (i = 0; i < this._optionsInitializedFromDom.length; i++)
    {
      item = this._optionsInitializedFromDom[i];
      this._TriggerOptionChange(item["option"], item['previousValue'], true /* shouldWriteback*/); 
    }
    
    this._optionsInitializedFromDom = null;
  },
    
  /**
   * Clears all messages for this component. Today this only happens when <br/>
   *  - the component's value changes as a result of user interaction, <br/>
   *  - the reset method is called, <br/>
   *  - component is destroyed.<br/>
   * 
   * @param {Event=} event
   * @param {boolean=} doNotSetOption default value is false; a true value clears the option 
   * directly without using the public option method, causing no events to be fired. 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _clearAllMessages : function(event, doNotSetOption)
  {
    doNotSetOption = doNotSetOption ? true : false;
    if (!doNotSetOption)
    {
      this._clearMessagesHidden(event);
      this._clearMessagesShown(event);
      this._clearMessagesCustom(event);
    }
    else
    {
      this.options['messagesHidden'] = [];
      this.options['messagesShown'] = [];
      this.options['messagesCustom'] = [];
    }
  },
  
  /**
   * Clears only messages that were added by component. 
   * Clears messagesHidden option and removes all messages except custom.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */  
  _clearComponentMessages : function ()
  {
    var shownMsgs = this.options['messagesShown'], beforeLen = shownMsgs.length, msg, flags = {};
    
    this._clearMessagesHidden(); 
    
    // remove component messages in messagesShown
    for (var i = beforeLen -1; i >= 0; i--)
    {
      msg = shownMsgs[i];
      if (msg instanceof oj.ComponentMessage)
      {
        shownMsgs.splice(i, 1);
      }
    }
    
    flags['changed'] = this.options['messagesShown'].length !== beforeLen ? true : false;
    this._messagesChanged("messagesShown", this.options['messagesShown'], flags);
  },
  
  /**
   * Generally 'messagesHidden' option property is changed directly, without invoking the option() 
   * method.
   * 
   * @param {Event=} event
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _clearMessagesHidden : function (event)
  {
    var flags = {};
    
    flags['changed'] = this.options['messagesHidden'].length > 0 ? true : false;
    if (event)
    {  
      flags['_oj_originalEvent'] = event;
    }    
    this.options['messagesHidden'] = [];

    // option has mutated. Set changed flag to always trigger optionChange. 
    this._messagesHiddenOptionChanged(this.options['messagesHidden'], flags);
  },
  
  /**
   * Generally 'messageComponent' option property is changed directly, without invoking the option() 
   * method.
   * 
   * @param {Event=} event
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _clearMessagesShown : function (event)
  {
    var flags = {};
    flags['changed'] = this.options['messagesShown'].length > 0 ? true : false;
    if (event)
    {  
      flags['_oj_originalEvent'] = event;
    }
    this.options['messagesShown'] = [];

    // option has mutated. Set changed flag to always trigger optionChange. 
    this._messagesShownOptionChanged(this.options['messagesShown'], flags);
  },  
  
  /**
   * Clears 'messageCustom' option when the following occurs - <br/>
   * - when user value changes <br/>
   * - when reset is called <br/>
   * - when component is destroyed <br/>
   * 
   * @param {Event=} event
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */  
  _clearMessagesCustom : function (event)
  {
    var msgsHash = {}, flags = {};
    flags['changed'] = this.options['messagesCustom'].length > 0 ? true : false;
    msgsHash['messagesCustom'] = [];
    if (event)
    {  
      flags['_oj_originalEvent'] = event;
    }
    this.option(msgsHash, flags);
  },  
  
  /**
   * Clones messages before it's set. <br/>
   * 
   * @param {Array=} value
   * @returns {Array} of cloned messages
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */    
  _cloneMessagesBeforeSet : function (value)
  {
    var val, msgsClone = [], i, msg;
    // we want all messages to be an instance of oj.Message. So clone array
    if (value && value.length > 0)
    {
      for (i = 0; i < value.length; i++)
      {
        val = value[i];
        if (val instanceof oj.Message)
        {
          msgsClone.push(val.clone());
        }
        else
        {
          msg = new oj.Message(val['summary'], val['detail'], val['severity']);
          msg =  Object.freeze ? Object.freeze(msg) : msg;
          msgsClone.push(msg);
        }
      }
    }
    
    return msgsClone;
  },  
  
 
  /** 
   * Create the _ojLabel component
   * @private
   * @memberof oj.editableValue
   * @instance
   * 
   */
  _createOjLabel : function ()
  {
    this.$label = this._GetLabelElement();
    if (this.$label)
    {
      var helpDef = this.options['help']['definition'];
      var helpSource = this.options['help']['source'];

      var labelHelpIconWrapper = this._ariaDescribedByHelpIconWrapper(helpSource);
      // create the ojLabel component 
      this.$label._ojLabel(
    //   {inputLabelStyleClass: this._GetDefaultStyleClass()+"-label",
        {rootAttributes:{'class': this._GetDefaultStyleClass()+"-label"},
        describedById: labelHelpIconWrapper, 
        required:this.options['required'], 
        help:{'definition': helpDef, 'source': helpSource}});

    }    
  },

  /**
   * Refreshes the component to respond to DOM changes, in which case fullRefresh=true. 
   * @param {boolean} fullRefresh true if a full refresh of the component is desired.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _doRefresh : function (fullRefresh)
  {
    var runFullValidation = false;
    
    fullRefresh = fullRefresh || false;
    if (fullRefresh)
    {
      // the DOM for the label and its text could have changed. 
      if (this.$label)
      {
        this.$label._ojLabel("refresh");
      }

      // reset state and re-initialize component messaging, since refresh() can be called when 
      // locale changes, requiring component to show messaging artifacts for current locale. 
      this._ResetComponentState();
      this._initComponentMessaging();
      
      if (this._hasInvalidMessagesShowing())
      {
        runFullValidation = true;
      }

      // clear component messages always
      this._clearComponentMessages();
      if (runFullValidation)
      {
        // run full validation using the current display value; 
        // show messages immediately if there are errors otherwise set value to option
        this._updateValue(_sRefreshMethodOptions);
      }
      else
      {
        // run deferred validation if comp is either showing a deferred error or has no errors. 
        // But only when required is true. 
        if (this._IsRequired())
        {
          this._runDeferredValidation(_sRefreshMethodOptions.validationContext);
        }
        // refresh UI display value when there are no errors or where there are only deferred errors 
        this._Refresh("value", this.options['value'], true);
      }
    }
    else
    {
      this._Refresh("value", this.options['value']);
      this._Refresh("required", this.options['required']);
      //this._RefreshAriaRequired(this.options.required);
      //this._refreshTheming("required", this.options.required);
    }
    // always refresh these
    this._Refresh("disabled", this.options['disabled']);
  },
  
  /**
   * Gets the last stored model value
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getLastModelValue : function ()
  {
    return this._oj_lastModelValue;
  },
          
  _getLastDisplayValue : function () 
  {
    return this._oj_lastElementValue;
  },
  /**
   * Get the element whose id matches the elem's aria-labelledby value, if any.
   * @param {Object} elem the dom element from which you want to get the 
   * aria-labelledby property value
   * @return {Object} if element does not have aria-labelledby defined, then
   *    returns null. If it  does, then return a new jQuery object with the 
   *    label with an id equal to the aria-labelledby value. If no match, then
   *    the jQuery object will be empty.
   *    
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getAriaLabelledByElement: function (elem)
  {
    // look for a label with an id equal to the value of aria-labelledby. 
    // .prop does not work for aria-labelledby. Need to use .attr to find
    // aria-labelledby.
    var ariaId = elem.attr("aria-labelledby");

    if (ariaId !== undefined )
    {
      var labelQuery = "label[id='" + ariaId + "']"; 
      return $(labelQuery);
    }    
    else
      return null;
  },

  /**  
   * If there is help source (an external URL), then construct an
   * id from the element's id, render aria-describedby with this id, and then
   * return the id to be used by the ojLabel.
   * 
   * For accessibility, we need to wrap help icons with a div. 
   * Then, on the input component we use aria-describedby to point to this div.
   * &lt;div id="fooIcons"&gt;
   *   &lt;span class="oj-label-help-icon oj-component-icon oj-clickable-icon"&gt;
   *   /&lt;span/&gt;
   * /&lt;div/&gt;
   * &lt;input aria-describedby="fooIcons" id="foo" type="text"/&gt;
   *    
   * This function constructs an id to put on the help icon div and returns it.
   * It also adds the aria-describedby on the input.
   * 
   * We render the help icon only if there is help source.
   * 
   * @return {string} an id we constructed
   * @param {string} helpSource helpSource must be present
   * for the aria-describedby to be rendered.
   * @private
   * @memberof oj.editableValue
   * @instance
   * 
   */
  _ariaDescribedByHelpIconWrapper : function (helpSource)
  {
    // generate a unique id if one does not exist, then get the id and use it to 
    // create an id that will be set on the label help icon wrapper
    this.element.uniqueId();
    var id = this.element.prop("id");
    var labelHelpIconWrapperId = id + "Icons";
    if (helpSource)
    {  
      var contentElements = this._GetContentElement();        

      // aria-describedby can be a list of ids, so make sure to append
      //contentElements.attr("aria-describedby", labelHelpIconWrapperId);
      contentElements.each(function() {
        var ariaDescBy = $(this).attr("aria-describedby");
        if (ariaDescBy)
          $(this).attr("aria-describedby", ariaDescBy + ' ' + labelHelpIconWrapperId);
        else
          $(this).attr("aria-describedby", labelHelpIconWrapperId);
     });
    }
    return labelHelpIconWrapperId;  
  },
  
  /**
   * Returns a concat of messagesShown and messagesHidden.
   * 
   * @returns {Array}
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getMessages : function()
  {
    return this.options['messagesShown'].concat(this.options['messagesHidden']); // todo: revisit
  },
  
  // helper method to retrieve the label text.          
  _getLabelText : function ()
  {
    if (this.$label)
    {
      return this.$label.text();
    }
  },

  _getValidityState : function ()
  {
    if (this._validityState)
    {
      return this._validityState;
    }
    else
    {
      
      this._validityState = new oj.ComponentValidity(this.isValid(), this._getMessages());
    }
    return this._validityState;
  },

  
  /**        
   * Whether component has invalid messages.
   * 
   * @return {boolean} true if invalid; false otherwise
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _hasInvalidMessages : function ()
  {
    return !oj.Message.isValid(this._getMessages());
  },
  
  /**        
   * Whether there are invalid messages, that are currently showing.
   * 
   * @return {boolean} 
   * @private
   * @memberof oj.editableValue
   * @instance
   */  
  _hasInvalidMessagesShowing : function ()
  {
    return (!this.isValid() && this.options['messagesShown'].length > 0);
  },
  
  /**        
   * Whether component has invalid messages added by component, that are currently showing.
   * 
   * @return {boolean} 
   * @private
   * @memberof oj.editableValue
   * @instance
   */  
  _hasInvalidComponentMessagesShowing : function ()
  {
    var shown = this.options['messagesShown'], msg, compMsgs;
    for (var i = 0; i < shown.length; i++)
    {
      msg = shown[i];
      if (msg instanceof oj.ComponentMessage && msg._isMessageAddedByComponent())
      {
        compMsgs = compMsgs || [];
        compMsgs.push(msg);
      }
    }
    
    return (compMsgs === undefined) ? false : !oj.Message.isValid(compMsgs);
  },  
  
  /**
   * Initializes component messaging both when component is initialized or when displayOptions is 
   * set/changed. 
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _initComponentMessaging : function()
  {
    var compMessaging = this._getComponentMessaging(), 
            messagingLauncher = this._GetMessagingLauncherElement(), 
            messagingContent = this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.ALL);
    
    // if default placeholder is currently set then it needs to be cleared here. This is needed for 
    // the following reasons
    // i. a component is reinitialized when the locale changed, requiring the converter hint for 
    // new locale to be set as placeholder.
    // ii. or a component's placeholder option or displayOptions option, could have changed 
    // requiring the placeholder to be reset if it's currently set to the default.
    // 
    if (!this._customPlaceholderSet)
    {
      this._ClearPlaceholder();
    }
    
    compMessaging.activate(messagingLauncher, messagingContent);
  },
  
  _messagesHiddenOptionChanged : function (previous, flags)
  {
    this._messagesChanged("messagesHidden", previous, flags);
  },
  
  _messagesShownOptionChanged : function (previous, flags)
  {
    this._messagesChanged("messagesShown", previous, flags);
  },
  
  /**
   * Called after messagesCustom option changed. This method pushes custom messages to the 
   * messagesShown option.
   * 
   * @param {Array} previous the previous messages array
   * @param {Object=} flags 
   * @returns {undefined}
   * @private
   */  
  _messagesCustomOptionChanged : function (previous, flags)
  {
    var customMsgs = this.options['messagesCustom'], 
            previousShown = this.options['messagesShown'], msg, compShownMsgs = [], i;
    
    // remove custom messages from messagesShown
    for (i = 0; i < previousShown.length; i++)
    {
      msg = previousShown[i];
      if (msg instanceof oj.ComponentMessage && msg._isMessageAddedByComponent())
      {
        compShownMsgs.push(msg);
      }
    }
    this.options['messagesShown'] = compShownMsgs;
    
    // add any new customMsgs
    for (i = 0; i < customMsgs.length; i++)
    {
      this.options['messagesShown'].push(customMsgs[i]);
    }
    
    this._messagesChanged("messagesCustom", previous, flags);
    this._messagesChanged("messagesShown", previousShown, flags);
  },
  
  /**
   * Called after the messages option has changed. 
   * 
   * @param {string} option name 
   * @param {Array} previous the previous messages array
   * @param {Object=} flags 
   * @returns {undefined}
   * @private
   */
  _messagesChanged : function(option, previous, flags) 
  {
    var shouldTriggerOptionChange = false, msgs = this.options[option], shouldWriteback = false, 
            originalEvent;
        
    if (flags)
    {
      // 'changed' set to true when ko knows the option changed, or component changes the option
      shouldTriggerOptionChange = flags['changed'] || false;
      // _oj_originalEvent specifies the dom event that triggered the change
      originalEvent = flags['_oj_originalEvent'] || null;
    }
    
    // update the valid flag
    this._updateValid();
    
    // update component messaging
    this._getComponentMessaging().update(this._getMessagingContent());

    // trigger optionChange if we are skipping comparison or when messages are different
    if (shouldTriggerOptionChange || !this._messagesEquals(previous, msgs))
    {
      this._TriggerOptionChange(option, previous, shouldWriteback, originalEvent);
    }
  },
  
  _placeholderOptionChanged : function (flags)
  {
    var refreshMessagingOptions = 
          //  _oj_messaging_update indicates whether the current change is from the messaging module.
          // see ComponentMessaging for details
          flags && flags['_oj_messaging_update'] ? false : true,
                  value = this.options['placeholder'];

    this._SetPlaceholder(value);
    if (refreshMessagingOptions)
    {
      // if placeholder was set and it's not from messaging code, then the messaging preferences 
      // will need to re-evaluated. E.g., the default display for 
      // converterHint: ['placeholder', 'notewindow'] is 'placeholder', and if user were to set a 
      // custom placeholder, this overrides the default display for convererHint from 'placeholder'
      // to 'notewindow'. 
      this._customPlaceholderSet = true;
      this._initComponentMessaging();
    }
    else
    {
      this._customPlaceholderSet = false;
    }
  },
    
    
  _setLastModelValue : function (value)
  {
    this._oj_lastModelValue = value;
  },

  _setLastSubmittedValue : function (value) 
  {
    this._oj_lastElementValue = value;
  },

  _titleOptionChanged : function ()
  {
    // when title changes push new title to messaging
    this._getComponentMessaging().update(
            this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE));
  },
  
  /**
   * Adds a message to the <code class="prettyprint">messagesHidden</code> option. This method 
   * does not call the option() method. It updates the option property directly and triggers 
   * optionChange.
   * 
   * @param {Object} message a Message object. 
   * @param {Event=} event
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _updateMessagesHiddenOption : function(message, event) 
  {
    var flags = {}, len, i;
    oj.Assert.assertPrototype(message, oj.Message);
    
    if (typeof message === "object" && Array.isArray(message)) 
    {
      flags['changed'] = true;

      len = message.length;
      for (i = 0; i < len; i++)
      {
        this.options['messagesHidden'].push(message[i]);
      }
    }
    
    if (event)
    {  
      flags['_oj_originalEvent'] = event;
    }    
    
    // trigger an optionChange and update component messaging
    this._messagesHiddenOptionChanged(this.options['messagesHidden'], flags);

  },
  
  /**
   * Adds a message to the <code class="prettyprint">messagesShown</code> option. This method 
   * does not call the option() method. It updates the option property directly and triggers 
   * optionChange.
   * 
   * @param {Object|Array} message a Message object. 
   * @param {Event=} event
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _updateMessagesShownOption : function(message, event) 
  {
    var flags = {}, len, i;
    oj.Assert.assertPrototype(message, oj.Message);
    
    if (typeof message === "object" && Array.isArray(message)) 
    {
      flags['changed'] = true;

      len = message.length;
      for (i = 0; i < len; i++)
      {
        this.options['messagesShown'].push(message[i]);
      }
    }
    
    if (event)
    {  
      flags['_oj_originalEvent'] = event;
    }    
    // trigger an optionChange and update component messaging
    this._messagesShownOptionChanged(this.options['messagesShown'], flags);
  },
  
  /**
   * Writes the value into the option by calling the option method.  
   * 
   * @param {Object|string} newValue the new value to be written to option
   * @param {Object=} event the original event that triggered this
   * @param {number=} validationContext the context in which validation was run that resulted in 
   * value being updated.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   * @see #_valueOptionChanged
   */
  _updateValueOption : function (newValue, event, validationContext)
  {
    var values = {}, flags = {}, shouldWriteback = false;
    values['value'] = newValue;
    
    // set dom event
    if (event)
    {  
      flags['_oj_originalEvent'] = event;
    }
    
    // set writeback flag that determines whether value is written back. 
    switch (validationContext)
    {
      // value is written back outside of normal UI interaction in the following cases.
      case this._VALIDATION_CONTEXT.CONVERTER_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.DISABLED_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.READONLY_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.REFRESH_METHOD:
      case this._VALIDATION_CONTEXT.REQUIRED_OPTION_CHANGE:
      case this._VALIDATION_CONTEXT.VALIDATE_METHOD:
      case this._VALIDATION_CONTEXT.VALIDATORS_OPTION_CHANGE:
        // when the above options change or methods are called, and full validation is run the 
        // current display value is parsed, and set on the value option if all validations pass. 
        // When the value option changes directly - either programmatically or user changes it, we 
        // end up clearing all 3 messages options.
        // But when value changes indirectly as a result of the above cases, then we decided not to 
        // clear custom messages. So a special flag is set so _AfterSetOptionValue can do the right 
        // thing. Component messages are already cleared when this method is called.
        shouldWriteback = true;
        flags['_oj_doNotClearMessages'] = true;
        break;
        
    }
    flags['shouldWriteback'] = shouldWriteback;
    this.option(values, flags);
  },

  
  /**
   * Update valid flag based on current value of the messages option.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _updateValid : function ()
  {
    var msgs = this._getMessages(), hasMessages;
    // When new messages are written update valid
    hasMessages = msgs && msgs.length !== 0;
    this._valid = true;
    if (hasMessages)
    {
      this._valid = !this._hasInvalidMessages();
    }
  },
  
  /**
   * Called after value option has changed, from option/_setOption() methods. The value option 
   * changes only in the following cases: <br/>
   * 
   * - programmatic updates using component option() method (called directly or from binding)<br/>
   * - user updates as a result of UI interaction
   * @param {Object=} previous
   * @param {Object=} flags
   * @private
   * @instance
   * @memberof oj.editableValue
   */ 
  _valueOptionChanged : function (previous, flags)
  {
    var newValue = this.options['value'], shouldTriggerOptionChange = false, 
            shouldWriteback = false, originalEvent;
    
    if (flags)
    {
      // 'changed' set to true when Knockout already knows that the option values changed. 
      // in such cases skip comparing values.
      shouldTriggerOptionChange = flags['changed'] || false;
      // _oj_originalEvent specifies the dom event that triggered the change
      originalEvent = flags['_oj_originalEvent'] || null;
      // we writeback if callers set this flag or if a dom event triggered this change.
      shouldWriteback = flags['shouldWriteback'] || originalEvent ? true : false;
    }
    
    // optionChange event is triggered when value is different from previous, except
    // when explicitly asked to skip comparing values (1).
    // 
    // (1) 'changed' flag tells us the value has changed, don't bother comparing values. This is 
    // the case when ko observalue mutates or option is mutated directly.
    if (shouldTriggerOptionChange || !this._ValueEquals(previous, newValue))
    {
      this._TriggerOptionChange('value', previous, shouldWriteback, originalEvent);
    }
  },
         
  
  /**
   * Formats the value for display, based on the converter options. If no converter is set then 
   * returns the value as is.
   * 
   * @param {string} value value to be formatted
   * 
   * @return {string} formatted value
   * @throws {Error} when an error occurs during formatting
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _formatValue : function (value)
  {
    var formattedValue = value, converter = this._GetConverter();
    
    // don't clear messages here because we clear messages only when direct user interaction with 
    // component changes value. All other usecases we expect page authors to clear messages.

    if (converter)
    {
      // TODO: We should support chaining converters but for now we use just the first converter 
      // to parse.

      // Check if we have a converter instance
      if (typeof converter === "object") 
      {
        if (converter['format'] && typeof converter['format'] === "function")
        {
          formattedValue = converter['format'](value);
        }
        else
        {
          if (oj.Logger.level > oj.Logger.LEVEL_WARN)
          {
            oj.Logger.info("converter does not support the format method.");
          }
        }
      }
    }
    
    return formattedValue;
  },
  
  /**
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getComponentMessaging : function ()
  {
    if (!this._componentMessaging)
    {
      this._componentMessaging = new oj.ComponentMessaging(this);
    }
    
    return this._componentMessaging;
  },
  

  /**
   * Returns an array of validator hints.
   * @param {Array} allValidators
   * @private
   * @memberof oj.editableValue
   * @instance
   */        
  _getHintsForAllValidators : function(allValidators)
  {
    var validator, validatorHints = [], vHint = "", i;
    if (this._IsRequired())
    {
      // get the hint for the default required validator and push into array if it's not already 
      // present in the validators array
      validator = this._getImplicitRequiredValidator();
      if (validator['getHint'] && typeof validator['getHint'] === "function")
      {
        vHint = validator['getHint']();
        if (vHint)
        {
          validatorHints.push(vHint);
        }
      }
    }

    // loop through all remaining validators to gather hints
    for (i = 0; i < allValidators.length; i++)
    {
      validator = allValidators[i], vHint = "";
      if (typeof validator === "object") 
      {
        if (validator['getHint'] && typeof validator['getHint'] === "function")
        {
          vHint = validator['getHint']();
          if (vHint)
          {
            validatorHints.push(vHint);
          }
        }
      }
    }

    return validatorHints;
  },
  
  /**
   * Returns the required validator instance or creates it if needed and caches it.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getImplicitRequiredValidator : function ()
  {
    var vf, reqTrans = {}, reqValOptions;
    
    if (this._implicitReqValidator == null) // falsey check
    {
      reqTrans = 
            this.options['translations'] ? this.options['translations']['required'] || {} : {} ;

      // TODO: cache required validator; purged when its options change, i.e., translations or label 
      // DOM changes
      reqValOptions = {
        'hint': reqTrans['hint'] || null,
        'label': this._getLabelText(), 
        'messageSummary': reqTrans['messageSummary'] || null,
        'messageDetail': reqTrans['messageDetail'] || null
      };

      vf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED);
      this._implicitReqValidator = vf ? vf.createValidator(reqValOptions) : null;
    }
    
    return this._implicitReqValidator;
  },

  
  /**
   * Returns content that will be used by messaging strategies.
   * 
   * @param {number} updateType of messaging content to update. Accepted values are defined by 
   * this._MESSAGING_CONTENT_UPDATE_TYPE.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _getMessagingContent : function (updateType)
  {
    var messagingContent = {}, converter = this._GetConverter(), converterHint, allValidators, 
            validatorHints = [], messages;
    updateType = updateType || this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE;
    
    // Add validityState which includes messages, valid and severity
    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE)
    {
      messages = this._getMessages();
      
      // update validityState before packaging it
      this._getValidityState().update(this.isValid(), messages);
      messagingContent['validityState'] = this._getValidityState();
    }
    
    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT)
    {
      if (converter)
      {
        if (typeof converter === "object") 
        {
          if (converter['getHint'] && typeof converter['getHint'] === "function")
          {
            converterHint = converter['getHint']() || "";
            messagingContent['converterHint'] = converterHint;
          }
        }
      }
    }
    
    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS)
    {
      allValidators = this._GetAllValidators();
      validatorHints = this._getHintsForAllValidators(allValidators) || [];
      messagingContent['validatorHint'] = validatorHints;
    }
    
    if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE)
    {
      messagingContent['title'] = this.options['title'] || "";
    }
    
    return messagingContent;
  },
  
  /**
   * Compares the messages arrays for equality.
   * 
   * @param {Array} pm previous messages
   * @param {Array} m new messages
   * @returns {boolean} true if equal false otherwise
   * @private
   * @memberof oj.editableValue
   * @instance
   * 
   */
  _messagesEquals : function (pm, m)
  {
    var match = -1, pmo, passed = true, previousMsgs = $.extend([], pm), msgs = $.extend([], m);
    if (previousMsgs === msgs) return true;
    if (previousMsgs == null || msgs == null) 
    {
      return false;
    }
    
    if (previousMsgs.length !== msgs.length)
    {
      return false;
    }
    
    $.each(previousMsgs, function (i, pMsg) 
    {
      if (!(pMsg instanceof oj.Message))
      {
        // freeze message instance once its created
        pmo = new oj.Message(pMsg['summary'], pMsg['detail'], pMsg['severity']);
        pmo = Object.freeze ? Object.freeze(pmo) : pmo;
      }
      else
      {
        pmo = pMsg;
      }
      
      match = -1;
      $.each(msgs, function(j, msg) {
        {
          if (pmo.equals(msg))
          {
            match = j;
            return; // found a match, so break out of loop
          }
        }
      });
      
      // remove entry at 'match' index from msgs
      if (match > -1)
      {
        msgs.splice(match, 1);
      }
      else
      {
        // we found no match so no need to loop
        passed = false;
        return;
      }
    });
    
    return passed;
  },
  
  /**
   * Parses the value using the converter set and returns the parsed value. If parsing fails the 
   * error is written into the element 
   * 
   * @param {string=} submittedValue to parse
   * @return {Object} parsed value 
   * @throws {Error} an Object with message
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _parseValue: function(submittedValue) 
  {
    var converter = this._GetConverter(), parsedValue = submittedValue;
    
    if (converter)
    {
      // TODO: We should support chaining converters but for now we use just the first converter 
      // to parse.

      if (typeof converter === "object") 
      {
        if (converter['parse'] && typeof converter['parse'] === "function")
        {
          // we are dealing with a converter instance
          parsedValue = converter['parse'](submittedValue);
        }
        else
        {
          if (oj.Logger.level > oj.Logger.LEVEL_WARN)
          {
            oj.Logger.info("converter does not support the parse method.");
          }
        }
      }
    }
    
    return parsedValue;
  },

  _addValidationError : function(e, msgs)
  {
    var ojmessage, summary, detail, severity;
    if (e instanceof oj.ConverterError || e instanceof oj.ValidatorError)
    {
      ojmessage = e.getMessage();
      oj.Assert.assertPrototype(ojmessage, oj.Message);

      severity = ojmessage['severity'];
      summary = ojmessage['summary'];
      detail = ojmessage['detail'];
    }
    else
    {
      // TODO: is this error message generic enough to use for both converter and validator errors?
      severity = oj.Message.SEVERITY_LEVEL['ERROR'];
      summary = oj.Translations.getTranslatedString("oj-message.error");
      detail = e['message'] || oj.Translations.getTranslatedString("oj-converter.detail");
    }
    
    msgs.push({summary: summary, detail: detail, severity: severity});
  },

  /**
   * Processes the error information for one or more errors and returns an Array of 
   * oj.ComponentMessage instances.
   * 
   * @param {Error} e instance of Error
   * @param {number=} context the context in which the validation error was thrown
   * @param {String=} display whether message is shown or hidden
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _processValidationErrors : function (e, context, display)
  {
    var msg, options = {}, componentMsgs = [], msgs = e._messages || [];
    
    options['context'] = context || 0;
    options['display'] = display || oj.ComponentMessage.DISPLAY.SHOWN;
    
    if (msgs.length === 0)
    {
      this._addValidationError(e, msgs);
    }
    
    for (var i = 0; i < msgs.length; i++)
    {
      msg = msgs[i];
      componentMsgs.push(this._createComponentMessage(msg.summary, msg.detail, msg.severity, options));
    }
    
    return componentMsgs || null;
  },
  
  _createComponentMessage : function (summary, detail, severity, options)
  {
    var cMsg;
    // new properties can't be added but existing properties can be changed
    cMsg = new oj.ComponentMessage(summary, detail, severity, options);
    cMsg = Object.seal ? Object.seal(cMsg) : cMsg;
    return cMsg;
  },
          
  /**
   * Refreshes the component display value, only when the current value is different from the last 
   * saved value, unless asked to always refresh the display value.
   * 
   * @param {Object|undefined} value the changed value that needs to be updated on UI
   * @param {boolean=} fullRefresh false is the default; true means always refresh component 
   * display value using the current option value. This overwrites any UI value, the user may have 
   * entered.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */        
  _refreshComponentDisplayValue : function (value, fullRefresh)
  {
    var modelValue = value || this.options['value'], lastModelValue, shouldUpdateElementValue;
    
    lastModelValue = this._getLastModelValue();
    shouldUpdateElementValue = fullRefresh || (modelValue !== lastModelValue) || false;

    if (shouldUpdateElementValue)
    {
      this._updateElementDisplayValue(modelValue);
    }
  },


  /**
   * Toggles css selector on the widget. E.g., when required option changes, the oj-required 
   * selector needs to be toggled.
   * @param {string} option
   * @param {Object|string} value 
   * @private
   * @memberof oj.editableValue
   * @instance
   */        
  _refreshTheming : function (option, value)
  {
    if (Object.keys(this._OPTION_TO_CSS_MAPPING).indexOf(option) != -1) 
    {
      this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], !!value);
    }
  },
 
  /**
   * Runs validators in deferred mode using the option value. Any validation error thrown is 
   * deferred, or hidden by component, until explicitly asked to show them (see showMessages()). 
   * Deferred error is pushed to <code class="prettyprint">messagesHidden</code> option.
   * 
   * @param {number} context in which validation was run. 
   * 
   * @see #showMessages
   * @private 
   * @memberof oj.editableValue
   * @instance
   */
  _runDeferredValidation : function (context) 
  {
    var newValue, newMsg;
    
    if (this._CanSetValue())
    {
      try
      {
        // TODO: Today required is the only validator that runs deferred. We need a generic way to 
        // retrieve deferred validators. 
        newValue = this._validateValue(this.options['value'], 
                      this._VALIDATION_MODE.REQUIRED_VALIDATOR_ONLY);
      }
      catch (ve)
      {
        newMsg = this._processValidationErrors(ve, context, oj.ComponentMessage.DISPLAY.HIDDEN);
        if (newMsg)
        {
          this._updateMessagesHiddenOption(newMsg);          
        }
      }
    }
    else
    {
      if (oj.Logger.level > oj.Logger.LEVEL_WARN)
      {
        oj.Logger.info("Deferred validation skipped as component is readonly or disabled.");
      }
    }
  },
  
    
  /**
   * Run deferred validation as a last step after component is created. Also component was 
   * initialized with messagesCustom then trigger optionChange for messagesShown.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _runDeferredValidationAfterCreate : function () 
  {
    this._runDeferredValidation(this._VALIDATION_CONTEXT.COMPONENT_CREATE);
    
    if (this.options['messagesShown'].length > 0)
    {
      this._messagesShownOptionChanged([], {'changed': true});
    }
  },
 
    
  /**
   * Runs validation based on the mode settings. 
   * 
   * @param {Object} value to parse and/or validate
   * @param {number=} mode determines how validation is run. see _VALIDATION_MODE
   * @param {number=} context determines when validation is being run.
   * @param {Event=} event the original event or undefined
   * 
   * @return {Object|string} parsed value
   * @throws {Error} when validation fails.
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _runNormalValidation : function (value, mode, context, event) 
  {
    var newValue = value, newMsg;

    // callers of this function should clear messages 
    try
    {
      // Step 1: only when "full" validation is requested converters get run
      if (mode === this._VALIDATION_MODE.FULL)
      {
        // Step1: Parse value using converter
        newValue = this._parseValue(value);
      }

      // Step 2: Run validators
      this._validateValue(newValue, mode === this._VALIDATION_MODE.REQUIRED_VALIDATOR_ONLY);
    }
    catch (ve)
    {
      newMsg = this._processValidationErrors(ve, context);
      this._updateMessagesShownOption (newMsg, event);
      throw ve;
    }
    
    return newValue;
  },
  
  /**
   * Runs either deferred or normal validation based on the state component is in. This method is 
   * called when certain options change - required, disabled etc.
   * 
   * <p>
   * - if component is invalid and has messgesShown -> required: false/true -> clear component errors; 
   * run full validation with UI value (we don't know if the UI error is from a required validator 
   * or something else);<br/>
   * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is 
   * updated<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to 
   * listen to optionChange(value) to clear custom errors.<br/>
   * 
   * - if component is invalid and has messagesHidden -> required: false -> clear component 
   * errors; no deferred validation is run.<br/>
   * - if component has no error -> required: true -> run deferred validation (we don't want to flag 
   * errors unnecessarily)<br/>
   * - messagesCustom is never cleared<br/>
   * </p>
   * 
   * @param {Object} validationOptions
   * 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _runMixedValidationAfterSetOption : function (validationOptions)
  {
    var runDeferredValidation = true;
    
    if (this._hasInvalidMessagesShowing())
    {
      runDeferredValidation = false;
    }

    // clear component messages always
    this._clearComponentMessages();
    if (!runDeferredValidation)
    {
      // run full validation using the current display value; 
      // show messages immediately if there are errors otherwise set value to option
      this._updateValue(validationOptions);
    }
    else
    {
      // run deferred validation if comp is either showing a deferred error or has no errors. 
      // But only when required is true. 
      if (this._IsRequired())
      {
        this._runDeferredValidation(validationOptions.validationContext);
      }
    }
  },
    
  
  _updateElementDisplayValue : function (modelValue, event)
  {
    var displayValue, newMsg;
    // cache the new model value on the element 
    this._setLastModelValue(modelValue);

    // Update element with the displayValue
    displayValue = modelValue;

    try
    {
      displayValue = this._formatValue(modelValue);
    }
    catch (e)
    {
      newMsg = this._processValidationErrors(e);
      this._updateMessagesShownOption (newMsg, event);
    }
    
    this._SetDisplayValue(displayValue); 
    this._setLastSubmittedValue(this._GetDisplayValue());
  },
  
    
  /**
   * Runs normal validation when certain options change - converter, required, validators etc. - and 
   * updates (re-sets) the value if no new errors are found. This is different from _SetValue()
   * which is called when end-user changes the value as a result of interacting with the component. 
   * Additionally _SetValue() clears all messages always, whereas callers of this method determine 
   * which messages they want cleared.
   * 
   * @param {Object} options - name value properties used when validation is run. 
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _updateValue : function (options)
  {
    var newValue;
    
    // run full validation using the current display value; 
    // show messages immediately if there are errors otherwise set value to option
    newValue = this._Validate(this._GetDisplayValue(), null, options);

    // if validation was a success and component is valid, or it's invalid with no new component 
    // messages then update value option. 
    // NOTE: often custom msgs are not cleared when this method is called.
    if (newValue !== undefined && 
        (this.isValid() || !this._hasInvalidComponentMessagesShowing()))
    {
      this._updateValueOption(newValue, null, options.validationContext);
    }
  }, 
  
  /**
   * Validates the value by running through the list of regsitered validators. The algorithm is as 
   * follows -
   * 1. check to see if we are currently valid, if not return
   * 2. run required check. 
   * 3. if value is not empty get all the validators and validate in sequence. 
   * 4. if all validators pass return.
   * 
   * Callers can rely on the 'valid' options property to determine the validity state of the 
   * component after calling this method
   * 
   * @param {Object|string} value to be validated
   * @param {boolean} requiredOnly true only runs required validation
   * @throws {Error} when validation fails.
   * @private
   * @memberof oj.editableValue
   * @instance
   */
  _validateValue : function (value, requiredOnly)
  {
    var allValidators = this._GetAllValidators(), validator, i, valMsgs = [];

    // run required validation first; 
    if (this._IsRequired())
    {
      validator = this._getImplicitRequiredValidator();
      try
      {
        // check if trimmed value is empty. See AdfUIEditableValue.prototype.ValidateValue
        validator.validate(oj.StringUtils.trim(value));
      }
      catch (e)
      {
        // save all validation errors
        this._addValidationError(e, valMsgs);
      }
    }
      
    // run other validators when requested. 
    // latest review - we want to do exactly as ADF does and it validates empty field values by 
    // default. The condition always resolves to true in JET!
    if (!requiredOnly) // && (!isEmptyValue || this._shouldValidateEmptyFields()))
    {
      for (i = 0; i < allValidators.length; i++)
      {
        validator = allValidators[i];
        if (typeof validator === "object") 
        {
          if (validator['validate'] && typeof validator['validate'] === "function")
          {
            try
            {
              validator['validate'](value);
            }
            catch (e)
            {
              // save all validation errors
              this._addValidationError(e, valMsgs);
            }              
          }
          else
          {
            if (oj.Logger.level > oj.Logger.LEVEL_WARN)
            {
              oj.Logger.info("validator does not support the validate method.");
            }
          }
        }
      }
    }

    // throw error if there were validation failures
    if (valMsgs.length > 0)
    {
      var ve = new Error();
      ve._messages = valMsgs;
      throw ve;
    }
  }
 
});

oj.Components.setDefaultOptions(
  {
    'editableValue': // properties for all editableValue components 
    {
      'displayOptions': oj.Components.createDynamicPropertyGetter(
        function(context) 
        {
          // var inTable = context['containers'].indexOf('ojTable') >= 0;
          return  {
                    'messages': ['notewindow'], 
                    'converterHint': ['placeholder', 'notewindow'], 
                    'validatorHint': ['notewindow'], 
                    'title': ['notewindow']
                  };
        }
      )
    }
  }
);

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
/*!
 * JET Label This component is private. @VERSION
 */
/**
 * The _ojLabel component is a private component. It is not meant to be used
 * on a label element directly. Instead EditableValue components 
 * use the _ojLabel component in the internal implementation. 
 * <p>
 * The _ojLabel component decorates the input component's label with
 * extra dom for the required icon and help information (help
 * icon, help description, and help external url). If oj-label* styles are on
 * the label element, then the _ojLabel element will move them onto its root
 * dom element.
 * <p>
 * Screen readers need to know that the input is associated with the help and required icons.
 * We do this by rendering on the input an aria-describedby id 
 * (see EditableValue#_ariaDescribedByHelpIconWrapper) and passing this id into ojLabel as the
 * describedById option, which gets rendered on the span wrapping the help and required icons.
 * &lt;span id="someConstructedByEditableValueDescribedById"&gt;help icon, required icon&lt;/span&gt;...
 * &lt;input aria-describedby="someConstructedByEditableValueDescribedById"...&gt;
 * EditableValue gets the id of the input, creates an sub-id from it, sets aria-describedby on
 * the input with this sub-id. then it passes this sub-id into ojLabel with the describedById option.
 *  will make sure the help and required icons are accessible by
 *    * If there is help source (an external URL), then construct an
   * id from the element's id, render aria-describedby with this id, and then
   * return the id to be used by the ojLabel.
 * </p>
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * <p>You can hover over the help and the required icons for additional information. 
 * You can also hover over the label to see the help definition text if there is some. 
 * </p>
 * @class
 * @private
 * @constructor
 * @name oj._ojLabel
 * @augments oj.baseComponent
 */
oj.__registerWidget("oj._ojLabel", $['oj']['baseComponent'],
{
  version : "1.0.0",  
  defaultElement : "<label>", 
  widgetEventPrefix : "oj", 
  options : 
  {
    /** 
     * describedById is a required option if there is help or required icons (help source is set
     * or required is true).
     * This is needed for accessibility so that the screenreader
     * knows that the help and required icons are related to the input. The describedById
     * is rendered on the icon wrapper dom as its id. EditableValue takes care of rendering the 
     * aria-describedby property on the input, and passing in this property value to its ojLabel 
     * on creation. E.g., if describedById is 'foo', then something like this will render: 
     * &lt;span id=foo&gt;help/required icons&lt;/span&gt;...
     * &lt;input aria-describedby="foo" .../&gt;
     * @expose 
     * @public
     * @instance
     * @memberof oj._ojLabel
     */
    describedById: null,
    /**
     * The help information that goes on the label.  The help options are:
     * <ul>
     * <li>definition - this is the help definition text. It is what shows up
     * when the user hovers over the label or the help icon.</li>
     * <li>source - this is the help source url. If present, a help icon will
     * render next to the label and the anchor's target is this source.
     * </ul>
     * 
     * @expose 
     * @memberof oj._ojLabel
     * @instance
     * @type {Object.<string, string>}
     * @default <code class="prettyprint">{help : {definition' :null, source: null}}</code>
     * 
     * @example <caption>Initialize the label with the help definition and external url information:</caption>
     * $( ".selector" )._ojLabel({ help: {definition:"some help definition", source:"some external url" } });
     * 
     * @example <caption>Set the <code class="prettyprint">help</code> option, after initialization:</caption>
     *
     * // setter
     * $( ".selector" )._ojLabel( "option", "help", {definition:"fill out the name", source:"http:\\www.oracle.com" } );
     */
    help: 
    {
   /**
     * <p>help definition text.  See the top-level <code class="prettyprint">help</code> option for details.
     * 
     * @expose
     * @alias help.definition
     * @memberof! oj._ojLabel
     * @instance
     * @type {?string|undefined}
     * @default <code class="prettyprint">{help : {definition :null, source: null}}</code>
     * 
     * @example <caption>Get or set the <code class="prettyprint">help.definition</code> sub-option, after initialization:</caption>
     * // getter
     * var definitionText = $( ".selector" )._ojLabel( "option", "help.definition" );
     * 
     * // setter:
     * $( ".selector" )._ojLabel( "option", "help.definition", "Enter your name" );
     */     
      definition: undefined, 
    /**
     * <p>help source url.  See the top-level <code class="prettyprint">help</code> option for details.
     * 
     * @expose
     * @alias help.source
     * @memberof! oj._ojLabel
     * @instance
     * @type {?string|undefined}
     * @default <code class="prettyprint">null</code>
     * 
     * @example <caption>Get or set the <code class="prettyprint">help.source</code> sub-option, after initialization:</caption>
     * // getter
     * var helpSource = $( ".selector" )._ojLabel( "option", "help.source" );
     * 
     * // setter:
     * $( ".selector" )._ojLabel( "option", "help.source", "www.abc.com" );
     */      
      source: undefined
 
    },
    /** 
     * Whether this label should have a required icon.  Allowed values for 
     * required are 'true' and 'false', 'false' being the default.
     * @expose 
     * @public
     * @instance
     * @memberof oj._ojLabel
     */
    required: null,
    /**
     * Allows you to set certain attributes on the root dom element.
     * For _ojLabel, we use 'class' only. The input components (via
     * EditableValue) set a styleclass on the _ojLabel's root in case
     * component-specific label styling is needed. For example, ojradioset
     * would pass class: 'oj-radioset-label'. ojinputtext would pass class:
     * 'oj-inputtext-label'. 
     *
     * @example <caption>Initialize root dom element with the set of 
     * <code class="prettyprint">rootAttributes</code>:</caption>
     * $(".selector")._ojLabel("option", "rootAttributes", {
     *   'class': 'oj-inputtext-label'
     * });
     * 
     * @expose
     * @access public
     * @memberof oj._ojLabel
     * @instance
     * @type {Object|undefined}
     * @default <code class="prettyprint">{ id: null, class: null, style:null }</code>
     */
     rootAttributes: undefined
  },
 /**
  * @private
  * @const
  */
  _BUNDLE_KEY:
  {
    _TOOLTIP_HELP:      'tooltipHelp',
    _TOOLTIP_REQUIRED:  'tooltipRequired'    
  },
  /**** start Public APIs ****/
   
  /**
   * Returns a jQuery object containing the root dom element of the label 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof oj._ojLabel
   * @instance
   * @return {jQuery} the label
  */
  widget : function ()
  {
    return this.uiLabel;
  },
  /**
   * Refreshes the required and help dom.
   * @example <caption>Clear messages and refresh component.</caption>
   * $(selector).ojInputText("option", "messages", []); <br/>
   * $(selector).ojInputText("refresh");
   * component 
   * @access public
   * @instance
   * @expose
   * @memberof oj._ojLabel
   */
  refresh : function ()
  {
    this._super();
    this._refreshRequired();
    this._refreshHelp();
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/  
    /**
   * Overridden to make sure describedById option is set
   * 
   * @memberof oj._ojLabel
   * @instance
   * @protected
   */  
  _InitOptions : function (originalDefaults, constructorOptions)
  {
    this._super(originalDefaults, constructorOptions);
    this._checkDescribedByIdOption();
  },
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @instance
   * @memberof oj._ojLabel
   */
  _ComponentCreate: function()
  {
    this._super();
    this._drawOnCreate();
  },
  /**
   * set up styles on create
   * @private
   */
  _drawOnCreate : function ()
  {
    // we put a span with an id on it around the help and required icons so that
    // the input's aria-describedby can point to it. Then the screen reader will
    // read the title on the images when focus is on the input, so the user knows
    // that there is help and required icons.
    var needsDescribedBySpan = this.options.help['source'] || this.options.required;  
    var describedByDom = null;
                             
    // wrap the label with a root dom element (oj-label) and its child 
    // (oj-label-group). Then point this.uiLabel to the root dom element.
    this.uiLabel = this.element.wrap(this._uiLabelWrapperHtml())
                               .closest(".oj-component");
                                                                     
    // move an oj-label styles off of this.element, and put on the 
    // root dom element. They are restored in _destroy
    this._moveClassesToRoot();
    
    if (needsDescribedBySpan)
    {
      describedByDom = this._createDescribedBySpan();
    }

    // now add help and required inside of this dom
    if (this.options.help['definition'] || this.options.help['source'])
    { 
      this._insertHelpHtml(describedByDom);
      this._addHelpDefToLabel();
    }

    if (this.options.required)
    {
      // Add or remove 'required' dom.
      // required. should go right before the label.
      //this.element.before(this._requiredHtml());
      describedByDom.append(this._requiredHtml());    
    }

   },
  /**
   * @throws error if label's describedById option is not set if required or help source is set
   * @private
   */
  _checkDescribedByIdOption : function ()
  {
    var needsDescribedBySpan = this.options.help['source'] || this.options.required;
    if (needsDescribedBySpan && this.options['describedById'] == null)
    {
      throw new Error("ojLabel's describedById option must be set if required or help source is set.");
    }
  },
   /**
   * move oj-label* classes from label element onto the root dom element
   * @private
   */
  _moveClassesToRoot : function ()
  {

    var classes = this.element.attr("class"), arrayOfClasses, numClasses;
    
    if (classes)
    {
      arrayOfClasses = classes.split(/\s+/);
      if (arrayOfClasses != null)
        numClasses = arrayOfClasses.length;
      else
        return;
      
      for (var i=0; i < numClasses; i++)
      {
        var className = arrayOfClasses[i];
        // if class name has -label- in it, then move it
        // (e.g., oj-label, oj-label-inline, oj-md-label-nowrap, 
        // oj-md-labels-inline)
        if (className.indexOf("-label") > 0)
        {
          this.uiLabel.addClass(className); 
          this.element.removeClass(className);
        }
      }
    }
  },
  /**
   * create and return the span with an id that we'll use to put in the help and required icons.
   * @private
   */
  _createDescribedBySpan : function ()
  {
    var ojLabelGroupDom = this.uiLabel.find(".oj-label-group");
    var describedBySpan = 
        $( "<span></span>", this.document[0] );
    describedBySpan.attr("id", this.options.describedById);
    return ojLabelGroupDom.prepend(describedBySpan).children().first();
  },
  /**
   * return the html string for the root dom element
   * @private
   */
  _uiLabelWrapperHtml : function ()
  {
    var rootAttributes = this.options.rootAttributes;
    var inputLabelClass;
    
    if (rootAttributes)
    {
      inputLabelClass = this.options.rootAttributes['class'];
    }
    
    if (inputLabelClass !== null)
    {
      return "<div class='oj-label oj-component " + inputLabelClass + 
              "'><div class='oj-label-group'></div></div>";
    }
    else
    {
      return "<div class='oj-label oj-component'><div class='oj-label-group'></div></div>";
    }
  },
  /** 
   * return the html string for the span with oj-label-required-icon
   * @private
   */
  _requiredHtml : function ()
  {
    var required = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_REQUIRED);
    return "<span class='oj-label-required-icon oj-component-icon' title='" 
            + required + "' role='img'></span>";
  },
  /** 
   * return the html string of the span and its help information.
   * if (source), show help icon
   * if (helpDef), add 'title'=helpDef on help icon.
   * @private
   */
  _helpHtml : function (helpDef, source)
  {
    var sourceLink, helpIconSpan;
    // construct the help html
    // if source (external url), then render a clickable help icon
    // if helpDef, then render oj-label-help-def style class on the label
    if (source)
    {
      sourceLink = 
        $( "<a target='_blank' class='oj-label-help-icon-anchor'></a>", this.document[0] );
      sourceLink.attr("href", source);
      helpIconSpan = 
        $( "<span class='oj-label-help-icon oj-component-icon oj-clickable-icon' role='img'></span>", 
        this.document[0] );
      if (helpDef)
        helpIconSpan.attr("title", helpDef);
      else
        helpIconSpan.attr("title", this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_HELP));
        
      sourceLink.append(helpIconSpan);
    }
    return sourceLink;
  },
   /** 
   * Add help definition information to the label element.
   * @private
   */
  _addHelpDefToLabel : function ()
  {
    var helpDef = this.options.help['definition'], title;
    if (helpDef)
    {
      // add oj-label-help-def styleclass to the label.
      // add title to the label.
      this.element.addClass("oj-label-help-def");
      // append helpDef to title. We concatenate in case label already has
      // title set. Usually the app dev will use title OR helpDef, not both.
      title = this.element.attr("title");
      if (title)
        this.element.attr("title", title + ' ' + helpDef);
      else
        this.element.attr("title", helpDef);
      
    }
  },
     /** 
   * Remove help definition information from the label element.
   * @private
   */
  _removeHelpDefToLabel : function ()
  {
      this.element.removeClass("oj-label-help-def");
      this.element.attr("title", "");
  },
  /** 
   * finds the oj-label-group dom node and prepends the help html to it.
   * @private
   */
  _insertHelpHtml : function (describedByDom)
  {
    var helpSource = this.options.help['source'], helpDef;
    if (helpSource)
    {
      // .prepend Insert content, specified by the parameter, to the beginning of each element
      helpDef = this.options.help['definition'];
      describedByDom.prepend(
        this._helpHtml(helpDef, 
                       helpSource));
    }                     
  },
  /** 
   * refresh the help dom --
   * find the help root dom node and remove it if it is there 
   * and add back the help html. Helpful if a help option changed.
   * @private
   */  
  _refreshHelp : function ()
  {
    var describedById, helpIconSpan, needsDescribedBySpan, describedBySpan;
    
    this._checkDescribedByIdOption();
    
    describedById = "#" + this.options.describedById;
    
    // remove the style off of label dom.
    this._removeHelpDefToLabel();
    
    // now remove the help info if it is there.
    helpIconSpan = this.uiLabel.find(".oj-label-help-icon");
    if(helpIconSpan.length === 1)
    {
      // remove the <a> around the icon and the icon.
      helpIconSpan.parent().remove(); 
    }
    needsDescribedBySpan = this.options.help['source'];

    // insert describedBySpan if it isn't there AND it is needed
    describedBySpan = this.uiLabel.find(describedById);
    if (needsDescribedBySpan != null && describedBySpan.length === 0)
    {
      // no describedBySpan, so we need to create one
      describedBySpan = this._createDescribedBySpan();
    }
    else if (needsDescribedBySpan == null && describedBySpan.length > 0)
    {
      // remove the span  IF it doesn't have any children.
      if (describedBySpan.children().size() === 0)
        describedBySpan.remove();
    }
    // now insert back if needed
    this._insertHelpHtml(describedBySpan);
    this._addHelpDefToLabel();
  },
  /** 
   * refresh the required dom --
   * if required is true, then add the required dom if it isn't already there
   * if required is false, remove the required dom if it is there.
   * Helpful if the required option changed.
   * @private
   */   
  _refreshRequired : function ()
  {
    var describedById, describedBySpan;
    
    describedById = "#" + this.options.describedById;
    if (this.options.required)
    {
      this._checkDescribedByIdOption();

      if (this.uiLabel.find(".oj-label-required-icon").length === 0)
      {
        // required, and required isn't already rendered     
        describedBySpan = this.uiLabel.find(describedById);
        if (describedBySpan.length === 0)
        {
          // no describedBySpan, so we need to create one
          describedBySpan = this._createDescribedBySpan();
        }
        describedBySpan.append(this._requiredHtml());
      }
    }
    else 
    {
      // not required, so find dom node with oj-label-required-icon on it.
      // Remove it. If it is the only child of the parent, remove the parent as well.
      this.uiLabel.find(".oj-label-required-icon").remove();
      // if describedBySpan exists, and it has no children anymore, remove it.
      describedBySpan = this.uiLabel.find(describedById);
      if (describedBySpan.length > 0)
      {
        if (describedBySpan.children().size() === 0)
          describedBySpan.remove();
      }    
    }
  },
  /**
   * Note that _setOption does not get called during create. it only gets called
   * when the component has already been created.
   * @override
   * @protected
   * @memberof oj._ojLabel
   * @instance
   */
  _setOption : function (key, value)
  {
    this._superApply(arguments);

    if (key === "required")
    {
      this._refreshRequired();
    }

    // if user changed the help definition or source, then update the UI.
    // Find the help dom first. If it exists, replace it with new dom.
    // if it doesn't exist, add it.
     if (key === "help")
    {
      this._refreshHelp();
    }
  }, 
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-label-help-icon</b>: the label's help icon</li>
   * <li><b>oj-label-help-icon-anchor</b>: the anchor tag of the help icon</li>
   * <li><b>oj-label-required-icon</b>: the label's required icon</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof oj._ojLabel
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    var node, subId;
    
    node = this._super(locator);
    if (!node)
    {
      subId = locator['subId'];
      if (subId === "oj-label-help-icon") {
        node = this.widget().find(".oj-label-help-icon")[0];
      }
      if (subId === "oj-label-help-icon-anchor") {
        node = this.widget().find(".oj-label-help-icon").parent()[0];
      }
      if (subId === "oj-label-required-icon") {
        node = this.widget().find(".oj-label-required-icon")[0];
      }
    }    
    // Non-null locators have to be handled by the component subclasses
    return node || null;
  },  
  /**
   * 
   * @override
   * @protected
   * @memberof oj._ojLabel
   * @instance
   */
  _destroy : function ()
  { 
    this.uiLabel.replaceWith(this.element);
    this._RestoreAttributes(); //remove when _RestoreAttributes is uncommented from jqueryui-base

    return this._super();
  }
  
  /**** end internal widget functions ****/ 
  
   /**
   * Removes the label functionality completely. 
   * This will return the element back to its pre-init state.
   * 
   * <p>This method does not accept any arguments.
   * 
   * @method
   * @name oj._ojLabel#destroy
   * @memberof oj._ojLabel
   * @instance
   * 
   * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
   * $( ".selector" )._ojLabel( "destroy" );
   */
});
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class JET Editable Component Utils
 * @export
 * @since 0.6
 * 
 */
oj.EditableValueUtils = {};

/**
 * This method is called during _InitOptions() to initialize a component option value from DOM. This 
 * uusally is the case when the option value is undefined, 
 * i.e., this.options.optionName === undefined.
 * <br/>
 * Returns the attribute value for the given attribute on the element appropriately converted, or 
 * the default, if the attribute isn't set on the element.<br/>
 * 
 * @param {Object} element the element the component is initialized with.
 * @param {string} attribute the name of the element's attribtue. Example, value, disabled etc.
 * 
 * @returns {Object} a JSON object containing the following properties - <br/>
 * <ul>
 * <li><b>fromDom</b> - whether the option value was initialized from DOM. When true the option's 
 * value is written back (to observable).</li> 
 * <li><b>value</b> - the option value. the attribute value or the default if the attribute isn't 
 * set on the element.</li> 
 * </ul>
 * 
 * @private
 */
oj.EditableValueUtils.getAttributeValue = function (element, attribute)
{
  var result, attrVal, propVal, returnVal = {}; 
  
  if (element && attribute)
  {
    switch (attribute)
    {
      case "disabled" :
        result = element.attr("disabled") !== undefined ? 
          !!element.prop("disabled") : undefined;
        break;
        
      case "pattern":
        result = element.prop("pattern") || undefined; 
        break; 
        
      case "placeholder":
        result = element.prop("placeholder") || undefined;
        break;
        
      case "readonly": 
        result = element.attr("readonly") !== undefined ? 
          !!element.prop("readonly") : undefined; 
        break;
      
      case "required":
        attrVal = element.attr("required");
        propVal = element.prop("required");

        // If attribute is present and not undefined
        //   - In IE9, required attribute is not supported at all, so attr() is defined, prop() is 
        //   undefined. In such cases set default to !!attrVal
        //   - Otherwise set to !!propVal
        // If neither attr is undefined then use defaultValue
        // TODO: review needed 
        result = (attrVal !== undefined) ? 
          ((propVal !== undefined) ? !!propVal : !!attrVal) : undefined;
        
        break;
      
      case "title":
        result = element.prop("title");
        break;
        
      case "value":
        // element attribute may not be set, in which case default to null
        result = element.val() || undefined;
        break;
      
      case "min": 
        //same logic for min + max as in default
      case "max":
      
      default: 
        result = element.attr(attribute) || undefined;
        break;
    }
  }
  
  if (result !== undefined)
  {
    returnVal.fromDom = true;
    returnVal.value = result;
  }
  else
  {
    returnVal.fromDom = false;
    // returnVal.value = defaultValue; 
  }
  return returnVal;
};

/**
 * Called from component._InitOptions(), when a component might need to initialize its options from 
 * DOM. This usually is done when the constructor option is undefined, even in the case where 
 * this.options.option has a value that comes from app defaults or component (original) default. 
 * See below for details.
 * <p>
 * IMPORTANT: Do not call this method after component has been created, since option values are 
 * mutated directly after that point.</p>
 * 
 * The 'final' value an option uses/initializes from, can come from these places (in order of least 
 * to most likely) - <br/>
 * <ol>
 * <li>component default - this is the widget default </li><br/>
 * <li>app default - this is what a page author defines for the value in the page/app</li> <br/>
 * <li>dom value - if your option also has a dom attribute, this is the value set on element for 
 * component. </li> <br/>
 * <li>constructor value - this is the value page author sets on the component binding </li><br/>
 * </ol>
 * 
 * At the time _InitOptions is called, (1), (2) and (4) are merged, but this may not be the value a 
 * component wants for the option, especially when (4) is undefined. For example, if these values 
 * were set for a component - <br/>
 * (1) - 'foo'<br/>
 * (2) - 'bar'<br/>
 * (3) - 'lucy'<br/>
 * (4) - undefined<br/>
 * <p>
 * at the time _InitOptions is called, this.options.option is set to 'bar', but because DOM value 
 * wins over app default or component default, component needs to check if the constructor value was 
 * undefined and if so, set option to 'lucy'. <br/>
 * If the dom value is not set, then the component provided default value - defaultOptionValue gets 
 * used. This method always defaults the value to be - this.options.option || defaultOptionValue -  
 * because we think if neither (3) nor (4) is set, then the value from (2) should win over the 
 * defaultOptionValue. <br/>
 * </p>
 * 
 * @param {Object} props an Object literal that a component provides with the following properties 
 * that helps determine the final value for one or more options.
 * 
 * @property {string} props.attribute - name of DOM attribute
 * @property {string|undefined} props.option - name of the option if different from attribute name.
 * @property {Object|null|string|number|boolean} props.defaultOptionValue - the default value to use
 * for the option when the DOM value is not set. For example, editable components bound to inputs, 
 * would pass false as the default for disabled option, while components like the *set components 
 * would pass null, because they support a tri-state.
 * 
 * @property {Function|boolean|undefined} props.coerceDomValue - if the DOM value is set and 
 * coercing the dom value is needed, then either set to boolean true, which uses the default 
 * coercion rules for common attributes (a), or provide a custom callback (b). <p>
 * E.g., 'value' option for input number, input date etc. have special rules for coercing the value,
 *  so thse provide a custom callback. For common attributes like required and disabled, set the 
 *  value to true so the default oj.EditableValueUtils#coerceDomValueForOption method gets used.
 *  
 * @property {Function|boolean|undefined} props.validateOption - if set to true, then it calls 
 * oj.EditableValueUtils.validateValueForOption method to validate the option. OTOH, components 
 * can pass a call 
 * 
 * @param {Object} constructorOptions the options set on the component instance, often using 
 * component binding.
 * @param {Object} comp component instance.
 * 
 *  
 * @public
 */
oj.EditableValueUtils.initializeOptionsFromDom = function (props, constructorOptions, comp)
{
  // Loop through props to initialize option 
  for (var i = 0; i < props.length; i++)
  {
    var finalValue, result, prop = props[i], 
        attribute = prop["attribute"], 
        option = prop["option"] || attribute, 
        coerceDomValue = prop["coerceDomValue"],
        validateOption = prop["validateOption"],
        element = comp.element, 
        previousValue = comp.options[option];

    /* The precedence for the value that an option uses is as follows from lowest to highest -
     *
     * (1) component default - this is the widget default
     * (2) app default - this is what a page author defines for the value in the page / app
     * (3) dom value - if your option also has a dom attribute, this is the value set on element. 
     * (4) constructor value - this is the value page author sets on the component binding
     *      
     * When (4) is undefined then attempt to default from (3). But if (3) is undefined use a 
     * defaultValue that component determines. If constructor option was not set then default 
     * value is the merged option value (i.e., this.options) || a hard-coded default determined 
     * by component.
     */

    // Step 1: use DOM value
    if (constructorOptions[option] === undefined)
    {
      previousValue = comp.options[option];
      result = oj.EditableValueUtils.getAttributeValue(element, attribute);

      // if we are using domValue then coerce the dom value before writing to options and trigegr 
      // option change so the value is written back (to ko)
      if (result.fromDom)
      {
        finalValue = result.value;

        // only required needs coercing so not bad
        if (coerceDomValue) 
        {
          if (typeof coerceDomValue === "boolean")
          {
            finalValue = oj.EditableValueUtils.coerceDomValueForOption(option, finalValue);
          }
          else if (typeof coerceDomValue === "function")
          {
            finalValue = coerceDomValue.call(comp, finalValue);
          }
        }
        comp.options[option] = finalValue;
        comp._InitializedOptionFromDom(option, previousValue);
      }
      else
      {
        // hmm, no dom value found; if comp.options also happens to be undefined then simply use 
        // the default option value. 
        if (previousValue === undefined)
        {
          comp.options[option] = prop["defaultOptionValue"];
        }
      }
    }

    // Step 2: validate the option value if needed
    if (validateOption)
    {
      if (typeof validateOption === "boolean")
      {
        oj.EditableValueUtils.validateValueForOption(option, comp.options[option]);
      }
      else if (typeof validateOption === "function")
      {
        validateOption.call(comp);
      }
    }
  }
};

  /**
   * Validates value set for the option and throws error if invalid.
   * 
   * @param {string} option name of the option. Validates options common to all edtiableValue 
   * holders.
   * @param {string|Object|boolean|number|undefined} value of the option that is validated
   * 
   * @throws {Error} if option value is invalid
   * @public
   */
  oj.EditableValueUtils.validateValueForOption = function (option, value)
  {
    var error = false;
    
    switch (option)
    {
      case 'required' :
        if (value !== null &&  typeof value !== "boolean")
        {
          error = true; 
        }
        break;
      
      case "readOnly":
      case "disabled" :
        if (value !== null &&  typeof value !== "boolean")
        {
          error = true;
        }
        
        break;
    }
    
    if (error)
    {
      throw "Option '" + option + " 'has invalid value set: " + value;
    }
  };
  
  
  /**
   * Coerces the dom value being used for the option, and throws error if invalid.
   * 
   * @param {string} option name of the option.
   * @param {string|Object|boolean|number|null} domValue dom value that is being coerced to the 
   * option value
   * @throws {Error} if domValue cannot be coerced appropriately
   * @public
   */
  oj.EditableValueUtils.coerceDomValueForOption = function(option, domValue) 
  { 
    var coerced = domValue;
    switch (option)
    {
      case 'required' :
        coerced = domValue ? true : false;
        break;
    }
    
    return coerced;
  };

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class
 * @name oj.inputBase
 * @augments oj.editableValue
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="inputBaseOverview-section">
 *   Abstract inputBase component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputBaseOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The inputBase component takes care of general needs of other input components [i.e. text + password]
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 */
oj.__registerWidget("oj.inputBase", $['oj']['editableValue'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj",
  
  /**
   * Convenience Array which one can extend to set the attribute to a mandatory value if it doesn't exist or is set to something else 
   * [
   * {
   *    "attr"              : string - attribute associated to the task
   *    "setMandatory"      : value it must be set to [i.e. type="text"]
   * }
   * ]
   * 
   * Examples:
   * 1) [{"attr": "type", "setMandatory": "text"}]
   * 
   * @expose
   * @private
   */
  _ATTR_CHECK : [],
  
  /** 
   * Class names to be applied to this.element()
   * 
   * @expose
   * @private
   */
  _CLASS_NAMES : "",
  
  /** 
   * Class names to be applied to this.widget()
   * 
   * Note that if this value is defined then the this.element will be wrapped
   * 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "",
  
  /**
   * If defined will append a div element containing text to be read out by Jaws when focus is placed on the input element 
   * and the value will be used to locate the translated text to be read out by Jaws.
   * 
   * Note the component must also be wrapped
   * Used in conjunction with the above variable. Used to locate the translated text to be read out by Jaws
   * 
   * @expose
   * @private
   */
  _INPUT_HELPER_KEY: "",
  
  _BLUR_HANDLER_KEY: "blur",
  _KEYDOWN_HANDLER_KEY: "keydown",
  _DROP_HANDLER_KEY: "drop",
  
  options : 
  {
    /** 
     * a converter instance that duck types {@link oj.Converter}. Or an object literal containing 
     * the following properties. 
     * <p>
     * When <code class="prettyprint">converter</code> option changes due to programmatic 
     * intervention, the component performs various tasks based on the current state it is in. </br>
     * 
     * <h4>Steps Performed Always</h4>
     * <ul>
     * <li>Any cached converter instance is cleared and new converter created. The converter hint is 
     * pushed to messaging. E.g., notewindow displays the new hint(s).
     * </li>
     * </ul>
     * 
     * <h4>Running Validation</h4>
     * <ul>
     * <li>if component is valid when <code class="prettyprint">converter</code> option changes, the 
     * display value is refreshed.</li>
     * <li>if component is invalid and is showing messages -
     * <code class="prettyprint">messagesShown</code> option is non-empty, when 
     * <code class="prettyprint">converter</code> option changes, then all messages generated by the 
     * component are cleared and full validation run using its current display value. 
     * <ul>
     *   <li>if there are validation errors, then <code class="prettyprint">value</code> 
     *   option is not updated, and the errors pushed to <code class="prettyprint">messagesShown</code>
     *   option. The display value is not refreshed in this case. </li>
     *   <li>if no errors result from the validation, <code class="prettyprint">value</code> 
     *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code> 
     *   event on the <code class="prettyprint">value</code> option to clear custom errors. The 
     *   display value is refreshed with the formatted value provided by converter.</li>
     * </ul>
     * </li>
     * <li>if component is invalid and has deferred messages -  
     * <code class="prettyprint">messagesHidden</code> option is non-empty, when 
     * <code class="prettyprint">converter</code> option changes, then the display value is 
     * refreshed with the formatted value provided by converter.</li>
     * </ul>
     * </p>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>When component messages are cleared in the cases described above, messages created by 
     * the component that are present in both <code class="prettyprint">messagesHidden</code> and 
     * <code class="prettyprint">messagesShown</code> options are cleared.</li>
     * <li><code class="prettyprint">messagesCustom</code> option is not cleared. Page authors can 
     * choose to clear it explicitly when setting the converter option.</li>
     * </ul>
     * </p>
     * 
     * @property {string} type - the converter type registered with the oj.ConverterFactory. 
     * Supported types are 'number' and 'datetime'. See {@link oj.ConverterFactory} for details. <br/>
     * E.g., <code class="prettyprint">{converter: {type: 'number'}</code>
     * @property {Object=} options - optional Object literal of options that the converter expects. 
     * See {@link oj.IntlNumberConverter} for options supported by the number converter. See 
     * {@link oj.IntlDateTimeConverter} for options supported by the date time converter. <br/>
     * E.g., <code class="prettyprint">{converter: {type: 'number', options: {style: 'decimal'}}</code>
     * 
     * @example <caption>Initialize the component with a number converter instance:</caption>
     * // Initialize converter instance using currency options
     * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
     * var numberConverterFactory = oj.Validation.converterFactory("number");
     * var salaryConverter = numberConverterFactory.createConverter(options);<br/>
     * // set converter instance using converter option
     * $(".selector").ojFoo({ // Foo is InputText, InputPassword, TextArea
     *   value: 25000, 
     *   converter: salaryConverter
     * });
     * 
     * @example <caption>Initialize the component with converter object literal:</caption>
     * $(".selector").ojFoo({ // Foo is InputText, InputPassword, TextArea
     *   value: new Date(),
     *   converter: {
     *     type: 'datetime', 
     *     options : {
     *       formatType: 'date', 
     *       dateFormat: 'long'
     *     }
     *   }
     * });
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof! oj.inputBase
     * @type {Object|undefined}
     */    
    converter: undefined,    
    
    /**
     * The placeholder text to set on the element. Though it is possible to set placeholder 
     * attribute on the element itself, the component will only read the value when the component
     * is created. Subsequent changes to the element's placeholder attribute will not be picked up 
     * and page authors should update the option directly.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> option:</caption>
     * &lt;!-- Foo is InputText, InputPassword, TextArea -->
     * &lt;input id="userId" data-bind="ojComponent: {component: 'ojFoo', placeholder: 'User Name'}" /&gt;
     * 
     * @example <caption>Initialize <code class="prettyprint">placeholder</code> option from html attribute:</caption>
     * &lt;!-- Foo is InputText, InputPassword, TextArea -->
     * &lt;input id="userId" data-bind="ojComponent: {component: 'ojFoo'}" placeholder="User Name" /&gt;
     * 
     * // reading the placeholder option will return "User Name"
     * $(".selector").ojFoo("option", "placeholder"); // Foo is InputText, InputPassword, TextArea<br/>
     * 
     * @default when the option is not set, the element's placeholder attribute is used if it exists. 
     * If the attribute is not set and if a datetime converter is set then the converter hint is 
     * used. See displayOptions for details.
     * 
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof! oj.inputBase
     * @type {string|null|undefined}
     */    
    placeholder: undefined,    
    
    /** 
     * Dictates component's readOnly state. Note that option value 
     * always supercedes element's attribute value and it is best practice to pass the value as an option than to 
     * set it as an element's attribute.
     * 
     * @example <caption>Initialize component with <code class="prettyprint">readOnly</code> option:</caption>
     * $(".selector").ojInputNumber({"readOnly": true});
     * 
     * @expose 
     * @type {boolean|undefined}
     * @default <code class="prettyprint">false</code>
     * @instance
     * @memberof! oj.inputBase
     */
    readOnly: undefined
  },
  
  /**
   * The base method needs to be overriden so that one can perform attribute check/set [i.e. ojInputText can only have type="text"] 
   * 
   * @protected
   * @override
   * @param {Object} element - jQuery selection to save attributes for
   * @instance
   * @memberof! oj.inputBase
   */
  _SaveAttributes : function (element)
  {
    var ret = this._superApply(arguments);
    
    this._processAttrCheck();
    
    return ret;
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */
  _InitOptions: function(originalDefaults, constructorOptions)
  {
    var props = [{'attribute': 'disabled', 'defaultOptionValue': false, 'validateOption': true},
                 {'attribute': 'pattern', 'defaultOptionValue': ""},
                 {'attribute': 'placeholder', 'defaultOptionValue': ""},
                 {'attribute': 'value', 'defaultOptionValue': null},
                 {'attribute': 'readonly', 'option': 'readOnly', 'defaultOptionValue': false, 
                   'validateOption': true},
                 {'attribute': 'required', 'defaultOptionValue': false, 
                  'coerceDomValue': true, 'validateOption': true},
                 {'attribute': 'title', 'defaultOptionValue': ""}]; 
    
    this._super(originalDefaults, constructorOptions);
    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);    
  },

  /**
   * 1) Initializes the options
   * 2) If needed wraps the input element, 
   * 
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */
  _ComponentCreate : function()
  {
    var node = this.element, 
        ret = this._superApply(arguments),
        savedAttributes = this._GetSavedAttributes(node);
    
    // update element state using options
    if (typeof this.options['readOnly'] === "boolean") 
    {
      this.element.prop("readonly", this.options['readOnly']);
    }
    
    if (this._DoWrapElement())
    {
      this._wrapElement();
    }
    
    // remove pattern attribute to not trigger html5 validation + inline bubble
    if ('pattern' in savedAttributes)
    {
      node.removeAttr('pattern');
    }
    
    this.__defaultRegExpOptions = {};
    this._eventHandlers = null;
    return ret;
  },
  
  /**
   * 1) Updates component state based on the option values
   * 2) Adds the classname to the element [intentionally postponing till this process since the component might need to 
   *    reset this.element for some reason]
   * 3) Hooks up the blur handler
   * 4) If necessary appends an input helper to be read out by Jaws accessibility reader
   * 
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */        
  _AfterCreate : function () 
  {
    var ret = this._superApply(arguments),
        options = ["disabled", "readOnly"],
        self = this;
    
    if(this._CLASS_NAMES) 
    {
      this.element.addClass(this._CLASS_NAMES);
    }
    
    //attach handlers such as blur, keydown, and drop. placed in a function so to detach the handlers as well
    //when the options change
    this._attachDetachEventHandlers();
    
    this._AppendInputHelper();
    
    //reason it should go through _setOption are for cases where the components are composite and just 
    //placing it on the root node is not sufficient enough
    $.each(options, function(index, ele)
    {
      if(self.options[ele]) 
      {
        self._processDisabledReadOnly(ele, self.options[ele]);
      }
    });
    
    return ret;
  },
  
  _processDisabledReadOnly : function __processDisabledReadOnly(key, value) 
  {
    if (key === "disabled")
    {
      this.element.prop("disabled", value);
    }
    
    if (key === "readOnly")
    {
      this.element.prop("readonly", value);
      this._refreshStateTheming("readOnly", value);
    }
    
    if(key === "disabled" || key === "readOnly") 
    {
      this._attachDetachEventHandlers();
    }
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _setOption : function __setOption(key, value)
  {
    var retVal = this._superApply(arguments);
    
    if(key === "disabled" || key === "readOnly") 
    {
      this._processDisabledReadOnly(key, value);
    }

    if (key === "pattern")
    {
      this.__defaultRegExpOptions['pattern'] = value;
      this._ResetAllValidators();
      this._AfterSetOptionValidators();
    }
    
    return retVal;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var ret = this._superApply(arguments);

    this.element.off("blur drop keydown");
    
    if(this._inputHelper) 
    {
      this._inputHelper.remove();
    }
    
    if(this._DoWrapElement())
    {
      this.element.unwrap();
    }

    this._RestoreAttributes(); //remove when _RestoreAttributes is uncommented from jqueryui-base
    
    return ret;
  },
  
  _attachDetachEventHandlers: function __attachDetachEventHandlers() 
  {
    
    if(!this.options["readOnly"] && !this.options["disabled"]) {
      
      this._eventHandlers = {};
      
      var blurHandler = $.proxy(this._onBlurHandler, this),
          keyDownHandler = $.proxy(this._onKeyDownHandler, this),
          dropHandler = function() 
                        {
                          this.focus();
                        };
      
      this.element.on("blur", blurHandler);
      this.element.on("keydown", keyDownHandler);
      
      //other than FF when a drop is dispatched focus is placed back on the element
      //this would cause difference in behavior of the observable change [as set within blur], so in order to provide
      //consisteny placing the focus on the element after the drop
      this.element.on("drop", dropHandler);
      
      
      this._eventHandlers[this._BLUR_HANDLER_KEY] = blurHandler;
      this._eventHandlers[this._KEYDOWN_HANDLER_KEY] = keyDownHandler;
      this._eventHandlers[this._DROP_HANDLER_KEY] = dropHandler;
    }
    else 
    {
      
      //meaning either it is readOnly or is disabled, remove the handlers if they were attached previously
      if(this._eventHandlers) 
      {
        var eventEntries = [this._BLUR_HANDLER_KEY, this._KEYDOWN_HANDLER_KEY, this._DROP_HANDLER_KEY];
        
        for(var i=0, j=eventEntries.length; i < j; i++) 
        {
          if(this._eventHandlers[eventEntries[i]]) 
          {
            this.element.off(eventEntries[i], this._eventHandlers[eventEntries[i]]);
            delete this._eventHandlers[eventEntries[i]];
          }
        }
      }
    }
    
  },
  
   /**
   * when below listed options are passed to the component, corresponding CSS will be toggled
   * @private
   * @const
   * @type {Object}
   */
  _OPTION_TO_CSS_MAPPING: {
    "readOnly": "oj-read-only"
  }, 
  
  /**
   * Performs the attribute check/set by using _ATTR_CHECK variable [i.e. ojInputText must have type be set to "text"].
   * 
   * @private
   */
  _processAttrCheck : function __processAttrCheck()
  {
    
    var attrCheck = this._ATTR_CHECK;
    
    for(var i=0, j=attrCheck.length; i < j; i++) 
    {
      var attr = attrCheck[i]["attr"],
          setMandatoryExists = "setMandatory" in attrCheck[i];
      
      //if it doesn't exist just have to check whether one should set it to a mandatory value
      if(setMandatoryExists)
      {
        this.element.attr(attr, attrCheck[i]["setMandatory"]);
      }
    }
  },
  
  /**
   * Invoked when blur is triggered of the this.element
   * 
   * @ignore
   * @protected
   * @param {Event} event
   */
  _onBlurHandler : function __onBlurHandler(event) 
  {
    this._SetValue(this._GetDisplayValue(), event);
  },
  
  /**
   * Invoked when keydown is triggered of the this.element
   * 
   * When of keyCode is of Enter, invoke _SetValue on it
   * 
   * @ignore
   * @protected
   * @param {Event} event
   */
  _onKeyDownHandler : function __onKeyDownHandler(event) 
  {
    if(event.keyCode === $.ui.keyCode.ENTER) 
    {
      this._SetValue(this._GetDisplayValue(), event);
    }
  },
  
  /**
   * Whether the this.element should be wrapped. Method so that additional conditions can be placed
   * 
   * @ignore
   * @protected
   * @return {boolean}
   */
  _DoWrapElement : function ()
  {
    return this._WIDGET_CLASS_NAMES;
  },
  
  /**
   * Wraps the this.element and adds _WIDGET_CLASS_NAMES classes to the wrapped element
   * 
   * @private
   */
  _wrapElement : function __wrapElement() 
  {
    $(this.element).wrap( $("<div>").addClass(this._WIDGET_CLASS_NAMES) );
    this._wrapper = this.element.parent();
  },
  
  /**
   * In some complex components [i.e. datepicker], when the input element receives focus we wish to have Jaws read 
   * out some content.
   * 
   * For those case does this method exist.
   *  
   * @protected
   * @instance
   * @memberOf !oj.inputBase
   */
  _AppendInputHelper : function __AppendInputHelper()
  {
    if(this._INPUT_HELPER_KEY && this._DoWrapElement()) 
    {
      var describedBy = this.element.attr("aria-describedby") || "",
          helperDescribedById = this._GetSubId(this._INPUT_HELPER_KEY);
      
      describedBy += " " + helperDescribedById;
      this.element.attr("aria-describedby", describedBy);
      this._inputHelper = $("<div class='oj-helper-hidden-accessible' id='" + helperDescribedById + "'>" + 
                              this.getTranslatedString(this._INPUT_HELPER_KEY) + "</div>");
      this._AppendInputHelperParent().append(this._inputHelper);
    }
  },
  
  /**
   * Which parent node the inputHelper should be appended to. Usually do not need to override.
   *  
   * @protected
   * @instance
   * @memberOf !oj.inputBase
   */
  _AppendInputHelperParent : function __AppendInputHelperParent() 
  {
    return this.widget();
  },
  
  /**
   * Called when refresh() method is called, to reset component state. 
   * 
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   * @see #refresh
   */
  _ResetComponentState : function ()
  {
    // for now reset all validators
    this.__defaultRegExpOptions = {};
    this._super();
  },
  
  /**
   * Sets up the default regExp validator.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */
  _GetImplicitValidators : function ()
  {
    var ret = this._superApply(arguments), validatorMap = {};

    // register a default RegExp validator if we have a valid pattern
    if (this.options['pattern'])
    {
      // add validator to the special internalValidators list. These are validators created by 
      // the framework. We don't want these cleared using the option - 'validators'
      validatorMap[oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP] = this._getDefaultRegExpValidator();
      return oj.CollectionUtils.copyInto(validatorMap, ret);
    }
    
    return ret;
  },
    /**
   * Toggles css selector on the widget. E.g., when readOnly option changes, 
   * the oj-read-only selector needs to be toggled.
   * @param {string} option
   * @param {Object|string} value 
   * @private
   */        
  _refreshStateTheming : function (option, value)
  {
    if (Object.keys(this._OPTION_TO_CSS_MAPPING).indexOf(option) != -1) 
    {
      // value is a boolean
      this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], !!value);
    }
  },
  
  /**
   * Returns the regexp validator instance or creates it if needed and caches it.
   * @private
   */
  _getDefaultRegExpValidator : function ()
  {
    var vf;
    this.__defaultRegExpOptions = {'pattern': this.options['pattern'], 
                                   'label': this._getLabelText()};

    vf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP);
    return vf ? vf.createValidator(this.__defaultRegExpOptions) : null;
  },  
  
  /**
   * This helper function will generate ids using widget's uuid as unique identifier for 
   * wai-aria and other necessary ids
   * 
   * @ignore
   * @protected
   * @param {string} sub
   * @return {string}
   */
  _GetSubId : function __getSubId(sub)
  {
    return this["uuid"] + "_" + sub;
  },
  
  /**
   * @ignore
   * @protected
   * @return {boolean}
   */
  _IsRTL : function ()
  {
    return this._GetReadingDirection() === "rtl";
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * @expose
   * @override
   * @instance
   * @memberof oj.inputBase
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    return this._super(locator);
  },

  /**
   * Returns a <code class="prettyprint">jQuery</code> object containing the element visually 
   * representing the component, excluding the label associated with the it. 
   * 
   * <p>This method does not accept any arguments.</p>
   * 
   * @expose
   * @memberof! oj.inputBase
   * @instance
   * @return {jQuery} the root of the component
   * 
   * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
   * var widget = $( ".selector" ).ojFoo( "widget" ); // Foo is InputText, InputPassword, TextArea
   */       
  widget : function _widget() 
  {
    return this._DoWrapElement() ? this._wrapper : this.element;
  }

});
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class
 * @name oj.ojInputText
 * @augments oj.inputBase
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="inputTextOverview-section">
 *   JET ojInputText Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputTextOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The ojInputText component enhances a browser input type="text" element.
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputText" )            // selects all JET input on the page
 * </code>
 * </pre>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * It is up to the application developer to associate the label to the input component.
 * For inputText, you should put an <code>id</code> on the input, and then set 
 * the <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <h3 id="label-section">
 *   Label and InputText
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a label element with the input
 * by putting an <code>id</code> on the input, and then setting the 
 * <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code>required</code> and <code>help</code> options are set. 
 * </p>
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="textId" data-bind="ojComponent: {component: 'ojInputText'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputText
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputText();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputText( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="textId" data-bind="ojComponent: {component: 'ojInputText'}" /&gt;
 */
oj.__registerWidget("oj.ojInputText", $['oj']['inputBase'],
{
  version : "1.0.0",  
  defaultElement : "<input>", 
  widgetEventPrefix : "oj", 
  
  /** 
   * @expose
   * @private
   */
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "text"}],
  
  /** 
   * @expose
   * @private
   */
  _CLASS_NAMES : "oj-inputtext-input",
  
  /** 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "oj-inputtext oj-form-control oj-component",
  
  options : 
  {
    /** 
     * Regular expression pattern which will be used to validate the component's value. Note that option value 
     * always supercedes element's attribute value and it is best practice to pass the value as an option than to 
     * set it as an element's attribute.
     * <p>
     * When pattern is set to true, an implicit regExp validator is created using the validator 
     * factory - 
     * <code class="prettyprint">oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP).createValidator()</code>.
     * </p>
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">pattern</code> option:</caption>
     * $(".selector").ojInputText({pattern: "[a-zA-Z0-9]{3,}"});<br/>
     * @example <caption>Initialize <code class="prettyprint">pattern</code> option from the html attribute 'pattern':</caption>
     * &lt;input type="text" id="username" value= "" pattern="[a-zA-Z0-9]{3,}" 
     *           title="Enter at least 3 alphanumeric characters"/><br/>
     * // reading the pattern option will return "[a-zA-Z0-9]{3,}"
     * $(".selector").ojInputText("option", "pattern");<br/>
     * 
     * @expose 
     * @instance
     * @memberof! oj.ojInputText
     * @type {string|undefined}
     */    
    pattern: undefined
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values. <br/>
   * If the locator is null or no subId string is provided then this method returns the element that 
   * this component was initalized with. <br/>
   * If a subId was provided but a subcomponent node cannot be located this method returns null.
   * 
   * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is 
   * <code class="prettyprint">null</code>, then this method returns the element on which this component was initalized.
   * 
   * <p>If a <code class="prettyprint">subId</code> was provided but no corresponding node 
   * can be located, then this method returns <code class="prettyprint">null</code>.
   * 
   * @expose
   * @override
   * @memberof oj.ojInputText
   * @instance
   * 
   * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code> 
   * property. See the table for details on its fields.
   * 
   * @property {string=} locator.subId - A string that identifies a particular DOM node in this component.
   * 
   * <p>The supported sub-ID's are documented in the <a href="#subids-section">Sub-ID's</a> section of this document.
   * 
   * @property {number=} locator.index - A zero-based index, used to locate a message content node 
   * or a hint node within the popup. 
   * @returns {Element|null} The DOM node located by the <code class="prettyprint">subId</code> string passed in 
   * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
   * 
   * @example <caption>Get the node for a certain subId:</caption>
   * var node = $( ".selector" ).ojInputText( "getNodeBySubId", {'subId': 'oj-some-sub-id'} );
   */
  getNodeBySubId: function(locator)
  {
    var node = this._superApply(arguments), subId;
    if (!node)
    {
      subId = locator['subId'];
      if (subId === "oj-inputtext-input") {
        node = this.element ? this.element[0] : null;
      }
    }
    // Non-null locators have to be handled by the component subclasses
    return node || null;
 },
  
  /**
   * @override
   * @instance
   * @memberof! oj.ojInputText
   * @protected
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputtext";
  }
  
});

//////////////////     SUB-IDS     //////////////////
/**
 * <p>Sub-ID for the ojInputText component's input element.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-inputtext-input
 * @memberof oj.ojInputText
 * @instance
 * 
 * @example <caption>Get the node for the input element:</caption>
 * var node = $( ".selector" ).ojInputText( "getNodeBySubId", {'subId': 'oj-inputtext-input'} );
 */
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class
 * @name oj.ojTextArea
 * @augments oj.inputBase
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="textAreaOverview-section">
 *   JET ojTextArea Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#textAreaOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The ojTextArea component enhances a browser textarea element.
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-textarea" )            // selects all JET textarea on the page
 * </code>
 * </pre>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * It is up to the application developer to associate the label to the textarea
 * component. For textarea, you should put an <code>id</code> on the textarea,
 * and then set the <code>for</code> attribute on the label to be the textarea's id.
 * </p>
 * <h3 id="label-section">
 *   Label and TextArea
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a label element with the textarea
 * by putting an <code>id</code> on the textarea, and then setting the 
 * <code>for</code> attribute on the label to be the textarea's id.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code>required</code> and <code>help</code> options are set. 
 * </p>
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;textarea id="textAreaId" data-bind="ojComponent: {component: 'ojTextArea'}" &gt;&lt;/textarea&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojTextArea.
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the textarea with no options specified:</caption>
 * $( ".selector" ).ojTextArea();
 * 
 * * @example <caption>Initialize the textarea with some options:</caption>
 * $( ".selector" ).ojTextArea( { "disabled": true } );
 * 
 * @example <caption>Initialize the textarea via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;textarea id="textAreaId" data-bind="ojComponent: {component: 'ojTextArea'}" &gt;&lt;/textarea&gt;
 */
oj.__registerWidget("oj.ojTextArea", $['oj']['inputBase'],
{
  version : "1.0.0",  
  defaultElement : "<textarea>", 
  widgetEventPrefix : "oj", 
  
  /** 
   * @expose
   * @private
   */
  _ATTR_CHECK : [],
  
  /** 
   * @expose
   * @private
   */
  _CLASS_NAMES : "oj-textarea-input",
  
  /** 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "oj-textarea oj-form-control oj-component",
  
  options : 
  {
    /** 
     * Regular expression pattern which will be used to validate the component's value. Note that 
     * option value always supercedes element's attribute value and it is best practice to pass the 
     * value as an option than to set it as an element's attribute.
     * <p>
     * When pattern is set to true, an implicit regExp validator is created using the validator 
     * factory - 
     * <code class="prettyprint">oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP).createValidator()</code>.
     * </p>
     * 
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">pattern</code> option:</caption>
     * $(".selector").ojTextArea({pattern: "[a-zA-Z0-9]{3,}"});<br/>
     * @example <caption>Initialize <code class="prettyprint">pattern</code> option from the html attribute 'pattern':</caption>
     * &lt;input type="text" id="username" value= "" pattern="[a-zA-Z0-9]{3,}" 
     *           title="Enter at least 3 alphanumeric characters"/><br/>
     * // reading the pattern option will return "[a-zA-Z0-9]{3,}"
     * $(".selector").ojTextArea("option", "pattern");<br/>
     * 
     * @expose 
     * @instance
     * @memberof! oj.ojTextArea
     * @type {string|undefined}
     */    
    pattern: undefined
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values. <br/>
   * If the locator is null or no subId string is provided then this method returns the element that 
   * this component was initalized with. <br/>
   * If a subId was provided but a subcomponent node cannot be located this method returns null.
   * 
   * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is 
   * <code class="prettyprint">null</code>, then this method returns the element on which this component was initalized.
   * 
   * <p>If a <code class="prettyprint">subId</code> was provided but no corresponding node 
   * can be located, then this method returns <code class="prettyprint">null</code>.
   * 
   * @expose
   * @override
   * @memberof oj.ojInputText
   * @instance
   * 
   * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code> 
   * property. See the table for details on its fields.
   * 
   * @property {string=} locator.subId - A string that identifies a particular DOM node in this component.
   * 
   * <p>The supported sub-ID's are documented in the <a href="#subids-section">Sub-ID's</a> section of this document.
   * 
   * @property {number=} locator.index - A zero-based index, used to locate a message content node 
   * or a hint node within the popup. 
   * @returns {Element|null} The DOM node located by the <code class="prettyprint">subId</code> string passed in 
   * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
   * 
   * @example <caption>Get the node for a certain subId:</caption>
   * var node = $( ".selector" ).ojTextArea( "getNodeBySubId", {'subId': 'oj-some-sub-id'} );
   */
  getNodeBySubId: function(locator)
  {
    var node = this._superApply(arguments), subId;
    if (!node)
    {
      subId = locator['subId'];
      if (subId === "oj-textarea-input") {
        node = this.element ? this.element[0] : null;
      }
    }
    // Non-null locators have to be handled by the component subclasses
    return node || null;
 },  
  
  /**
   * @instance
   * @memberof! oj.ojTextArea
   * @override
   * @protected
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-textarea";
  }
  
});

//////////////////     SUB-IDS     //////////////////
/**
 * <p>Sub-ID for the ojTextArea component's textarea element.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-textarea-input
 * @memberof oj.ojTextArea
 * @instance
 * 
 * @example <caption>Get the node for the input element:</caption>
 * var node = $( ".selector" ).ojTextArea( "getNodeBySubId", {'subId': 'oj-textarea-input'} );
 */
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class
 * @name oj.ojInputPassword
 * @augments oj.inputBase
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="inputPasswordOverview-section">
 *   JET ojInputPassword Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputPasswordOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The ojInputPassword component enhances a browser input type="password" element.
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputPassword" )            // selects all JET input on the page
 * </code>
 * </pre>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * It is up to the application developer to associate the label to the input component.
 * For inputPassword, you should put an <code>id</code> on the input, and then set 
 * the <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <h3 id="label-section">
 *   Label and InputPassword
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a label element with the input
 * by putting an <code>id</code> on the input, and then setting the 
 * <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code>required</code> and <code>help</code> options are set. 
 * </p>
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="passwordId" data-bind="ojComponent: {component: 'ojInputPassword'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputPassword
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputPassword();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputPassword( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="passwordId" data-bind="ojComponent: {component: 'ojInputPassword'}" /&gt;
 */
oj.__registerWidget("oj.ojInputPassword", $['oj']['inputBase'],
{
  version : "1.0.0",  
  defaultElement : "<input>", 
  widgetEventPrefix : "oj", 
  
  /** 
   * @expose
   * @private
   */
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "password"}],
  
  /** 
   * @expose
   * @private
   */
  _CLASS_NAMES : "oj-inputpassword-input",
  
  /** 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "oj-inputpassword oj-form-control oj-component",
  
  options : 
  {
    /** 
     * Regular expression pattern which will be used to validate the component's value. Note that option value 
     * always supercedes element's attribute value and it is best practice to pass the value as an option than to 
     * set it as an element's attribute.
     * <p>
     * When pattern is set to true, an implicit regExp validator is created using the validator 
     * factory - 
     * <code class="prettyprint">oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP).createValidator()</code>.
     * </p>
     * 
     * <p>
     * Note: It is recommended that the <code class="prettyprint">title</code> option be used to 
     * describe the pattern expected for the value entered by end-user.
     * </p>
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">pattern</code> option:</caption>
     * $(".selector").ojInputPassword({pattern: "[a-zA-Z0-9]{3,}"});<br/>
     * @example <caption>Initialize <code class="prettyprint">pattern</code> option from the html attribute 'pattern':</caption>
     * &lt;input type="text" id="username" value= "" pattern="[a-zA-Z0-9]{3,}" 
     *           title="Enter at least 3 alphanumeric characters"/><br/>
     * // reading the pattern option will return "[a-zA-Z0-9]{3,}"
     * $(".selector").ojInputPassword("option", "pattern");<br/>
     * 
     * @expose 
     * @instance
     * @memberof! oj.ojInputPassword
     * @type {string|undefined}
     */    
    pattern: undefined
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values. <br/>
   * If the locator is null or no subId string is provided then this method returns the element that 
   * this component was initalized with. <br/>
   * If a subId was provided but a subcomponent node cannot be located this method returns null.
   * 
   * <p>If the <code class="prettyprint">locator</code> or its <code class="prettyprint">subId</code> is 
   * <code class="prettyprint">null</code>, then this method returns the element on which this component was initalized.
   * 
   * <p>If a <code class="prettyprint">subId</code> was provided but no corresponding node 
   * can be located, then this method returns <code class="prettyprint">null</code>.
   * 
   * @expose
   * @override
   * @memberof oj.ojInputText
   * @instance
   * 
   * @param {Object} locator An Object containing, at minimum, a <code class="prettyprint">subId</code> 
   * property. See the table for details on its fields.
   * 
   * @property {string=} locator.subId - A string that identifies a particular DOM node in this component.
   * 
   * <p>The supported sub-ID's are documented in the <a href="#subids-section">Sub-ID's</a> section of this document.
   * 
   * @property {number=} locator.index - A zero-based index, used to locate a message content node 
   * or a hint node within the popup. 
   * @returns {Element|null} The DOM node located by the <code class="prettyprint">subId</code> string passed in 
   * <code class="prettyprint">locator</code>, or <code class="prettyprint">null</code> if none is found.
   * 
   * @example <caption>Get the node for a certain subId:</caption>
   * var node = $( ".selector" ).ojInputPassword( "getNodeBySubId", {'subId': 'oj-some-sub-id'} );
   */
  getNodeBySubId: function(locator)
  {
    var node = this._superApply(arguments), subId;
    if (!node)
    {
      subId = locator['subId'];
      if (subId === "oj-inputpassword-input") {
        node = this.element ? this.element[0] : null;
      }
    }
    // Non-null locators have to be handled by the component subclasses
    return node || null;
 },  
  /**
   * @override
   * @instance
   * @memberof! oj.ojInputPassword
   * @protected
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputpassword";
  }
   
});

//////////////////     SUB-IDS     //////////////////
/**
 * <p>Sub-ID for the ojInputPassword component's input element.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-inputpassword-input
 * @memberof oj.ojInputPassword
 * @instance
 * 
 * @example <caption>Get the node for the input element:</caption>
 * var node = $( ".selector" ).ojInputPassword( "getNodeBySubId", {'subId': 'oj-inputpassword-input'} );
 */
/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/

/*global ojld:true*/

/**
 * @class Locale Data Services
 * @export
 * @since 0.6
 */
oj.LocaleData = {};

/**
 * Sets the Locale Elements bundle used by JET
 * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
 * a Locale Elements for JET.
 * This method may also be used by an application that wants to completely replace the Locale Elements bundle that is automatically
 * fetched by an AMD loader.
 * @param {Object} bundle resource bundle that should be used by the framework
 * @export
 */
oj.LocaleData.setBundle = function(bundle)
{
  oj.LocaleData._bundle = bundle;
};

/**
 * Retrieves the first day of week for the current locale's region
 * @return {number} a numeric representation of the first week day of the week: 
 * 0 for Sunday, 1 for Monday, etc.
 * @export
 */
oj.LocaleData.getFirstDayOfWeek = function()
{
  return oj.LocaleData._getWeekData("firstDay");
};

/**
 * Retrieves the first weekend day for the current locale's region
 * @return {number} a numeric representation of the first weekend day: 
 * 0 for Sunday, 1 for Monday, etc.
 * @export
 */
oj.LocaleData.getWeekendStart = function()
{
  return oj.LocaleData._getWeekData("weekendStart");
};

/**
 * Retrieves the last weekend day for the current locale's region
 * @return {number} a numeric representation of the last weekend day: 
 * 0 for Sunday, 1 for Monday, etc.
 * @export
 */
oj.LocaleData.getWeekendEnd = function()
{
  return oj.LocaleData._getWeekData("weekendEnd");
};

/**
 * Retrieves locale-specific names of the days of the week
 * @return {Array.<string>} names of the days from Sunday through Sturday
 * @param {string} type - the type of the name. Currently, "abbreviated", "narrow" and "wide" are supported
 * @export
 */
oj.LocaleData.getDayNames = function(type)
{
  if (type== null || (type !== "abbreviated" && type !== "narrow"))
  {
    type = "wide";
  }
  var days = oj.LocaleData._getCalendarData()["days"]["stand-alone"][type];
  
  return [days["sun"], days["mon"], days["tue"], days["wed"], days["thu"],  days["fri"],  days["sat"]];
};

/**
 * Retrieves locale-specific names of months
 * @return {Array.<string>} names of months from January through December
 * @param {string} type - the type of the name. Currently, "abbreviated", "narrow" and "wide" are supported
 * @export
 */
oj.LocaleData.getMonthNames = function(type)
{
  if (type== null || (type !== "abbreviated" && type !== "narrow"))
  {
    type = "wide";
  }
  var months = oj.LocaleData._getCalendarData()["months"]["stand-alone"][type];
  
  return [months["1"], months["2"], months["3"], months["4"], months["5"], months["6"],
           months["7"], months["8"], months["9"], months["10"], months["11"], months["12"]];
};

/**
 * Retrieves whether month is displayed prior to year
 * @return {boolean} whether month is prior to year
 * @export
 */
oj.LocaleData.isMonthPriorToYear = function() 
{
  var longDateFormat = oj.LocaleData._getCalendarData()["dateFormats"]["long"].toUpperCase(),
      monthIndex = longDateFormat.indexOf("M"),
	  yearIndex = longDateFormat.indexOf("Y");
  
  return monthIndex < yearIndex;
}

/**
 * @hidden
 * @private
 */
oj.LocaleData._getWeekData = function(key)
{
  var b = oj.LocaleData.__getBundle();
  var defRegion = "001";
  var region = oj.LocaleData._getRegion() || defRegion;
  
  var data = b["supplemental"]["weekData"][key];
  
  var val = data[region];
  
  if (val === undefined)
  {
    val = data[defRegion];
  }
  
  return val;
};

/**
 * @hidden
 * @private
 */
oj.LocaleData._getCalendarData = function()
{
   var b = oj.LocaleData.__getBundle();
   var main  = b['main'];
   
   // skip one level (the name of the locale)
   var data, p;
   for (p in main)
   {
     if (main.hasOwnProperty(p)) {
        data = main[p];
        break;
     }
   }
   return data['dates']['calendars']['gregorian'];
};

/**
 * @hidden
 * @private
 */
oj.LocaleData._getRegion = function()
{
  var locale = oj.Config.getLocale();
  if (locale)
  {
    var tokens = locale.toUpperCase().split(/-|_/);
    if (tokens.length >= 2)
    {
      var tag = tokens[1];
      if (tag.length == 4) // this is a script tag
      {
        if (tokens.length >= 3)
        {
          return tokens[2];
        }
      }
      else
      {
        return tag;
      }
    }
  }
  return null;
};

/**
 * @hidden
 * @private
 */
oj.LocaleData.__getBundle = function()
{
  var b = oj.LocaleData._bundle;
  if (b)
  {
    return b;
  }
  
  if (oj.__isAmdLoaderPresent()) {
    oj.Assert.assert(ojld !== undefined, "LocaleElements module must be loaded");
    return ojld;
  }
  return {};
};

/**
 * Called from oj.Config after AMD loader fetches LocaleElements for the new locale.
 *
 * @hidden
 * @private
 * 
 */
oj.LocaleData.__updateBundle = function(bundle)
{
  ojld = bundle;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * The ojvalidation module.
 * @name oj.Validation
 * @class 
 * @export
 * @since 0.6
 * 
 */
oj.Validation = {};

/**
 * Internal properties to hold all factory provider callbacks or instances by name
 * @private
 */
oj.Validation._converterFactories = {}; oj.Validation._validatorFactories = {};

/**
 * Internal properties to hold the default factory instances.
 * @private
 */
oj.Validation._defaultConverterFactories = {}; oj.Validation._defaultValidatorFactories = {};

/**
 * Internal property that identifies the type that is the contract for conveters and validators.
 * @private
 */
oj.Validation._CONTRACTS = {'converter' : {name: "oj.ConverterFactory",  type: oj.ConverterFactory},
                            'validator': {name: "oj.ValidatorFactory", type: oj.ValidatorFactory}};

/**
 * Module method to register and retrieve converter factory instances by name. 
 * When passed only the name, an existing factory (registered for the name) is returned. Callers can 
 * expect to get back the default 'number' and 'datetime' converters. 
 * When passed two arguments, a new factory for the name is registered. If the name already exists 
 * the new instance replaces the old one. 
 * 
 * @param {string} type a case insensitive name of the converter factory. 
 * @param {Object=} instance the instance of the factory that implements the contract for 
 * oj.ConverterFactory.
 * 
 * @export
 * @see oj.ConverterFactory
 */
oj.Validation.converterFactory = function (type, instance)
{
  var retValue;
  if (type && !instance)
  {
    // getter
    retValue = oj.Validation._getFactory(type, oj.Validation._converterFactories);
  }
  else if (type && instance)
  {
    // setter
    retValue = oj.Validation._registerFactory(type, 
                                              instance, 
                                              oj.Validation._converterFactories,
                                              oj.Validation._CONTRACTS['converter']);
  }
  
  return retValue;
};

/**
 * Module method to register and retrieve validator factory instances by name. 
 * When passed only the name, an existing factory (registered for the name) is returned. 
 * When passed two arguments, a new factory for the name is registered. If the name already exists 
 * the new instance replaces the old one. 
 * 
 * @param {string} type a case insensitive name of the validator factory. 
 * @param {Object=} instance the instance of the factory that implements the contract for 
 * oj.ValidatorFactory.
 * 
 * @export
 * @see oj.ValidatorFactory
 */
oj.Validation.validatorFactory = function (type, instance)
{
  var retValue;
  if (type && !instance)
  {
    // getter
    retValue = oj.Validation._getFactory(type, oj.Validation._validatorFactories);
  }
  else if (type && instance)
  {
    // setter
    retValue = oj.Validation._registerFactory(type, 
                                              instance, 
                                              oj.Validation._validatorFactories, 
                                              oj.Validation._CONTRACTS['validator']);
  }
  
  return retValue;
};

/**
 * Returns the default converter factory instances for the supported types as defined by the 
 * oj.ConverterFactory.
 * 
 * @param {string} type The default converter factory for the type. Supported types are 'number' and 
 * 'datetime'
 * @return {Object} an instance of oj.ConverterFactory or null if an unknown type is requested.
 * 
 * @export
 * @see oj.ConverterFactory
 * 
 */
oj.Validation.getDefaultConverterFactory = function (type)
{
  return oj.Validation._getFactory(type, oj.Validation._defaultConverterFactories);
};

/**
 * Returns the default validator factory instance for the requested types as defined by the 
 * oj.ValidatorFactory.
 * 
 * @param {string} type The default converter factory for the type. Supported types are 'number' and 
 * 'datetime'
 * @return {Object} an instance of oj.ConverterFactory or null if an unknown type is requested.
 * 
 * @export
 * @see oj.ValidatorFactory
 */
oj.Validation.getDefaultValidatorFactory = function (type)
{
  return oj.Validation._getFactory(type, oj.Validation._defaultValidatorFactories);
};

// PACKAGE PRIVATE METHODS
/**
 * Called only by internal jet converter factory implementations.
 * 
 * @param {string} name
 * @param {Object} instance
 * @private
 */
oj.Validation.__registerDefaultConverterFactory = function (name, instance)
{
  // save to both factories
  var contractDef = oj.Validation._CONTRACTS['converter'];
  oj.Validation._registerFactory (name, instance, oj.Validation._defaultConverterFactories, contractDef);
  oj.Validation._registerFactory(name, instance, oj.Validation._converterFactories, contractDef);
};

/**
 * Called only by internal jet validator factory implementations.
 * 
 * @param {string} name of the validator factory
 * @param {Object} instance of the validator factory that creates instances of the validator
 * @private
 */
oj.Validation.__registerDefaultValidatorFactory = function (name, instance)
{
  // save to both factories
  var contractDef = oj.Validation._CONTRACTS['validator'];
  oj.Validation._registerFactory (name, instance, oj.Validation._defaultValidatorFactories, contractDef);
  oj.Validation._registerFactory(name, instance, oj.Validation._validatorFactories, contractDef);
};


/**
 * Checks that the instance implements the interface type. If it doesn't it throws an error.
 * @param {Object} instance
 * @param {Object} type
 * @param {string} typeName 
 * @throws {Error} if instance does not implement the methods defined on type.  
 * @private
 */
oj.Validation._doImplementsCheck = function (instance, type, typeName)
{
  if (type)
  {
    // Check that instance duck types providerType
    if (!oj.Validation._quacksLike(instance, type))
    {
      throw new Error("Factory instance does not implement the methods expected by the factory of type " + typeName);
    }
  }
};

/**
 * Retrieves the converter factory by name from the provided factories.
 * @private
 */
oj.Validation._getFactory = function(name, factories)
{
  oj.Assert.assertString(name);
  var cachedInstance = null;
  
  if (name)
  {
    name = name.toLowerCase();

    // getter called to retrieve the factory instance 
    var providerProps = factories[name] || {}; 
    cachedInstance = providerProps['instance'] || null;
  }
  // TODO: log a warning that name is null
  return cachedInstance;
};

/**
 * Tests whether an object 'quacks like a duck'. Returns `true` if the thingie has all of the 
 * methods of the second, parameter 'duck'. Returns `false` otherwise. 
 *
 * @param {Object} thingie the object to test.
 * @param {Object} duck The archetypal object, or 'duck', that the test is against.
 * @private
*/
oj.Validation._quacksLike = function(thingie, duck) 
{
  var valid = true, property;

  oj.Assert.assertObject(thingie);
  oj.Assert.assertObject(duck);

  for (property in duck) 
  {
    // Ensure that thingie defines the same functions as duck. We don't care about other properties
    if (duck.hasOwnProperty(property)) 
    {
      if (typeof duck[property] === "function" && 
              !thingie[property] && typeof thingie[property] !== "function") 
      {
        valid = false;
        break;
      }
    }
  }
  
  return valid;
};

/**
 * Registers the factory instance by the name, storing it into the factories object, after ensruing 
 * that the instance duck types the specified contract.
 * 
 * @private
 */
oj.Validation._registerFactory = function(name, instance, factories, contractDef)
{
  oj.Assert.assertString(name);
  oj.Assert.assertObject(instance);

  if (name)
  {
    // set new provider factory function clearing out the previously stored instance
    var props = {};
    props['instance'] = instance;
    oj.Validation._doImplementsCheck(instance, contractDef.type, contractDef.name);

    // Save to default and public factories
    factories[name.toLowerCase()] = props;
  }
};

/**
 * Contract for a ConverterFactory that provides a factory method to create a converter instance for 
 * the requested type. JET provides 2 factory implementations for number and datetime types that 
 * implement this contract. Customers can register custom converter factories for the supported 
 * types or create and register factories for new types altogether.
 * 
 * @name oj.ConverterFactory
 * @abstract
 * @class
 * @export
 * @see oj.Validation
 * @see oj.NumberConverterFactory
 * @see oj.DateTimeConverterFactory
 */
oj.ConverterFactory = 
{
  /**
   * Default type for a factory used to create number converters. This type is passed to the 
   * [Validation.converterFactory]{@link oj.Validation#converterFactory} method to retrieve the 
   * number converter factory of type {@link oj.NumberConverterFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "CONVERTER_TYPE_NUMBER" : 'number',
  
  /**
   * Default type for a factory used to create datetime converters. This type is passed to the 
   * [Validation.converterFactory]{@link oj.Validation#converterFactory} method to retrieve the 
   * datetime converter factory of type {@link oj.DateTimeConverterFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "CONVERTER_TYPE_DATETIME" : 'datetime',

  /**
   * Creates an immutable converter instance of the type the factory implements. 
   * 
   * @param {(Object|null)} options an object literal containing properties required by the converter 
   * for its initialization. The properties provided in the options is implementation specific.
   * 
   * @return {Object} a converter instance.
   * @throws {TypeError} if an unrecognized type was provided 
   * @expose
   */
  createConverter : function(options) {}  
};

/**
 * Contract for a ValidatorFactory that provides a factory method to create a validator instance for 
 * the requested type. JET provides several factory implementations that implement this contract - 
 * for example dateRestriction, dateTimeRange, numberRange, length, required, regexp. Customers can 
 * register custom validator factories for the supported types or create and register factories for 
 * new types altogether.
 * 
 * @name oj.ValidatorFactory
 * @abstract
 * @class
 * @export
 * @see oj.Validation
 * @see oj.DateRestrictionValidatorFactory
 * @see oj.DateTimeRangeValidatorFactory
 * @see oj.LengthValidatorFactory
 * @see oj.NumberRangeValidatorFactory
 * @see oj.RegExpValidatorFactory
 * @see oj.RequiredValidatorFactory
 */
oj.ValidatorFactory = 
{
  /**
   * Default type for a factory used to create required validators. This type is passed to the 
   * [Validation.validatorFactory]{@link oj.Validation#validatorFactory} method to retrieve the 
   * required validator factory of type {@link oj.RequiredValidatorFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "VALIDATOR_TYPE_REQUIRED" : 'required',
          
  /**
   * Default type for a factory used to create regExp validators. This type is passed to the 
   * [Validation.validatorFactory]{@link oj.Validation#validatorFactory} method to retrieve the 
   * regExp validator factory of type {@link oj.RegExpValidatorFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "VALIDATOR_TYPE_REGEXP" : 'regexp',

  /**
   * Default type for a factory used to create numberRange validators. This type is passed to the 
   * [Validation.validatorFactory]{@link oj.Validation#validatorFactory} method to retrieve the 
   * numberRange validator factory of type {@link oj.NumberRangeValidatorFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "VALIDATOR_TYPE_NUMBERRANGE" : 'numberRange',

  /**
   * Default type for a factory used to create length validators. This type is passed to the 
   * [Validation.validatorFactory]{@link oj.Validation#validatorFactory} method to retrieve the 
   * length validator factory of type {@link oj.LengthValidatorFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "VALIDATOR_TYPE_LENGTH" : 'length',

  /**
   * Default type for a factory used to create required validators. This type is passed to the 
   * [Validation.validatorFactory]{@link oj.Validation#validatorFactory} method to retrieve the 
   * dateTimeRange validator factory of type {@link oj.DateTimeRangeValidatorFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "VALIDATOR_TYPE_DATETIMERANGE" : 'dateTimeRange',
  
  /**
   * Default type for a factory used to create date restriction validators. This type is passed to 
   * the [Validation.validatorFactory]{@link oj.Validation#validatorFactory} method to retrieve the 
   * dateRestriction validator factory of type {@link oj.DateRestrictionValidatorFactory}. 
   * @expose
   * @const
   * @member
   * @type {string}
   */
  "VALIDATOR_TYPE_DATERESTRICTION" : 'dateRestriction',
          
  /**
   * Creates an immutable validator instance of the type the factory implements. 
   * 
   * @param {(Object|null)} options an object literal containing properties required by the validator 
   * for its initialization. The properties provided in the options is implementation specific.
   * 
   * @return {Object} a validator instance.
   * @throws {TypeError} if an unrecognized type was provided 
   * @expose
   */
  createValidator : function(options) {}  
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Converter Contract
 */

/**
 * Constructs an immutable instance of Converter.
 * 
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 * @constructor
 * @since 0.6
 */
oj.Converter = function(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.Converter, oj.Object, "oj.Converter");


/**
 * Initializes converter instance with the set options
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.Converter.prototype.Init = function(options) 
{
  oj.Converter.superclass.Init.call(this);
  // should we make options truly immutable? non-configurable, non-enumerable, non-writable
  // Object.defineProperty(oj.Converter.prototype, "_options", {value: options});
  this._options = options;
};

/**
 * Returns a hint that describes the converter format expected.
 * @return {String|null} a hint describing the format the value is expected to be in.
 * @export
 */
oj.Converter.prototype.getHint = function () 
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Returns the options called with converter initialization.
 * @return {Object} an object of options.
 * @export
 */
oj.Converter.prototype.getOptions = function () 
{
  return (this._options || {});
};

/**
 * Parses a String value using the options provided. 
 * 
 * @param {String} value to parse
 * @return {(Number|Date)} the parsed value. 
 * @throws {Error} if parsing fails
 * @export
 */
oj.Converter.prototype.parse = function (value) 
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Formats the value using the options provided. 
 * 
 * @param {(Number|Date)} value the value to be formatted for display
 * @return {(String|null)} the localized and formatted value suitable for display
 * @throws {Error} if formatting fails.
 * @export
 */
oj.Converter.prototype.format = function (value) 
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Returns an object literal with locale and formatting options computed during initialization of 
 * the object. If options was not provided at the time of initialization, the properties will be 
 * derived from the locale defaults.
 * @return {Object} an object of resolved options.
 * @export
 */
oj.Converter.prototype.resolvedOptions = function ()
{
  var resolved = {};
  // returns a clone of this._options
  $.extend(resolved, this._options);
  
  return resolved;
};


// oj.ConverterError

/**
 * Constructs a ConverterError instance from a summary and detail 
 * 
 * @param {string} summary a localized String that provides a summary of the error
 * @param {string} detail a localized String that provides a detail of the error
 * @constructor
 * @export
 */
oj.ConverterError = function (summary, detail)
{
  var message = new oj.Message(summary, detail, oj.Message.SEVERITY_LEVEL['ERROR']);
  this.Init(message); 
};

oj.ConverterError.prototype = new Error();

/**
 * Initializes the instance. 
 * @param {Object} message instance of oj.Message
 * @export
 */
oj.ConverterError.prototype.Init = function (message)
{
  var detail = message['detail'], summary = message['summary'];
  this._message = message;

  // so browser can get to e.name and e.message 
  this.name = 'Converter Error';
  this.message = detail || summary;
};

/**
 * Returns an instance of oj.Message.
 * 
 * @return {Object} instance of oj.Message
 * @export
 */
oj.ConverterError.prototype.getMessage = function ()
{
  return this._message;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * oj.NumberConverter Contract. 
 */

/**
 * @export
 * @constructor
 * @augments oj.Converter 
 * @name oj.NumberConverter
 * @since 0.6
 */
oj.NumberConverter = function()
{
  this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.NumberConverter, oj.Converter, "oj.NumberConverter");

/**
 * Initializes the number converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.NumberConverter.prototype.Init = function(options) 
{
  oj.NumberConverter.superclass.Init.call(this, options);
};

/**
 * Formats the Number value using the options provided and returs a String value.
 * 
 * @param {Number} value the value to be formatted for display
 * @return {(String|null)} the localized and formatted value suitable for display
 * @throws {Error} a ConverterError if formatting fails.
 * @export
 */
oj.NumberConverter.prototype.format = function (value) 
{
  return oj.NumberConverter.superclass.format.call(this, value);
};

/**
 * Parses the value using the options provided and returns a Number object.
 * 
 * @param {String} value to parse
 * @return {Number} the parsed value as a Number object.
 * @throws {Error} a ConverterError if parsing fails
 * @export
 */
oj.NumberConverter.prototype.parse = function (value) 
{
  return oj.NumberConverter.superclass.parse.call(this, value);
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * oj.DateTimeConverter Contract. 
 */

/**
 * @constructor
 * @param {Object=} options an object literal used to provide an optional information to 
 * @augments oj.Converter 
 * @name oj.DateTimeConverter
 * @export
 * @since 0.6
 */
oj.DateTimeConverter = function(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DateTimeConverter, oj.Converter, "oj.DateTimeConverter");

/**
 * Initializes the date time converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.DateTimeConverter.prototype.Init = function(options) 
{
  oj.DateTimeConverter.superclass.Init.call(this, options);
};

/**
 * Formats the Date value using the options provided and returns a String value.
 * 
 * @param {Date} value to be formatted for display
 * @return {(String|null)} the localized and formatted value suitable for display
 * @throws {Error} a ConverterError if formatting fails.
 * @export
 */
oj.DateTimeConverter.prototype.format = function (value) 
{
  return oj.DateTimeConverter.superclass.format.call(this, value);
};


/**
 * Returns true if a 24-hour format is set; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isHourInDaySet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if 12-hour is set; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isHourInAMPMSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if minutes are shown in the time portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isMinuteSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if seconds are shown in the time portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isSecondSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if milliseconds are shown in the time portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isMilliSecondSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if year is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isYearSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if month is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isMonthSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if day is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isDaySet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if the day name is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isDayNameSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Parses the value using the options provided and returns a Date value.
 * 
 * @param {String} value to parse
 * @return {Date} the parsed value as a Date object.
 * @throws {Error} a ConverterError if parsing fails
 * @export
 */
oj.DateTimeConverter.prototype.parse = function (value) 
{
  return oj.DateTimeConverter.superclass.parse.call(this, value);
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Validator Contract
 */

/**
 * @constructor
 * @export
 * @since 0.6
 * 
 */
oj.Validator = function()
{
  this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.Validator, oj.Object, "oj.Validator");

/**
 * Initializes validator instance with the set options
 * @export
 */
oj.Validator.prototype.Init = function() 
{
  oj.Validator.superclass.Init.call(this);
};

/**
 * Vaidates the value.
 * 
 * @param {Object} value to be validated
 * @return {*} a boolean true if validation passes.
 * @throws Error if validation fails
 * @export
 */
oj.Validator.prototype.validate = function (value) {
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns a hint that describes the validator rule.
 * @returns {*} a hint string or null
 * @export
 */
oj.Validator.prototype.getHint = function () 
{
  oj.Assert.failedInAbstractFunction();
};

// ValidatorError

/**
 * Constructs a ValidatorError instance from a summary and detail 
 * 
 * @param {string} summary a localized String that provides a summary of the error
 * @param {string} detail a localized String that provides a detail of the error
 * @constructor
 * @export
 */
oj.ValidatorError = function (summary, detail)
{
  var message = new oj.Message(summary, 
                               detail, 
                               oj.Message.SEVERITY_LEVEL['ERROR']);
  this.Init(message); 
};

oj.ValidatorError.prototype = new Error();

/**
 * Initializes the instance. 
 * @param {Object} message an instance of oj.Message
 * @export
 */
oj.ValidatorError.prototype.Init = function (message)
{
  var detail = message['detail'], summary = message['summary'];
  this._message = message;

  // so browser can get to e.name and e.message 
  this.name = 'Validator Error';
  this.message = detail || summary;
};

/**
 * Returns an instance of oj.Message.
 * 
 * @returns {Object} instance of oj.Message
 * @export
 */
oj.ValidatorError.prototype.getMessage = function ()
{
  return this._message;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * This is a forked version of globalize.js
 */
/*
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

/*
   DESCRIPTION
   OraDateTimeConverter object implements date-time parsing and formatting and 
   relative date formatting. It supports ECMA-402 options, predefined and user 
   defined pattern.

   PRIVATE CLASSES
    <list of private classes defined - with one-line descriptions>

   NOTES
    <other useful comments, qualifications, etc.>

   MODIFIED    (MM/DD/YY)
   gmurr       05/13/14 - Creation
 */

/*
 *OraDateTimeConverter object implements date-time parsing and formatting and 
 *relative date formatting.It supports ECMA-402 options, predefined and user 
 *defined pattern.
 * <p>The format and parse functions can throw the following exceptions:
 * <li> RangeError can be thrown during the validation of the options:
 * Example: The value 'longs' is out of range for 'OraDateTimeConverter.parse'
 * options property 'year'. Expected: ['2-digit', 'numeric']<br>
 * var errorInfo = {<br>
 *   'errorCode' : "datetimeOutOfRange",<br>
 *   'parameterMap' : {<br>
 *   'propertyName': $property$,<br>
 *   'propertyValue': $options.property$,<br>
 *   'propertyValueValid': $expectedValues$,<br>
 *   'caller': $_getOptionCaller$<br>
 * }<br>
 * };<br>
 * <br>
 * <li>SyntaxError can be thrown when the date format is invalid. it can happen
 * during the calls to parse and format date.<br>
 * Example: Unexpected character(s) encountered in the pattern "MM/dd/cc".<br>
 * An example of a valid pattern is "MM/dd/y".<br>
 * var errorInfo = {<br>
 * 'errorCode' : "optionValueInvalid",<br> 
 * parameterMap : {'propertyName' : 'pattern',<br>
 *                 'propertyValue': $options.pattern$,<br>
 *                 'propertyValueHint': $format$}<br>
 * };<br>
 * <br>
 * <br>
 * <li>Error can be thrown when there is mismatch between date format and
 * date string. it can happen during the calls to parse date.<br>
 * Example: The value "03,05,12" does not match the expected date format
 * "MM/dd/yy"<br>
 * var errorInfo = {'errorCode' : "datetimeFormatMismatch", 'parameterMap' : 
 * { 'value': $value$,  'format': $format$}};<br>
 * errorInfo = {'errorCode' : "timeFormatMismatch", 'parameterMap' : 
 * { 'value': $value$,  'format': $format$}};<br>
 * verrorInfo = {'errorCode' : "dateFormatMismatch", 'parameterMap' : 
 * { 'value': $value$,  'format': $format$}};<br>
 * <br>
 * <br>
 * <li>RangeError can be thrown if one of the date fields is out of range.
 * It can happen during the calls to parse date.<br>
 * Example: 64  is out of range.  Enter a value between 0 and 59 for minute 
 * var errorInfo = {<br>
 * 'errorCode' : "datetimeOutOfRange",<br>
 * 'parameterMap' : {'value': $value$, 'minValue': $mainValue$,
 * 'maxVlaue': $maxValue$, 'propertyName': $name$}<br>
 * };<br>
 * <br>
 * <br>
 * <li>Error can be thrown the weekday does not match the date.
 * It can happen during the calls to parse date.<br>
 * Example: The weekday Tuesday does not match the date 27.
 * var errorInfo = {<br>
 * 'errorCode' : "dateToWeekdayMismatch",<br>
 * 'parameterMap' : {'weekday' : $weekday$, 'date':$date$}<br>
 * };<br>
 */
 
var OraDateTimeConverter;
  
OraDateTimeConverter =  (function() {

  var
  _appendPreOrPostMatch,
  _expandFormat,
  _parseExact,
  _formatImpl,
  _parseImpl,
  _formatRelativeImpl,
  _throwInvalidDateFormat,
  _getResolvedOptionsFromPattern,
  _dateTimeStyle,
  _get2DigitYearStart,
  _isHour12,
  _dateTimeStyleFromPattern,
  _expandPredefinedStylesFormat,
  _localeDataCache = {},
  _isLeapYear, _getDaysInMonth, instance,
  _toAvailableFormatsKeys,
  _expandAvailableDateFormatsPattern,
  _expandAvailableTimeFormatsPattern,
  _basicFormatMatcher,
  _appendToKey,
  _getDaysDif, _getDayIndex,
  _isSameYear, _isNextYear, _isPrevYear,
  _isSameMonth, _isNextMonth, _isPrevMonth,
  _isSameWeek, _isNextWeek, _isPrevWeek,
  _isSameDay, _isNextDay, _isPrevDay,
  _expandYear,
  _getTokenIndex,
  _parseLenient,
  _parseLenientyMEd,
  _parseLenientyMMMEd,
  _parseLenienthms,
  _getDayIndex1,
  _getMonthIndex,
  _getParseRegExp,
  _validateRange,
  _arrayIndexOfDay,
  _arrayIndexOfMonth,
  _throwDateFormatMismatch,
  _throwWeekdayMismatch, _createParseISOString,
  _getTimePart, _getNameIndex, _getWeekdayName;

  var _YEAR_AND_DATE_REGEXP = /(\d{1,4})\D+?(\d{1,4})/g;
  var _YMD_REGEXP = /(\d{1,4})\D+?(\d{1,4})\D+?(\d{1,4})/g;
  var _MONTH_REGEXP_FMT =/^[M][^M]|[^M]M[^M]/g;
  var _MONTH_REGEXP_STD =/^[L][^L]|[^L]L[^L]/g;
  var _DAY_REGEXP =/^[d][^d]|[^d]d[^d]/g;
  var _HOUR_REGEXP=/(?:^|[^h])h[^h]|[^H]H[^H]|[^k]k[^k]|[^K]K[^K]/;
  var _TIME_REGEXP = /(\d{1,2})(?:\D+?(\d{1,2}))?(?:\D+?(\d{1,2}))?(?:\D+?(\d{1,3}))?/g;
  var _TIME_FORMAT_REGEXP= /h|H|K|k/g;
  var _ESCAPE_REGEXP = /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g;
  var _TOKEN_REGEXP = /ccccc|cccc|ccc|cc|c|EEEEE|EEEE|EEE|EE|E|dd|d|MMMMM|MMMM|MMM|MM|M|LLLLL|LLLL|LLL|LL|L|yyyy|yy|y|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|aa|a|SSS|SS|S|zzzz|zzz|zz|z|GGGGG|GGGG|GGG|GG|G/g;
  var _TIME_FORMATS_Z_TOKENS = /\s?(?:\(|\[)??z{1,4}(?:\)|\])?/g;
  var _ISO_DATE_REGEXP = /^\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{1,3})?)?Z?)?$|^T\d{2}:\d{2}(?::\d{2}(?:\.\d{1,3})?)?Z?$/;
      
  var _DAYS_INDEXES = {
    0: "sun", 
    1: "mon", 
    2: "tue", 
    3: "wed", 
    4: "thu", 
    5: "fri", 
    6: "sat"
  };


  var _ALNUM_REGEXP = '(\\D+|\\d\\d?\\D|\\d\\d?|\\D+\\d\\d?)',
  _NON_DIGIT_REGEXP ='(\\D+|\\D+\\d\\d?)',
  _NON_DIGIT_OPT_REGEXP = '(\\D*)',
  _TWO_DIGITS_REGEXP = '(\\d\\d?)',
  _THREE_DIGITS_REGEXP = '(\\d{1,3})',
  _FOUR_DIGITS_REGEXP = '(\\d{1,4})',
  _TZ_REGEXP = '([+-]?\\d{1,4})',
  _SLASH_REGEXP = '(\\/)';
  
  var _PROPERTIES_MAP = {
    'MMM' : {
      'token' : 'months',
      'style' : 'format',
      'mLen' : 'abbreviated',
      'matchIndex': 0,
      'key' : 'month',
      'value' : 'short',
      'regExp' : _ALNUM_REGEXP
    },
    'MMMM' : {
      'token' : 'months',
      'style' : 'format',
      'mLen' : 'wide',
      'matchIndex': 0,
      'key' : 'month',
      'value' : 'long',
      'regExp' : _ALNUM_REGEXP
    },
    'MMMMM' : {
      'token' : 'months',
      'style' : 'format',
      'mLen' : 'narrow',
      'matchIndex': 0,
      'key' : 'month',
      'value' : 'narrow',
      'regExp' : _ALNUM_REGEXP
    },
    'LLL' : {
      'token' : 'months',
      'style' : 'stand-alone',
      'mLen' : 'abbreviated',
      'matchIndex': 1,
      'key' : 'month',
      'value' : 'short',
      'regExp' : _ALNUM_REGEXP
    },
    'LLLL' : {
      'token' : 'months',
      'style' : 'stand-alone',
      'mLen' : 'wide',
      'matchIndex': 1,
      'key' : 'month',
      'value' : 'long',
      'regExp' : _ALNUM_REGEXP
    },
    'LLLLL' : {
      'token' : 'months',
      'style' : 'stand-alone',
      'mLen' : 'narrow',
      'matchIndex': 1,
      'key' : 'month',
      'value' : 'narrow',
      'regExp' : _ALNUM_REGEXP
    },
    'E' : {
      'token' : 'days',
      'style' : 'format',
      'dLen' : 'abbreviated',
      'matchIndex': 0,
      'key' : 'weekday',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'EE' : {
      'token' : 'days',
      'style' : 'format',
      'dLen' : 'abbreviated',
      'matchIndex': 0,
      'key' : 'weekday',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'EEE' : {
      'token' : 'days',
      'style' : 'format',
      'dLen' : 'abbreviated',
      'matchIndex': 0,
      'key' : 'weekday',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'EEEE' : {
      'token' : 'days',
      'style' : 'format',
      'dLen' : 'wide',
      'matchIndex': 0,
      'key' : 'weekday',
      'value' : 'long',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'EEEEE' : {
      'token' : 'days',
      'style' : 'format',
      'dLen' : 'narrow',
      'matchIndex': 0,
      'key' : 'weekday',
      'value' : 'narrow',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'c' : {
      'token' : 'days',
      'style' : 'stand-alone',
      'dLen' : 'abbreviated',
      'matchIndex': 1,
      'key' : 'weekday',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'cc' : {
      'token' : 'days',
      'style' : 'stand-alone',
      'dLen' : 'abbreviated',
      'matchIndex': 1,
      'key' : 'weekday',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'ccc' : {
      'token' : 'days',
      'style' : 'stand-alone',
      'dLen' : 'abbreviated',
      'matchIndex': 1,
      'key' : 'weekday',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'cccc' : {
      'token' : 'days',
      'style' : 'stand-alone',
      'dLen' : 'wide',
      'matchIndex': 1,
      'key' : 'weekday',
      'value' : 'long',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'ccccc' : {
      'token' : 'days',
      'style' : 'stand-alone',
      'dLen' : 'narrow',
      'matchIndex': 1,
      'key' : 'weekday',
      'value' : 'narrow',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'h' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 11,
      'start2' : 1,
      'end2' : 12,
      'key' : 'hour',
      'value' : 'numeric',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'hh' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 11,
      'start2' : 1,
      'end2' : 12,
      'key' : 'hour',
      'value' : '2-digit',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'K' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 11,
      'start2' : 0,
      'end2' : 11,
      'key' : 'hour',
      'value' : 'numeric',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'KK' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 11,
      'start2' : 0,
      'end2' : 11,
      'key' : 'hour',
      'value' : '2-digit',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'H' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 23,
      'start2' : 0,
      'end2' : 23,
      'key' : 'hour',
      'value' : 'numeric',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'HH' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 23,
      'start2' : 0,
      'end2' : 23,
      'key' : 'hour',
      'value' : '2-digit',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'k' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 23,
      'start2' : 1,
      'end2' : 24,
      'key' : 'hour',
      'value' : 'numeric',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'kk' : {
      'token' : 'time',
      'timePart' : 'hour',
      'start1' : 0,
      'end1' : 23,
      'start2' : 1,
      'end2' : 24,
      'key' : 'hour',
      'value' : '2-digit',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'm' : {
      'token' : 'time',
      'timePart' : 'minute',
      'start1' : 0,
      'end1' : 59,
      'start2' : 0,
      'end2' : 59,
      'key' : 'minute',
      'value' : 'numeric',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'mm' : {
      'token' : 'time',
      'timePart' : 'minute',
      'start1' : 0,
      'end1' : 59,
      'start2' : 0,
      'end2' : 59,
      'key' : 'minute',
      'value' : '2-digit',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    's' : {
      'token' : 'time',
      'timePart' : 'second',
      'start1' : 0,
      'end1' : 59,
      'start2' : 0,
      'end2' : 59,
      'key' : 'second',
      'value' : 'numeric',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'ss' : {
      'token' : 'time',
      'timePart' : 'second',
      'start1' : 0,
      'end1' : 59,
      'start2' : 0,
      'end2' : 59,
      'key' : 'second',
      'value' : '2-digit',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'S' : {
      'token' : 'time',
      'timePart' : 'millisec',
      'start1' : 0,
      'end1' : 999,
      'start2' : 0,
      'end2' : 999,
      'key' : 'millisecond',
      'value' : 'numeric',
      'regExp' : _THREE_DIGITS_REGEXP
    },
    'SS' : {
      'token' : 'time',
      'timePart' : 'millisec',
      'start1' : 0,
      'end1' : 999,
      'start2' : 0,
      'end2' : 999,
      'key' : 'millisecond',
      'value' : 'numeric',
      'regExp' : _THREE_DIGITS_REGEXP
    },
    'SSS' : {
      'token' : 'time',
      'timePart' : 'millisec',
      'start1' : 0,
      'end1' : 999,
      'start2' : 0,
      'end2' : 999,
      'key' : 'millisecond',
      'value' : 'numeric',
      'regExp' : _THREE_DIGITS_REGEXP
    },
    'd' : {
      'token' : 'dayOfMonth',
      'key' : 'day',
      'value' : 'numeric',
      'getPartIdx' : 2,
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'dd' : {
      'token' : 'dayOfMonth',
      'key' : 'day',
      'value' : '2-digit',
      'getPartIdx' : 2,
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'M' : {
      'token' : 'monthIndex',
      'key' : 'month',
      'value' : 'numeric',
      'getPartIdx' : 1,
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'MM' : {
      'token' : 'monthIndex',
      'key' : 'month',
      'value' : '2-digit',
      'getPartIdx' : 1,
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'L' : {
      'token' : 'monthIndex',
      'key' : 'month',
      'value' : 'numeric',
      'getPartIdx' : 1,
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'LL' : {
      'token' : 'monthIndex',
      'key' : 'month',
      'value' : '2-digit',
      'getPartIdx' : 1,
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'y' : {
      'token' : 'year',
      'key' : 'year',
      'value' : 'numeric',
      'regExp' : _FOUR_DIGITS_REGEXP
    },
    'yy' : {
      'token' : 'year',
      'key' : 'year',
      'value' : '2-digit',
      'regExp' : _TWO_DIGITS_REGEXP
    },
    'yyyy' : {
      'token' : 'year',
      'key' : 'year',
      'value' : 'numeric',
      'regExp' : _FOUR_DIGITS_REGEXP
    },
    'a' : {
      'token' : 'ampm',
      'key' : 'hour12',
      'value' : true,
      'regExp' : _NON_DIGIT_OPT_REGEXP
    },
    'z' : {
      'token' : 'tz',
      'key' : 'timeZoneName',
      'value' : 'short',
      'regExp' : _TZ_REGEXP
    },
    'zz' : {
      'token' : 'tz',
      'key' : 'timeZoneName',
      'value' : 'short',
      'regExp' : _TZ_REGEXP
    },
    'zzz' : {
      'token' : 'tz',
      'key' : 'timeZoneName',
      'value' : 'short',
      'regExp' : _TZ_REGEXP
    },
    'zzzz' : {
      'token' : 'tz',
      'key' : 'timeZoneName',
      'value' : 'long',
      'regExp' : _TZ_REGEXP
    },
    'G' : {
      'token' : 'era',
      'key' : 'era',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'GG' : {
      'token' : 'era',
      'key' : 'era',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'GGG' : {
      'token' : 'era',
      'key' : 'era',
      'value' : 'short',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'GGGG' : {
      'token' : 'era',
      'key' : 'era',
      'value' : 'long',
      'regExp' : _NON_DIGIT_REGEXP
    },
    'GGGGG' : {
      'token' : 'era',
      'key' : 'era',
      'value' : 'narrow',
      'regExp' : _NON_DIGIT_REGEXP
    },
    '/' : {
      'token' : 'slash',
      'regExp' : _SLASH_REGEXP
    }
  };

  /*
   *Helper functions
   */
  _get2DigitYearStart = function(options) {
    var option = options['two-digit-year-start'];
    if(option === undefined || isNaN(option))
      option = 1950;
    option = parseInt(option, 10);
    return option;
  };
    
  //Each locale has 12 or 24 hour preferred format
  _isHour12 = function(localeElements) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
    var bcp47Keys = OraI18nUtils.parseBCP47(mainNode);
    var territory = bcp47Keys['region'] || '001';
    var prefferedHours = localeElements['supplemental']['prefferedHours'];
    var hour12 = prefferedHours[territory];
    return hour12 === 'h';      
  };
    
  _isLeapYear = function(y) {
    if (y % 400 == 0)
      return true;
    else if (y % 100 == 0)
      return false;
    else if (y % 4 == 0)
      return true;
    else
      return false;
  };
    
  _getDaysInMonth = function(y, m) {
    switch (m) {
      case 0 :
      case 2 :
      case 4 :
      case 6 :
      case 7 :
      case 9 :
      case 11 :
        return 31;
      case 1:
        if(_isLeapYear(y))
          return 29;
        else
          return 28;
      default:
        return 30;
    }
  };

  //returns the locale's pattern from the predefined styles.
  //EX: for en-US dateFormat:"full" returns the pattern "EEEE, MMMM d, y".
  _expandPredefinedStylesFormat = function(options, localeElements, caller) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var getOption = OraI18nUtils.getGetOption(options, caller);
    var fmtType = getOption('formatType', 'string', ['date', 'time', 
      'datetime'], 'date');
    var dStyle = getOption('dateFormat', 'string', 
      ['short', 'medium', 'long', 'full'], 'short');
    var tStyle = getOption('timeFormat', 'string', 
      ['short', 'medium', 'long', 'full'], 'short');
    var cal = mainNode['dates']['calendars']['gregorian'];
    var dateFormats = cal['dateFormats'];
    var timeFormats = cal['timeFormats'];
    
    var dStyleFmt, tStyleFmt, format;
    switch (dStyle)
    {
      case "full" :
        dStyleFmt = dateFormats['full'];
        break;
      case "long" :
        dStyleFmt = dateFormats['long'];
        break;
      case "medium" :
        dStyleFmt = dateFormats['medium'];
        break;
      case "short" :
        dStyleFmt = dateFormats['short'];
        break;
      default:
        break;
    }
    switch (tStyle)
    {
      case "full" :
        tStyleFmt = timeFormats['full'];
        break;
      case "long" :
        tStyleFmt = timeFormats['long'];
        break;
      case "medium" :
        tStyleFmt = timeFormats['medium'];
        break;
      case "short" :
        tStyleFmt = timeFormats['short'];
        break;
      default:
        break;
    }
    if(dStyleFmt !== undefined && (fmtType === "datetime" || 
      fmtType === "date"))
      format = dStyleFmt;
    if(tStyleFmt !== undefined && (fmtType === "datetime" || 
      fmtType === "time")) { 
      tStyleFmt = tStyleFmt.replace(_TIME_FORMATS_Z_TOKENS, '');
      if(format)
        format = format + " " + tStyleFmt;
      else
        format = tStyleFmt;
    }
    return format;
  };
      
  // appends pre- and post- token match strings while removing escaped 
  // characters.
  // Returns a single quote count which is used to determine if the 
  // token occurs
  // in a string literal.
  _appendPreOrPostMatch = function(preMatch, strings) {
    var quoteCount = 0,
    escaped = false;
    for (var i = 0, il = preMatch.length; i < il; i++) {
      var c = preMatch.charAt(i);
      switch (c) {
        case "\'":
          if (escaped) {
            strings.push("\'");
          }
          else {
            quoteCount++;
          }
          escaped = false;
          break;
        case "\\":
          if (escaped) {
            strings.push("\\");
          }
          escaped = !escaped;
          break;
        default:
          strings.push(c);
          escaped = false;
          break;
      }
    }
    return quoteCount;
  };
    
  //Throw an exception if date-time pattern is invalid
  _throwInvalidDateFormat = function(format, options, m) {
    var msg, error, errorInfo, samplePattern;
    var isDate = options['year'] !== undefined || options['month'] !== 
    undefined ||
    options['weekday'] !== undefined || options['day'] !== undefined;
    var isTime = options['hour'] !== undefined || options['minute'] !==
    undefined ||
    options['second'] !== undefined;
    if(isDate && isTime) {
      samplePattern = "MM/dd/yy hh:mm:ss a";
    }
    else if(isDate) {
      samplePattern = "MM/dd/yy";           
    }
    else {
      samplePattern = "hh:mm:ss a";          
    }
    msg = "Unexpected character(s) " + m + " encountered in the pattern \"" +
    format  + " An example of a valid pattern is \"" + samplePattern + '".';
    error = new SyntaxError(msg);
    errorInfo = {
      'errorCode' : 'optionValueInvalid',
      'parameterMap' : {
        'propertyName' : 'pattern',
        'propertyValue' : format,
        'propertyValueHint ': samplePattern
      }
    };
    error['errorInfo'] = errorInfo;
    throw error;
  };
    
  //implementation of basic forat matcher algorithm from ECMA spec.
  //This impelmentation takes into consideration hour12, For example if 
  //hour12=true, H entries are removed from availableFormats in order to
  //avoid wrong matching for hour.
  _basicFormatMatcher = function(dateTimeKeys, localeElements, isDate,
    hour12)
    {          
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var availableFormats = mainNode['dates']['calendars']['gregorian']
    ['dateTimeFormats']['availableFormats'];
    var dateTimeFormats;
    if(isDate)
      dateTimeFormats = ['era', 'year', 'month', 'weekday', 'day'];
    else
      dateTimeFormats = ['weekday', 'hour', 'minute', 'second'];
    //,'timeZoneName'];

    var removalPenalty = 120;
    var additionPenalty = 20;
    var longLessPenalty = 8;
    var longMorePenalty = 6;
    var shortLessPenalty = 6;
    var shortMorePenalty = 3;
    var bestScore = -Infinity;
    var bestFormat = undefined; 
    var match;
    for(var f in availableFormats) {
      var format = {};
      format['pattern'] = availableFormats[f];
      var score = 0;
      while ((match = _TOKEN_REGEXP.exec(f)) !== null) {
        var m = match[0];
        if((m === 'h' || m === 'hh') && !hour12) {
          continue;
        }
        else if ((m === 'H' || m === 'HH') && hour12) {
          continue;
        }
        if(_PROPERTIES_MAP[m] !== undefined) {
          format[_PROPERTIES_MAP[m]['key']] = 
          _PROPERTIES_MAP[m]['value'];
        }
      }
      for(var property in dateTimeFormats) {
        var optionsProp = dateTimeKeys[dateTimeFormats[property]];
        var formatProp = format[dateTimeFormats[property]];
        if(optionsProp === undefined && formatProp !== undefined) {
          score -= additionPenalty;
        }
        else if(optionsProp !== undefined && formatProp === undefined) {
          score -= removalPenalty;
        }
        else if(optionsProp !== undefined && formatProp !== undefined){
 
          var values = {
            '2-digit':0, 
            'numeric':1, 
            'narrow':2, 
            'short':3, 
            'long':4
          };
          var optionsPropIndex = values[optionsProp];
          var formatPropIndex = values[formatProp];
          var delta = Math.max(Math.min(formatPropIndex - 
            optionsPropIndex, 2), -2);
          if(delta === 2) {
            score -= longMorePenalty;
          }
          else if(delta ===1 ) {
            score -= shortMorePenalty;
          }
          else if(delta === -1) {
            score -= shortLessPenalty;
          }
          else if(delta === -2) {
            score -= longLessPenalty;
          }
        }
      }
      if(score > bestScore) {
        bestScore = score;
        bestFormat = format;
      }         
    }
    if(bestFormat !== undefined) {
      return bestFormat['pattern'];
    }
    return null;
  };
      
  //Return a format key from ecma options. For example:
  //{year:"2-digit", month:"long", day:"numeric", weekday:"long"};
  //will return "yyMMMMdEEEE"
  _toAvailableFormatsKeys = function (options, localeElements, caller) {
    var dateKey = '', timeKey = '';
    var dateOptions = {}, timeOptions = {};
  
    var getOption = OraI18nUtils.getGetOption(options, caller);
          
    //date key
    var option = getOption('era', 'string', ['narrow', 'short', 'long']);
    dateKey += _appendToKey(dateOptions, 'era',
      option, {
        'narrow': 'GGGGG', 
        'short': 'GGG', 
        'long': 'GGGG'
      });            
  
    option = getOption('year',  'string', ['2-digit', 'numeric']); 
    dateKey += _appendToKey(dateOptions, 'year',
      option, {
        '2-digit': 'yy', 
        'numeric': 'y'
      });

    option = getOption('month', 'string', ['2-digit', 'numeric', 'narrow',
      'short', 'long']);
    dateKey += _appendToKey(dateOptions, 'month',
      option, {
        '2-digit': 'MM', 
        'numeric': 'M',
        'narrow': 'MMMMM', 
        'short': 'MMM', 
        'long': 'MMMM'
      });

    option = getOption('weekday', 'string', ['narrow', 'short', 'long']);
    dateKey += _appendToKey(dateOptions, 'weekday',
      option, {
        'narrow': 'EEEEE', 
        'short': 'E', 
        'long': 'EEEE'
      });

    option = getOption('day', 'string', ['2-digit', 'numeric']);
    dateKey += _appendToKey(dateOptions, 'day',
      option, {
        '2-digit': 'dd', 
        'numeric': 'd'
      });
   
    //time key
    var hr12 = getOption('hour12', 'boolean', [true, false]);
    if(hr12 === undefined)
      hr12 = _isHour12(localeElements);
    option = getOption('hour', 'string', ['2-digit', 'numeric']);
    if (hr12 === true) {
      timeKey += _appendToKey(timeOptions, 'hour',
        option, {
          '2-digit': 'hh', 
          'numeric': 'h'
        });
    } 
    else {
      timeKey += _appendToKey(timeOptions, 'hour',
        option, {
          '2-digit': 'HH', 
          'numeric': 'H'
        });
    }

    option = getOption('minute', 'string', ['2-digit', 'numeric']);
    timeKey += _appendToKey(timeOptions, 'minute',
      option, {
        '2-digit': 'mm', 
        'numeric': 'm'
      });

    option = getOption('second', 'string', ['2-digit', 'numeric']);
    timeKey += _appendToKey(timeOptions, 'second',
      option, {
        '2-digit': 'ss', 
        'numeric': 's'
      });
            
    return [dateKey, timeKey, dateOptions, timeOptions];
  };
        
  _appendToKey = function (obj, prop, option, pairs) {
    if (option !== undefined) {
      obj[prop] = option;
      return pairs[option];
    } else {
      return '';
    }
  };


  /*
   *This function is used by the munger algorith. It expands a pattern
   *in order to match the user's ECMA options.
   *For example if the user provided options is 
   *options = {year: 'numeric', month: 'long', weekday: 'long',
   *day : '2-digit'}; 
   *The key for these options is: yMMMMEEEEdd. under availableFormats, 
   *we have the following entry: "yMMMEd": "E, MMM d, y".
   *The _basicFormatMatcher algorithm will find "yMMMEd" key as the 
   *closest match to yMMMMEEEEdd. If formatMatcher ="munger", we will 
   *expand the corresponding pattern to match the options. 
   *So "E, MMM d, y" will be expanded to "EEEE, MMMM dd y".
   */        
  _expandAvailableDateFormatsPattern = function (formatTemplate, options,
    caller)
    {
    var datePat = formatTemplate, match;
    var getOption = OraI18nUtils.getGetOption(options, caller);
    //year
    var option = getOption('year', 'string', ['2-digit', 'numeric']);
    var pairs =  {
      '2-digit': 'yy', 
      'numeric': 'yyyy'
    };
    if(option !== undefined)
      datePat = datePat.replace(/y{1,4}/, pairs[option]);

    //month
    option = getOption('month', 'string', ['2-digit', 'numeric', 'narrow',
      'short', 'long']);
    if(option !== undefined) {
      pairs = {
        '2-digit': 'MM', 
        'numeric': 'M', 
        'narrow': 'MMMMM', 
        'short': 'MMM', 
        'long': 'MMMM'
      };
      var pairsL = {
        '2-digit': 'LL', 
        'numeric': 'L', 
        'narrow': 'LLLLL', 
        'short': 'LLL', 
        'long': 'LLLL'
      };
      if(pairs[option] !== undefined && pairs[option].length > 2) {
        datePat = datePat.replace(/M{3,5}/, pairs[option]);
        datePat = datePat.replace(/L{3,5}/, pairsL[option]);
      }
      else if(option === '2-digit') {
        _MONTH_REGEXP_FMT.lastIndex = 0;
        match= _MONTH_REGEXP_FMT.test(formatTemplate);
        if(match) {
          datePat = datePat.replace('M', 'MM');
        }
        match= _MONTH_REGEXP_STD.test(formatTemplate);
        if(match) {
          datePat = datePat.replace('L', 'LL');
        }
      }
    }
            
    //weekday
    option = getOption('weekday', 'string', ['narrow', 'short', 'long']);
    if(option !== undefined) { 
      var pairsFormat = {
        'narrow': 'EEEEE', 
        'short': 'EEE', 
        'long': 'EEEE'
      };
      var pairsStandalone = {
        'narrow': 'ccccc', 
        'short': 'ccc', 
        'long': 'cccc'
      };
      datePat = datePat.replace(/E{1,5}/, pairsFormat[option]);
      datePat = datePat.replace(/c{1,5}/, pairsStandalone[option]);
    }
    //day

    option = getOption('day', 'string', ['2-digit', 'numeric']);
    if(option !== undefined) { 
      if(option === '2-digit') {
        _DAY_REGEXP.lastIndex = 0;
        match = _DAY_REGEXP.test(formatTemplate);
        if(match) {
          datePat = datePat.replace('d', 'dd');
        }
      }
    }          
    return datePat;
  };
      
  //Same as above for time entries
  _expandAvailableTimeFormatsPattern = function (formatTemplate, options,
    caller) {
    var timePat = formatTemplate;
    var getOption = OraI18nUtils.getGetOption(options, caller);
    var option = getOption('hour', 'string', ['2-digit', 'numeric']);
    if(option === '2-digit') {
      _HOUR_REGEXP.lastIndex = 0;
      var match= _HOUR_REGEXP.exec(formatTemplate);
      if(match !== null) {
        var len = match[0].length-2;
        var ext = match[0][len] + match[0][len];
        timePat = formatTemplate.replace(match[0][len], ext);
      }
    }
    return timePat;
  };
        
  //Returns a pattern corresponding to user's options.
  //Cache the entries for which we already found a pattern 
  _expandFormat = function(options, localeElements, caller) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var locale = OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
    var getOption = OraI18nUtils.getGetOption(options, caller);
    var pattern;
    var matcher = getOption('formatMatcher',  'string', 
      ['basic', 'munger'], 'munger');
    var count = 0;
    for(count in options){
      count++;
    }
    if(count == 0) {
      options = {
        'year': 'numeric', 
        'month': 'numeric', 
        'day': 'numeric'
      };
    }

    var dateTimeKeys = _toAvailableFormatsKeys(options, localeElements, 
      caller);
    //First try to get the pattern from cache
    if(_localeDataCache[locale] !== undefined) {
      if(_localeDataCache[locale]['dates']['calendars']['gregorian']
        ['dateTimeFormats'][dateTimeKeys[0] + dateTimeKeys[1]] !==
        undefined){
        return _localeDataCache[locale]['dates']['calendars']['gregorian']['dateTimeFormats'][dateTimeKeys[0] + dateTimeKeys[1]];
      }
    }          
    if(dateTimeKeys[0] === '' && dateTimeKeys[1] === '') {
      return _expandPredefinedStylesFormat(options, localeElements, 
        caller);
    }
    var availableFormats = mainNode['dates']['calendars']['gregorian']
    ['dateTimeFormats']['availableFormats'];
    var datePattern = availableFormats[dateTimeKeys[0]];
    var hour12 = getOption('hour12', 'boolean', [true, false]);
    if(hour12 === undefined)
      hour12 = _isHour12(localeElements);
    if(datePattern === undefined && dateTimeKeys[0] !== '') {
      var dateTemplatePattern = _basicFormatMatcher(dateTimeKeys[2], 
        localeElements, true, hour12);
      if(dateTemplatePattern !== null) {
        if(matcher === 'basic') {
          datePattern = dateTemplatePattern;
        }
        else {
          datePattern = _expandAvailableDateFormatsPattern(
            dateTemplatePattern, options, caller);
        }
      }
      else
        datePattern = dateTimeKeys[0];
    }
    var timePattern = availableFormats[dateTimeKeys[1]];
    if(timePattern === undefined && dateTimeKeys[1] !== '') {
      var timeTemplatePattern = _basicFormatMatcher(dateTimeKeys[3],
        localeElements, false, hour12);
      if(timeTemplatePattern !== null) {
        if(matcher === 'basic')
          timePattern = timeTemplatePattern;
        else
          timePattern = _expandAvailableTimeFormatsPattern(
            timeTemplatePattern, options, caller);
      }
      else
        timePattern = dateTimeKeys[1];
    }
    pattern = datePattern || '';
    if(timePattern !== undefined)
    {
      if(pattern !== '')
        pattern += ' ' + timePattern;
      else
        pattern = timePattern;
    }
    //cache the pattern
    if(_localeDataCache[locale] === undefined) {
      _localeDataCache[locale] = {};
      _localeDataCache[locale]['dates'] = {};
      _localeDataCache[locale]['dates']['calendars'] = {};
      _localeDataCache[locale]['dates']['calendars']['gregorian'] = {};
      _localeDataCache[locale]['dates']['calendars']['gregorian']
      ['dateTimeFormats'] = {};
    }
    _localeDataCache[locale]['dates']['calendars']['gregorian']
    ['dateTimeFormats'][dateTimeKeys[0] + dateTimeKeys[1]] = pattern;
    return pattern;
  };
            
      
  _formatImpl = function(value, localeElements, options) {
    var ret;
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    //get the pattern from options
    var format = options['pattern'] || _expandFormat(options, localeElements,
      "OraDateTimeConverter.format");
    // Start with an empty string
    ret = [];
    var part,
    quoteCount = 0,
    cal = mainNode['dates']['calendars']['gregorian'];
      
    function _getPart(date, part) {
      switch (part) {
        case 0:
          return date.getFullYear();
        case 1:
          return date.getMonth() + 1;
        case 2:
          return date.getDate();
        case 3:
          return _DAYS_INDEXES[date.getDay()];
      }
    }
      
    function _getPaddedPart(ret, value, idx, len) {          
      var val = _getPart(value, idx);
      ret.push(len > 1 ? OraI18nUtils.padZeros(val, len) : val)
    }

    function _getTimeParts(ret, value, len, currentPart, current) {
      var val;
      switch (currentPart['timePart']) {
        case 'hour' :
          if(currentPart['end1'] === 11)
            val = value.getHours() % 12;
          else
            val = value.getHours();
          if(current === 'h' || current === 'hh') {
            if (val === 0) val = 12;
          }
          else if(current === 'k' || current === 'kk') {
            if (val === 0) val = 24;
          }
          break;
        case 'minute' :
          val = value.getMinutes();
          break;
        case 'second' :
          val = value.getSeconds();
          break;
        case 'millisec' :
          val = value.getMilliseconds();
          break;            
      }
      ret.push(len > 1 ? OraI18nUtils.padZeros(val, len) : val)
    }
      
    for (; ;) {
      // Save the current index
      var index = _TOKEN_REGEXP.lastIndex,
      // Look for the next pattern
      ar = _TOKEN_REGEXP.exec(format);

      // Append the text before the pattern (or the end of the string if 
      // not found)
      var preMatch = format.slice(index, ar ? ar.index : format.length);
      quoteCount += _appendPreOrPostMatch(preMatch, ret);

      if (!ar) {
        break;
      }

      // do not replace any matches that occur inside a string literal.
      if (quoteCount % 2) {
        ret.push(ar[0]);
        continue;
      }

      var current = ar[ 0 ],
      clength = current.length,
      currentPart = _PROPERTIES_MAP[current];
      switch (currentPart['token']) {
        case 'days':
          part = cal[currentPart['token']][currentPart['style']][currentPart['dLen']];
          ret.push(part[_getPart(value, 3)]);
          break;
        case 'months':
          part = cal[currentPart['token']][currentPart['style']][currentPart['mLen']];
          ret.push(part[_getPart(value, 1)]);
          break;
        case 'dayOfMonth' :
        case 'monthIndex' :
          ret.push(_getPaddedPart(ret, value, currentPart['getPartIdx'], clength));
          break;
        case 'year':
          // Year represented by four full digits
          part =  value.getFullYear();
          if (clength == 2) {
            part = part % 100;
          }
          ret.push(OraI18nUtils.padZeros(part, clength));
          break;
        case 'time':
          _getTimeParts(ret, value, clength, currentPart, current);
          break;
        case "ampm":
          // Multicharacter am/pm indicator
          part = value.getHours() < 12 ? 
          cal['dayPeriods']['format']['wide']['am'] : 
          cal['dayPeriods']['format']['wide']['pm'];
          ret.push(part);
          break;
        case "tz":
          // Time zone offset with leading zero
          /*part = value.getTimezoneOffset();
          ret.push(
            (part <= 0 ? "+" : "-") + 
            OraI18nUtils.padZeros(Math.floor(Math.abs(part/60)), 2) + 
            OraI18nUtils.padZeros(Math.floor(Math.abs(part%60)), 2)
            );*/
          break;
        case "era":
          part = cal['eras']['eraAbbr'];             
          ret.push(part['1']);
          break;
        case "slash":
          ret.push("/");
          break;
        default:
          _throwInvalidDateFormat(format, options, current);
      }
    }
    return ret.join("");
  };
  

  //_formatRelativeImpl

  //d1 and d2 same year
  _isSameYear = function(d1, d2) {
    return d1.getFullYear() == d2.getFullYear();
  };

  //d2 is next year
  _isNextYear = function(d1, d2) {
    return d2.getFullYear() - d1.getFullYear() == 1;
  };

  //d2 is previous year
  _isPrevYear = function(d1, d2) {
    return _isNextYear(d2, d1);
  };

  //d2 and d1 same month 
  _isSameMonth = function(d1, d2) {
    return _isSameYear(d1, d2) && (d1.getMonth() === d2.getMonth());
  };

  //d2 is next month
  _isNextMonth = function(d1, d2) {
    if(_isSameYear(d1, d2))
      return (d2.getMonth() - d1.getMonth()) == 1;
    else if(_isNextYear(d1, d2)) {
      return d1.getMonth() == 11 && (d2.getMonth() == 0);   
    }
    return false;
  };

  //d2 is previous month
  _isPrevMonth = function(d1, d2) {
    return _isNextMonth(d2, d1);
  };

  //difference in days between d2 and d1. Only valid if d2 is same or 
  //next month of d1
  _getDaysDif = function(d1, d2) {
    var day1 = d1.getDate();
    var day2 = d2.getDate();  
    if(_isNextMonth(d1, d2)) {
      day2 += _getDaysInMonth(d1.getFullYear, d1.getMonth());
    }
    return day2 - day1;
  };

  _getDayIndex = function(localeElements, idx) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
    var bcp47Keys = OraI18nUtils.parseBCP47(mainNode);
    var territory = bcp47Keys['region'] || '001';
    var firstDayNode = 
    localeElements['supplemental']['weekData']['firstDay'];
    var firstDayOfweek = firstDayNode[territory];
    var ret = idx - firstDayOfweek;
    if(ret < 0)
      ret += 7;
    return ret;
  };

  //d1 and d2 same week
  _isSameWeek = function(localeElements, d1, d2) {
    if(d1 > d2) {
      //swap dates to make sure we work with positive numbers
      var tmp = d1;
      d1 = d2;
      d2 = tmp;  
    }
    if((!_isSameMonth(d1, d2)) && (!_isNextMonth(d1, d2)))
      return false;
    var dif = _getDaysDif(d1, d2) + 
    _getDayIndex(localeElements, d1.getDay());
    return dif >= 0 && dif <= 6; 
  };

  //d2 is next week
  _isNextWeek = function(localeElements, d1, d2) {
    if((!_isSameMonth(d1, d2)) && (!_isNextMonth(d1, d2)))
      return false;
    var dif = _getDaysDif(d1, d2) + 
    _getDayIndex(localeElements, d1.getDay());
    return dif >= 7 && dif <= 13; 
  };

  //d2 is previous week
  _isPrevWeek = function(localeElements, d1, d2) {
    return _isNextWeek(localeElements, d2, d1);
  };

  //d1 and d2 same day
  _isSameDay = function(d1, d2) {
    return _isSameYear(d1, d2) && _isSameMonth(d1, d2) &&
    (d1.getDate() === d2.getDate());
  };

  //d2 is next day
  _isNextDay = function(d1, d2) {
    if((!_isSameMonth(d1, d2)) && (!_isNextMonth(d1, d2))) {
      return false;
    }
    return (_getDaysDif(d1, d2) === 1);
  };

  //d2 is previous day
  _isPrevDay = function(d1, d2) {
    return _isNextDay(d2, d1);
  };
      
 
  _formatRelativeImpl = function(value, localeElements, options) {
    if(typeof value === "number") {
      value = new Date(value);            
    }
    else if(typeof value === "string") {
      if(OraI18nUtils.trim(value) === '')
        return null;
      value = OraI18nUtils.isoToLocalDate(value);
    }
    else {
      return 'Invalid Date';
    }
    if(value.toString() === 'Invalid Date') {
      return 'Invalid Date';
    }
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var fields = mainNode['dates']['fields'];
    var getOption = OraI18nUtils.getGetOption(options, 
      "OraDateTimeConverter.formatRelative");
    var formatUsing = getOption('formatUsing', 'string', 
      ['displayName']);
    var option = getOption('dateField', 'string',
      ['day', 'week', 'month', 'year']);
    var now = new Date();
    switch(option) {
      case "day" :
        if(_isSameDay(now, value))
          return fields['day']['relative-type-0'];
        if(_isNextDay(now, value))
          return fields['day']['relative-type-1'];
        if(_isPrevDay(now, value))
          return fields['day']['relative-type--1'];
        break;
      case "week" :
        if(_isSameWeek(localeElements, now, value))
          return fields['week']['relative-type-0'];
        if(_isNextWeek(localeElements, now, value))
          return fields['week']['relative-type-1'];
        if(_isPrevWeek(localeElements, now, value))
          return fields['week']['relative-type--1'];
        break;
      case "month" :
        if(_isSameMonth(now, value))
          return fields['month']['relative-type-0'];
        if(_isNextMonth(now, value))
          return fields['month']['relative-type-1'];
        if(_isPrevMonth(now, value))
          return fields['month']['relative-type--1'];
        break;
      case "year" :
        if(_isSameYear(now, value))
          return fields['year']['relative-type-0'];
        if(_isNextYear(now, value))
          return fields['year']['relative-type-1'];
        if(_isPrevYear(now, value))
          return fields['year']['relative-type--1'];
        break;
      default :
        break;
    }
    return null;
  };
    
    
  // parse functions
      
  _throwWeekdayMismatch = function(weekday, day) {
    var msg, error, errorInfo;
    msg =  "The weekday " + weekday + " does not match the date " + day; 
    error = new Error(msg);
    errorInfo = {
      'errorCode' : 'dateToWeekdayMismatch',
      'parameterMap' : {
        'weekday' : weekday,
        'date':day
      }
    };
    error['errorInfo'] = errorInfo;
    throw error;
  };
      
  _throwDateFormatMismatch = function(value, format, style) {
    var msg, error, errorInfo, errorCodeType;
    if(style === 2) {
      msg =  "The value \"" + value + 
      "\" does not match the expected date-time format \"" + format + '"';
      errorCodeType = "datetimeFormatMismatch";
    }
    else if(style === 0) {
      msg =  "The value \"" + value + 
      "\" does not match the expected date format \"" + format + '"';
      errorCodeType = "dateFormatMismatch";
         
    }
    else {
      msg = "The value \"" + value + 
      "\" does not match the expected time format \"" + format + '"';
      errorCodeType = "timeFormatMismatch";
        
    }
    error = new Error(msg);
    errorInfo = {
      'errorCode' : errorCodeType,
      'parameterMap' : {
        'value': value,
        'format': format
      }
    };
    error['errorInfo'] = errorInfo;
    throw error;
  };
        
  _expandYear = function(start2DigitYear, year) {
    // expands 2-digit year into 4 digits.
    if (year < 100) {
      var ambiguousTwoDigitYear = start2DigitYear % 100;
      year += Math.floor((start2DigitYear/100))*100 + 
      (year < ambiguousTwoDigitYear ? 100 : 0);
    }
    return year;
  };
  
  _arrayIndexOfDay = function(daysObj, item) {
    var days = {
      "sun": 0, 
      "mon": 1, 
      "tue": 2, 
      "wed": 3, 
      "thu": 4, 
      "fri": 5, 
      "sat": 6
    };
    for (var d in daysObj) {
      if (OraI18nUtils.trim(OraI18nUtils.toUpper(daysObj[d])) == OraI18nUtils.trim(item)) {
        return days[d];
      }
    }
    return -1;
  };
  
  _arrayIndexOfMonth = function(monthsObj, item) {    
    for (var m in monthsObj) {
      if (OraI18nUtils.trim(OraI18nUtils.toUpper(monthsObj[m])) === OraI18nUtils.trim(item)) {
        return (m - 1);
      }
    }
    return -1;
  };
      
  _getDayIndex1 = function(localeElements, value, fmt) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var ret, days;
    var calDaysFmt = 
    mainNode['dates']['calendars']['gregorian']['days']['format'];
    var calDaysStdAlone = 
    mainNode['dates']['calendars']['gregorian']['days']['stand-alone'];
    switch(fmt) {
      case 0:
        days =  [
        calDaysFmt['abbreviated'],
        calDaysFmt['wide']
        ];
        break;
      case 1:
        days =  [
        calDaysStdAlone['abbreviated'],
        calDaysStdAlone['wide']
        ];
        break;
      default:
        break;
    }
    value = OraI18nUtils.toUpper(value);
    ret = _arrayIndexOfDay(days[0], value);
    if (ret === -1) {
      ret = _arrayIndexOfDay(days[1], value);
    }
    return ret;
  };

  //fmt:0 for format, 1 for stand-alone, 2 for lenient parse
  _getMonthIndex = function(localeElements, value, fmt) {
    var ret = -1, months;
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var calMonthsFmt = 
    mainNode['dates']['calendars']['gregorian']['months']['format'];
    var calMonthsStdAlone = 
    mainNode['dates']['calendars']['gregorian']['months']['stand-alone'];
    switch(fmt) {
      case 0:
        months =  [
        calMonthsFmt['wide'],
        calMonthsFmt['abbreviated']
        ];
        break;
      case 1:
        months =  [
        calMonthsStdAlone['wide'],
        calMonthsStdAlone['abbreviated']
        ];
        break;
      case 2:
        months =  [
        calMonthsFmt['wide'],
        calMonthsFmt['abbreviated'],
        calMonthsStdAlone['wide'],
        calMonthsStdAlone['abbreviated']
        ];
        break; 
      default:
        return -1;
    }
    value = OraI18nUtils.toUpper(value);
    for(var m in months) {
      ret = _arrayIndexOfMonth(months[m], value);
      if (ret !== -1) {
        return ret;
      }
    }
    return ret;
  };
        
  // converts a format string into a regular expression with groups that
  // can be used to extract date fields from a date string.
  // check for a cached parse regex.
  _getParseRegExp = function(format, options) {
    var re = {};
		

    // expand single digit formats, then escape regular expression
    //  characters.
    var expFormat = format.replace(_ESCAPE_REGEXP, "\\\\$1"),
    regexp = [ "^" ],
    groups = [],
    index = 0,
    quoteCount = 0,
    match;

    // iterate through each date token found.
    while ((match = _TOKEN_REGEXP.exec(expFormat)) !== null) {
      var preMatch = expFormat.slice(index, match.index);
      index = _TOKEN_REGEXP.lastIndex;

      // don't replace any matches that occur inside a string literal.
      quoteCount += _appendPreOrPostMatch(preMatch, regexp);
      if (quoteCount % 2) {
        regexp.push(match[0]);
        continue;
      }

      // add a regex group for the token.
      var m = match[ 0 ],
      add;
      if(_PROPERTIES_MAP[m] !== undefined){
        add = _PROPERTIES_MAP[m]['regExp'];
      }
      else
        _throwInvalidDateFormat(format, options, m);
      if (add) {
        regexp.push(add);
      }
      groups.push(match[0]);
    }
    _appendPreOrPostMatch(expFormat.slice(index), regexp);
    regexp.push("$");

    // allow whitespace to differ when matching formats.
    var regexpStr = regexp.join("").replace(/\s+/g, "\\s+"),
    parseRegExp = {
      'regExp': regexpStr, 
      'groups': groups
    };
    // cache the regex for this format.
    return re[ format ] = parseRegExp;
  };

  _validateRange = function(name, value, low, high, displayValue,
    displayLow, displayHigh) {
    if(value < low || value > high) { 
      var msg =  displayValue + 
      " is out of range.  Enter a value between " + displayLow +
      " and " + displayHigh + " for " + name; 
      var rangeError = new RangeError(msg);
      var errorInfo = {
        'errorCode' : "datetimeOutOfRange",
        'parameterMap' : {
          'value': displayValue, 
          'minValue': displayLow,
          'maxValue': displayHigh,
          'propertyName': name
        }
      };
      rangeError['errorInfo'] = errorInfo;
      throw rangeError;              
    }
  };
        
  _getTokenIndex = function(arr, token)
  {
    for(var i in arr){
      for (var n in arr[i])
      {
        if(n === token)
          return parseInt(i, 10);
      }         
    }
    return 0;
  };
        
  //time lenient parse
  _parseLenienthms = function(result, timepart, format, localeElements) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var calPM = mainNode['dates']['calendars']['gregorian']['dayPeriods']['format']['wide']['pm'];
    //hour, optional minutes and optional seconds
    _TIME_REGEXP.lastIndex = 0;
    var hour = 0, minute = 0, second = 0, msec=0, idx;
    var match = _TIME_REGEXP.exec(timepart);
    if(match === null) {
      _throwDateFormatMismatch(timepart, format, 1);
    }
    if(match[1] !== undefined)
      hour = parseInt(match[1], 10);
    if(match[2] !== undefined)
      minute = parseInt(match[2], 10);
    if(match[3] !== undefined)
      second = parseInt(match[3], 10);
    if(match[4] !== undefined)
      msec = parseInt(match[4], 10);
    
    _TIME_FORMAT_REGEXP.lastIndex = 0;
    match =  _TIME_FORMAT_REGEXP.exec(format);
    switch(match[0]) {
      case "h":
        // Hour in am/pm (1-12)
        if (hour === 12) hour = 0;
        _validateRange("hour", hour, 0, 11, hour, 1, 12);
        idx = (OraI18nUtils.toUpper(timepart)).indexOf(OraI18nUtils.toUpper(calPM));
        if( idx !== -1 && hour < 12)
          hour += 12;
        break;
      case "K":
        // Hour in am/pm (0-11)
        _validateRange("hour", hour, 0, 11, hour, 0, 11);
        idx = (OraI18nUtils.toUpper(timepart)).indexOf(OraI18nUtils.toUpper(calPM));
        if( idx !== -1 && hour < 12)
          hour += 12;
        break;
      case "H":
        _validateRange("hour", hour, 0, 23, hour, 0, 23);
        break;
      case "k":
        if (hour === 24) hour = 0;
        _validateRange("hour", hour, 0, 23, hour, 1, 24);
        break;
      default:
        break;
    }
    // Minutes.
    _validateRange("minute", minute, 0, 59, minute, 0, 59);
    // Seconds.
    _validateRange("second", second, 0, 59, second, 0, 59);
    //millisec
    _validateRange("millisec", msec, 0, 999, msec, 0, 999);

    result.setHours(hour, minute, second, msec);
  };
  
  _getWeekdayName = function(value, localeElements) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var calDaysFmt = 
    mainNode['dates']['calendars']['gregorian']['days']['format'];
    var calDaysStandAlone = 
    mainNode['dates']['calendars']['gregorian']['days']['stand-alone'];
    var days =  [
    calDaysFmt['wide'],
    calDaysFmt['abbreviated'],
    calDaysStandAlone['wide'],         
    calDaysStandAlone['abbreviated']
    ];
          
    var foundMatch = false;
    var dName, i, j;
    for (i in days) {
      for(j in days[i]) {
        dName = days[i][j];
        var dRegExp = new RegExp(dName + "\\b", 'i');
        if (dRegExp.test(value)) {         
          foundMatch = true;
          break;
        }
      }
      if(foundMatch)
        break;
      dName = null;
    }
    return dName;
  };
  
  //lenient parse yMd and yMEd patterm. Must have year, moth, 
  //date all numbers. Ex: 5/3/2013
  //weekday is optional. If present it must match date. 
  //Ex:  Tuesday 11/19/2013
  //if year > 2-digits it can be anywhere in the string. 
  //Otherwise assume its position based on pattern
  //if date > 12 it can be anywhere in the string. 
  //Otherwise assume its position based on pattern 
  //separators can be any non digit characters
  _parseLenientyMEd = function(value, format, options, localeElements,
    isDateTime)
    {
    _YMD_REGEXP.lastIndex = 0;
    var match = _YMD_REGEXP.exec(value);
    if(match === null) {
      _throwDateFormatMismatch(value, format, 0);
    }
    var tokenIndexes = [{
      'y':format.indexOf("y")
    },{
      'M':format.indexOf("M")
    },{
      'd':format.indexOf("d")
    }];
    tokenIndexes.sort(function(a,b){
      for (var n1 in a)
      {
        break;
      }
      for (var n2 in b)
      {
        break;
      }
      return a[n1]-b[n2];
    });
    var year, month, day, yearIndex, dayIndex, i, j;
    var foundYear = false, foundDay = false;
    for(i =1; i <= 3; i++)
    {
      var tokenMatch =  match[i];
      //find year if year is yyy|yyyy
      if(tokenMatch.length > 2 || tokenMatch > 31)
      {
        year = tokenMatch;
        foundYear = true;
        yearIndex = i-1;
      }
    }

    if(!foundYear) {
      yearIndex = _getTokenIndex(tokenIndexes, 'y');
      year = match[_getTokenIndex(tokenIndexes, 'y')+1];
    }
    //find day if day value > 12
    for(i = 0; i < 3; i++) { 
      if(i!== yearIndex && match[i+1] > 12) {
        day = match[i+1];
        foundDay = true;
        dayIndex = i;
        break;
      }
    }
    if(!foundDay) {
      if(yearIndex === _getTokenIndex(tokenIndexes, 'd'))
      {
        day = match[_getTokenIndex(tokenIndexes, 'y')+1];
        month = match[_getTokenIndex(tokenIndexes, 'M')+1];
      }
      else if (yearIndex === _getTokenIndex(tokenIndexes, 'M'))
      {
        day = match[_getTokenIndex(tokenIndexes, 'd')+1];
        month = match[_getTokenIndex(tokenIndexes, 'y')+1];   
      }
      else {
        day = match[_getTokenIndex(tokenIndexes, 'd')+1];
        month = match[_getTokenIndex(tokenIndexes, 'M')+1];   
 
      }
    }
    else {
      for(i = 0; i < 3; i++) { 
        if(i!== dayIndex && i !== yearIndex) {
          month = match[i+1];
          break;
        }
      }
      if(month === undefined) {
        month = match[_getTokenIndex(tokenIndexes, 'M')+1];
      }
    }
    month -= 1;
    var daysInMonth = _getDaysInMonth(year, month);
    _validateRange("month", month, 0, 11, month+1, 1, 12);
    _validateRange("day", day, 1, daysInMonth, day, 1, daysInMonth);
    var start2DigitYear = _get2DigitYearStart(options);
    year = _expandYear(start2DigitYear, parseInt(year, 10));
    _validateRange("year", year, 0, 9999, year, 0, 9999);
    var parsedDate = new Date(year, month, day);
    //locate weekday
    var dName = _getWeekdayName(value, localeElements);
    if(dName != null) {
      var weekDay = _getDayIndex1(localeElements, dName, 0);  
      // day of week does not match date
      if (parsedDate.getDay() !== weekDay) {
        _throwWeekdayMismatch(dName, parsedDate.getDate());
      }
    }
    var result = 
    {
      'value': parsedDate,
      'warning' : 'lenient parsing was used'
    };
    if(isDateTime) {
      var timepart = value.substr(_YMD_REGEXP.lastIndex);
      if(timepart.length === 0)
        result['value'].setHours(0, 0, 0, 0);
      else
        _parseLenienthms(result['value'], timepart, format, localeElements); 
    }
    return result;
  };

  //lenient parse yMMMd and yMMMEd patterns. Must have year, date as numbers 
  //and month name.
  //weekday is optional. If present it must match date.
  // Ex:  Monday Nov, 11 2013
  //weekday and month name can be anywhere in the string.
  //if year > 2-digits it can be anywhere in the string. 
  //Otherwise assume its position based on pattern
  //separators can be any non digit characters
  _parseLenientyMMMEd = function(value, format, options, localeElements,
    isDateTime) {
    var origValue = value;
    value =  OraI18nUtils.toUpper(value); 
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    //locate month name
    var calMonthsFmt = 
    mainNode['dates']['calendars']['gregorian']['months']['format'];
    var calMonthsStandAlone = 
    mainNode['dates']['calendars']['gregorian']['months']['stand-alone'];
    var months =  [
    calMonthsFmt['wide'],
    calMonthsFmt['abbreviated'],
    calMonthsStandAlone['wide'],         
    calMonthsStandAlone['abbreviated']
    ];
    var foundMatch = false;
    var reverseMonth;
    var i, j, mName;
    for (i in months) {
      reverseMonth = [];
      for(j in months[i]) {
        mName = OraI18nUtils.toUpper( months[i][j]);
        reverseMonth.push({
          'idx':j, 
          'name':mName
        });
      }
      reverseMonth.sort(function(a,b){
        return b['idx'] - a['idx'];
      });
          
      for(j in reverseMonth) {
        mName =  reverseMonth[j]['name'];
        if (value.indexOf(mName) != -1) {
          foundMatch = true;
          value = value.replace(mName, "");
          break;
        }
      }
      if(foundMatch)
        break;
    }
    //There is no month name. Try yMEd lenient parse.
    if(!foundMatch) {
      return _parseLenientyMEd(origValue, format, options, localeElements,
        isDateTime);
    }
          
    var month = _getMonthIndex(localeElements, mName, 2);          
    _validateRange("month", month, 0, 11, month, 1, 12);

    //locate weekday
    var dName = _getWeekdayName(origValue, localeElements);
    var dRegExp = new RegExp(dName + "\\W", 'i');
    if(dName !== null) {
      value = value.replace(dRegExp, "");
    }
    //find year and date
    _YEAR_AND_DATE_REGEXP.lastIndex = 0;
    var match = _YEAR_AND_DATE_REGEXP.exec(value);
    if(match === null) {
      _throwDateFormatMismatch(origValue, format, 0);
    }
    var tokenIndexes = [{
      'y':format.indexOf("y")
    },{
      'd':format.indexOf("d")
    }];
      
    tokenIndexes.sort(function(a,b){
      for (var n1 in a)
      {
        break;
      }
      for (var n2 in b)
      {
        break;
      }
      return a[n1]-b[n2];
    });
        
    var year, day, yearIndex;
    var foundYear = false;
    for(i =1; i <= 2; i++)
    {
      var tokenMatch =  match[i];
      //find year if year is yyy|yyyy
      if(tokenMatch.length > 2 || tokenMatch > 31)
      {
        year = tokenMatch;
        foundYear = true;
        yearIndex = i-1;
      }
    }
    if(!foundYear) {
      yearIndex = _getTokenIndex(tokenIndexes, 'y');
      year = match[_getTokenIndex(tokenIndexes, 'y')+1];
    } 
    if(yearIndex === _getTokenIndex(tokenIndexes, 'd'))
    {
      day = match[_getTokenIndex(tokenIndexes, 'y')+1];
    }
    else {
      day = match[_getTokenIndex(tokenIndexes, 'd')+1];
    }
          
    var start2DigitYear = _get2DigitYearStart(options);
    year = _expandYear(start2DigitYear, parseInt(year, 10));
    _validateRange("year", year, 0, 9999, year, 0, 9999);
    var parsedDate = new Date(year, month, day);
    if(dName != null) {
      var weekDay = _getDayIndex1(localeElements, dName, 0);  
      // day of week does not match date
      if (parsedDate.getDay() !== weekDay) {
        _throwWeekdayMismatch(dName, parsedDate.getDate());
      }
    }
    var daysInMonth = _getDaysInMonth(year, month);
    _validateRange("day", day, 1, daysInMonth, day, 1, daysInMonth);
    var result = 
    {
      'value': parsedDate,
      'warning' : 'lenient parsing was used'
    };
    if(isDateTime) {
      var timepart = value.substr(_YEAR_AND_DATE_REGEXP.lastIndex);
      if(timepart.length === 0)
        result['value'].setHours(0, 0, 0, 0);
      else
        _parseLenienthms(result['value'], timepart, format, localeElements); 
    }
    return result;
  };
      
  _parseLenient = function(value, format, options, localeElements) {
    var dtStyle = _dateTimeStyle(options, "OraDateTimeConverter.parse");
    switch (dtStyle) {
      //date style
      case 0 :
        return _parseLenientyMMMEd(value, format, options, localeElements,
          false);
        break
      //time style
      case 1 :
        var d = new Date();
        _parseLenienthms(d, value, format, localeElements);
        var result = 
        {
          'value': d,
          'warning' : 'lenient parsing was used'
        };
        return result;
        break;
      //date-time style
      case 2 :
        return _parseLenientyMMMEd(value, format, options, localeElements,
          true);
        break;
      default:
        break;
    }
    return null;
  };
    
  _getNameIndex = function(localeElements, datePart, matchGroup, mLength,
    style, matchIndex, start1, end1, start2, end2, name){
    var index;
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var monthsFormat = 
    mainNode['dates']['calendars']['gregorian'][datePart][style];
    var startName, endName;
    if(datePart === 'months') {
      index = _getMonthIndex(localeElements, matchGroup, matchIndex);
    }
    else {
      index = _getDayIndex1(localeElements, matchGroup, matchIndex);
    }
    startName = monthsFormat[mLength][start2];
    endName = monthsFormat[mLength][end2];
    _validateRange(name, index, start1, end1, matchGroup, 
      startName, endName);
    return index;
  };
     
  _getTimePart = function(matchInt, timeObj, objMap, clength, timeToken) {
    timeObj[objMap['timePart']] = matchInt;
    if(timeToken === 'h' || timeToken === 'hh') {
      if (matchInt === 12)
        timeObj[objMap['timePart']] = 0;
    }
    else if(timeToken === 'k' || timeToken === 'kk') {
      if (matchInt === 24)
        timeObj[objMap['timePart']] = 0;
    }
    else if(timeToken === 'S') {
      timeObj[objMap['timePart']] = matchInt * Math.pow(10, 3 - clength);
    }
    _validateRange(objMap['timePart'], timeObj[objMap['timePart']], 
      objMap['start1'], objMap['end1'], matchInt,
      objMap['start2'], objMap['end2']); 
  };
     
  //exact match parsing for date-time. If it fails, try lenient parse.
  _parseExact = function(value, format, options, localeElements) {
    var mainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    // try to parse the date string by matching against the format string
    // while using the specified culture for date field names.
    value = OraI18nUtils.trim(value);
    // remove spaces from era.
    var cal = mainNode['dates']['calendars']['gregorian'];
    var eraPart = cal['eras']['eraAbbr']['1'];
    var trimEraPart = OraI18nUtils.trimNumber(eraPart);
    value = value.replace(eraPart, trimEraPart);
 
    // convert date formats into regular expressions with groupings.
    // use the regexp to determine the input format and extract the date
    //  fields.
    var parseInfo = _getParseRegExp(format, options),
    match = new RegExp(parseInfo['regExp']).exec(value);
    if (match === null) {
      return _parseLenient(value, format, options, localeElements);
    }

    // found a date format that matches the input.
    var groups = parseInfo['groups'],
    year = null, month = null, date = null, weekDay = null,
    hourOffset, tzMinOffset = null,
    pmHour = false, minOffset, weekDayName,
    timeObj = {
      'hour':0, 
      'minute':0, 
      'second':0, 
      'millisec':0
    },
    calPM = mainNode['dates']['calendars']['gregorian']['dayPeriods']['format']['wide']['pm'];
    var start2DigitYear = _get2DigitYearStart(options);
    // iterate the format groups to extract and set the date fields.
    for (var j = 0, jl = groups.length; j < jl; j++) {
      var matchGroup = match[ j + 1 ];
      if (matchGroup) {
        var current = groups[ j ],
        clength = current.length,
        matchInt = parseInt(matchGroup, 10);
        var currentGroup = _PROPERTIES_MAP[current];
        switch (currentGroup['token']) {
          case 'months':
            month = _getNameIndex(localeElements, currentGroup['token'],
              matchGroup, currentGroup['mLen'], currentGroup['style'],
              currentGroup['matchIndex'], 0, 11, '1', '12', 'month name');
            break;
          case 'days':
            weekDayName = matchGroup;
            weekDay = _getNameIndex(localeElements, currentGroup['token'],
              matchGroup, currentGroup['dLen'], currentGroup['style'],
              currentGroup['matchIndex'], 0, 6, 'sun', 'sat', 'weekday');
            break;
          case 'time':
            _getTimePart(matchInt, timeObj, currentGroup, clength, current);
            break;
          case 'dayOfMonth':
            date = matchInt;
            //try leneient parse for date style only
            if(date > 31)                    
              return _parseLenient(value, format, options, localeElements);
            break;
          case 'monthIndex':
            // Month.
            month = matchInt - 1;
            //try leneient parse for date style only
            if(month > 11)
              return _parseLenient(value, format, options, localeElements);
            break;
          case 'year':
            year = _expandYear(start2DigitYear, matchInt);
            _validateRange("year", year, 0, 9999, year, 0, 9999);
            break;
          case "ampm":
            pmHour = (OraI18nUtils.toUpper(matchGroup) === OraI18nUtils.toUpper(calPM));
            break;
          case "tz":
            // Time zone offset in +/-hhmm | +/-hmm.
            hourOffset = (matchInt/100) << 0;
            _validateRange("TZ Offset", hourOffset, -12, 13, 
              matchInt, -12, 13);
            minOffset = Math.abs(matchInt % 100);
            _validateRange("TZ Offset", minOffset, 0, 59, minOffset, 0, 
              59);
            tzMinOffset  = (hourOffset * 60)  + 
            (OraI18nUtils.startsWith(matchGroup, "-") ? -minOffset : minOffset);
            break;
        }       
      }
    }
    var parsedDate = new Date(), defaultYear;
    defaultYear =  parsedDate.getFullYear();
    if (year === null) {
      year = defaultYear;
    }
    // if day and month are unspecified,the defaults are current 
    // day and month.
    if (month === null && date === null) {
      month = parsedDate.getMonth();
      date = parsedDate.getDate();
    }
    // if day is unspecified, default 1st day of month.
    else if (date === null) {
      date = 1;
    }
        
    //validate day range, depending on the month and year
    var daysInMonth = _getDaysInMonth(year, month);
    _validateRange("day", date, 1, daysInMonth, date, 1, daysInMonth);
    // have to set year, month and date together to avoid overflow based 
    // on current date.
    parsedDate.setFullYear(year, month, date);

    // day of week does not match date
    if (weekDay !== null && parsedDate.getDay() !== weekDay) {
      _throwWeekdayMismatch(weekDayName, parsedDate.getDate());
    }
    // if pm designator token was found make sure the hours fit the 
    // 24-hour clock.
    if (pmHour && timeObj['hour'] < 12) {
      timeObj['hour'] += 12;
    }
    parsedDate.setHours(timeObj['hour'], timeObj['minute'], timeObj['second'],
      timeObj['millisec']);
    if (tzMinOffset !== null) {
      // adjust timezone to utc before applying local offset.
      var adjustedMin = parsedDate.getMinutes() - (tzMinOffset + 
        parsedDate.getTimezoneOffset());
      parsedDate.setHours(parsedDate.getHours() + 
        ((adjustedMin / 60) << 0), adjustedMin % 60);
    }
    var result =
    {
      'value': parsedDate
    };
    return result;
  };
    
  //given a user defined pattern, derive the ecma options that will
  //be returned by getResolvedOptions method
  _getResolvedOptionsFromPattern = function(locale, numberingSystemKey, 
    pattern) {
    // expand single digit formats, then escape regular expression 
    // characters.
    var expFormat = pattern.replace(_ESCAPE_REGEXP, "\\\\$1"),
    regexp = [ "^" ],
    quoteCount = 0,
    index=0,
    match;
    var result = {
      'locale': locale,
      'numberingSystem': numberingSystemKey,
      'calendar': 'gregorian'
    };
    // iterate through each date token found.
    while ((match = _TOKEN_REGEXP.exec(expFormat)) !== null) {
      var preMatch = expFormat.slice(index, match.index);
      index = _TOKEN_REGEXP.lastIndex;

      // skip matches that occur inside a string literal.
      quoteCount += _appendPreOrPostMatch(preMatch, regexp);
      if (quoteCount % 2) {
        continue;
      }

      // add a regex group for the token.
      var m = match[ 0 ];
      if(m === '/' || m === 'zzzz' || m === 'zzz' ||
        m === 'zz' || m === 'z') {
        continue;
      }
      if(_PROPERTIES_MAP[m] !== undefined) {
        result[_PROPERTIES_MAP[m]['key']] = _PROPERTIES_MAP[m]['value'];
        if(m === 'kk' || m === 'HH' || m === 'H' || m === 'k') {
          result['hour12'] = false;
        }
        else if(m === 'KK' || m === 'hh' || m === 'h' || m === 'K') {
          result['hour12'] = true;
        }
      }
      else {
        _throwInvalidDateFormat(pattern, result, m);
      }
    }
    return result;
  };
  //test if the pattern is date, time or date-time
  //0: date, 1:time, 2:date-time
  _dateTimeStyleFromPattern = function(pattern) {
    var result = _getResolvedOptionsFromPattern('', '', pattern);
    var isDate = (result['year'] !== undefined || result['month'] !== 
      undefined ||
      result['weekday'] !== undefined || result['day'] !== undefined);
    var isTime = (result['hour'] !== undefined || result['minute'] !== 
      undefined ||
      result['second'] !== undefined);
    if(isDate && isTime)
      return 2;
    else if (isTime)
      return 1;
    else
      return 0;    
  };
      
  //test if the pattern/options is date, time or date-time
  //0: date, 1:time, 2:date-time
  _dateTimeStyle = function(options, caller) {
    //try pattern
    if(options['pattern'] !== undefined ) {
      return _dateTimeStyleFromPattern(options['pattern']);     
    }
        
    //try ecma options
    var getOption = OraI18nUtils.getGetOption(options, caller);
    var isTime = (getOption('hour', 'string', ['2-digit', 'numeric']) !== 
      undefined ||
      getOption('minute', 'string', ['2-digit', 'numeric']) !== undefined ||
      getOption('second', 'string', ['2-digit', 'numeric']) !== undefined);
    var isDate = (getOption('year', 'string', ['2-digit', 'numeric']) !== 
      undefined ||
      getOption('month', 'string', 
        ['2-digit', 'numeric', 'narrow', 'short', 'long']) !== undefined ||
      getOption('day', 'string', ['2-digit', 'numeric']) !== undefined ||
      getOption('weekday', 'string', ['narrow', 'short', 'long']) !== 
      undefined);
    if(isDate && isTime)
      return 2;
    else if (isTime)
      return 1;
    else if (isDate)
      return 0;                
        
    //try predefined style
    var option = getOption('formatType', 'string', 
      ['date', 'time', 'datetime'], 'date');
    if(option === 'datetime')
      return 2;
    else if (option === 'time')
      return 1;
    return 0;
  };
  
  _createParseISOString = function(dtStyle, d) {
    var ms, val;
    switch (dtStyle) {
      case 0 :
        val = d.getFullYear() + "-" + OraI18nUtils.padZeros((d.getMonth() + 1 ), 2) + "-" +
        OraI18nUtils.padZeros(d.getDate(), 2);
        break;
      case 1 :
        val = "T" + OraI18nUtils.padZeros(d.getHours(), 2) + ":" + 
        OraI18nUtils.padZeros(d.getMinutes(), 2) + ":" +
        OraI18nUtils.padZeros(d.getSeconds(), 2);
        ms = d.getMilliseconds();
        if( ms > 0) {
          val += "." + ms
        }
        break;
      default :
        val = d.getFullYear() + "-" + 
        OraI18nUtils.padZeros((d.getMonth() + 1 ), 2) + "-" +
        OraI18nUtils.padZeros(d.getDate(), 2) +
        "T" + OraI18nUtils.padZeros(d.getHours(), 2) + ":" + 
        OraI18nUtils.padZeros(d.getMinutes(), 2) + ":" +
        OraI18nUtils.padZeros(d.getSeconds(), 2);
        ms = d.getMilliseconds();
        if( ms > 0) {
          val += "." + ms
        }
        break;
    }
    return val;
  };
  
  _parseImpl = function(str, localeElements, options, locale) {
    var numberingSystemKey =  OraI18nUtils.getLanguageExtension(locale, "nu");
    if(OraI18nUtils.numeringSystems[numberingSystemKey] === undefined)
      numberingSystemKey = 'latn';         
    if(numberingSystemKey !== 'latn') {
      var idx;
      var latnStr = [];
      for(idx = 0; idx < str.length; idx++)
      {
        var pos = OraI18nUtils.numeringSystems[numberingSystemKey].indexOf(str[idx]);
        if(pos != -1)
          latnStr.push(pos);
        else
          latnStr.push(str[idx]);       
      }
      str =  latnStr.join("");
    }
    if(arguments.length <= 2 || options === undefined)
    {
      //default is yMd
      options = {
        'year': 'numeric', 
        'month': 'numeric', 
        'day': 'numeric'
      };
    }
    var dtStyle = _dateTimeStyle(options, "OraDateTimeConverter.parse");
    var formats = options['pattern'] || _expandFormat(options, localeElements, 
      "OraDateTimeConverter.parse");
    var dateObj = {};
    //First try if str is an iso 8601 string 
    var testIsoStr = _ISO_DATE_REGEXP.test(str);
    if(testIsoStr === true) {
      var dateFromISOStr = new Date(Date.parse(str));
      dateObj['value'] = _createParseISOString(dtStyle, dateFromISOStr);
      return dateObj;
    }
    var parsedDateObj = _parseExact(str, formats, options, localeElements);
    var d = parsedDateObj['value'];
    dateObj['warning'] = parsedDateObj['warning'];
    dateObj['value'] = _createParseISOString(dtStyle, d);    
    return dateObj;
  };
      
  function _init() {    
    return {
      /**
     * Format a date.
     * @memberOf OraDateTimeConverter
     * @param {string} value - an iso 8601 string to be formatted. It  may be in 
     * extended or non-extended form. http://en.wikipedia.org/wiki/ISO_8601
     * @param {Object} localeElements - the instance of LocaleElements bundle.
     * @param {Object=} options - Containing the following properties:<br>
     * - <b>weekday.</b> Allowed values: "narrow", "short", "long".<br>
     * - <b>era.</b> Allowed values: "narrow", "short", "long".<br>
     * - <b>year.</b> Allowed values:"2-digit", "numeric".<br>
     * - <b>month.</b> Allowed values: "2-digit", "numeric", "narrow", 
     * "short", "long".<br>
     * - <b>day.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>hour.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>minute.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>second.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>timeZoneName.</b> Will be ignored in phase1. We do not support it 
     * yet.<br>
     * - <b>hour12.</b> is a Boolean value indicating whether 12-hour format 
     * (true) or 24-hour format (false) should be used. It is only relevant 
     * when hour is also present.<br>
     * - <b>formatMatcher.</b> optional, specifies the algorithm to be used 
     * for looking up the date format based on the options. Allowed values: 
     * "basic", "munger". The default is munger.
     * - <b>pattern.</b> custom String pattern as defined by Unicode CLDR.<br>
     * - <b>formatType.</b> a predefined formatting type. Allowed values: 
     * "date", "time", "datetime".
     * - <b>dateFormat.</b> optional, specifies the date format field. 
     * Allowed values: "short", "medium", "long", "full". It is only 
     * considered when formatType is present. The default value 
     * is "short".<br>
     * - <b>timeFormat.</b> optional, specifies the time format field. 
     * Allowed values: "short", "medium", "long", "full". It is only 
     * considered when formatType is present. The default value 
     * is "short".<br><br>
     * The order of precedence is the following:<br>
     * 1. pattern.<br>
     * 2. ECMA options.<br>
     * 3. formatType.<br>
     * If options is ommitted, the default will be the following object:<br>
     * {<br>
     * year:"numeric",<br> 
     * month:"numeric",<br> 
     * day:"numeric"<br>
     * };
     * @param {string=} locale - A BCP47 compliant language tag. it is only 
     * used to extract the unicode extension keys. 
     * @return {string|null} formatted date.
     * @throws {RangeError} If a propery value of the options parameter is 
     * out of range.
     * @throws {SyntaxError} If an Unexpected token is encountered in the 
     * pattern. 
     */ 
      format : function(value, localeElements, options, locale) {
        var val;
        if(typeof value === "number") {
          val = new Date(value);            
        }
        else if(typeof value === "string") {
          if(OraI18nUtils.trim(value) === '')
            return null;
          val = OraI18nUtils.isoToLocalDate(value);
        }
        else {
          return 'Invalid Date';
        }
        if(val.toString() === 'Invalid Date') {
          return 'Invalid Date';
        }
        if(arguments.length <=2 || options === undefined)
        {
          //default is yMd
          options = {
            'year': 'numeric', 
            'month': 'numeric', 
            'day': 'numeric'
          };
        }
        var ret = _formatImpl(val, localeElements, options);
        var numberingSystemKey =  OraI18nUtils.getLanguageExtension(locale, "nu");
        if(OraI18nUtils.numeringSystems[numberingSystemKey] === undefined)
          numberingSystemKey = 'latn';           
        if(numberingSystemKey !== 'latn') {
          var idx;
          var nativeRet = [];
          for(idx = 0; idx < ret.length; idx++)
          {
            if(ret[idx] >= '0' && ret[idx] <= '9')
              nativeRet.push(OraI18nUtils.numeringSystems[numberingSystemKey][ret[idx]]);
            else nativeRet.push(ret[idx]);
        
          }
          return nativeRet.join("");
        }
        return ret;
      },
      
      /**
     * Format a relative date/time
     * @memberOf OraDateTimeConverter
     * @param {string} value - iso 8601 string to be formatted. It may be in
     *  extended or non-extended form. http://en.wikipedia.org/wiki/ISO_8601
     * @param {Object} localeElements - the instance of LocaleElements bundle.
     * @param {Object} options - Containing the following properties:
     * formatUsing. Allowed values: "displayName"
     * dateField. Allowed values: "day", "week", "month", "year"
     * @return {string|null} relative date. null if the value falls out side 
     * the supported relative range.
     */
      formatRelative : function(value, localeElements, options) {
        return _formatRelativeImpl(value, localeElements, options);
      },


      /**
     * Parse a date. It also support lenient parse when input does not match
     * the pattern.<br>
     * We first try to match month a pattern where we have month and weekday 
     * names Ex:  Monday Nov, 11 2013
     * weekday name and month name can be anywhere in the string.
     * if year > 2-digits it can be anywhere in the string. Otherwise we assume
     * its position based on pattern. Separators can be any non digit characters
     * <br>If month name is not present, we try lenient parse yMd and yMEd
     * pattern. Must have year, moth and date all numbers. Ex: 5/3/2013 weekday
     * is optional. If present it must match date. Ex:  Tuesday 11/19/2013
     * if year > 2-digits it can be anywhere in the string. Otherwise assume its
     * position based on pattern if date > 12 it can be anywhere in the string. 
     * Otherwise assume its position based on pattern separators can be any
     * non digit characters.<br><br>
     * @memberOf OraDateTimeConverter
     * @param {string} str - String to be parsed. it can be an iso 8601 string
     * or a formatted string.
     * @param {Object} localeElements - The instance of LocaleElements bundle
     * @param {Object=} options - Containing the following properties:<br>
     * - <b>weekday.</b> Allowed values: "narrow", "short", "long".<br>
     * - <b>era.</b> Allowed values: "narrow", "short", "long".<br>
     * - <b>year.</b> Allowed values:"2-digit", "numeric".<br>
     * - <b>month.</b> Allowed values: "2-digit", "numeric", "narrow", 
     * "short", "long".<br>
     * - <b>day.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>hour.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>minute.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>second.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>timeZoneNmae.</b> Will be ignored in phase1. We do not support it
     *  yet.<br>
     * - <b>hour12.</b> is a Boolean value indicating whether 12-hour format 
     * (true) or 24-hour format (false) should be used. It is only relevant 
     * when hour is also present.<br>
     * - <b>formatMatcher.</b> optional, specifies the algorithm to be used 
     * for looking up the date format based on the options. Allowed values: 
     * "basic", "munger". The default is munger.
     * - <b>pattern.</b> custom String pattern as defined by Unicode CLDR.<br>
     * - <b>two-digit-year-start.</b> the 100-year period 2-digit year. 
     * During parsing, two digit years will be placed in the range 
     * two-digit-year-start to two-digit-year-start + 100 years. 
     * The default is 1950.<br>
     * - <b>formatType.</b> a predefined formatting type. Allowed values: 
     * "date", "time", "datetime".
     * - <b>dateFormat.</b> optional, specifies the date format. Allowed 
     * values: "short", "medium", "long", "full". It is only considered when 
     * formatType is present. The default value is "short".<br>
     * - <b>timeFormat.</b> optional, specifies the time format. Allowed 
     * values: "short", "medium", "long", "full". It is only considered when 
     * formatType is present. The default value is "short".<br><br>
     * The order of precedence is the following:<br>
     * 1. pattern.<br>
     * 2. ECMA options.<br>
     * 3. formatType.<br>          
     * If options is ommitted, the default will be the following object:<br>
     * {<br>
     * year:"numeric",<br> 
     * month:"numeric",<br> 
     * day:"numeric"<br>
     * };
     * @param {string=} locale - A BCP47 compliant language tag. it is only 
     * used to extract the unicode extension keys. 
     * @return {string} an iso 8601 extended String. If the patern is a date only,
     * returns the date part of the iso string. If the pattern is time only,
     * returns the time part of the iso string. If the pattern is date-time, 
     * returns the date-time iso string. http://en.wikipedia.org/wiki/ISO_8601
     * @throws {RangeError} If a property value of the options parameter is 
     * out of range.
     * @throws {SyntaxError} If an Unexpected token is encountered in the 
     * pattern.
     * @throws {Error} If the <i>str</i> parameter does not match the format 
     * pattern.
     * @throws {RangeError} if one of the date fields is out of range.
     */ 
      parse : function(str, localeElements, options, locale) {
        return _parseImpl(str, localeElements, options, locale);
      },
      
      /**
     * Resolve options.
     * Returns a new object with properties reflecting the date and time 
     * formatting options computed based on the options parameter. 
     * If the options parameter is ommitted, the following object will be 
     * returned:<br>
     * {<br>
     * calendar: "gregorian"<br>
     * numberingSystem: "latn"<br>
     * locale: &lt;locale parameter&gt;,<br>
     * day: "numeric",<br>
     * month: "numeric",<br>
     * year: "numeric"<br>
     * };
     * @memberOf OraDateTimeConverter
     * @param {Object} localeElements - The instance of LocaleElements bundle                           
     * @param {Object=} options - Containing the following properties:<br>
     * - <b>calendar.</b> The calendar system.<br>
     * - <b>weekday.</b> Allowed values: "narrow", "short", "long".<br>
     * - <b>era.</b> Allowed values: "narrow", "short", "long".<br>
     * - <b>year.</b> Allowed values:"2-digit", "numeric".<br>
     * - <b>month.</b> Allowed values: "2-digit", "numeric", "narrow", 
     * "short", "long".<br>
     * - <b>day.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>hour.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>minute.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>second.</b> Allowed values: "2-digit", "numeric".<br>
     * - <b>timeZoneName.</b> Will be ignored in phase1. We do not support 
     * it yet.<br>
     * - <b>hour12.</b> is a Boolean value indicating whether 12-hour format 
     * (true) or 24-hour format (false) should be used. It is only relevant 
     * when hour is also present.<br>
     * - <b>formatMatcher.</b> optional, specifies the algorithm to be used 
     * for looking up the date format based on the options. Allowed values: 
     * "basic", "munger". The default is munger.
     * - <b>pattern.</b> custom String pattern as defined by Unicode CLDR. 
     * Will override above options when present.<br>
     * - <b>two-digit-year-start.</b> the 100-year period 2-digit year. 
     * During parsing, two digit years will be placed in the range 
     * two-digit-year-start to two-digit-year-start + 100 years. 
     * The default is 1950.<br>
     * - <b>formatType.</b> predefined format type.  Allowed values: 
     * "datetime", "date", "time"<br>
     * - <b>dateFormat.</b> format of date field.  Allowed values: "short", 
     * "medium", "long", "full". It is only relevant when formatType is also 
     * present<br>
     * - <b>timeFormat.</b> format of time field.  Allowed values: "short", 
     * "medium", "long", "full". It is only relevant when formatType is also 
     * present<br>
     * @param {string=} locale - A BCP47 compliant language tag. it is only 
     * used to extract the unicode extension keys.
     * @return {Object} Resolved options object.
     * @throws {RangeError} If a property value of the options parameter is 
     * out of range.
     * @throws {Error} if weekday does not match the date.
     */
           
      resolvedOptions : function(localeElements, options, locale){
        if(arguments.length < 3 || locale === undefined) {
          locale = OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
        }
        if(arguments.length < 2 || options === undefined)
        {
          //default is yMd
          options = {
            'year': 'numeric', 
            'month': 'numeric', 
            'day': 'numeric'
          };
        }
        var ecma = false;
        var result;
        var numberingSystemKey =  OraI18nUtils.getLanguageExtension(locale, "nu");
        if(OraI18nUtils.numeringSystems[numberingSystemKey] === undefined)
          numberingSystemKey = 'latn';
        if(options !== undefined && options['pattern'] !== undefined ) {
          result = _getResolvedOptionsFromPattern(locale, numberingSystemKey, 
            options['pattern']);
          result['pattern'] = options['pattern'];
          return result;
        }
        if(options !== undefined) {
          result = {
            'locale': locale,
            'numberingSystem': numberingSystemKey,
            'calendar': 'gregorian'
          };
          var count = 0;
          for(count in options){
            count++;
          }
          if(count == 0) {            
            result['year']= 'numeric'; 
            result['month'] = 'numeric'; 
            result['day']=  'numeric';
            return result;
          }
          var getOption = OraI18nUtils.getGetOption(options, 
            "OraDateTimeConverter.resolvedOptions");
          var option = getOption('year',  'string', ['2-digit', 'numeric']);
          if(option !== undefined) {
            result['year'] = option;
            ecma = true;
          }
          option = getOption('era', 'string', ['narrow', 'short', 'long']);
          if(option !== undefined) {
            result['era'] = option;
            ecma = true;
          }
          option = getOption('month', 'string', ['2-digit', 'numeric', 
            'narrow', 'short', 'long']);
          if(option !== undefined) {
            result['month'] = option;
            ecma = true;
          }
          option = getOption('day', 'string', ['2-digit', 'numeric']);
          if(option !== undefined) {
            result['day'] = option;
            ecma = true;
          }
          option = getOption('weekday', 'string', ['narrow', 'short', 
            'long']);
          if(option !== undefined) {
            result['weekday'] = option;
            ecma = true;
          }           
          option = getOption('hour', 'string', ['2-digit', 'numeric']);
          if(option !== undefined) {
            result['hour'] = option;
            ecma = true;
            option = getOption('hour12', 'boolean', [true, false]);
            if(option === undefined)
              option = _isHour12(localeElements);
            result['hour12'] = option;
          }
          option = getOption('minute', 'string', ['2-digit', 'numeric']);
          if(option !== undefined) {
            result['minute'] = option;
            ecma = true;
          }
          option = getOption('second', 'string', ['2-digit', 'numeric']);
          if(option !== undefined) {
            result['second'] = option;
            ecma = true;
          }
          result['two-digit-year-start'] = _get2DigitYearStart(options);
          if(!ecma) {
            var format = _expandPredefinedStylesFormat(options, 
              localeElements, OraDateTimeConverter.resolvedOptions);
            var fmtType = getOption('formatType', 'string', 
              ['date', 'time', 'datetime'], 'date');
            var dStyle = getOption('dateFormat', 'string', 
              ['short', 'medium', 'long', 'full'], 'short');
            var tStyle = getOption('timeFormat', 'string', 
              ['short', 'medium', 'long', 'full'], 'short');
            result['formatType'] = fmtType;
            if(fmtType === 'datetime' || fmtType === 'date') {
              result['dateFormat'] = dStyle;
            }
            if(fmtType === 'datetime' || fmtType === 'time') {
              result['timeFormat'] = tStyle;
            }
            result['patternFromOptions'] = format;
            return result;
          }
          result['patternFromOptions'] = _expandFormat(options, 
            localeElements, "OraDateTimeConverter.resolvedOptions");
          return result;
        }
        var defaultOptions = {
          'year': 'numeric', 
          'month': 'numeric', 
          'day': 'numeric'
        };
        var patternFromOptions = _expandFormat(defaultOptions,
          localeElements, "OraDateTimeConverter.resolvedOptions");
        return {
          'calendar': 'gregorian',
          'locale': locale,
          'numberingSystem': numberingSystemKey,
          'year': 'numeric', 
          'month': 'numeric', 
          'day': 'numeric',
          'patternFromOptions': patternFromOptions
        };
      },
      
      /**
     * Returns the current week in the year when provided a date.
     * @memberOf OraDateTimeConverter
     * @param {string} date - iso 8601 string. It may be in extended or 
     * non-extended form. http://en.wikipedia.org/wiki/ISO_8601
     * @param {Object} localeElements - The instance of LocaleElements bundle  
     * @param {string=} locale - A BCP47 compliant language tag. it is only 
     * used to extract the unicode extension keys.
     * @return {number}. The current week in the year when provided a date.
     */
      calculateWeek : function(date, localeElements, locale)
      {
        var d = OraI18nUtils.isoToLocalDate(date);
        var time, checkDate = new Date(d.getTime());

        // Find Thursday of this week starting on Monday
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        time = checkDate.getTime();
        checkDate.setMonth(0);// Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }      
    };
  }
   
  return {
    /**
   * getInstance.
   * Returns the singleton instance of OraDateTimeConverter class.  
   * @memberOf OraDateTimeConverter
   * @return {Object} The singleton OraDateTimeConverter instance.
   */
    getInstance: function () {	 
      if ( !instance ) {
        instance = _init();
      }	 
      return instance;
    }	 
  };
}());
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*global OraNumberConverter:true*/
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * @constructor
 * @classdesc Constructs an immutable instance and initializes it with the options provided. When initialized 
 * with no options, the default options for the current locale are assumed. The converters by 
 * default use the current page locale (returned by oj.Config.getLocale()). There are several ways 
 * to initialize the converter.
 * <p>
 * <ul>
 * <li>Using options defined by the ECMA 402 Specification, these would be the properties style, 
 * currency, currencyDisplay, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, 
 * useGrouping. NOTE: minimumSignificantDigits and maximumSignificantDigits are not supported.</li>
 * <li>Using a custom decimal, currency or percent format pattern. specified using the 'pattern' property</li>
 * </ul>
 * <p>
 * 
 * The converter provides leniency when parsing user input value to a number in the following ways:<br/>
 * 
 * <ul>
 * <li>Prefix and suffix that do not match the pattern, are removed. E.g., when pattern is 
 * "#,##0.00%" (suffix is the % character), a value of "abc-123.45xyz", will be leniently parsed to 
 * -123.45</li>
 * <li>When a value includes a symbol but the pattern doesn't require it.  E.g., the options are 
 * {pattern: "###", currency: 'USD'}, then values ($123), (123) and -123 will be leniently parsed as 
 * -123.</li>
 * </ul>
 * <p>
 * @property {Object=} options - an object literal used to provide an optional information to 
 * initialize the converter.
 * @property {string=} options.style - sets the style of number formatting. Allowed values are "decimal" 
 * (the default), "currency" or "percent". When a number is formatted as a decimal, the decimal 
 * character is replaced with the most appropriate symbol for the locale. In English this is a 
 * decimal point ("."), while in many locales it is a decimal comma (","). If grouping is enabled the 
 * locale dependent grouping separator is also used. These symbols are also used for numbers 
 * formatted as currency or a percentage, where appropriate.
 * @property {string=} options.currency - specifies the currency that will be used when formatting the 
 * number. The value should be a ISO 4217 alphabetic currency code. If the style is set to currency, 
 * it's required that the currency property also be specified. This is because the currency used is 
 * not dependent on the locale. You may be using a Thai locale, but dealing in US Dollars, e.g.
 * @property {string=} options.currencyDisplay - if the number is using currency formatting, specifies 
 * if the currency will be displayed using its "code" (as an ISO 4217 alphabetic currency code), 
 * "symbol" (a localized currency symbol (e.g. $ for US dollars, £ for Great British pounds, and so 
 * on), or "name" (a localized currency name. Allowed values are "code", "symbol" and "name". 
 * The default is "symbol".
 * @property {number=} options.minimumIntegerDigits - sets the minimum number of digits before the 
 * decimal place (known as integer digits). The number is padded with leading zeros if it would not 
 * otherwise have enough digits. The value must be an integer between 1 and 21.
 * @property {number=} options.minimumFractionDigits - similar to 'minimumIntegerDigits', except it 
 * deals with the digits after the decimal place (fractional digits). It must be an integer between 
 * 0 and 20. The fractional digits will be padded with trailing zeros if they are less than the minimum.
 * @property {number=} options.maximumFractionDigits - follows the same rules as 'minimumFractionDigits', 
 * but sets the maximum number of fractional digits that are allowed. The value will be rounded if 
 * there are more digits than the maximum specified.
 * @property {boolean=} options.useGrouping - when the value is truthy, the locale dependent grouping 
 * separator is used when formatting the number. This is often known as the thousands separator, 
 * although it is up to the locale where it is placed. The ‘useGrouping’ is set to true by default.
 * @property {string=} options.pattern an optional localized pattern, where the characters used in 
 * pattern are as defined in the Unicode CLDR for numbers, percent or currency formats. When present 
 * this will override the other "options". <p>
 * 
 * &nbsp;&nbsp;- When the pattern represents a currency style the 'currency' property is required to 
 * be set, as not setting this will throw an error. The 'currencyDisplay' is optional. <br/>Example: 
 * {pattern: '¤#,##0', currency: 'USD'}. <p>
 * 
 * &nbsp;&nbsp;- It's not mandatory for the pattern to have the special character '¤' (currency sign) 
 * be present. When not present, values are treated as a currency value, but are not formatted to 
 * show the currency symbol. <br/>Example: {pattern: '#,##0', currency: 'USD'} <p>
 * 
 * &nbsp;&nbsp;- When the pattern represents a percent style, the percent special character ('%') needs to be 
 * explicitly specified in the pattern, e.g., {pattern: "#,##0%"}. If the pattern does not contain 
 * the percent character it's treated as a decimal pattern, unless the style is set to percent, 
 * in which case the value is treated as a percent value, but not formatted to show the percent symbol. 
 * <br/>Example: {style: 'percent', pattern: "#,##0"}. <p>
 * 
 * &nbsp;&nbsp;- A decimal pattern or exponent pattern is specified in the pattern using the CLDR 
 * conventions. <br/>Example: {pattern: "#,##0.00"} or {pattern: "0.##E+0"}. <p>
 * 
 * NOTE: 'pattern' is provided for backwards compatibility with existing apps that may want the 
 * convenience of specifying an explicit format mask. Setting a pattern will override the default 
 * locale specific format. <br/>
 * 
 * @example <caption>Create a number converter to parse/format currencies</caption>
 * var converterFactory = oj.Validation.converterFactory("number");
 * var options = {style: "currency", currency: "USD", minimumIntegerDigits: 2};
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>A number converter for percent values using a custom (CLDR) pattern</caption>
 * var converterFactory = oj.Validation.converterFactory("number");
 * var options = {pattern: '#,##0%'};
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>To parse a value as percent but format it without displaying the percent character</caption>
 * var options = {style: 'percent', pattern: '#,##0'};<br/>
 * 
 * @example <caption>To parse a value as currency using a custom (CLDR) pattern</caption>
 * var options = {pattern: '¤#,##0', currency: 'USD'};
 * 
 * @export
 * @augments oj.NumberConverter 
 * @name oj.IntlNumberConverter
 * @since 0.6
 */
oj.IntlNumberConverter = function(options)
{
  this.Init(options);
};

oj.Object.createSubclass(oj.IntlNumberConverter, oj.NumberConverter, "oj.IntlNumberConverter");

/**
 * Initializes the number converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.IntlNumberConverter.prototype.Init = function(options) 
{
  oj.IntlNumberConverter.superclass.Init.call(this, options);
};


// Returns the wrapped number converter implementation object.
oj.IntlNumberConverter.prototype._getWrapped = function ()
{
  if (!this._wrapped)
  {
    this._wrapped = OraNumberConverter.getInstance();
  }
  
  return this._wrapped;
};

/**
 * Formats a Number and returns the formatted string, using the options this converter was 
 * initialized with.
 * 
 * @param {Number|number} value to be formatted for display
 * @return {string} the localized and formatted value suitable for display. When the value is 
 * formatted as a percent it's multiplied by 100.
 * 
 * @throws {Error} a ConverterError both when formatting fails, or if the options provided during 
 * initialization cannot be resolved correctly. 
 * 
 * @export
 */
oj.IntlNumberConverter.prototype.format = function (value) 
{
  // undefined, null and empty string values all return null. If value is NaN then return "".
  if (value == null || 
      (typeof value === "string" && (oj.StringUtils.trim("" + value)).length === 0) ||
      (typeof value === "number" && isNaN(value))) 
  {
    return oj.IntlConverterUtils.__getNullFormattedValue();
  }
  
  // TODO: Is this correct?
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;
  
  try
  {
    return this._getWrapped().format(value, localeElements, resolvedOptions, locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};

/**
 * Retrieves a hint String describing the format the value is expected to be in.
 * 
 * @return {String} a hint describing the format the value is expected to be in.
 * @export
 */
oj.IntlNumberConverter.prototype.getHint = function ()
{
  // UX does not want any hint for numbers. 
  // return oj.Translations.getTranslatedString("oj-converter.hint.summary",
  //        {'exampleValue': this._getHintValue()}); 
  return oj.IntlNumberConverter.superclass.getHint.call(this);
};

/**
 * Returns the options called with converter initialization.
 * @return {Object} an object of options.
 * @export
 */
oj.IntlNumberConverter.prototype.getOptions = function () 
{
  return oj.IntlNumberConverter.superclass.getOptions.call(this);
};

/**
 * Parses a string value to return a Number, using the options this converter was initialized with. 
 * 
 * @param {String|string} value to parse
 * @return {number|null} the parsed number or null if the value was null or an empty string. When 
 * the value is parsed as a percent its 1/100th part is returned.
 * 
 * @throws {Error} a ConverterError both when parsing fails, or if the options provided during 
 * initialization cannot be resolved correctly. 
 *  
 * @export
 */
oj.IntlNumberConverter.prototype.parse = function (value) 
{
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;

  // null and empty string values are ignored and not parsed. It
  // undefined.
  if (value == null || value === "") // check for undefined, null and ""
  {
    return null;
  }
  
  try
  {
    // we want to trim the value for leading spaces before and after
    return this._getWrapped().parse(oj.StringUtils.trim(value), 
                                    localeElements, 
                                    resolvedOptions, 
                                    locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
  
};

/**
 * Returns an object literal with properties reflecting the number formatting options computed based 
 * on the options parameter. If options (or pattern) is not provided, the properties will be derived 
 * from the locale defaults.
 * 
 * @return {Object} An object literal containing the resolved values for the following options. Some 
 * of these properties may not be present, indicating that the corresponding components will not be 
 * represented in the formatted output.
 * <ul>
 * <li><b>locale</b>: a String value with the language tag of the locale whose localization is used 
 * for formatting.</li>
 * <li><b>style</b>: a String value. One of the allowed values - "decimal", "currency" or "percent".</li>
 * <li><b>currency</b>: a String value.  an ISO 4217 alphabetic currency code. May be present only 
 *  when style is currency.</li>
 * <li><b>currencyDisplay</b>: a String value. One of the allowed values - "code", "symbol", or 
 *  "name".</li>
 * <li><b>numberingSystem</b>: a String value of the numbering system used. E.g. latn</li>
 * <li><b>minimumIntegerDigits</b>: a non-negative integer Number value indicating the minimum 
 *  integer digits to be used.</li>
 * <li><b>minimumFractionDigits</b>: a non-negative integer Number value indicating the minimum 
 *  fraction digits to be used.</li>
 * <li><b>maximumFractionDigits</b>: a non-negative integer Number value indicating the maximum 
 *  fraction digits to be used.</li>
 * <li><b>useGrouping</b>: a Boolean value indicating whether a grouping separator is used.</li>
 * 
 * @throws a oj.ConverterError when the options that the converter was initialized with are invalid. 
 * @export
 */
oj.IntlNumberConverter.prototype.resolvedOptions = function()
{
  var localeElements, locale = oj.Config.getLocale(), converterError;
  // options are resolved and cached for the current locale. when locale changes resolvedOptions 
  // is reevaluated as it contains locale specific info.
  if ((locale !== this._locale) || !this._resolvedOptions)
  {
    localeElements = oj.LocaleData.__getBundle();
    try
    {
      // cache if successfully resolved
      this._resolvedOptions = this._getWrapped().resolvedOptions(localeElements, 
                                                                 this.getOptions(), 
                                                                 locale);
      this._locale = locale;
    }
    catch (e)
    {
      converterError = this._processConverterError(e);
      throw converterError;
    }
  }
  
  return this._resolvedOptions;
};

/**
 * Processes the error returned by the converter implementation and throws a oj.ConverterError 
 * instance.
 * 
 * @param {Error} e
 * @param {String|string|Number|number|Object=} value
 * @throws an instance of oj.ConverterError
 * @private
 */
oj.IntlNumberConverter.prototype._processConverterError = function (e, value)
{
  var errorInfo = e['errorInfo'], summary, detail, errorCode, parameterMap, converterError, 
          propName, resourceKey;
  if (errorInfo)
  {
    errorCode = errorInfo['errorCode'];
    parameterMap = errorInfo['parameterMap'];
    oj.Assert.assertObject(parameterMap);
    propName = parameterMap['propertyName'];
    
    if (e instanceof TypeError)
    {
      if (errorCode === "optionTypesMismatch" || errorCode === "optionTypeInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof RangeError)
    {
      if (errorCode === "optionOutOfRange")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof SyntaxError)
    {
      if (errorCode === "optionValueInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof Error)
    {
      if (errorCode === "decimalFormatMismatch")
      {
        // The '{value}' does not match the expected decimal format '{format}'.
        resourceKey = "oj-converter.number.decimalFormatMismatch.summary";
      }
      else if (errorCode === "currencyFormatMismatch")
      {
        // The {value} does not match the expected currency format {format}.
        resourceKey = "oj-converter.number.currencyFormatMismatch.summary";
      }
      else if (errorCode === "percentFormatMismatch")
      {
        resourceKey = "oj-converter.number.percentFormatMismatch.summary";
      }
      
      if (resourceKey)
      {
        summary = oj.Translations.getTranslatedString(resourceKey, 
          {'value': value || parameterMap['value'],
           'format': parameterMap['format']});
        
        detail = oj.Translations.getTranslatedString("oj-converter.hint.detail",
          {'exampleValue': this._getHintValue()}); 
          
        converterError = new oj.ConverterError(summary, detail);
      }
    }
  }
  
  if (!converterError)
  {
    // An error we are unfamiliar with. Get the message and set as detail
    summary = e.message; // TODO: What should the summary be when it's missing??
    detail = e.message;
    converterError = new oj.ConverterError(summary, detail);
  }
  
  return converterError;
};

// Returns the hint value.
oj.IntlNumberConverter.prototype._getHintValue = function()
{
  var value = "";
  try
  {
    value =  this.format(12345.98765);
  }
  catch (e)
  {
    if (e instanceof oj.ConverterError)
    {
      // Something went wrong and we don't have a way to retrieve a valid value.
      // TODO: Log an error
      value = "";
    }
  }
  finally
  {
    return value;
  }
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * This is a forked version of globalize.js
 */
/*
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

/*
   DESCRIPTION
   OraNumberConverter object implements number parsing and formatting for
   decimal, currency, percent and perMill types. It supports ECMA-402 options 
   and user defined pattern. The user defined pattern is parsed in order to 
   derive the options that can be specified as ECMA options.

   PRIVATE CLASSES
    <list of private classes defined - with one-line descriptions>

   NOTES
    <other useful comments, qualifications, etc.>

   MODIFIED    (MM/DD/YY)
   gmurr       05/13/14 - Creation
 */

/* 
 * OraNumberConverter object implements number parsing and formatting for
 * decimal, currency, percent and perMill types. It supports ECMA-402 options 
 * and user defined pattern. The user defined pattern is parsed in order to 
 * derive the options that can be specified as ECMA options.
 *<p>The format and parse functions can throw the following exceptions:
 * <li> RangeError can be thrown during the validation of the options:
 * Example: The value 'currencies' is out of range for 'OraNumberConverter.parse'
 * options property 'style'. 
 * Expected: ['currency', 'decimal', 'percent', 'perMill']<br>
 * var errorInfo = {<br>
 *   'errorCode' : "optionOutOfRange",<br>
 *   'parameterMap' : {<br>
 *   'propertyName': $property$,<br>
 *   'propertyValue': $options.property$,<br>
 *   'propertyValueValid': $expectedValues$,<br>
 *   'caller': $_getOptionCaller$<br>
 * }<br>
 * };<br>
 * <br>
 * <br>
 * <li> TypeError can be thrown when currency is missing for currency style. It 
 * can be generic when an options requires a corresponding  option value.<br>
 * Example: A value for the property currency is required when the property
 * style is set to the value currency. An accepted value is a three-letter
 * ISO 4217 currency code.<br>
 * var errorInfo = {<br>
 * 'errorCode' : "optionTypesMismatch",<br>  
 * 'parameterMap' : {<br>
 * 'propertyName': 'style', // the driving property<br>
 * 'propertyValue': 'currency', // the driving property's value<br>
 * 'requiredPropertyName': 'currency', // the required property name<br>
 * 'requiredPropertyValueValid': 'a three-letter ISO 4217 currency code'<br>
 * }<br>
 * };<br> 
 * <br>
 * <br>
 * <li>SyntaxError can be thrown when the number format is invalid. it can 
 * happen during the calls to parse and format number.<br>
 * Example: Unexpected character(s) encountered in the pattern "#00#.00".<br>
 * An example of a valid pattern is "#,##0.0".<br>
 * var errorInfo = {<br>
 * 'errorCode' : "optionValueInvalid",<br> 
 * parameterMap : {'propertyName' : 'pattern',<br>
 *                 'propertyValue': $options.pattern$,<br>
 *                 'propertyValueHint': $format$}<br>
 * };<br>
 * <br>
 * <br>
 * <br>
 * <li>RangeError can be thrown if one of the number options is out of range.
 * It can happen during the calls to format number.<br>
 * Example: 30  is out of range. Enter a value between 0 and 20 for 
 * minimumFractionDigits. 
 * var errorInfo = {<br>
 * 'errorCode' : "numberOptionOutOfRange",<br>
 * 'parameterMap' : {'value': $value$, 'minValue': $mainValue$,
 * 'maxVlaue': $maxValue$, 'propertyName': $name$}<br>
 * };<br>
 * <br>
 * <br>
 * <li>Error can be thrown when there is mismatch between number pattern and
 * number string. it can happen during the calls to parse number.<br>
 * Example: The value "-$125" does not match the expected currency 
 * pattern "&#xa4;#,##0.00;(&#xa4;#,##0.00)"<br>
 * var errorInfo = {'errorCode' : "decimalFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,  'format': $format$}};<br>
 * var errorInfo = {'errorCode' : "currencyFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,   'format': $format$}};<br>
 * var errorInfo = {'errorCode' : "percentFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,   'format': $format$}};<br>
 */
 
var OraNumberConverter;
  
OraNumberConverter = (function () {
  var _zeroPad,
  _formatNumberImpl,
  _applyPatternImpl,
  _parseNegativePattern,
  _lenientParseNumber,
  _parseNegativeExponent,
  _getNumberSettings,
  _validateNumberOptions,
  _throwMissingCurrency,
  _throwNumberOutOfRange,
  _getNumberOption,
  _throwNaNException,
  _toRawFixed, _toExponentialPrecision, instance,
  _regionMatches, _expandAffix, _expandAffixes, _throwSyntaxError;
 
  var _REGEX_INFINITY = /^[+\-]?infinity$/i,
  _REGEX_PARSE_FLOAT = /^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/,
  _LENIENT_REGEX_PARSE_FLOAT = /([^+-.0-9]*)([+\-]?\d*\.?\d*(E[+\-]?\d+)?).*$/,
  _ESCAPE_REGEXP = /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g,
  _REGEX_TRIM_ZEROS = /(^0\.0*)([^0].*$)/;

    
  //prepend or append count zeros to a string.
  _zeroPad = function(str, count, left) {
    var l;
    for (l = str.length; l < count; l += 1) {
      str = (left ? ("0" + str) : (str + "0"));
    }
    return str;
  };
  
  _throwNumberOutOfRange = function(value, minimum, maximum, property) {
    var msg =  value + 
    " is out of range.  Enter a value between " + minimum +
    " and " + maximum + " for " + property; 
    var rangeError = new RangeError(msg);
    var errorInfo = {
      'errorCode' : "numberOptionOutOfRange",
      'parameterMap' : {
        'value': value, 
        'minValue': minimum,
        'maxValue': maximum,
        'propertyName': property
      }
    };
    rangeError['errorInfo'] = errorInfo;
    throw rangeError;     
  };
  
  _getNumberOption = function(options, property, minimum, maximum, fallback) {
    var value = options[property];
    if(value !== undefined) {
      value = Number(value);
      if(isNaN(value) || value < minimum || value > maximum) {
        _throwNumberOutOfRange(value, minimum, maximum, property);
      }
      return Math.floor(value);
    }
    else {
      return fallback;
    }
  };
    
  /*return the properties for a number such as minimum and maximum fraction 
     *digits, decimal separator, grouping separator.
     *-If no user defined pattern is provided, get the pattern from the locale
     *  data and parse it to extrcat the number properties. If ecma options are
     *  present, override the corresponding default properties.
     *-If a user defined pattern is provided, parse it and extrcat the number
     *  properties. Ignore ecma ptions if present.
     */
    
  _getNumberSettings = function(localeElements, numberSettings,
    options, locale) {
    var pat;
    var localeElementsMainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    var numberingSystemKey = OraI18nUtils.getNumberingSystemKey(localeElementsMainNode, locale);
    numberSettings['numberingSystemKey'] = numberingSystemKey;
    numberSettings['numberingSystem'] = "symbols-numberSystem-" +
    numberingSystemKey;        

    //pattern passed in options
    if(options['pattern'] !== undefined && options['pattern'].length > 0) {
      pat = options['pattern'];
    }
    else
    {  
      var key;
      switch(options['style'])
      {
        case "decimal" :
          key = "decimalFormats-numberSystem-";
          break;
        case "currency" :
          key = "currencyFormats-numberSystem-";
          break;
        case "percent" :
          key = "percentFormats-numberSystem-";
          break;
        default:
          key = "decimalFormats-numberSystem-";
          break;
      }
      key +=  numberSettings['numberingSystemKey'];
      pat = localeElementsMainNode['numbers'][key]['standard'];

    }
    var mainNodeKey = OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
    var bcp47Keys = OraI18nUtils.parseBCP47(mainNodeKey);
    var lang = bcp47Keys['language']['language'];
    numberSettings['lang'] = lang;
    numberSettings['pat'] = pat;
    numberSettings['minusSign'] = localeElementsMainNode['numbers']
    [numberSettings['numberingSystem']]['minusSign'];
    numberSettings['decimalSeparator'] = localeElementsMainNode['numbers']
    [numberSettings['numberingSystem']]['decimal'];
    numberSettings['exponential'] = localeElementsMainNode['numbers']
    [numberSettings['numberingSystem']]['exponential'];
    numberSettings['groupingSeparator'] = localeElementsMainNode['numbers']
    [numberSettings['numberingSystem']]['group'];
    numberSettings['currencyDisplay'] = options['currencyDisplay'];
    if(options['currency'] !== undefined)
      numberSettings['currencyCode'] = options['currency'].toUpperCase();
    numberSettings['style'] = options['style'];
    _applyPatternImpl(options, pat, localeElementsMainNode, numberSettings);
    if(options['pattern'] === undefined) {
      numberSettings['minimumIntegerDigits'] = _getNumberOption(options,
        'minimumIntegerDigits', 1, 21,
        numberSettings['minimumIntegerDigits']);
      if(options['maximumFractionDigits'] !== undefined) {
        numberSettings['maximumFractionDigits'] = _getNumberOption(options,
          'maximumFractionDigits', 0, 20, numberSettings['maximumFractionDigits']);
        if(numberSettings['maximumFractionDigits'] < numberSettings['minimumFractionDigits']) {
          numberSettings['minimumFractionDigits'] = numberSettings['maximumFractionDigits'];
        }
      }
      if(options['minimumFractionDigits'] !== undefined) {
        numberSettings['minimumFractionDigits'] = _getNumberOption(options,
          'minimumFractionDigits', 0, 20,
          numberSettings['minimumFractionDigits']);
      }
      if(numberSettings['maximumFractionDigits'] < numberSettings['minimumFractionDigits']) {
        numberSettings['maximumFractionDigits'] = numberSettings['minimumFractionDigits'];
      }
    }
  };
    
  _throwMissingCurrency = function(prop) {
    var typeError = new TypeError('The property "currency" is required when' +
      'the property "' + prop + '" is "currency". An accepted value is a ' +
      'three-letter ISO 4217 currency code.');
    var errorInfo = {
      'errorCode' : 'optionTypesMismatch',
      'parameterMap' : {
        'propertyName': prop, // the driving property
        'propertyValue': 'currency', // the driving property's value
        'requiredPropertyName': 'currency', // the required property name
        'requiredPropertyValueValid':  'a three-letter ISO 4217 currency code'  
      }
    };
    typeError['errorInfo'] = errorInfo;
    throw typeError;
  };
  //If the user specifies currency as a style, currency option must also be
  // provided.
  _validateNumberOptions = function(options, caller) {
    var getOption = OraI18nUtils.getGetOption(options, caller);
    var s = getOption('style', 'string', ['currency', 'decimal', 'percent', 'perMill'],
      'decimal');
    var c =getOption('currency', 'string');
    if(s === 'currency' && c === undefined) {
      _throwMissingCurrency("style");
    }
  };
  
  //_toExponentialPrecision does the formatting when the pattern contain E,
  //for example #.#E0  
  _toExponentialPrecision = function(number, numberSettings) {
    var numStr0 = number + "";
    var trimExp = 0;
    var split = numStr0.split(/e/i);
    var numStr = split[0];
    _REGEX_TRIM_ZEROS.lastIndex = 0;
    var match= _REGEX_TRIM_ZEROS.exec(numStr);
    if(match !== null) {
      trimExp = match[1].length - 1;  
      numStr  = match[2];
    }
    else {
      numStr = numStr.replace(".", "");
    }
    var exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
    var numStr1 = parseInt(numStr, 10);
    var len = numberSettings['minimumIntegerDigits'] + numberSettings['maximumFractionDigits'];
    if(numStr.length > len) {
      len -= numStr.length;
      var factor = Math.pow( 10, len );
      numStr1 =  Math.round( numStr1 * factor );
    }
    var padLen = numberSettings['minimumIntegerDigits'] + numberSettings['minimumFractionDigits'];
    numStr1 = numStr1 + "";
    numStr1 = _zeroPad(numStr1, padLen, false);
    if(numStr0.indexOf('.') !== -1) {
      exponent -=  numberSettings['minimumIntegerDigits'] - numStr0.indexOf('.') + trimExp;
    }
    else {
      exponent -= padLen - numStr.length - numberSettings['minimumFractionDigits'];
    }
    var posExp = Math.abs(exponent);
    posExp = _zeroPad(posExp + "", numberSettings['minExponentDigits'], true);
    if(exponent < 0)
      posExp = numberSettings['minusSign'] + posExp;
    var str1 = numStr1.slice(0, numberSettings['minimumIntegerDigits']);
    var str2 = numStr1.slice(numberSettings['minimumIntegerDigits']);
    if(str2.length > 0) {
      str1 += numberSettings['decimalSeparator'] + numStr1.slice(numberSettings['minimumIntegerDigits']) +
      numberSettings['exponential'] + posExp;
    }
    else {
      str1 += numberSettings['exponential'] + posExp;
    }
    return str1;
  }; 
   
  //_toRawFixed does the formatting based on
  //minimumFractionDigits and maximumFractionDigits.
  _toRawFixed = function(number, options, numberSettings) {
    var curSize = numberSettings['groupingSize'];
    //First round the number based on maximumFractionDigits
    var numberString = number + "";
    var split = numberString.split( /e/i );
    var exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
    numberString = split[ 0 ];
    split = numberString.split('.');
    var right = split.length > 1 ? split[ 1 ] : "";
    //round the number only if it has decimal points
    if(split.length > 1 && right.length > exponent)      
    {
      var precision = Math.min(numberSettings['maximumFractionDigits'],
        right.length-exponent);
      var factor = Math.pow( 10, precision ),
      rounded = Math.round( number * factor )  / factor;
      if ( !isFinite(rounded) ) {
        rounded = number;
      }
      number = rounded;
    }
    //split the number into integer, fraction and exponent parts.
    numberString = number + "";
    split = numberString.split( /e/i );
    exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
    numberString = split[ 0 ];
    split = numberString.split('.');
    numberString = split[ 0 ];
    right = split.length > 1 ? split[ 1 ] : "";
    //pad zeros based on the exponent value and minimumFractionDigits 
    if (exponent > 0) {
      right = _zeroPad(right, exponent, false);
      numberString += right.slice(0, exponent);
      right = right.substr(exponent);
    }
    else if (exponent < 0) {
      exponent = -exponent;
      numberString = _zeroPad(numberString, exponent + 1, true);
      right = numberString.slice(-exponent, numberString.length) + right;
      numberString = numberString.slice(0, -exponent);
    }
    if (precision > 0) {       
      right = numberSettings['decimalSeparator'] +
      ((right.length > precision) ? right.slice(0, precision) : 
        _zeroPad(right, precision, false));
    }
    else {
      if (numberSettings['minimumFractionDigits'] > 0){
        right = numberSettings['decimalSeparator'];
      }
      else {
        right = "";
      }
    }
    //insert grouping separator in the integer part based on groupingSize
    var padLen = numberSettings['decimalSeparator'].length +
    numberSettings['minimumFractionDigits'];
    right = _zeroPad(right, padLen, false);
    var sep = numberSettings['groupingSeparator'],
    ret = "";
    if(options['useGrouping'] === false && options['pattern'] === undefined)
      sep = '';      
    numberString = _zeroPad(numberString,
      numberSettings['minimumIntegerDigits'], true);
    var stringIndex = numberString.length - 1;
    right = right.length > 1 ? right : "";
    var rets;
    while (stringIndex >= 0) {
      if (curSize === 0 || curSize > stringIndex) {
        rets = numberString.slice(0, stringIndex + 1) +
        (ret.length ? (sep + ret + right) : right);
        return rets;
      }
      ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) +
      (ret.length ? (sep + ret) : "");
      stringIndex -= curSize;
    }
    rets = numberString.slice(0, stringIndex + 1) + sep + ret + right;
    return rets;
  };
 
  //first call _toRawFixed then add prefixes and suffixes. Display the 
  //number using native digits based on the numbering system
  _formatNumberImpl = function(value, options, localeElements,
    numberSettings, locale) {
    var localeElementsMainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
    if (!isFinite(value)) {
      if (value === Infinity) {
        return localeElementsMainNode['numbers'][numberSettings['numberingSystem']]['infinity'];
      }
      if (value === -Infinity) {
        return localeElementsMainNode['numbers'][numberSettings['numberingSystem']]['infinity'];
      }
      return localeElementsMainNode['numbers'][numberSettings['numberingSystem']]['nan'];
    }
    var number = Math.abs(value);
    if(numberSettings['isPercent'] === true ||
      options['style'] === 'percent')
      number *= 100;
    else if(numberSettings['isPerMill'] === true)
      number *= 1000;
	
    //expand the number
    if(numberSettings['useExponentialNotation'] == true)
      number = _toExponentialPrecision(number, numberSettings);
    else
      number = _toRawFixed(number, options, numberSettings);
    var ret = "";
    //add negative prefix and suffix if number is negative
    if(value < 0) {
      ret += numberSettings['negativePrefix'] + number +
      numberSettings['negativeSuffix'];
    }
    //add positive prefix and suffix if number is positive
    else {
      ret += numberSettings['positivePrefix'] + number +
      numberSettings['positiveSuffix'];
    }
    //display the digits based on the numbering system
    var numberingSystemKey =  OraI18nUtils.getLanguageExtension(locale, "nu");
    if(OraI18nUtils.numeringSystems[numberingSystemKey] === undefined)
      numberingSystemKey = 'latn';
    if(numberingSystemKey !== 'latn') {
      var idx;
      var nativeRet = [];
      for(idx = 0; idx < ret.length; idx++)
      {
        if(ret[idx] >= '0' && ret[idx] <= '9')
          nativeRet.push(OraI18nUtils.numeringSystems[numberingSystemKey][ret[idx]]);
        else nativeRet.push(ret[idx]);
        
      }
      return nativeRet.join("");
    }
    return ret;
  };
    
  //remove prefix and suffix, return a sign and value. First try to extract
  //a number using exact match. If it fails try lenient parsing.
  _parseNegativePattern = function(value, options, numberSettings,
    localeElements) {
    var ret, num = OraI18nUtils.trimNumber(value);
    var sign = "";
    var exactMatch = false;
    var posSign =  localeElements['numbers'][numberSettings['numberingSystem']]['plusSign'];
    var posSignRegExp = new RegExp("^" + posSign.replace(_ESCAPE_REGEXP, "\\$1"));
    num = num.replace(posSignRegExp, "");
    var nbSettingPosPrefix = OraI18nUtils.trimNumber(numberSettings['positivePrefix']),
    nbSettingPosSuffix = OraI18nUtils.trimNumber(numberSettings['positiveSuffix']),
    nbSettingNegPrefix = OraI18nUtils.trimNumber(numberSettings['negativePrefix']),
    nbSettingNegSuffix = OraI18nUtils.trimNumber(numberSettings['negativeSuffix']);
    //try exact match of negative prefix and suffix
    var posPrefRegexp = new RegExp("^" + (nbSettingPosPrefix ||
      "").replace(_ESCAPE_REGEXP, "\\$1"));
    var posSuffRegexp = new RegExp((nbSettingPosSuffix || "").
      replace(_ESCAPE_REGEXP, "\\$1") + "$");
    var negPrefRegexp = new RegExp("^" + (nbSettingNegPrefix ||
      "").replace(_ESCAPE_REGEXP, "\\$1"));
    var negSuffRegexp = new RegExp((nbSettingNegSuffix ||
      "").replace(_ESCAPE_REGEXP, "\\$1") + "$");
    
    if(negPrefRegexp.test(num) == true && negSuffRegexp.test(num) == true) {   
      num = num.replace(negPrefRegexp, "");
      num = num.replace(negSuffRegexp, "");
      sign = "-"; 
      exactMatch = true;
    }
    //try exact match of positive prefix and suffix
    else if(posPrefRegexp.test(num) == true && posSuffRegexp.test(num) == true){
      num = num.replace(posPrefRegexp, "");
      num = num.replace(posSuffRegexp, "");
      sign = "+";
      exactMatch = true;
    }
    //if style is currency, remove currency symbol from prefix and suffix 
    //and try a match
    else if (options['style'] === 'currency') {
      var code = numberSettings['currencyCode'], symbol = code;
      var posPrefix, posSuffix, negPrefix, negSuffix, repStr;
      if(localeElements['numbers']['currencies'][code] !== undefined) {
        symbol = localeElements['numbers']['currencies'][code]['symbol'];
      }
      if(numberSettings['currencyDisplay'] === undefined ||
        numberSettings['currencyDisplay'] === "symbol") {
        repStr = symbol;
      }
      else if (numberSettings['currencyDisplay'] === "code") {
        repStr = code;
      }
      if(repStr !== undefined) {
        posPrefix = (nbSettingPosPrefix || "").replace(
          repStr, "");
        posSuffix = (nbSettingPosSuffix || "").replace(
          repStr, "");
        negPrefix = (nbSettingNegPrefix || "").replace(
          repStr, "");
        negSuffix = (nbSettingNegSuffix || "").replace(
          repStr, "");
        posPrefRegexp = new RegExp(("^" + posPrefix).replace(
          _ESCAPE_REGEXP, "\\$1"));
        posSuffRegexp = new RegExp(posSuffix.replace(
          _ESCAPE_REGEXP, "\\$1") + "$");
        negPrefRegexp = new RegExp(("^" + negPrefix).replace(
          _ESCAPE_REGEXP, "\\$1"));
        negSuffRegexp = new RegExp(negSuffix.replace(
          _ESCAPE_REGEXP, "\\$1") + "$");
 
        //try  match of positive prefix and suffix
        if(negPrefRegexp.test(num) == true && negSuffRegexp.test(num) == true) {        
          num = num.replace(negPrefRegexp, "");
          num = num.replace(negSuffRegexp, "");
          sign = "-";
          exactMatch = true;
        }
        //try exact match of positive prefix and suffix
        else if(posPrefRegexp.test(num) == true && posSuffRegexp.test(num) == true) {
          num = num.replace(posPrefRegexp, "");
          num = num.replace(posSuffRegexp, "");
          sign = "+";
          exactMatch = true;
        }
      }
    }
    if(!exactMatch) {
      ret = _lenientParseNumber(num, numberSettings, localeElements);
      ret[2] = true;
    }
    else 
      ret = [sign, num];
    return ret;
  };

  _lenientParseNumber = function(num, numberSettings, localeElements) {
    // Try to extract the number accoring to the following pattern:
    // optional +- followed by one or many digits followed by optional
    // fraction part followed by optional exponential.
    // use localized +, -, decimal separator, exponential
    // [+-]?\d+(?:\.\d+)?(?:E[+-]?\d+)?/;
    //remove grouping deparator from string
    var groupingSeparator = 
    localeElements['numbers'][numberSettings['numberingSystem']]['group'];
    var decimalSeparator = 
    localeElements['numbers'][numberSettings['numberingSystem']]['decimal'];
    var plusSign = "+";
    var minusSign = "-";
    var sign = "";
    var dot = "";
    var exponential = 
    OraI18nUtils.toUpper(localeElements['numbers'][numberSettings['numberingSystem']]['exponential']);
    num = OraI18nUtils.toUpper(num);
    num = num.split(exponential).join("E");
    //remove grouping separator from string
    var groupSep = groupingSeparator;
    num = num.split(groupSep).join("");
    var altGroupSep = groupSep.replace(/\u00A0/g, " ");
    if (groupSep !== altGroupSep) {
      num = num.split(altGroupSep).join("");
    }
    num = num.split(decimalSeparator).join(".");
    if(num.charAt(0)=== ".") {
      num = num.substr(1);
      dot = ".";
    }
    var match = _LENIENT_REGEX_PARSE_FLOAT.exec(num);
    var resNum = dot + match[2]; 
    if (OraI18nUtils.startsWith(resNum, minusSign)) {
      resNum =  resNum.substr(minusSign.length);
      sign = "-";
    }
    else if (OraI18nUtils.startsWith(num, plusSign)) {
      resNum = resNum.substr(plusSign.length);
      sign = "+";
    }
    return [sign, resNum];
  };
  
  //parse the exponent part of a number
  _parseNegativeExponent = function(value, localeElements, numberSettings) {
    var neg = localeElements['numbers'][numberSettings['numberingSystem']]['minusSign'],
    pos =  localeElements['numbers'][numberSettings['numberingSystem']]['plusSign'],
    ret;
    value = OraI18nUtils.trimNumber(value);
    neg =OraI18nUtils.trimNumber(neg);
    pos =OraI18nUtils.trimNumber(pos);
    if (OraI18nUtils.startsWith(value, neg)) {
      ret = [ "-", value.substr(neg.length) ];
    }
    else if (OraI18nUtils.startsWith(value, OraI18nUtils.trimNumber(pos))) {
      ret = [ "+", value.substr(pos.length) ];
    }
    return ret || [ "", value ];
  };

  /* This module handles the  parsing of a number pattern.
     * It sets prefix, suffix, minimum and maximum farcation digits, 
     * miimum  integer digits and grouping size. 
     */
   
  var _ZERO_DIGIT         = '0',
  _GROUPING_SEPARATOR = ',',
  _DECIMAL_SEPARATOR  = '.',
  _PERCENT           = '%',
  _PER_MILL          = '\u2030',
  _DIGIT             = '#',
  _SEPARATOR         = ';',
  _EXPONENT          =  "E",
  _MINUS             = '-',
  _QUOT              = '\'',
  _CURRENCY     = '\u00A4';
  
  var posPrefixPattern,
  posSuffixPattern,
  negPrefixPattern,
  negSuffixPattern;

  var _MAXIMUM_INTEGER_DIGITS = 0x7fffffff;
  var _MAXIMUM_FRACTION_DIGITS = 0x7fffffff;
      
  _throwSyntaxError = function(pattern) {
    var msg, syntaxError, errorInfo, samplePattern = "#,##0.###";
    msg =  "Unexpected character(s) encountered in the pattern \"" + 
    pattern + " An example of a valid pattern is \"" + samplePattern +
    '".';
    syntaxError = new SyntaxError(msg);
    errorInfo = {
      'errorCode' : 'optionValueInvalid',
      'parameterMap' : {
        'propertyName' : 'pattern',
        'propertyValue': pattern,
        'propertyValueHint': samplePattern
      }
    };
    syntaxError['errorInfo'] = errorInfo;
    throw syntaxError;
  };
      
  _regionMatches = function(str1, offset1, str2) {
    var sub1 = str1.substr(offset1, str2.length);
    var regExp = new RegExp(str2, "i");
    return (regExp.exec(sub1) !== null);
  };

  _expandAffixes = function(localeElements, numberSettings) {
    var curDisplay = {};
    if (posPrefixPattern != null) {
      numberSettings['positivePrefix'] = _expandAffix(posPrefixPattern,
        localeElements, numberSettings, curDisplay);
    }
    if (posSuffixPattern != null) {
      numberSettings['positiveSuffix'] = _expandAffix(posSuffixPattern,
        localeElements, numberSettings, curDisplay);
    }
    if (negPrefixPattern != null) {
      numberSettings['negativePrefix'] = _expandAffix(negPrefixPattern,
        localeElements, numberSettings, curDisplay);
    }
    if (negSuffixPattern != null) {
      numberSettings['negativeSuffix'] = _expandAffix(negSuffixPattern,
        localeElements, numberSettings, curDisplay);
    }
    if(curDisplay['name'] !== undefined) {
      numberSettings['positiveSuffix'] = "\u00a0" + curDisplay['name'];
      numberSettings['positivePrefix'] = "";
      if( numberSettings['lang'] === 'ar') {
        numberSettings['negativeSuffix'] = localeElements['numbers'][numberSettings['numberingSystem']]['minusSign'] + "\u00a0" + curDisplay['name'];
        numberSettings['negativePrefix'] = "";
      }
      else {
        numberSettings['negativeSuffix'] = "\u00a0" + curDisplay['name'];
        numberSettings['negativePrefix'] =  localeElements['numbers'][numberSettings['numberingSystem']]['minusSign'];
      }
    }
  };

  _expandAffix = function(pattern, localeElements, numberSettings,
    currencyDisplay) {
    var buffer = "";
    for (var i=0; i<pattern.length;) {
      var c = pattern.charAt(i++);
      if (c == _QUOT)// {
        continue;
      //c = pattern.charAt(i++);
      switch (c) {
        case _CURRENCY:
          var code = numberSettings['currencyCode'];
          var name = code, symbol = code;
          if(localeElements['numbers']['currencies'][code] !== undefined) {
            name = localeElements['numbers']['currencies'][code]['displayName']; 
            symbol = localeElements['numbers']['currencies'][code]['symbol'];
          }
          if(numberSettings['currencyDisplay'] === undefined ||
            numberSettings['currencyDisplay'] === "symbol")
            c = symbol;
          else if (numberSettings['currencyDisplay'] === "code") {
            c = code;
          }
          else {
            c = name;
            currencyDisplay['name'] = c;
          }
          break;
        case _PERCENT:
          c = localeElements['numbers'][numberSettings['numberingSystem']]['percentSign'];
          break;
        case _PER_MILL:
          c = localeElements['numbers'][numberSettings['numberingSystem']]['perMille'];
          break;
        case _MINUS:
          c = localeElements['numbers'][numberSettings['numberingSystem']]['minusSign'];
          break;
      }
      //}
      buffer = buffer.concat(c);
    }
    return buffer;
  };

  _applyPatternImpl = function(options, pattern, localeElements,
    numberSettings) {
      
    var gotNegative = false,
    useExponentialNotation = false;
    var phaseOneLength = 0;         
    var start = 0;
    var isPrefix = true;
        
    for (var j = 1; j >= 0 && start < pattern.length; --j) {
      var inQuote = false;
      var prefix = "";
      var suffix = "";
      var decimalPos = -1;
      var multiplier = 1;
      var digitLeftCount = 0, zeroDigitCount = 0, digitRightCount = 0,
      groupingCount = -1;
      var minExponentDigits;
      var phase = 0;

      isPrefix = true;
      for (var pos = start; pos < pattern.length; ++pos) {
        var ch = pattern.charAt(pos);
        switch (phase) {
          case 0:
          case 2:
            // Process the prefix / suffix characters
            if (inQuote) {
              if (ch === _QUOT) {
                if ((pos+1) < pattern.length && pattern.charAt(pos+1) === 
                  _QUOT) {
                  ++pos;
                  if(isPrefix)
                    prefix = prefix.concat("''");
                  else
                    suffix = suffix.concat("''");
                } else {
                  inQuote = false; // 'do'
                }
                continue;
              }
            }
            else {
              // Process unquoted characters seen in prefix or suffix phase.
              if (ch === _DIGIT ||
                ch === _ZERO_DIGIT ||
                ch === _GROUPING_SEPARATOR ||
                ch === _DECIMAL_SEPARATOR) {
                phase = 1;
                --pos; // Reprocess this character
                continue;
              } else if (ch === _CURRENCY) {
                if(options['currency'] === undefined)
                  _throwMissingCurrency("pattern");
                // Use lookahead to determine if the currency sign
                // is doubled or not.
                options['style'] = 'currency';
                var doubled = (pos + 1) < pattern.length &&
                pattern.charAt(pos + 1) === _CURRENCY;
                if (doubled) { // Skip over the doubled character
                  ++pos;
                }
                if(isPrefix)
                  prefix = prefix.concat(doubled ? "'\u00A4\u00A4" : 
                    "'\u00A4");
                else
                  suffix = suffix.concat(doubled ? "'\u00A4\u00A4" : 
                    "'\u00A4");
                continue;
              } else if (ch === _QUOT) {
                if (ch == _QUOT) {
                  if ((pos+1) < pattern.length &&
                    pattern.charAt(pos+1) == _QUOT) {
                    ++pos;
                    if(isPrefix)
                      prefix = prefix.concat("''");// o''clock
                    else
                      suffix = suffix.concat("''");
                  } else {
                    inQuote = true; // 'do'
                  }
                  continue;
                }
              } else if (ch === _SEPARATOR) {
                if (phase === 0 || j === 0) {                    
                  _throwSyntaxError(pattern);
                }
                start = pos + 1;
                pos = pattern.length;
                continue;
              }

              // Next handle characters which are appended directly.
              else if (ch === _PERCENT) {
                options['style'] = 'percent';
                if (multiplier != 1) {                      
                  _throwSyntaxError(pattern);
                }
                numberSettings['isPercent'] = true;
                multiplier = 100;
                if(isPrefix)
                  prefix = prefix.concat("'%");
                else
                  suffix = suffix.concat("'%");
                continue;
              } else if (ch === _PER_MILL) {
                if (multiplier != 1) {                      
                  _throwSyntaxError(pattern);
                }
                options['style'] = 'perMill';
                numberSettings['isPerMill'] = true;
                multiplier = 1000;
                if(isPrefix)
                  prefix = prefix.concat("'\u2030");
                else
                  suffix = suffix.concat("'\u2030");
                continue;
              }
              else if (ch === _MINUS) {
                if(isPrefix)
                  prefix = prefix.concat("'-");
                else
                  suffix = suffix.concat("'-");
                continue;
              }
            }
            if(isPrefix)
              prefix = prefix.concat(ch);
            else
              suffix = suffix.concat(ch);
            break;

          case 1:
            if (j === 1) {
              ++phaseOneLength;
            } else {
              if (--phaseOneLength === 0) {
                phase = 2;
                isPrefix = false;
              }
              continue;
            }

            if (ch === _DIGIT) {
              if (zeroDigitCount > 0) {
                ++digitRightCount;
              } else {
                ++digitLeftCount;
              }
              if (groupingCount >= 0 && decimalPos < 0) {
                ++groupingCount;
              }
            } else if (ch === _ZERO_DIGIT) {
              if (digitRightCount > 0) {
                _throwSyntaxError(pattern);
              }
              ++zeroDigitCount;
              if (groupingCount >= 0 && decimalPos < 0) {
                ++groupingCount;
              }
            } else if (ch === _GROUPING_SEPARATOR) {
              groupingCount = 0;
            } else if (ch === _DECIMAL_SEPARATOR) {
              if (decimalPos >= 0) {                    
                _throwSyntaxError(pattern);
              }
              decimalPos = digitLeftCount + zeroDigitCount + 
              digitRightCount;
            } else if (_regionMatches(pattern, pos, _EXPONENT)) {
              if (useExponentialNotation) {
                _throwSyntaxError(pattern);
              }
              useExponentialNotation = true;
              minExponentDigits = 0;
              pos = pos + _EXPONENT.length;
              while (pos < pattern.length && pattern.charAt(pos) === 
                _ZERO_DIGIT) {
                ++minExponentDigits;
                ++phaseOneLength;
                ++pos;
              }
              
              if ((digitLeftCount + zeroDigitCount) < 1 || 
                minExponentDigits < 1) {
                _throwSyntaxError(pattern);
              }
              phase = 2;
              isPrefix = false;
              --pos;
              continue;
            } else {
              phase = 2;
              isPrefix = false;
              --pos;
              --phaseOneLength;
              continue;
            }
            break;
        }
      }

      
      if (zeroDigitCount === 0 && digitLeftCount > 0 && decimalPos >= 0) {
        // Handle "###.###" and "###." and ".###"
        var n = decimalPos;
        if (n === 0) { // Handle ".###"
          ++n;
        }
        digitRightCount = digitLeftCount - n;
        digitLeftCount = n - 1;
        zeroDigitCount = 1;
      }

      // Do syntax checking on the digits.
      if ((decimalPos < 0 && digitRightCount > 0) ||
        (decimalPos >= 0 && (decimalPos < digitLeftCount ||
          decimalPos > (digitLeftCount + zeroDigitCount))) ||
        groupingCount == 0 || inQuote) {
        _throwSyntaxError(pattern);
      }

      if (j === 1) {
        posPrefixPattern = prefix;
        posSuffixPattern = suffix;
        negPrefixPattern = posPrefixPattern;
        negSuffixPattern = posSuffixPattern;
        var digitTotalCount = digitLeftCount + zeroDigitCount + 
        digitRightCount;
        // The effectiveDecimalPos is the position the decimal is at or
        //would be at if there is no decimal. Note that if decimalPos<0,
        // then digitTotalCount == digitLeftCount + zeroDigitCount.
        var effectiveDecimalPos = decimalPos >= 0 ?
        decimalPos : digitTotalCount;
        numberSettings['minimumIntegerDigits'] = (effectiveDecimalPos - 
          digitLeftCount);
        numberSettings['maximumIntegerDigits'] = (useExponentialNotation ?
          digitLeftCount + numberSettings['minimumIntegerDigits'] :
          _MAXIMUM_INTEGER_DIGITS);
        numberSettings['maximumFractionDigits'] = (decimalPos >= 0 ?
          (digitTotalCount - decimalPos) : 0);
        numberSettings['minimumFractionDigits'] = (decimalPos >= 0 ?
          (digitLeftCount + zeroDigitCount - decimalPos) : 0);
        numberSettings['groupingSize'] = (groupingCount > 0) ? 
        groupingCount : 0;
      } else {
        negPrefixPattern = prefix;
        negSuffixPattern = suffix;
        gotNegative = true;
      }
    }

    if (pattern.length == 0) {
      posPrefixPattern = posSuffixPattern = "";
      numberSettings['minimumIntegerDigits'] = 0;
      numberSettings['maximumIntegerDigits'] = _MAXIMUM_INTEGER_DIGITS;
      numberSettings['minimumFractionDigits'] = 0;
      numberSettings['maximumFractionDigits'] = _MAXIMUM_FRACTION_DIGITS;
    }
    numberSettings['useExponentialNotation'] = useExponentialNotation;
    numberSettings['minExponentDigits'] = minExponentDigits;
    // If there was no negative pattern, or if the negative pattern is
    // identical to the positive pattern, then prepend the minus sign to
    // the positive pattern to form the negative pattern.
    if (!gotNegative ||
      ((negPrefixPattern.localeCompare(posPrefixPattern) == 0)
        && (negSuffixPattern.localeCompare(posSuffixPattern) == 0))) {
      if(options['style'] === 'currency' && numberSettings['lang'] === 'ar') {
        negSuffixPattern = posSuffixPattern + "'\u200f-";
        negPrefixPattern =  posPrefixPattern;
      }
      else {
        negSuffixPattern = posSuffixPattern;
        negPrefixPattern = "'-" + posPrefixPattern;

      }
    }
    _expandAffixes(localeElements, numberSettings);
  };
  
  _throwNaNException = function(ret, options, numberSettings, errStr) {
    if(isNaN(ret)) {
      var msg, error, errorInfo, code;
      msg = "Unparsable number " + errStr + " The expected number " + 
      "pattern is " + numberSettings['pat'];
      switch(options['style'])
      {
        case "decimal" :
          code = "decimalFormatMismatch";
          break;
        case "currency" :
          code = "currencyFormatMismatch";
          break;
        case "percent" :
          code = "percentFormatMismatch";
          break;
      }
      error = new Error(msg);
      errorInfo = {
        'errorCode' : code,
        'parameterMap' : {
          'value' : errStr,
          'format': numberSettings['pat']
        }
      };
      error['errorInfo'] = errorInfo;
      throw error;
    }
    if(numberSettings['isPercent'] === true || options['style'] ===
      'percent')
      ret /= 100;
    else if(numberSettings['isPerMill'] === true)
      ret /= 1000;
    return ret;
  };
  
  function _init()
  {
    
    return {
      /**
         * Format a number.
         * @memberOf OraNumberConverter
         * @param {number} value - Number object to be formatted.
         * @param {Object} localeElements - the instance of LocaleElements  
         * bundle
         * @param {Object=} options - Containing the following properties:<br>
         * - <b>style.</b>  is one of the String values "decimal", "currency"  
         * or "percent". The default is "decimal".<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory 
         *  when style is "currency".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code", 
         * "symbol", or "name", specifying whether to display the currency as  
         * an ISO 4217 alphabetic currency code, 
         * a localized currency symbol, or a localized currency name if 
         * formatting with the "currency" style. It is only present when style 
         * has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value 
         * indicating the minimum integer digits to be used. Numbers will be 
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value 
         * indicating the minimum fraction digits to be used. Numbers will be 
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value 
         * indicating the maximum fraction digits to be used. Numbers will be 
         * rounded if necessary.<br>
         * - <b>useGrouping.</b> is a Boolean value indicating whether a 
         * grouping separator should be used. The default is true.<br>
         * - <b>pattern.</b> custom pattern. Will override above options 
         * when present.
         * @param {string=} locale - A BCP47 compliant language tag. it is only 
         * used to extract the unicode extension keys. 
         * @return {string} formatted number.
         * @throws {RangeError} If a property value of the options parameter is 
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is 
         * missing.
         * @throws {SyntaxError} If an unexpected character is encountered in 
         * the pattern.
         */ 
      format : function(value, localeElements, options, locale) {
        if(arguments.length <=2 || options === undefined) {
          options = {
            'useGrouping': true,
            'style': 'decimal'
          }; 
        }
        _validateNumberOptions(options, "OraNumberConverter.format");
        var numberSettings = {};
        _getNumberSettings(localeElements, numberSettings, options, locale);
        return _formatNumberImpl(value, options, localeElements,
          numberSettings, locale);
      },
    
      /**
         * Parse a number.
         * @memberOf OraNumberConverter
         * @param {string|number} str - string to be parsed.
         * @param {Object} localeElements - the instance of LocaleElements 
         * bundle
         * @param {Object=} options - Containing the following properties:<br>
         * - <b>style.</b>  is one of the String values "decimal", "currency" or 
         * "percent". The default is "decimal".<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory 
         * when style is "currency".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code", 
         * "symbol", or "name", specifying whether to display the currency as 
         * an ISO 4217 alphabetic currency code,
         *  a localized currency symbol, or a localized currency name if 
         *  formatting with the "currency" style. It is only considered when 
         *  style has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value 
         * indicating the minimum integer digits to be used. Numbers will be 
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value 
         * indicating the minimum fraction digits to be used. Numbers will be 
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value 
         * indicating the maximum fraction digits to be used. Numbers will be 
         * rounded if necessary.<br>
         * - <b>useGrouping.</b> is a Boolean value indicating whether a 
         * grouping separator should be used. The default is true.<br>
         * - <b>pattern.</b> custom pattern. Will override above options when 
         * present.<br>
         * @param {string=} locale - A BCP47 compliant language tag. it is only 
         * used to extract the unicode extension keys. 
         * @return {number} a number object parsed from the string. In case of 
         * error, returns null.
         * @throws {RangeError} If a property value of the options parameter is 
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is 
         * missing.
         * @throws {SyntaxError} If an unexpected character is encountered in 
         * the pattern.
         * @throws {Error} If the <i>str</i> parameter does not match the number 
         * pattern.
         */ 
      parse : function(str, localeElements, options, locale) {
        if(typeof str === "number")
          return str;
        if(Object.prototype.toString.call(str) === '[object Number]')
          return  Number(str);
        if(arguments.length <= 2 || options === undefined) {
          options = {
            'useGrouping': true,
            'style': 'decimal'
          }; 
        }
        var errStr = str;
        _validateNumberOptions(options, "OraNumberConverter.parse");
        var localeElementsMainNode = OraI18nUtils.getLocaleElementsMainNode(localeElements);
        var numberSettings = {};
        var numberingSystemKey =  OraI18nUtils.getLanguageExtension(locale, "nu");
        if(OraI18nUtils.numeringSystems[numberingSystemKey] === undefined)
          numberingSystemKey = 'latn';
        if(numberingSystemKey !== 'latn') {
          var idx;
          var latnStr = [];
          for(idx = 0; idx < str.length; idx++)
          {
            var pos = OraI18nUtils.numeringSystems[numberingSystemKey].indexOf(str[idx]);
            if(pos != -1)
              latnStr.push(pos);
            else
              latnStr.push(str[idx]);       
          }
          str =  latnStr.join("");
        }
        _getNumberSettings(localeElements, numberSettings, options, locale); 
        var decimalSeparator = localeElementsMainNode['numbers']
        [numberSettings['numberingSystem']]['decimal'],
        groupingSeparator = localeElementsMainNode['numbers']
        [numberSettings['numberingSystem']]['group'],      
        ret = NaN,        
        value1 = str.replace(/ /g, "");      
        // allow infinity or hexidecimal
        if (_REGEX_INFINITY.test(value1)) {
          ret = parseFloat(str);
          return ret;
        }
        var signInfo = _parseNegativePattern(str, options, numberSettings,
          localeElementsMainNode),
        sign = signInfo[ 0 ],
        num = signInfo[ 1 ];
        sign = sign || "+";
        if (signInfo[2]) {
          ret = parseFloat(sign + num);
          return  _throwNaNException(ret, options, numberSettings, errStr);
        }
        // remove spaces: leading, trailing and between - and number. 
        // Used for negative currency pt-BR

        num = num.replace(/ /g, "");
        // determine exponent and number
        var exponentSymbol = numberSettings['exponential'];
        var exponent,
        intAndFraction,
        exponentPos = num.indexOf(exponentSymbol.toLowerCase());
        if (exponentPos < 0) exponentPos = num.indexOf(
          OraI18nUtils.toUpper(exponentSymbol));
        if (exponentPos < 0) {
          intAndFraction = num;
          exponent = null;
        }
        else {
          intAndFraction = num.substr(0, exponentPos);
          exponent = num.substr(exponentPos + exponentSymbol.length);
        }
        // determine decimal position
        var integer,
        fraction,
        decSep = decimalSeparator,
        decimalPos = intAndFraction.indexOf(decSep);
        if (decimalPos < 0) {
          integer = intAndFraction;
          fraction = null;
        }
        else {
          integer = intAndFraction.substr(0, decimalPos);
          fraction = intAndFraction.substr(decimalPos + decSep.length);
        }
        // handle groups (e.g. 1,000,000)
        var groupSep = groupingSeparator;
        integer = integer.split(groupSep).join("");
        var altGroupSep = groupSep.replace(/\u00A0/g, " ");
        if (groupSep !== altGroupSep) {
          integer = integer.split(altGroupSep).join("");
        }
        // build a natively parsable number string
        var p = sign + integer;
        if (fraction !== null) {
          p += "." + fraction;
        } 
        if (exponent !== null) {
          // exponent itself may have a number pattern
          var expSignInfo = _parseNegativeExponent(exponent, localeElementsMainNode,
            numberSettings);
          p += "e" + (expSignInfo[0] || "+") + expSignInfo[ 1 ];
        }
        if (_REGEX_PARSE_FLOAT.test(p)) {
          ret = parseFloat(p);
        }
        else {
          p = _lenientParseNumber(str, numberSettings, localeElementsMainNode);
          ret = parseFloat(p[0] + p[1]);
        }
        return  _throwNaNException(ret, options, numberSettings, errStr);
      },
      
      /**
         * Resolve options.
         * Returns a new object with properties reflecting the number formatting 
         * options computed based on the options parameter.
         * If options is not provided, the properties will be derived from the 
         * locale defaults.
         * @memberOf OraNumberConverter
         * @param {Object} localeElements - the instance of LocaleElements 
         * bundle
         * @param {Object=} options containing the following properties:<br>
         * - <b>style.</b> "decimal", "currency" or "percent". The default is 
         * "decimal".<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory 
         * when when style is "currency".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code", 
         * "symbol", or "name", specifying whether to display the currency as 
         * an ISO 4217 alphabetic currency code,
         *   a localized currency symbol, or a localized currency name if 
         *   formatting with the "currency" style. It is only present 
         *   when style has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value 
         * indicating the minimum integer digits to be used. Numbers will be 
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value 
         * indicating the minimum fraction digits to be used. Numbers will be 
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value 
         * indicating the maximum fraction digits to be used. Numbers will be 
         * rounded if necessary.<br>
         * - <b>numberingSystem</b>. The numbering system.
         * - <b>useGrouping.</b> is a Boolean value indicating whether a 
         * grouping separator should be used. The default is true.<br>
         * - <b>pattern.</b> custom pattern. Will override above options when 
         * present.<br>
         * @param {string=} locale - A BCP47 compliant language tag. it is only 
         * used to extract the unicode extension keys. 
         * @return {Object} Resolved options object.
         * @throws {RangeError} If a property value of the options parameter is 
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is 
         * missing. 
         */
      resolvedOptions : function(localeElements, options, locale){
        if(arguments.length < 3 || locale === undefined) {
          locale = OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
        }
        if(arguments.length < 2 || options === undefined) {
          options = {
            'useGrouping': true,
            'style': 'decimal'
          }; 
        }
        var numberSettings = {};
        _validateNumberOptions(options, "OraNumberConverter.resolvedOptions");
        _getNumberSettings(localeElements, numberSettings, options, locale);
        numberSettings['numberingSystemKey'] =  OraI18nUtils.getLanguageExtension(locale,
          "nu");
        if(OraI18nUtils.numeringSystems[numberSettings['numberingSystemKey']] === 
          undefined)
          numberSettings['numberingSystemKey'] = 'latn';
        var resOptions = {
          'locale': locale,
          'style': (options['style'] === undefined) ? 'decimal' : 
          options['style'],
          'useGrouping' : (options['useGrouping'] === undefined) ? true : 
          options['useGrouping'],
          'minimumIntegerDigits' : numberSettings['minimumIntegerDigits'],
          'minimumFractionDigits' : numberSettings['minimumFractionDigits'],
          'maximumFractionDigits' : numberSettings['maximumFractionDigits'],
          'numberingSystem': numberSettings['numberingSystemKey']
        }
        if(options['style'] === 'currency') {
          resOptions['currency'] = options['currency'];
          resOptions['currencyDisplay'] = (options['currencyDisplay'] === 
            undefined) ?  'symbol' : options['currencyDisplay'];
        }
        if(options['pattern'] !== undefined)
          resOptions['pattern'] = options['pattern'];
        return resOptions;
      }
    };
  }
  
  return {
    /**
       * getInstance.
       * Returns the singleton instance of OraNumberConverter class.  
       * @memberOf OraNumberConverter
       * @return {Object} The singleton OraNumberConverter instance.
       */
    getInstance: function () {	 
      if ( !instance ) {
        instance = _init();
      }	 
      return instance;
    }	 
  };
  
}());
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * Constructs a DateRestrictionValidator that ensures the value provided is not in a disabled entry of dayMetaData
 * @param {Object=} options an object literal used to provide the following properties
 * @param {Function=} options.dayFormatter - Additional info to be used when rendering the day. This 
 * should be a JavaScript Function reference which accepts as its argument the following JSON format 
 * <code class="prettyprint">{fullYear: Date.getFullYear(), month: Date.getMonth()+1, date: Date.getDate()}</code>
 * and returns <code class="prettyprint">null</code> or all or partial JSON data of the form 
 * <code class="prettyprint">{disabled: true|false, className: "additionalCSS", tooltip: 'Stuff to display'}</code>
 * @param {Object=} options.message - an optional object literal of custom error message to be used. 
 * @param {string=} options.message.messageDayMetaData - a custom error message used for creating 
 * detail part of message if input value is in disabled entry of dayMetaData. When not present, the 
 * default message detail is the resource defined with the key 
 * <code class="prettyprint">oj-validator.restriction.date.dayMetaData.detail</code>.<p>
 * Tokens: {value} - value entered by user<p>. 
 * Example:<br/>
 * "Value {value} is a disabled entry."<br/>
 * 
 * @export
 * @constructor
 * @since 0.6
 */
oj.DateRestrictionValidator = function _DateRestrictionValidator(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DateRestrictionValidator, oj.Validator, "oj.DateRestrictionValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @memberof oj.DateRestrictionValidator
 * @instance
 * @export
 */
oj.DateRestrictionValidator.prototype.Init = function (options)
{
  oj.DateRestrictionValidator.superclass.Init.call(this);
  this._dayFormatter = options["dayFormatter"];
  this._converter = oj.IntlConverterUtils.getConverterInstance(options["converter"]);
  if (options)
  {
    this._customMessage = options['message'] || {};
  }
};

/**
 * Validates whether the date provided is part of disabled date
 *
 * @param {Date} valueDate that is being validated
 * @returns {boolean} boolean of whether it is a disabled date
 * 
 * @private
 * @memberof oj.DateRestrictionValidator
 * @instance
 * 
 */
oj.DateRestrictionValidator.prototype._inDisabled = function(valueDate) 
{
  var dayFormatter = this._dayFormatter;
  
  if(dayFormatter) {
    var fullYear = valueDate.getFullYear(),
        month = valueDate.getMonth() + 1, //request to start from 1 rather than 0
        date = valueDate.getDate(),
        metaData = dayFormatter({"fullYear": fullYear, "month": month, "date": date});
    
    return metaData && metaData.disabled;
  }
  
  return false;
};

/**
 * Validates whether the date provided is part of disabled date
 *
 * @param {Object} value that is being validated
 * @returns {Object} original if validation was successful
 *
 * @throws {Error} when there is no match
 * @memberof oj.DateRestrictionValidator
 * @instance
 * @export
 */
oj.DateRestrictionValidator.prototype.validate = function (value)
{
  var messageDayMetaData,
      summary = "", 
      detail = "", 
      translations = oj.Translations, 
      customMessage = this._customMessage,
      valueStr = value ? this._converter['format'](value) : value,
      valueDate = valueStr ? oj.IntlConverterUtils.isoToLocalDate(valueStr) : null;
  
  if(value === null) 
  {
    return value;
  }
  
  if(this._inDisabled(valueDate)) {
    
    messageDayMetaData = customMessage["messageDayMetaData"];
    summary = translations.getTranslatedString('oj-validator.restriction.date.dayMetaData.summary');
    detail = messageDayMetaData ? translations.applyParameters(messageDayMetaData, {"value": valueStr}) : 
                translations.getTranslatedString('oj-validator.restriction.date.dayMetaData.detail', {"value": valueStr});
    throw new oj.ValidatorError(summary, detail);
  }
  
  return value;
};

/**
 * @preserve Copyright (c) 2008, 2013, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Constructs a RegExpValidator that ensures the value matches the provided pattern
 * @param {Object} options an object literal used to provide the pattern, an optional hint and error 
 * message.
 * @param {RegExp=} options.pattern - a regexp pattern that the validator matches a value against.<p>
 * Example:<br/>
 * '\\d{10}'
 * @param {string=} options.hint - an optional hint text. There is no default hint provided by the 
 * validator. It is generally not recommended to show the actual pattern in the hint as it might be 
 * confusing to end-user.<p>
 * Tokens: <br/>
 * {pattern} - the pattern to enforce<p>
 * Example:<br/>
 * "value must meet this pattern {pattern}" 
 * @param {string=} options.messageSummary - a custom error message summarizing the error when the 
 * users input does not match the specified pattern. When not present, the default summary is the 
 * resource defined with the key <code class="prettyprint">oj-validator.regExp.summary</code>. 
 * It is generally not recommended to show the actual pattern in the message as it might be 
 *  confusing to end-user. <p>
 * Tokens: <p>
 * {label} - label of the component for which this message applies. The label may not always be 
 * available depending on the usage of the validator. <br/>
 * {pattern} - the pattern the value should match<br/>
 * {value} - value entered by user<p>
 * Examples:<br/>
 * "'{label}' Format Incorrect" // translating to 'Phone Number' Format Incorrect
 * @param {string=} options.messageDetail - a custom error message to be used for creating detail 
 * part of message, when the users input does not match the specified pattern. When not present, the 
 * default detail message is the resource defined with the key 
 * <code class="prettyprint">oj-validator.regExp.detail</code>.<p>
 * Tokens:<br/>
 * {label} - label text of the component for which this message applies. <br/>
 * {pattern} the 'pattern' that the value should match <br/>
 * {value} value entered by the user <p>
 * Examples:<br/>
 * "The value {value} must contain at least 3 alphanumeric characters"<br/>
 * @export
 * @constructor
 * @since 0.6
*/
oj.RegExpValidator = function(options) 
{
  this.Init(options);
};

// Subclass from oj.Object or oj.Validator. It does not matter
oj.Object.createSubclass(oj.RegExpValidator, oj.Validator, "oj.RegExpValidator");

// key to access required validator specific resources in the bundle 
oj.RegExpValidator._BUNDLE_KEY_DETAIL = "oj-validator.regExp.detail";
oj.RegExpValidator._BUNDLE_KEY_SUMMARY = "oj-validator.regExp.summary";

/**
 * Initializes validator instance with the set options
 * @param {Object} options
 * @memberof oj.RegExpValidator
 * @instance
 * @export
 */
oj.RegExpValidator.prototype.Init = function(options) 
{
  oj.RegExpValidator.superclass.Init.call(this);
  this._options = options;
};

/**
 * Validates value for matches using the regular expression provided by the pattern. This method 
 * does not raise error when value is empty string or null, then this method returns.
 * 
 * @param {string|number} value that is being validated 
 * @returns {boolean} true if validation was successful 
 * 
 * @throws {Error} when there is no match
 * @memberof oj.RegExpValidator
 * @instance
 * @export
 */
oj.RegExpValidator.prototype.validate = function(value)
{
  var pattern = (this._options && this._options['pattern']) || "", label, summary, detail, params;
  
  // don't validate null or empty string; per bug 18753849
  if (value === null || value === undefined || value === "")
  {
    return true;
  }
  
  // when using digits as input values parseString becomes a integer type, so get away with it.
  value = value ? value.toString() : value;
  
  // We intend that the pattern provided is matched exactly
  var exactPattern = "^(" + pattern + ")$", valid = false, 
          localizedDetail, localizedSummary, matchArr;
  
  matchArr = value.match(exactPattern);
  if ((matchArr !== null) && (matchArr[0] === value))
  {
    valid = true;
  }
  else
  {
    if (this._options)
    {
      summary = this._options['messageSummary'] || null;
      detail = this._options['messageDetail'] || null;
      label = this._options && this._options['label'] || "";
    }
    
    params = {'label': label, 'pattern': pattern, 'value': value};
    localizedSummary = summary ? 
      oj.Translations.applyParameters(summary, params) : 
      oj.Translations.getTranslatedString(this._getSummaryKey(), params);
    localizedDetail = (detail) ? 
      oj.Translations.applyParameters(detail, params) : 
      oj.Translations.getTranslatedString(this._getDetailKey(), params);
    
    throw new oj.ValidatorError(localizedSummary, localizedDetail);
  }
  
  return valid;
};

/**
 * A message to be used as hint, when giving a hint on the expected pattern. There is no default 
 * hint for this property.
 * 
 * @returns {String|null} a hint message or null if no hint is available in the options
 * @memberof oj.RegExpValidator
 * @instance
 * @export
 */
oj.RegExpValidator.prototype.getHint = function()
{
  var hint = null, params = {};
  if (this._options && (this._options['hint']))
  {
    params = {'pattern': this._options['pattern']};
    hint = oj.Translations.applyParameters(this._options['hint'], params);
  }
  
  return hint;
};

oj.RegExpValidator.prototype._getSummaryKey = function ()
{
  return oj.RegExpValidator._BUNDLE_KEY_SUMMARY;
};

oj.RegExpValidator.prototype._getDetailKey = function ()
{
  return oj.RegExpValidator._BUNDLE_KEY_DETAIL;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*global OraDateTimeConverter:true*/
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * @constructor
 * 
 * @classdesc Constructs an immutable instance and initializes it with the options provided. There are 
 * several ways to initialize the converter. The converters by default uses the locale symbols for 
 * the current page locale (returned by {@link oj.Config#getLocale}.
 * <ul>
 * <li>Using options defined by the ECMA 402 Specification, these would be the properties year, 
 * month, day, hour, minute, second, weekday, era, timeZoneName, hour12</li>
 * <li>Using a custom date and/or time format pattern using the 'pattern' property</li>
 * <li>Using the standard date, datetime and time format lengths defined by Unicode CLDR, these 
 * would include the properties formaType, dateFormat, timeFormat.</li>
 * </ul>
 * 
 * <p>
 * The options when specified take precendence in the following order:<br>
 * 1. pattern.<br>
 * 2. ECMA options.<br>
 * 3. formatType/dateFormat/timeFormat.
 * <p>
 * The converter provides great leniency when parsing a user input value to a date in the following 
 * ways: <br/>
 * <ul>
 * <li>Allows use of any character for separators irrespective of the separator specified in the 
 * associated pattern. E.g., if pattern is set to 'y-M-d', the following values are all valid - 
 * 2013-11-16, 2013/11-16 and 2013aaa11xxx16.</li>
 * <li>Allows specifying 4 digit year in any position in relation to day and month. E.g., 11-2013-16 
 * or 16-11-2013</li>
 * <li>Supports auto-correction of value, when month and day positions are swapped as long as the 
 * date is > 12 when working with the Gregorian calendar. E.g., if the pattern is 'y-M-d', 
 * 2013-16-11 will be auto-corrected to 2013-11-16. However if both date and month are less or equal 
 * to 12, no assumptions are made about the day or month and the value parsed against the exact pattern.</li>
 * <li>Supports auto-correction of value, for the short and long types of weekday and month names. 
 * So they can are used anywhere in the value. E.g., if the expected pattern is E, MMM, d, y, all 
 * these values are acceptable - Tue, Nov 26 2013 or Nov, Tue 2013 26 or 2013 Tue 26 Nov. <br/>
 * NOTE: Lenient parsing of narrow era, weekday or month name is not supported because of ambiguity in 
 * choosing the right value. So we expect for narrow era, weekday or month option that values be 
 * provided either in their short or long forms. E.g., Sat, March 02, 2013.
 * </li>
 * <li>Specifying the weekday is optional. E.g., if the expected pattern is E, MMM, d, y; then 
 * entering Nov 26, 2013, is automatically turned to Tuesday Nov 26, 2013. But entering an invalid 
 * weekday, i.e., if the weekday does not match the date, an exception is thrown.</li>
 * <li>Leniency rules apply equally no matter which option is used - pattern, ECMA options or formatType</li>
 * </ul>
 * 
 * @property {Object=} options - an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @property {string=} options.year - allowed values are "2-digit", "numeric". When no options are 
 * set the default value of "numeric" is used.
 * @property {string=} options.month - specifies how the month is formatted. Allowed values are 
 * "2-digit", "numeric", "narrow", "short", "long". The last 3 values behave in the same way as for 
 * weekday, indicating the length of the string used. When no options are set the default value of 
 * "numeric" is used.
 * @property {string=} options.day - specifies how the day is formatted. Allowed values are "2-digit",
 *  "numeric". When no options are set the default value of "numeric" is used.
 * @property {string=} options.hour - specifies how the hour is formatted. Allowed values are 
 * "2-digit" or "numeric". The hour is displayed using the 12 or 24 hour clock, depending on the 
 * locale. See 'hour12' for details.
 * @property {string=} options.minute - specifies how the minute is formatted. Allowed values are 
 * "2-digit", "numeric".
 * @property {string=} options.second - specifies whether the second should be displayed as "2-digit" 
 * or "numeric".
 * @property {string=} options.weekday - specifies how the day of the week is formatted. If absent, it 
 * is not included in the date formatting. Allowed values are "narrow", "short", "long" indicating the 
 * length of the string used.
 * @property {string=} options.era - specifies how the era is included in the formatted date. If 
 * absent, it is not included in the date formatting. Allowed values are "narrow", "short", "long".
 * @property {string=} options.timeZoneName - allowed values are "short", "long".
 * @property {boolean=} options.hour12 - specifies what time notation is used for formatting the time. 
 * A true value uses the 12-hour clock and false uses the 24-hour clock (often called military time 
 * in the US). This property is undefined if the hour property is not used when formatting the date.
 * 
 * @property {string=} options.pattern - a localized string pattern, where the the characters used in 
 * pattern conform to Unicode CLDR for date time formats. This will override all other options 
 * when present. <br/>
 * NOTE: 'pattern' is provided for backwards compatibility with existing apps that may want the 
 * convenience of specifying an explicit format mask. Setting a 'pattern' will override the default 
 * locale specific format.
 * 
 * @property {string=} options.formatType - determines the 'standard' date and/or time format lengths 
 * to use. Allowed values: "date", "time", "datetime". See 'dateFormat' and 'timeFormat' options. 
 * When set a value must be specified.
 * @property {string=} options.dateFormat - specifies the standard date format length to use when 
 * formatType is set to "date" or "datetime". Allowed values are : "short" (default), "medium", "long", 
 * "full". 
 * @property {string=} options.timeFormat - specifies the standard time format length to use when 
 * 'formatType' is set to "time" or "datetime". Allowed values: "short" (default), "medium", "long", 
 * "full". 
 * 
 * @example <caption>Create a date time converter using no options. This uses the default value for 
 * year, month, day properties</caption>
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter();
 * var resolved = converter.resolvedOpions();
 * // logs "day=numeric, month=numeric, year=numeric"
 * window.console.log("day=" + resolved.day + ", month=" + resolved.month + ", year=" + resolved.year);
 * <br/>
 * 
 * @example <caption>Create a date time converter using the ECMA options to represent date</caption>
 * var options = { year:'2-digit', month: '2-digit', day: '2-digit'};
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>Create a date time converter using the 'pattern' option</caption>
 * var options = {pattern: 'MM-dd-yyyy'}; 
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>Create a date time converter using the standard format length</caption>
 * var options = {formatType: 'date', dateFormat: 'medium'}; 
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @export
 * @augments oj.DateTimeConverter 
 * @name oj.IntlDateTimeConverter
 * @since 0.6
 */
oj.IntlDateTimeConverter = function(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.IntlDateTimeConverter, oj.DateTimeConverter, "oj.IntlDateTimeConverter");
oj.IntlDateTimeConverter._DEFAULT_DATE = new Date(1998, 10, 29, 15, 45, 31).toISOString();

/**
 * Initializes the date time converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to initialize 
 * the converter.<p>
 * 
 * @export
 */
oj.IntlDateTimeConverter.prototype.Init = function(options) 
{
  oj.IntlDateTimeConverter.superclass.Init.call(this, options);
};


// Returns the wrapped date time converter implementation object.
oj.IntlDateTimeConverter.prototype._getWrapped = function ()
{
  if (!this._wrapped)
  {
    this._wrapped = OraDateTimeConverter.getInstance();
  }
  
  return this._wrapped;
};

/**
 * Formats the ISOString value using the resolved options and returns a formatted string value.
 * 
 * @param {string} value to be formatted for display
 * @return {string|Object} the localized and formatted value suitable for display
 * 
 * @throws {Error} a ConverterError both when formatting fails, and if the options provided during 
 * initialization cannot be resolved correctly. 
 * @export
 */
oj.IntlDateTimeConverter.prototype.format = function (value) 
{
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;
  
  // undefined, null and empty string values all return null. If value is NaN then return "".
  // TODO: Should we automatically parse() the integer value representing the number of milliseconds 
  // since 1 January 1970 00:00:00 UTC (Unix Epoch)?
  if (value == null || 
      (typeof value === "string" && (oj.StringUtils.trim("" + value)).length === 0)) 
  {
    return oj.IntlConverterUtils.__getNullFormattedValue();
  }
  
  try
  {
    return this._getWrapped().format(value, localeElements, resolvedOptions, locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};


/**
 * Formats an ISOString as a relative date, using the relativeOptions.
 * @param {string} value - value to be formatted. This value is compared with the current date 
 * on the client to arrive at the relative formatted value.
 * @param {Object} relativeOptions - an Object literal containing the following properties. The 
 * default options are ignored during relative formatting - <br>
 * <ul>
 * <li><b>formatUsing</b>: Specifies the relative formatting convention to use for (calendar or) 
 * the date field type. allowed values: "displayName". <br>Setting value to 'displayName' uses the 
 * relative display name for the instance of the dateField, and one or two past and future instances.
 * </li>
 * <li><b>dateField</b>: allowed values are: "day", "week", "month", "year"</li>
 * </ul>
 * @return {string|null} relative date. null if the value falls out side the supported relative range.
 * @throws {Object} an instance of {@link oj.ConverterError}
 * @memberOf oj.IntlDateTimeConverter
 * @export
 */
oj.IntlDateTimeConverter.prototype.formatRelative = function(value, relativeOptions) 
{
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), converterError;
  try
  {
    return this._getWrapped().formatRelative(value, localeElements, relativeOptions, locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};

/**
 * Retrieves a hint String describing the format the value is expected to be in.
 * 
 * @return {String} a hint describing the format the value is expected to be in.
 * @export
 */
oj.IntlDateTimeConverter.prototype.getHint = function ()
{
  var resolvedOptions = this.resolvedOptions(), patternFromOptions = 
          resolvedOptions["patternFromOptions"];;
  
  // TODO: converter hints are often shown in placeholder and is a user-friendly readable pattern. 
  // Until this feature is implemented use the CLDR pattern
  return patternFromOptions ? patternFromOptions : "";
};

// Returns the hint value.
oj.IntlDateTimeConverter.prototype._getHintValue = function()
{
  var value = "";
  try
  {
    // example date 
    value =  this.format(oj.IntlDateTimeConverter._DEFAULT_DATE);
  }
  catch (e)
  {
    if (e instanceof oj.ConverterError)
    {
      // Something went wrong and we don't have a way to retrieve a valid value.
      // TODO: Log an error
      value = "";
    }
  }
  finally
  {
    return value;
  }
};


/**
 * Returns the options called with converter initialization.
 * @return {Object} an object of options.
 * @export
 */
oj.IntlDateTimeConverter.prototype.getOptions = function () 
{
  return oj.IntlDateTimeConverter.superclass.getOptions.call(this);
};

/**
 * Returns an object literal with locale and formatting options computed during initialization of 
 * the object. If options was not provided at the time of initialization, the properties will be 
 * derived from the locale defaults.
 * @return {Object} an object of resolved options. Properties whose corresponding internal 
 * properties are not present are not assigned. More properties may be included as needed.
 * <ul>
 * <li><b>locale</b> - a String value with the language tag of the locale whose localization is used 
 * for formatting.</li>
 * <li><b>numberingSystem</b>: a String value of the numbering system used. E.g. latn</li>
 * <li><b>era</b>: a String value. One of allowed values - "narrow", "short", "long"</li>
 * <li><b>year</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>month</b>: a String value. One of allowed values - "2-digit", "numeric", "narrow", "short"
 * , "long"</li>
 * <li><b>weekday</b>: a String value. One of the allowed values - "narrow", "short", "long"</li>
 * <li><b>day</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>hour</b>: String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>minute</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>second</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>hour12</b>: a Boolean value indicating whether 12-hour format (true) or 24-hour format 
 * (false) should be used. It is only relevant when hour is also present.</li>
 * <li><b>timeZoneName</b>: String value. One of allowed values - "short", "long".</li>
 * </ul>
 * 
 * @throws a oj.ConverterError when the options that the converter was initialized with are invalid. 
 * @export
 */
oj.IntlDateTimeConverter.prototype.resolvedOptions = function ()
{
  var localeElements, locale = oj.Config.getLocale(), converterError, options = this.getOptions();
  // options are resolved and cached for a locale
  if ((locale !== this._locale) || !this._resolvedOptions)
  {
    localeElements = oj.LocaleData.__getBundle();
    try
    {
      // cache if successfully resolved
      this._resolvedOptions = this._getWrapped().resolvedOptions(localeElements, 
                                                                 options, 
                                                                 locale);
      this._locale = locale;
    }
    catch (e)
    {
      converterError = this._processConverterError(e);
      throw converterError;
    }
  }
  
  return this._resolvedOptions;
};

/**
 * Returns true if a 24-hour format is set; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isHourInDaySet = function()
{
  var ro = this.resolvedOptions(), hour = ro['hour'], hour12 = ro['hour12'];
  if (hour && !hour12)
  {
    // if hour12=false or not set and hour is set to some value
    return true;
  }
  
  return false;
};

/**
 * Returns true if 12-hour is set; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isHourInAMPMSet = function()
{
  var ro = this.resolvedOptions(), hour = ro['hour'], hour12 = ro['hour12'];  
  if (hour && hour12)
  {
    // if hour12==true and hour is set to some value
    return true;
  }
  
  return false;
  
};

/**
 * Returns true if minutes are shown in the time portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isMinuteSet = function()
{
  return this._isOptionSet('minute');
};

/**
 * Returns true if seconds are shown in the time portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isSecondSet = function()
{
  return this._isOptionSet('second');
};

/**
 * Returns true if milliseconds are shown in the time portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isMilliSecondSet = function()
{
  return this._isOptionSet('millisecond');
};

/**
 * Returns true if year is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isYearSet = function()
{
  return this._isOptionSet('year');
};

/**
 * Returns true if month is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isMonthSet = function()
{
  return this._isOptionSet('month');
};

/**
 * Returns true if day is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isDaySet = function()
{
  return this._isOptionSet('day');
};

/**
 * Returns true if the day name is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isDayNameSet = function()
{
  return this._isOptionSet('weekday');
};

/**
 * Returns the calculated week for the isoString value
 * 
 * @param {string} value to return the calculated week of
 * @return {number} calculated week.
 * 
 * @export
 */
oj.IntlDateTimeConverter.prototype.calculateWeek = function(value)
{
  return this._getWrapped().calculateWeek(value, oj.LocaleData.__getBundle(), oj.Config.getLocale());
};

/**
 * Parses the value using the resolved options provided and returns a ISOString value.
 * 
 * @param {String|string} value to parse
 * @return {string|Object} the parsed value as an ISOString.
 * 
 * @throws {Error} a ConverterError both when parsing fails, and if the options provided during 
 * initialization cannot be resolved correctly. 
 *  
 * @export
 */
oj.IntlDateTimeConverter.prototype.parse = function (value) 
{
  var result, parsed;
  // undefined, null and empty string values are ignored and not parsed. 
  if (value == null || value === "") 
  {
    return null;
  }
  
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;

  try
  {
    // date converter parses the value and returns an Object with 2 fields - 'value' and 'warning'
    result = this._getWrapped().parse(value, localeElements, resolvedOptions, locale); 
    parsed = result['value'];
    if (parsed)
    {
      // TODO: For now log a warning when we leniently parse a value; later we plan to flash the 
      // field.
      if (result['warning'])
      {
        oj.Logger.warn("The value " + value + " was leniently parsed to represent a date " + 
                (parsed.toString) ? parsed.toString() : parsed);
      }
      
    }
    return parsed;
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};

/**
 * Processes the error returned by the converter implementation and throws a oj.ConverterError 
 * instance.
 * @param {Error} e
 * @param {String|string|Date|Object=} value 
 * @throws an instance of oj.ConverterError
 * @private
 */
oj.IntlDateTimeConverter.prototype._processConverterError = function (e, value)
{
  var errorInfo = e['errorInfo'], summary, detail, errorCode, parameterMap, converterError, 
          propName, resourceKey;
  if (errorInfo)
  {
    errorCode = errorInfo['errorCode'];
    parameterMap = errorInfo['parameterMap'];
    oj.Assert.assertObject(parameterMap);
    propName = parameterMap['propertyName'];
    
    if (e instanceof TypeError)
    {
      if (errorCode === "optionTypesMismatch" || errorCode === "optionTypeInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof RangeError)
    {
      if (errorCode === "optionOutOfRange")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
      else if (errorCode === 'datetimeOutOfRange') // TODO: NLS should use lower case time
      {
        // The '{value}' is out of range. Enter a value between '{minValue}' and '{maxValue}' for 
        // '{propertyName}'.
        summary = oj.Translations.getTranslatedString("oj-converter.datetime.datetimeOutOfRange.summary", 
          {'propertyName': propName,
           'value': parameterMap['value']});
        detail = oj.Translations.getTranslatedString("oj-converter.datetime.datetimeOutOfRange.detail",
          {'minValue': parameterMap['minValue'],
           'maxValue': parameterMap['maxValue']});
         
        converterError = new oj.ConverterError(summary, detail);
      }
    }
    else if (e instanceof SyntaxError)
    {
      if (errorCode === "optionValueInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof Error)
    {
      if (errorCode === "dateFormatMismatch")
      {
        // The '{value}' does not match the expected date format '{format}'.
        resourceKey = "oj-converter.datetime.dateFormatMismatch.summary";
      }
      else if (errorCode === "timeFormatMismatch")
      {
        // The {value} does not match the expected time format {format}.
        resourceKey = "oj-converter.datetime.timeFormatMismatch.summary";
      }
      else if (errorCode === "datetimeFormatMismatch")
      {
        resourceKey = "oj-converter.datetime.datetimeFormatMismatch.summary";
      }
      else if (errorCode === "dateToWeekdayMismatch")
      {
        summary = oj.Translations.getTranslatedString("oj-converter.datetime.dateToWeekdayMismatch.summary", 
          {'date': parameterMap['date'], 'weekday': parameterMap['weekday']});
        detail = oj.Translations.getTranslatedString("oj-converter.datetime.dateToWeekdayMismatch.detail");
        converterError = new oj.ConverterError(summary, detail);
      }
      
      if (resourceKey)
      {
        summary = oj.Translations.getTranslatedString(resourceKey, 
          {'value': value || parameterMap['value'],
           'format': parameterMap['format']});
        
        detail = oj.Translations.getTranslatedString("oj-converter.hint.detail",
          {'exampleValue': this._getHintValue()}); 
          
        converterError = new oj.ConverterError(summary, detail);
      }
    }
  }
  
  if (!converterError)
  {
    // An error we are unfamiliar with. Get the message and set as detail
    summary = e.message; // TODO: What should the summary be when it's missing??
    detail = e.message;
    converterError = new oj.ConverterError(summary, detail);
  }
  
  return converterError;
};

/**
 * Checks to see if an option is present in the resolved options.
 * @param {string} optionName
 * @returns {boolean} true if optionName is present.
 * @private
 */
oj.IntlDateTimeConverter.prototype._isOptionSet = function (optionName)
{
  var ro = this.resolvedOptions(), hasOption = ro[optionName] ? true : false;
  return hasOption;
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*
   DESCRIPTION
   OraI18nUtils provides helper functions for converter objects.

   PRIVATE CLASSES
    <list of private classes defined - with one-line descriptions>

   NOTES
    <other useful comments, qualifications, etc.>

   MODIFIED    (MM/DD/YY)
   gmurr       05/13/14 - Creation
 */


var OraI18nUtils = {};
//supported numbering systems
OraI18nUtils.numeringSystems = {
  'latn' : "\u0030\u0031\u0032\u0033\u0034\u0035\u0036\u0037\u0038\u0039",
  'arab' : "\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669",
  'thai' : "\u0e50\u0e51\u0e52\u0e53\u0e54\u0e55\u0e56\u0e57\u0e58\u0e59"
};
   
OraI18nUtils.BCP47RE = /^(?:(en-GB-oed|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)|sgn-(?:BE-FR|BE-NL|CH-DE))|(art-lojban|cel-gaulish|no-(?:bok|nyn)|zh-(?:guoyu|hakka|min|min-nan|xiang)))$|^(x(?:-[0-9a-z]{1,8})+)$|^(?:((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[a-z0-9]{5,8}|[0-9][a-z0-9]{3}))*)?((?:-[0-9a-wy-z](?:-[a-z0-9]{2,8}){1,})*)?(-x(?:-[0-9a-z]{1,8})+)?)$/i;
OraI18nUtils.regexTrim = /^\s+|\s+$|\u200f|\u200e/g;
OraI18nUtils.regexTrimNumber = /\s+|\u200f|\u200e/g;
OraI18nUtils.zeros = [ "0", "00", "000" ];

OraI18nUtils.isoToLocalDate = function(isoString) 
{
  if(!isoString || typeof isoString !== "string") 
  {
    return null;
  }
  
  var parsed = new Date(isoString),
      tIndex = isoString.indexOf("T");
  
  if(tIndex === -1) {
    //note this is when isoString is like "2014-02-14"
    //when lacking time portion, getDate and etc are unpredictable as they are based on local time.
    //i.e. getDate [local time] conversion would be made and return 13 or something else
    parsed = new Date(parsed.getUTCFullYear(), parsed.getUTCMonth(), parsed.getUTCDate());
  }else {
    //check if date portion is missing and is an Invalid Date [issue in browser such as chrome]
    if(parsed.toString() === 'Invalid Date') {
      if(tIndex === 0) {
        var today = new Date().toISOString();
        isoString = today.substring(0, today.indexOf("T")) + isoString;
        parsed = new Date(isoString);
      }
    }
  }
  return parsed;
}
OraI18nUtils.trim = function(value) {
  return (value + "").replace(OraI18nUtils.regexTrim, "");
};

OraI18nUtils.trimNumber = function(value) {
  var s = (value + "").replace(OraI18nUtils.regexTrimNumber, "");
  return s;
};
    
OraI18nUtils.startsWith = function(value, pattern) {
  return value.indexOf(pattern) === 0;
};
    
OraI18nUtils.toUpper = function(value) {
  // "he-IL" has non-breaking space in weekday names.
  return value.split("\u00A0").join(" ").toUpperCase();
};

OraI18nUtils.padZeros = function(num, c) {
  var r, s = num + "";
  if (c > 1 && s.length < c) {
    r = (OraI18nUtils.zeros[c - 2] + s);
    return r.substr(r.length - c, c);
  }
  else {
    r = s;
  }
  return r;
}

//get the numbering system key from the locale's unicode extension.
//Verify that the locale data has a numbers entry for it, if not return latn as default.
OraI18nUtils.getNumberingSystemKey = function(localeElements, locale){
  if(locale === undefined)
    return 'latn';
  var numberingSystemKey = OraI18nUtils.getLanguageExtension(locale, "nu") || "";
  var symbols = "symbols-numberSystem-" + numberingSystemKey;
  if(localeElements['numbers'][symbols] === undefined)
    numberingSystemKey =  'latn';
  return numberingSystemKey;
};
  
//parse a bcp47 language and extracts the tokens such as language, region, variant.
OraI18nUtils.parseBCP47 = function (tag){
  var match = OraI18nUtils.BCP47RE.exec (tag);
  if (!match) return null;
	
  var match4 = match[4];
  match4 = match4 ? match4.split ("-") : null;
  var language = null;
  if (match4) language = match4.shift ();
	
  var match7 = match[7];
  match7 = match7 ? match7.split ("-") : null;
  if (match7) match7.shift ();
	
  var match9 = match[9];
  match9 = match9 ? match9.split ("-") : null;
  if (match9){
    match9.shift ();
    match9.shift ();
  }
	
  var match3 = match[3];
  match3 = match3 ? match3.split ("-") : null;
  if (match3) match3.shift ();
  return {
    language: {
      language: language,
      extlang: match4 || []
    },
    script: match[5] || null,
    'region': match[6] || null,
    variant: match7 || null,
    extension: OraI18nUtils.parseExtension (match[8]),
    privateuse: match9 || match3 || [],
    grandfathered: {
      irregular: match[1] || null,
      regular: match[2] || null
    }
  };
};

//parse the extensions in the language tag
OraI18nUtils.parseExtension = function (tag){
      
  if (!tag) return [];

  var extensions = [];
  var e;
  var c;
  var newExtension = false;
  var singleton = false;
  var extension = "";
  var parsingExtension = false;
	
  for (var i=0, len=tag.length; i<len; i++){
    c = tag[i];
		
    if (c === "-" && !newExtension){
      newExtension = true;
      e = {
        'singleton': null,
        'extension': []
      };
      continue;
    }
		
    if (newExtension && !singleton){
      singleton = true;
      e['singleton'] = c;
      continue;
    }
		
    if (c === "-"){
      if (!parsingExtension){
        extension = "";
        parsingExtension = true;
      }else{
        if (extension.length === 1){
          parsingExtension = false;
          singleton = false;
          extensions.push (e);
          e = {
            'singleton': null,
            'extension': []
          };
        }
        else{
          e['extension'].push (extension);
          extension = "";
        }
      }
      continue;
    }
		
    extension += c;
  }
	
  e['extension'].push (extension);
  extensions.push (e);
	
  return extensions;
}; 
    
//get the unicode extension from a bcp47 locale given a token.
// for example, token can be "nu" for numbering system, "ca" for calendar.
OraI18nUtils.getLanguageExtension = function(locale, token){
  locale = locale || "en-US";
  var parsedLang = OraI18nUtils.parseBCP47(locale);
  if(parsedLang === null || parsedLang === undefined)
    return null;
  var ext = parsedLang['extension'];
  var localeExtension;
  for(var i in ext) {
    if(ext[i]['singleton'] === 'u') {
      for(var j in ext[i]['extension']) {
        if(ext[i]['extension'][j] === token) {
          j++;
          localeExtension = ext[i]['extension'][j];
          break;
        }
      }
      break;
    }
  }
  return localeExtension;    
};
    
//cldr locale data start with "main" node.
//return the subnode under main.
OraI18nUtils.getLocaleElementsMainNode = function(bundle) {
  var mainNode = bundle['main'];
  var subnode;
  for (var n in mainNode)
  {
    subnode = n;
    break;
  }
  return mainNode[subnode];
}
     
//get the locale which is a subnode of "main".
OraI18nUtils.getLocaleElementsMainNodeKey= function(bundle) {
  var mainNode = bundle['main'];
  var subnode;
  for (var n in mainNode)
  {
    subnode = n;
    break;
  }
  return subnode;
}
  
//Return a function getOption.
//The getOption function extracts the value of the property named 
//property from the provided options object, converts it to the required type,
// checks whether it is one of a List of allowed values, and fills in a 
// fallback value if necessary.
OraI18nUtils.getGetOption = function(options, getOptionCaller) {
  if (options === undefined) {
    throw new Error('Internal ' + getOptionCaller +
      ' error. Default options missing.');
  }

  var getOption = function getOption(property, type, values, defaultValue) {
    if (options[property] !== undefined) {
      var value = options[property];
      switch (type) {
        case 'boolean':
          value = Boolean(value);
          break;
        case 'string':
          value = String(value);
          break;
        case 'number':
          value = Number(value);
          break;
        default:
          throw new Error('Internal error. Wrong value type.');
      }
      if (values !== undefined && values.indexOf(value) === -1) {
        var expectedValues = [];
        for(var i=0; i < values.length; i++) {
          expectedValues.push(values[i]);
        }
        var msg = "The value '" + options[property] +
        "' is out of range for '" + getOptionCaller +
        "' options property '" + property + "'. Valid values: " + 
        expectedValues; 
        var rangeError = new RangeError(msg);
        var errorInfo = {
          'errorCode' : 'optionOutOfRange',
          'parameterMap' : {
            'propertyName': property,
            'propertyValue': options[property],
            'propertyValueValid': expectedValues,
            'caller': getOptionCaller
          }
        };
        rangeError['errorInfo'] = errorInfo;
        throw rangeError;
      }

      return value;
    }
    return defaultValue;
  }

  return getOption;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * Constructs a DateTimeRangeValidator that ensures the value provided is within a given range
 * @param {Object=} options an object literal used to provide the following properties
 * @param {Date=} options.min - the minimum datetime value of the entered value.
 * @param {Date=} options.max - the maximum datetime value of the entered value.
 * @param {Object=} options.hint - an optional object literal of hints to be used. 
 * @param {string=} options.hint.max - a hint used to indicate the allowed maximum. When not present, 
 * the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.datetime.hint.max</code>.<p>
 * Tokens: <br/>
 * {max} - the maximum<p>
 * Usage: <br/>
 * Enter a datetime less than or equal to {max}
 * @param {string=} options.hint.min - a hint used to indicate the allowed minimum. When not present, 
 * the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.datetime.hint.min</code>.<p>
 * Tokens: <br/>
 * {min} the minimum <p>
 * Usage: <br/>
 * Enter a datetime greater than or equal to {min}
 * @param {string=} options.hint.inRange - a hint used to indicate the allowed range. When not 
 * present, the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.datetime.hint.inRange</code>.<p>
 * Tokens:<br/>
 * {min} the minimum<br/>
 * {max} the maximum<p>
 * Usage: <br/>
 * Enter a datetime between {min} and {max}
 * @param {Object=} options.messageDetail - an optional object literal of custom error messages to 
 * be used.
 * @param {string=} options.messageDetail.rangeUnderflow - the detail error message to be used when 
 * input value is less than the set minimum value. When not present, the default detail message is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.datetime.messagedetail.rangeUnderflow</code>.<p>
 * Tokens:<br/>
 * {value} - value entered by the user<br/>
 * {min} - the minimum allowed value<p>
 * Usage: <br/>
 * Entered {value} with min being {min}
 * @param {string=} options.messageDetail.rangeOverflow - the detail error message to be used when 
 * input value exceeds the maximum value set.  When not present, the default detail message is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.datetime.messagedetail.rangeOverflow</code>.<p>
 * Tokens:<br/>
 * {value} - value entered by the user<br/>
 * {max} - the maximum allowed value<p>
 * Usage: <br/>
 * Entered {value} with max being {max}
 * @param {Object=} options.messageSummary - optional object literal of custom error summary message 
 * to be used. 
 * @param {string=} options.messageSummary.rangeUnderflow - the summary of the error message when 
 * input value is less than the set minimum value. When not present, the default message summary is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.datetime.messageSummary.rangeUnderflow</code>.
 * @param {string=} options.messageSummary.rangeOverflow - the summary of the error message when 
 * input value exceeds the maximum value set.  When not present, the default message summary is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.datetime.messageSummary.rangeOverflow</code>.
 * @export
 * @constructor
 * @since 0.6
*/
oj.DateTimeRangeValidator = function _DateTimeRangeValidator(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DateTimeRangeValidator, oj.Validator, "oj.DateTimeRangeValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @memberof oj.DateTimeRangeValidator
 * @instance
 * @export
 */
oj.DateTimeRangeValidator.prototype.Init = function (options)
{
  oj.DateTimeRangeValidator.superclass.Init.call(this);
  
  //if undefined set to null as they are equivalent in terms of logic
  //setting to null for the default validator [min + max option] is taken care of for ojInputDate 
  //in _InitOptions for min + max values [default validator]; however 
  //user can pass in the validators via validators option so taking care of it here
  this._converter = oj.IntlConverterUtils.getConverterInstance(options["converter"]);
  this._min = options["min"] ? oj.IntlConverterUtils.isoToLocalDate(options["min"]) : null;
  this._max = options["max"] ? oj.IntlConverterUtils.isoToLocalDate(options["max"]) : null;
  if (options)
  {
    this._hint = options['hint'] || {};
    this._customMessageSummary = options['messageSummary'] || {};
    this._customMessageDetail = options['messageDetail'] || {};
  }
};

/**
 * Validates the minimum + maximum conditions
 *
 * @param {string} value that is being validated
 * @returns {string} original if validation was successful
 *
 * @throws {Error} when there is no match
 * @memberof oj.DateTimeRangeValidator
 * @instance
 * @export
 */
oj.DateTimeRangeValidator.prototype.validate = function (value)
{
  var customMessageSummary = this._customMessageSummary,
      customMessageDetail = this._customMessageDetail,
      messageDetailRangeOverflow = customMessageDetail["rangeOverflow"], 
      messageDetailRangeUnderflow = customMessageDetail["rangeUnderflow"], 
      messageSummaryRangeOverflow = customMessageSummary["rangeOverflow"],
      messageSummaryRangeUnderflow = customMessageSummary["rangeUnderflow"],
      min = this._min, 
      max = this._max, 
      summary = "", 
      detail = "", 
      translations = oj.Translations, 
      params = null,
      valStr = value ? this._converter['format'](value) : value,
      valDate = valStr ? oj.IntlConverterUtils.isoToLocalDate(value) : null,
      minStr = min && this._converter ? this._converter['format'](min.toISOString()) : min,
      maxStr = max && this._converter ? this._converter['format'](max.toISOString()) : max;
  
  if(value === null) 
  {
    // request to not throw an error when value being passed is of null
    return value;
  }
  
  if (min !== null && max !== null)
  {
    //range
    if ((valDate >= min && valDate <= max) || min > max)
    {
      return value;
    }
  }
  else 
  {
    //only min
    if (min !== null)
    {
      if (valDate >= min)
      {
        return value;
      }
	  
    }
    //max only
    else 
    {
      if (max === null || valDate <= max)
      {
        return value;
      }
      
    }
  }
  
  if (max !== null && valDate > max)
  {
      params = {"value": valStr, "max": maxStr};
      summary = messageSummaryRangeOverflow ? messageSummaryRangeOverflow : 
        translations.getTranslatedString('oj-validator.range.datetime.messageSummary.rangeOverflow');
      detail = messageDetailRangeOverflow ? 
        translations.applyParameters(messageDetailRangeOverflow, params) : 
        translations.getTranslatedString('oj-validator.range.datetime.messageDetail.rangeOverflow', 
        params);
  }
  else if (min !== null && valDate < min)
  {
      params = {"value": valStr, "min": minStr};
      summary = messageSummaryRangeUnderflow ? messageSummaryRangeUnderflow : 
        translations.getTranslatedString('oj-validator.range.datetime.messageSummary.rangeUnderflow');
      detail = messageDetailRangeUnderflow ?
        translations.applyParameters(messageDetailRangeUnderflow, params) : 
        translations.getTranslatedString('oj-validator.range.datetime.messageDetail.rangeUnderflow', 
        params);   
  }
 

  throw new oj.ValidatorError(summary, detail);
};

/**
 * A message to be used as hint. There is no default hint for this property.
 *
 * @returns {String|null} a hint message or null if no hint is available in the options
 * @memberof oj.DateTimeRangeValidator
 * @instance
 * @export
 */
oj.DateTimeRangeValidator.prototype.getHint = function ()
{
  var hint = null, hints = this._hint, 
      hintInRange = hints["inRange"], hintMinimum = hints["min"], 
      hintMaximum = hints["max"],
      min = this._min, 
      max = this._max, 
      minStr = min && this._converter ? this._converter['format'](min.toISOString()) : min,
      maxStr = max && this._converter ? this._converter['format'](max.toISOString()) : max,
      params = null,
      translations = oj.Translations;
  
  if (min !== null && max !== null) 
  {
    params = {"min": minStr, "max": maxStr};
    hint = hintInRange ? translations.applyParameters(hintInRange, params) : 
            translations.getTranslatedString('oj-validator.range.datetime.hint.inRange', params);
  }
  else if (min !== null)
  {
    params = {"min": minStr};
    hint = hintMinimum ?  translations.applyParameters(hintMinimum, params) :
            translations.getTranslatedString('oj-validator.range.datetime.hint.min', params);
  }
  else if (max !== null)
  {
    params = {"max": maxStr};
    hint = hintMaximum ?  translations.applyParameters(hintMaximum, params) :
            translations.getTranslatedString('oj-validator.range.datetime.hint.max', params);
  }

  return hint;
};
/**
 * @preserve Copyright (c) 2008, 2013, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Constructs a RequiredValidator that ensures that the value provided is not empty
 * @param {Object=} options an object literal used to provide an optional hint and error message.<p>
 * @param {string=} options.hint an optional hint text. There is no default hint provided by this 
 * validator.
 * @param {string=} options.messageSummary - an optional custom error message summarizing the 
 * error. When not present, the default message summary is the resource defined with the key 
 * <code class="prettyprint">oj-validator.required.summary</code>.<p>
 * Tokens: {label} - this token can be used to substitute the label of the component at runtime. </p>
 * <p>
 * Example:<br/>
 * "'{label}' Required"<br/>
 * </p>
 * @param {string=} options.messageDetail - a custom error message used for creating detail part 
 * of message, when the value provided is empty. When not present, the default message detail is the 
 * resource defined with the key <code class="prettyprint">oj-validator.required.detail</code>.
 * <p>Tokens: {label} - this token can be used to substitute the label of the component at runtime.</p>
 * <p>
 * Example:<br/>
 * "A value is required for the field '{label}'."<br/>
 * </p>
 * 
 * @export
 * @constructor
 * @since 0.6
 * 
 */
oj.RequiredValidator = function(options) 
{
  this.Init(options);
};

// Subclass from oj.Object or oj.Validator. It does not matter
oj.Object.createSubclass(oj.RequiredValidator, oj.Validator, "oj.RequiredValidator");

// key to access required validator specific resources in the bundle 
oj.RequiredValidator._BUNDLE_KEY_DETAIL = "oj-validator.required.detail";
oj.RequiredValidator._BUNDLE_KEY_SUMMARY = "oj-validator.required.summary";

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @memberof oj.RequiredValidator
 * @instance
 * @export
 */
oj.RequiredValidator.prototype.Init = function(options) 
{
  oj.RequiredValidator.superclass.Init.call(this);
  this._options = options;
};

/**
 * Validates value to be non-empty
 * 
 * @param {Object|string|number} value that is being validated 
 * @returns {boolean} true if validation was was successful the value is non-empty
 * 
 * @throws {Error} when fails required-ness check
 * @memberof oj.RequiredValidator
 * @instance
 * @export
 */
oj.RequiredValidator.prototype.validate = function(value)
{
  var localizedDetail, localizedSummary, detail, summary, params = {}, label = "";
  // checks for empty arrays and String. Objects are considered non-null.
  // Need to specifically test for if value is 0 first if number is passed on.
  if ((typeof value === "number" && value === 0) || (value && value.length !== 0))
  {
    return true;
  }
  else
  {
    if (this._options)
    {
      // we have deprecated support for message param and instead use messageDetail.
      detail = this._options['messageDetail'] || this._options['message'] || null;
      summary = this._options['messageSummary'] || null;
      label = this._options['label'] || "";
    }
    params = {'label': label};
    localizedSummary = (summary) ? oj.Translations.applyParameters(summary, params) :
            oj.Translations.getTranslatedString(this._getSummaryKey(), params);
    localizedDetail = (detail) ? 
    oj.Translations.applyParameters(detail, params) : 
    oj.Translations.getTranslatedString(this._getDetailKey(), params);
    
    throw new oj.ValidatorError(localizedSummary, localizedDetail);
  }

};

/**
 * A message to be used as hint, when giving a hint on the expected pattern. There is no default 
 * hint for this property.
 * 
 * @returns {String|string|null} a hint message or null if no hint is available in the options
 * @memberof oj.RequiredValidator
 * @instance
 * @export
 */
oj.RequiredValidator.prototype.getHint = function()
{
  var hint = "";
  if (this._options && (this._options['hint']))
  {
    hint = oj.Translations.getTranslatedString(this._options['hint']);
  }
  
  return hint;
};

oj.RequiredValidator.prototype._getSummaryKey = function ()
{
  return oj.RequiredValidator._BUNDLE_KEY_SUMMARY;
};

oj.RequiredValidator.prototype._getDetailKey = function ()
{
  return oj.RequiredValidator._BUNDLE_KEY_DETAIL;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Constructs a LengthValidator that ensures the value entered is within a given length. 
 * 
 * @param {Object=} options an object literal used to provide:<p>
 * @param {number=} options.min - a number that is the minimum length of the value.
 * @param {number=} options.max - a number that is the maximum length of the value.
 * @param {Object=} options.hint - an optional object literal of hints to be used. 
 * @param {string=} options.hint.max - a hint message to be used to indicate the allowed maximum. 
 * When not present, the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.hint.max</code>.<p>
 * Tokens: <br/>
 * {max} - the maximum<p>
 * Usage: <br/>
 * Enter {max} or fewer characters
 * @param {string=} options.hint.min - a hint message to be used to indicate the allowed minimum. 
 * When not present, the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.hint.min</code>.<p>
 * Tokens: <br/>
 * {min} the minimum<p>
 * Usage: <br/>
 * Enter {min} or more characters 
 * @param {string=} options.hint.inRange - a hint message to be used to indicate the allowed range. 
 * When not present, the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.hint.inRange</code>.<p>
 * Tokens: <br/>
 * {min} the minimum<p>
 * {max} - the maximum<p>
 * Usage: <br/>
 * Enter between {min} and {max} characters
 * @param {string=} options.hint.exact - a hint message to be used, to indicate the exact length. 
 * When not present, the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.hint.exact</code>.<p>
 * Tokens: <br/>
 * {length} the length<p>
 * Usage: <br/>
 * Enter {length} characters
 * @param {Object=} options.messageDetail - an optional object literal of custom error messages to 
 * be used.
 * @param {string=} options.messageDetail.tooLong - the detail error message to be used as the error 
 * message, when the length of the input value exceeds the maximum value set. When not present, the 
 * default detail message is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.messageDetail.tooLong</code>.<p>
 * Tokens:<br/>
 * {value} - value entered by the user<br/>
 * {max} - the maximum allowed value<p>
 * Usage: <br/>
 * The {value} has too many characters. Enter {max} or fewer characters, not more.
 * @param {string=} options.messageDetail.tooShort - the detail error message to be used as the error 
 * message, when the length of the input value is less the minimum value set. When not present, the 
 * default detail message is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.messageDetail.tooShort</code>.<p>
 * Tokens:<br/>
 * {value} - value entered by the user<br/>
 * {min} - the minimum allowed value<p>
 * Usage: <br/>
 * The {value} has too few characters. Enter {min} or more characters, not less.
 * @param {Object=} options.messageSummary - optional object literal of custom error summary message 
 * to be used. 
 * @param {string=} options.messageSummary.tooLong - the message to be used as the summary error 
 * message, when the length of the input value exceeds the maximum value set. When not present, the 
 * default message summary is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.messageSummary.tooLong</code>.
 * @param {string=} options.messageSummary.tooShort - the message to be used as the summary error 
 * message, when input value is less than the set minimum value. When not present, the default 
 * message summary is the resource defined with the key 
 * <code class="prettyprint">oj-validator.length.messageSummary.tooShort</code>.
 * @export
 * @constructor
 * @since 0.7
 */
oj.LengthValidator = function (options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.LengthValidator, oj.Validator, "oj.LengthValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @export
 */
oj.LengthValidator.prototype.Init = function (options)
{
  oj.LengthValidator.superclass.Init.call(this);
  this._min = options["min"];
  this._max = options["max"];
  
  if (options)
  {
    this._hint = options['hint'] || {};
    this._customMessageSummary = options['messageSummary'] || {};
    this._customMessageDetail = options['messageDetail'] || {};

  }
};

oj.LengthValidator.prototype.getHint = function()
{
  var hint = null, hints = this._hint, 
      hintInRange = hints["inRange"], hintMinimum = hints["min"], 
      hintMaximum = hints["max"], hintExact = hints["exact"],
      translations = oj.Translations,
      min = this._min !== undefined ? parseInt(this._min, 10) : null, 
      max = this._max !== undefined ? parseInt(this._max, 10) : null, params;
	  
  if (min !== null && max !== null) 
  {
    if (min !== max)
    {
      params = {"min": min, "max": max};
      hint = hintInRange ? translations.applyParameters(hintInRange, params) : 
	                       translations.getTranslatedString('oj-validator.length.hint.inRange', params);
    }
    else
    {
      params = {'length': min};
      hint = hintExact ? translations.applyParameters(hintExact, params) :
                          translations.getTranslatedString('oj-validator.length.hint.exact', params);
    }
  }
  else if (min !== null)
  {
    params = {"min": min};
    hint = hintMinimum ?  translations.applyParameters(hintMinimum, params) :
	                      translations.getTranslatedString('oj-validator.length.hint.min', params);
  }
  else if (max !== null)
  {
    params = {"max": max};
    hint = hintMaximum ?  translations.applyParameters(hintMaximum, params) :
                          translations.getTranslatedString('oj-validator.length.hint.max', params);
  }

  return hint;
};

/**
 * Validates the length of vaue is greater than minimum and/or less than maximum.
 *
 * @param {string} value that is being validated
 * @returns {string} original if validation was successful
 *
 * @throws {Error} when the length is out of range.
 * @export
 */
oj.LengthValidator.prototype.validate  = function(value)
{
  var summary = "", detail = "", string = "" + value, length = string.length,
      customMessageDetail = this._customMessageDetail, 
      customMessageSummary = this._customMessageSummary,
      messageTooShort = customMessageDetail["tooShort"], 
      messageTooLong = customMessageDetail["tooLong"],
      messageSummaryTooShort = customMessageSummary["tooShort"], 
      messageSummaryTooLong = customMessageSummary["tooLong"],
      translations = oj.Translations, params,
      min = this._min !== undefined ? parseInt(this._min, 10) : null, 
      max = this._max !== undefined ? parseInt(this._max, 10) : null;
  
  // If only min is set and length is at least min, or 
  // if only max is set and length is at most max, or
  // if length is between min and max or
  // if neither min or max is set return with no error.
  if ((min === null || length >= this._min) &&
     ((max === null) || (length <= this._max)))
  {
    return string;
  }
  else
  {
    if (length < this._min) //too short
    {
      params = {"value": value, "min": min};
      summary = messageSummaryTooShort ? translations.applyParameters(messageSummaryTooShort, params) :
                  translations.getTranslatedString('oj-validator.length.messageSummary.tooShort');
      detail = messageTooShort ? translations.applyParameters(messageTooShort, params) : 
                  translations.getTranslatedString('oj-validator.length.messageDetail.tooShort', params);
    }
    else // too long
    {
      params = {"value": value, "max": max};
      summary = messageSummaryTooLong ? translations.applyParameters(messageSummaryTooLong, params) :
                  translations.getTranslatedString('oj-validator.length.messageSummary.tooLong');
      detail = messageTooLong ? translations.applyParameters(messageTooLong, params) : 
                    translations.getTranslatedString('oj-validator.length.messageDetail.tooLong', params);
    }
    
    throw new oj.ValidatorError(summary, detail);
  }
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * Constructs a NumberRangeValidator that ensures the value provided is within a given range
 * @param {Object=} options an object literal used to provide the following properties
 * @param {number=} options.min - the minimum number value of the entered value.
 * @param {number=} options.max - the maximum number value of the entered value.
 * @param {Object=} options.hint - an optional object literal of hints to be used. 
 * @param {string=} options.hint.max - a hint used to indicate the allowed maximum. When not present, 
 * the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.number.hint.max</code>.<p>
 * Tokens: <br/>
 * {max} - the maximum<p>
 * Usage: <br/>
 * Enter a number less than or equal to {max}
 * @param {string=} options.hint.min - a hint used to indicate the allowed minimum. When not present, 
 * the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.number.hint.min</code>.<p>
 * Tokens: <br/>
 * {min} the minimum <p>
 * Usage: <br/>
 * Enter a number greater than or equal to {min}</li>
 * @param {string=} options.hint.inRange - a hint used to indicate the allowed range. When not 
 * present, the default hint is the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.number.hint.inRange</code>.<p>
 * Tokens:<br/>
 * {min} the minimum<br/>
 * {max} the maximum<p>
 * Usage: <br/>
 * Enter a number between {min} and {max}
 * @param {Object=} options.messageDetail - an optional object literal of custom error messages to 
 * be used.
 * @param {string=} options.messageDetail.rangeUnderflow - the detail error message to be used when 
 * input value is less than the set minimum value. When not present, the default detail message is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.number.messageDetail.rangeUnderflow</code>.<p>
 * Tokens:<br/>
 * {value} - value entered by the user<br/>
 * {min} - the minimum allowed value<p>
 * Usage: <br/>
 * The number {value} must be greater than or equal to {min}.
 * @param {string=} options.messageDetail.rangeOverflow - the detail error message to be used when 
 * input value exceeds the maximum value set. When not present, the default detail message is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.number.messageDetail.rangeOverflow</code>.<p>
 * Tokens:<br/>
 * {value} - value entered by the user<br/>
 * {max} - the maximum allowed value<p>
 * Usage: <br/>
 * The number {value} must be less than or equal to {max}.     
 * @param {Object=} options.messageSummary - optional object literal of custom error summary message 
 * to be used. 
 * @param {string=} options.messageSummary.rangeUnderflow - the summary of the error message when 
 * input value is less than the set minimum value. When not present, the default message summary is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.number.messageSummary.rangeUnderflow</code>.
 * @param {string=} options.messageSummary.rangeOverflow - the summary of the error message when 
 * input value exceeds the maximum value set.  When not present, the default message summary is 
 * the resource defined with the key 
 * <code class="prettyprint">oj-validator.range.number.messageSummary.rangeOverflow</code>.
 * @export
 * @constructor
 * @since 0.7
 * 
 */
// TODO: Probably get rid of the 'message' level, and just have 'hint', 'messageDetail', 'messageSummary'. This matches what I put in oj-translations.
oj.NumberRangeValidator = function _NumberRangeValidator(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.NumberRangeValidator, oj.Validator, "oj.NumberRangeValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @memberof oj.NumberRangeValidator
 * @instance
 * @export
 */
oj.NumberRangeValidator.prototype.Init = function (options)
{
  oj.NumberRangeValidator.superclass.Init.call(this);

  
  if (options)
  {
    this._min = options["min"];
    this._max = options["max"];
    this._converter = oj.IntlConverterUtils.getConverterInstance(options['converter']);
    this._hint = options['hint'] || {};
    this._customMessageSummary = options['messageSummary'] || {};
    this._customMessageDetail = options['messageDetail'] || {};
  }
};

/**
 * Validates the minimum + maximum conditions
 *
 * @param {string|number} value that is being validated
 * @returns {string} original if validation was successful
 *
 * @throws {Error} when value is out of range
 * @memberof oj.NumberRangeValidator
 * @instance
 * @export
 */
oj.NumberRangeValidator.prototype.validate = function (value)
{
  var string = value ? value.toString() : value, 
      numberValue = parseFloat(string), 
      customMessageSummary = this._customMessageSummary,
      customMessageDetail = this._customMessageDetail,
      messageDetailRangeOverflow = customMessageDetail["rangeOverflow"], 
      messageDetailRangeUnderflow = customMessageDetail["rangeUnderflow"], 
      messageSummaryRangeOverflow = customMessageSummary["rangeOverflow"],
      messageSummaryRangeUnderflow = customMessageSummary["rangeUnderflow"],
      min = this._min !== undefined ? parseFloat(this._min) : null, 
      max = this._max !== undefined ? parseFloat(this._max) : null, 
      minStr = min && this._converter ? this._converter['format'](min) : min,
      maxStr = max && this._converter ? this._converter['format'](max) : max,
      summary = "", 
      detail = "", 
      params = null,
      translations = oj.Translations;
  
  if(value === null) 
  {
    // request to not throw an error when value being passed is of null
    return value;
  }
  
  if (min !== null && max !== null)
  {
    //range
    if ((numberValue >= min && numberValue <= max) || min > max)
    {
      return string;
    }
  }
  else 
  {
    //only min
    if (min !== null)
    {
      if (numberValue >= min)
      {
        return string;
      }
	  
    }
    //max only
    else 
    {
      if (max === null || numberValue <= max)
      {
        return string;
      }
    }
  }
  
  // if we haven't returned with an OK, then we need to throw a ValidatorError
  if (max !== null && numberValue > max)
  {
	  params = {"value": value, "max": maxStr};
      summary = messageSummaryRangeOverflow ? messageSummaryRangeOverflow : 
                  translations.getTranslatedString('oj-validator.range.number.messageSummary.rangeOverflow');
      detail = messageDetailRangeOverflow ? translations.applyParameters(messageDetailRangeOverflow, params) : 
                  translations.getTranslatedString('oj-validator.range.number.messageDetail.rangeOverflow', params);
  }
  else if (min !== null && numberValue < min)
  {
 	  params = {"value": value, "min": minStr};
      summary = messageSummaryRangeUnderflow ? messageSummaryRangeUnderflow : 
                  translations.getTranslatedString('oj-validator.range.number.messageSummary.rangeUnderflow');
      detail = messageDetailRangeUnderflow ? translations.applyParameters(messageDetailRangeUnderflow, params) : 
                  translations.getTranslatedString('oj-validator.range.number.messageDetail.rangeUnderflow', params);   
  }

  throw new oj.ValidatorError(summary, detail);
};

/**
 * @returns {String|null} a hint message or null if no hint is available in the options
 * @memberof oj.NumberRangeValidator
 * @instance
 * @export
 */
oj.NumberRangeValidator.prototype.getHint = function ()
{
  var hint = null, hints = this._hint, 
      hintInRange = hints["inRange"], hintMinimum = hints["min"], hintMaximum = hints["max"],
      translations = oj.Translations,
      min = this._min !== undefined ? parseFloat(this._min) : null, 
      max = this._max !== undefined ? parseFloat(this._max) : null,
      minStr = min && this._converter ? this._converter['format'](min) : min,
      maxStr = max && this._converter ? this._converter['format'](max) : max;
	  
  if (min !== null && max !== null) 
  {
  	hint = hintInRange ? translations.applyParameters(hintInRange, {"min": minStr, "max": maxStr}) : 
	                       translations.getTranslatedString('oj-validator.range.number.hint.inRange', {"min": minStr, "max": maxStr});
  }
  else if (min !== null)
  {
    hint = hintMinimum ?  translations.applyParameters(hintMinimum, {"min": minStr}) :
	                      translations.getTranslatedString('oj-validator.range.number.hint.min', {"min": minStr});
  }
  else if (max !== null)
  {
    hint = hintMaximum ?  translations.applyParameters(hintMaximum, {"max": maxStr}) :
                          translations.getTranslatedString('oj-validator.range.number.hint.max', {"max": maxStr});
  }

  return hint;
};
/**
 * @preserve Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
 * All rights reserved.
 */

/**
 * A factory implementation to create the built-in number converter of type 
 * {@link oj.IntlNumberConverter}. 
 * 
 * @name oj.NumberConverterFactory
 * @class
 * 
 * @example <caption>create an instance of the jet datetime converter using the options provided</caption>
 * var ncf = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER); 
 * var salaryOptions = {currency: "EUR" , pattern: "¤#,##0.00;(¤#,##0.00)"};
 * var salaryConverter = ncf.createConverter(salaryOptions);
 * @public
 * @since 0.6
 * 
 */
oj.NumberConverterFactory = (function () 
{
  
  function _createNumberConverter(options) 
  {
    return new oj.IntlNumberConverter(options);
  }
  
  return {
    /**
     * Creates an immutable (jet) number converter instance.
     * 
     * @param {Object=} options an object literal used to provide optional information to initialize 
     * the jet number converter with. For details on what to pass for options, refer to 
     * {@link oj.IntlNumberConverter}
     * 
     * @return {oj.IntlNumberConverter}
     * @memberOf oj.NumberConverterFactory
     * @public
     */
    'createConverter': function(options) {
      return _createNumberConverter(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultConverterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER, // factory name
                               oj.NumberConverterFactory);


/**
 * A factory implementation to create the built-in datetime converter of type 
 * {@link oj.IntlDateTimeConverter}. 
 * 
 * @name oj.DateTimeConverterFactory
 * @public
 * @class
 * @example <caption>create an instance of the jet datetime converter using the options provided</caption>
 * var dtcf = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME);  
 * var dateOptions = {year: '2-digit', month: 'numeric', day: 'numeric'};
 * var dateConverter = dtcf.createConverter(dateOptions);
 * @since 0.6
 * 
 */
oj.DateTimeConverterFactory = (function () 
{
  function _createDateTimeConverter(options) 
  {
    return new oj.IntlDateTimeConverter(options);
  }
  
  /**
   * 
   * @public
   */
  return {
    /**
     * Creates an immutable (jet) datetime converter instance. 
     * 
     * @param {Object=} options an object literal used to provide an optional information to 
     * initialize the jet datetime converter. For details on what to pass for options, refer to 
     * @link oj.IntlDateTimeConverter.
     * 
     * @return {oj.IntlDateTimeConverter} 
     * @memberOf oj.DateTimeConverterFactory
     * @public
     */
    'createConverter' : function(options) {
      return _createDateTimeConverter(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultConverterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME, // factory name
                               oj.DateTimeConverterFactory);


// JET VALIDATOR FACTORIES 

/**
 * A factory implementation to create an instance of the built-in required validator of type 
 * {@link oj.RequiredValidator}. 
 * 
 * @example <caption>create an instance of the required validator using the factory</caption>
 * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED); 
 * var options = {'hint' : 'a value is required for this field'};
 * var requiredValidator = rvf.createValidator(options);
 * 
 * @name oj.RequiredValidatorFactory
 * @class
 * @public
 * @since 0.6
 * 
 */
oj.RequiredValidatorFactory = (function () 
{
  
  function _createRequiredValidator(options) 
  {
    return new oj.RequiredValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type @link oj.RequiredValidator that ensures that 
     * the value provided is not empty.  
     * 
     * @param {Object=} options an object literal used to provide an optional hint and error 
     * message. See {@link oj.RequiredValidator} for details.<p>
     * 
     * @return {oj.RequiredValidator}
     * @memberOf oj.RequiredValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createRequiredValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED,
                                                oj.RequiredValidatorFactory);
                               
/**
 * A factory implementation that creates an instance of the built-in regExp validator of type 
 * {@link oj.RegExpValidator}.
 * 
 * @example <caption>create an instance of the regExp validator using the factory</caption>
 * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP);  
 * var usernameValidator = rvf.createValidator(
 *  {
 *    'pattern': '[a-zA-Z0-9]{3,}', 
 *    'messageDetail': 'You must enter at least 3 letters or numbers'}
 *  });
 * 
 * @name oj.RegExpValidatorFactory
 * @class
 * @public
 * @since 0.6
 * 
 */
oj.RegExpValidatorFactory = (function () 
{
  
  function _createRegExpValidator(options) 
  {
    return new oj.RegExpValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type {@link oj.RegExpValidator} that ensures the value 
     * matches the provided pattern. 
     * 
     * @param {Object} options an object literal used to provide the pattern, an optional hint, error 
     * message among others. See {@link oj.RegExpValidator} for details.<p>
     * 
     * 
     * @return {oj.RegExpValidator} 
     * @memberOf oj.RegExpValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createRegExpValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP,
                                                oj.RegExpValidatorFactory);
                                        
/**
 * a factory implementation to create an instance of the built-in dateTimeRange validator of type 
 * {@link oj.DateTimeRangeValidator}. 
 * 
 * @example <caption>create an instance of the dateTimeRange validator using the factory</caption>
 * var drvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE);  
 * var birthdateOptions = {min: new Date(1930, 00, 01), max: new Date(1995, 11,31)};
 * var birthdateValidator = drvf.createValidator(birthdateOptions);
 *  
 * @name oj.DateTimeRangeValidatorFactory
 * @class
 * @public
 * @since 0.6
 * 
 */
oj.DateTimeRangeValidatorFactory = (function () 
{
  
  function _createDateTimeRangeValidator(options) 
  {
    return new oj.DateTimeRangeValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type {@link oj.DateTimeRangeValidator} that ensures 
     * that the (datetime) value provided is within a given range.
     * 
     * @param {Object=} options an object literal used to provide the minimum, maximum and other 
     * optional values. See {@link oj.DateTimeRangeValidator} for details.<p>
     * 
     * @return {oj.DateTimeRangeValidator}
     * @memberOf oj.DateTimeRangeValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createDateTimeRangeValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE,
                                                oj.DateTimeRangeValidatorFactory);
												
/**
 * a factory method to create an instance of the built-in dateRestriction validator of type 
 * {@link oj.DateRestrictionValidator}. 
 * 
 * @example <caption>create an instance of the dateRestriction validator using the factory </caption>
 * var drvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION);
 * var drValidator = drvf.createValidator();
 *  
 * @name oj.DateRestrictionValidatorFactory
 * @class
 * @since 0.6
 * @public
 * 
 */
oj.DateRestrictionValidatorFactory = (function () 
{
  
  function _createDateRestrictionValidator(options) 
  {
    return new oj.DateRestrictionValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type oj.DateRestrictionValidator that ensures that the 
     * (date) value provided is not in a disabled entry of dayMetaData.
     * 
     * @param {Object=} options an object literal used to provide the dayMetaData optional value. 
     * See {@link oj.ojInputDate} and {@link oj.DateRestrictionValidator} for details.<p>
     * 
     * @return {oj.DateRestrictionValidator}
     * @memberOf oj.DateRestrictionValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createDateRestrictionValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION,
                                                oj.DateRestrictionValidatorFactory);
                                        
/**
 * a factory method to create an instance of a built-in numberRange validator of type 
 * {@link oj.NumberRangeValidator}. 
 * 
 * @example <caption>create an instance of the numberRange validator using the factory</caption>
 * var lrvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBER_RANGE);
 * var options = {hint: {min: 'Enter a value greater than {min}'}, min: 100};
 * var lrValidator = lrvf.createValidator(options);
 * 
 * @name oj.NumberRangeValidatorFactory
 * @class
 * @public
 * @since 0.6
 * 
 */
oj.NumberRangeValidatorFactory = (function () 
{
  
  function _createNumberRangeValidator(options) 
  {
    return new oj.NumberRangeValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type {@link oj.NumberRangeValidator} that ensures 
     * that the value provided is within a given range.
     * 
     * @param {Object=} options an object literal used to provide the minimum, maximum and other 
     * optional values. See {@link oj.NumberRangeValidator} for details.<p>
     * 
     * @return {oj.NumberRangeValidator}
     * @memberOf oj.NumberRangeValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createNumberRangeValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE,
                                                oj.NumberRangeValidatorFactory);
                                        
/**
 * Returns an instance of oj.LengthValidatorFactory that provides a factory method to create an 
 * instance of a length validator. 
 * 
 * @example <caption>create an instance of the length validator using the factory</caption>
 * var lvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_LENGTH);
 * var options = {hint: {max: 'Enter {max} or fewer characters'}, max: 10};
 * var lValidator = lvf.createValidator(options);
 * 
 * @name oj.LengthValidatorFactory
 * @class
 * @public
 * @since 0.6
 * 
 */
oj.LengthValidatorFactory = (function () 
{
  
  function _createLengthValidator(options) 
  {
    return new oj.LengthValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type oj.LengthValidator that ensures that the 
     * value provided is withing a given length.
     * 
     * @param {Object=} options an object literal used to provide the 'minimum', 'maximum' and other 
     * optional values. See {@link oj.LengthValidator} for details.<p>
     * 
     * @return {oj.LengthValidator}
     * @memberOf oj.LengthValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createLengthValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_LENGTH,
                                                oj.LengthValidatorFactory);
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @expose
 */
oj.IntlConverterUtils = {};

/**
 * Returns a Date object provided an isoString
 * 
 * @param {string} isoString date in isoString format
 * @returns {Date} localDate 
 * @expose
 * @since 0.7
 */
oj.IntlConverterUtils.isoToLocalDate = function(isoString) 
{
  return OraI18nUtils.isoToLocalDate(isoString);
}

/**
 * Given either an Object literal representing a 'converter' option (used in components) or a 
 * converter instance of type oj.Converter, this method returns the converter instance.
 * 
 * @param {Object} converterOption
 * @returns {Object} converterInstance or null if a converter cannot be determined
 * @expose
 * @since 0.6
 */
oj.IntlConverterUtils.getConverterInstance = function (converterOption)
{
  var cTypeStr = "", cOptions = {}, converterInstance = null, cf;
  
  if (converterOption)
  {
    if (typeof converterOption === "object")
    {
      // TODO: Should we check that it duck types oj.Converter?
      if (converterOption instanceof oj.Converter || 
          (converterOption['parse'] && typeof converterOption['parse'] === "function") || 
          (converterOption['format'] && typeof converterOption['format'] === "function"))
      {
        // we are dealing with a converter instance
        converterInstance = converterOption;
      }
      else 
      {
        // check if there is a type set
        cTypeStr = converterOption['type'];
        cOptions = converterOption['options'] || {};
      }
    }

    if (!converterInstance)
    {
      // either we have an object literal or just plain string.
      cTypeStr = cTypeStr || converterOption;
      if (cTypeStr && typeof cTypeStr === "string")
      {
        // if we are passed a string get registered type. 
        cf = oj.Validation.converterFactory(cTypeStr);
        converterInstance = cf.createConverter(cOptions);
      }
    }
  }
  
  return converterInstance;
};

// PACKAGE PRIVATE

/**
 * Processes an converter option error and returns a oj.ConverterERror instance.
 * @param {string} errorCode
 * @param {Object} parameterMap
 * @return {Object} an oj.ConverterError instance
 * @private
 */
oj.IntlConverterUtils.__getConverterOptionError = function(errorCode, parameterMap)
{
  oj.Assert.assertObject(parameterMap);
  var summary = "", detail = "", propName = parameterMap['propertyName'], reqPropName, 
          propValueValid;
  
  if (errorCode === "optionTypesMismatch")
  {
    reqPropName = parameterMap['requiredPropertyName'];
    propValueValid = parameterMap['requiredPropertyValueValid'];
    // Summary: A value for the property '{requiredPropertyName}' is required when the property 
    // '{propertyName}' is set to '{propertyValue}'.
    summary = oj.Translations.getTranslatedString("oj-converter.optionTypesMismatch.summary", 
      {'propertyName': propName,
       'propertyValue': parameterMap['propertyValue'],
       'requiredPropertyName': reqPropName});

    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(reqPropName, propValueValid);
  }
  else if (errorCode === "optionTypeInvalid")
  {
    // Summary: A value of the expected type was not provided for '{propertyName}'.
    propName = parameterMap['propertyName'];
    propValueValid = parameterMap['propertyValueValid'];
    summary = oj.Translations.getTranslatedString("oj-converter.optionTypeInvalid.summary", 
      {'propertyName': propName});

    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
  }
  else if (errorCode === "optionOutOfRange")
  {
    // The value {propertyValue} is out of range for the option '{propertyName}'.
    summary = oj.Translations.getTranslatedString("oj-converter.optionOutOfRange.summary", 
      {'propertyName': propName,
       'propertyValue': parameterMap['propertyValue']});

    propValueValid = parameterMap['propertyValueValid'];
    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
  }
  else if (errorCode === "optionValueInvalid")
  {
    // An invalid value '{propertyValue}' was specified for the option '{propertyName}'.. 
    summary = oj.Translations.getTranslatedString("oj-converter.optionValueInvalid.summary", 
      {'propertyName': propName,
       'propertyValue': parameterMap['propertyValue']});
    
    propValueValid = parameterMap['propertyValueHint'];
    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
  }
  
  return new oj.ConverterError(summary, detail);

};


/**
 * Builds the detail message for possible converter option values. Only applicable when errorInfo is 
 * returned from JET converter implementation.
 * 
 * @param {string} propName name of the property 
 * @param {Array|string} propValueValid valid value or values expected.
 * 
 * @return {string} the localized message
 * @private
 */
oj.IntlConverterUtils._getOptionValueDetailMessage = function (propName, propValueValid)
{
  // Detail: An accepted value for '{propertyName}' is '{propertyValueValid}'. or 
  // Accepted values for '{propertyName}' are '{propertyValueValid}'.
  var resourceKey;
  
  if (propValueValid)
  {
    if (typeof propValueValid === "string")
    {
      resourceKey = "oj-converter.optionHint.detail";
    }
    else
    {
      // we have an array of values
      resourceKey = "oj-converter.optionHint.detail-plural";
      propValueValid = 
         propValueValid.join(oj.Translations.getTranslatedString("oj-converter.plural-separator"));
    }
    return oj.Translations.getTranslatedString(resourceKey, 
      {'propertyName': propName,
       'propertyValueValid': propValueValid});

  }
  
  return "";
};

/**
 * Returns the default value for non-truthy values.
 * 
 * @returns {string} an empty string
 * @private
 */
oj.IntlConverterUtils.__getNullFormattedValue = function ()
{
  return "";
};

/*jslint browser: true, devel: true*/
/*global ComponentChangeTracker:true*/


/**
 * To create a custom binding,
 * use oj.ComponentBinding.create(). Using prototypal inheritance to extend
 * oj.ComponentBinding is not supported.
 * @export
 * @class oj.ComponentBinding 
 * @classdesc JQueryUI component binding for Knockout.js. 
 * @param {string|Array.<string>} name - the name of the binding or an
 * array of strings in case the binding needs to be registered under several names
 * @param {?(Object|string)=} options - property object
 * @see oj.ComponentBinding.create
 * @constructor
 */
oj.ComponentBinding = function(name, options)
{
  this.Init(name, options);
};

oj.Object.createSubclass(oj.ComponentBinding, oj.Object, "oj.ComponentBinding");


/**
 * Creates a binding instance and registers it with Knockout.js
 * @export
 * @param {string|Array.<string>} name - the name of the binding or an
 * array of strings in case the binding needs to be registered under several names
 * @param {?(Object|string)=} options - property object with the following fields:
 * <ul>
 *   <li>{string} 'componentName' - name of the component 
 *       Not specifying this parameter indicates that the binding should use the 'component' attribute 
 *       on itself to determine the constructor name
 *   </li>
 *   <li>{Function} 'afterCreate'- a callback invoked after component instance has been created.
 *        The function will receive the following parameters:
 *        <ul>
 *           <li>{Element} element - DOM element associated with this binding</li>
 *           <li>{Function} widgetConstructor - constructor for the JQueryUI widget created
 *            by this binding. The constructor is already bound to the associated 
 *            JQuery element</li>
 *           <li>{Function} valueAccessor - a JavaScript function that you can call to 
 *           get a map of current binding attributes</li>
 *           <li>{Object} allBindings -  a JavaScript object that you can use to access all the model values bound 
 *           to this DOM element</li>
 *           <li>{Object} bindingContext -  an object that holds the binding context available to this element's bindings. 
 *           This object includes special properties including $parent, $parents, and $root that can be used to access
 *           data that is bound against ancestors of this context</li>
 *        </ul>
 *   </li>
 *   <li>{Function} 'beforeDestroy'- a callback invoked before the component instance is detroyed by this binding
 *        The function will receive the same parameters as the 'afterCreate' callback above.
 *   </li>
 * </ul>
 * When this parameter is specified as a string, it will be interpreted as a single 'componentName' option
 * @return {oj.ComponentBinding} binding instance
 */
oj.ComponentBinding.create = function(name, options)
{
  if (name == null)
  {
    throw "Binding name is required!";
  }
  
  var instance = new oj.ComponentBinding(name, options);
  
  var handlers = ko.bindingHandlers, i;
  var names = Array.isArray(name) ? name : [name];
  for (i=0; i<names.length; i++)
  {
    handlers[names[i]] = instance;
  }
  
  return instance;
};

/**
 * Retrieves the default componnet binding instance registered with Knockout.js
 * @return {oj.ComponentBinding} default binding instance
 * @export
 */
oj.ComponentBinding.getDefaultInstance = function()
{
  return oj.ComponentBinding._INSTANCE;
};

/**
 * Sets up custom handling for attributes that will be managed by this binding 
 * instance
 * @param {Object} opts - property object with the following fields:
 * <ul>
 *   <li>'attributes' - string array of attribue names</li>
 *   <li>{Function} 'init' - a function called when a managed attribute is initialized.
 *        The function will receive the following parameters:
 *        <ul>
 *           <li>{string} name - attribute name</li>
 *           <li>{Object} value - attribute value</li>
 *           <li>{Element} element - DOM element where this binding is being attached</li>
 *           <li>{Function} widgetConstructor - constructor for the JQueryUI widget created
 *            by this binding. The constructor is already bound to the associated 
 *            JQuery element</li>
 *           <li>{Function} valueAccessor - a JavaScript function that you can call to 
 *           get a map of current binding attributes</li>
 *           <li>{Object} allBindings -  a JavaScript object that you can use to access all the model values bound 
 *           to this DOM element</li>
 *           <li>{Object} bindingContext -  an object that holds the binding context available to this element's bindings. 
 *           This object includes special properties including $parent, $parents, and $root that can be used to access
 *           data that is bound against ancestors of this context</li>
 *        </ul>
 *        The optional return value of the function is a name-to-value map of
 *        properties that should be set on the component
 *   </li>
 *   <li>{Function} 'update' - a function called when a managed attribute is updated.
 *        The function will receive the same parameters as the 'init' callback above.
 *        The optional return value of the function is a name-to-value map of
 *        properties that should be set on the component at the time when other
 *        accumulated changes are delivered
 *   </li>
 *   <li>{Function} 'afterCreate'- a callback invoked after component instance has been created.
 *        The function will receive the following parameters:
 *        <ul>
 *           <li>{string} name - attribute name</li>
 *           <li>{Element} element - DOM element associated with this binding</li>
 *           <li>{Function} widgetConstructor - constructor for the JQueryUI widget created
 *            by this binding. The constructor is already bound to the associated 
 *            JQuery element</li>
 *           <li>{Function} valueAccessor - a JavaScript function that you can call to 
 *           get a map of current binding attributes</li>
 *           <li>{Object} allBindings -  a JavaScript object that you can use to access all the model values bound 
 *           to this DOM element</li>
 *           <li>{Object} bindingContext -  an object that holds the binding context available to this element's bindings. 
 *           This object includes special properties including $parent, $parents, and $root that can be used to access
 *           data that is bound against ancestors of this context</li>
 *        </ul>
 *   </li>
 *   <li>{string} 'for' (optional) - a string representing component type or constructor 
 *        name restricting the applicability of these managed attributes
 *   </li>
 *   <li>{Array.<string>} 'use' (optional) - an string array of component types whose managed attribute behavior
 *       should be used for the component type specified with the 'for' attribute
 *   </li>
 * </ul>
 * @export
 */
oj.ComponentBinding.prototype.setupManagedAttributes = function(opts)
{
  var forName = opts['for'];
  forName = forName == null ? '@global' : forName;
  
  var managers = this._managedAttrOptions[forName] || [];
  
  managers.push(opts);
  
  this._managedAttrOptions[forName] = managers;
};



/**
 * Delivers all accumulated component changes across all instances of this binding.
 * Calling this method is optional - the changes will be delivered after a 1ms timeout
 * if this method is never invoked. However, you may call this method to speed up
 * component updates when the aplication code is done updating the view models.
 * @export
 */
oj.ComponentBinding.deliverChanges = function()
{
  oj.ComponentBinding._changeQueue.deliverChanges();
};

/**
 * @private
 */
oj.ComponentBinding.prototype.Init = function(names, options)
{
  oj.ComponentBinding.superclass.Init.call(this);
  
  if (typeof options === "string")
  {
    options = {'componentName': options};
  }
  
  this._bindingOptions = options || {};
  
  
  this._bindingNames = Array.isArray(names) ? names : [names];
  
  this['init'] = oj.Object.createCallback(this, this._init);
  this['update'] = oj.Object.createCallback(this, this._update);
  
  this._managedAttrOptions = {};
};



/**
 * @private
 */
oj.ComponentBinding._NEEDS_JUIB_INIT = "_ojNeedsJUIBInit";


/**
 * @private
 */
oj.ComponentBinding.prototype._init = function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) 
{
  //Invoke child bindings first to allow on-the-fly generation of child content
  ko.applyBindingsToDescendants(bindingContext, element);
  
  // Store the flag on the DOM element indicating that this binding still needs to be initialized
  // We will delay initialiazation (including creation of the JQueryUI component until update()
  // because other bindings such as foreachcdelay their DOM manipulation until update(). 
  // We need the complete dom to support functions like buttonset() and menu() on containers
  
  $(element).data(oj.ComponentBinding._NEEDS_JUIB_INIT, true);
  
    
  return {'controlsDescendantBindings': true};
};


/**
 * @private
 */
oj.ComponentBinding.prototype._update = function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext)
{
  var jelem = $(element);
  
  if (!jelem.data(oj.ComponentBinding._NEEDS_JUIB_INIT))
  {
    return;
  }
  
  jelem.data(oj.ComponentBinding._NEEDS_JUIB_INIT, null);
  
  
  this._initComponent(element, jelem, valueAccessor, allBindingsAccessor, bindingContext);
};


/**
 * @private
 */
oj.ComponentBinding.prototype._initComponent = function(element, jelem, valueAccessor, allBindingsAccessor, bindingContext)
{
  var options = valueAccessor();
  var roleAttrName = null;
  var disposed = false;
  var registeredListers = [];
  var tracker = null;
  var comp = null;
  
  var bindingMap = oj.ComponentBinding._getBindingValueMap(this._bindingNames, element, bindingContext);
  
 
  
  var stage = 0; // init
  
  var attributeEvaluatorCache = {};
  
  var componentName = this._bindingOptions['componentName'];
  
  if (componentName == null)
  {
    roleAttrName = 'component';    
      
    if (!bindingMap[roleAttrName])
    {
      // Try the deprecated 'role' attribute
      roleAttrName = 'role';
      
      if (!bindingMap[roleAttrName])
      {
        oj.Logger.error("component attribute is required for the ojComponent binding");
        return;
      }
    }
  
    var role = options[roleAttrName];
    
    if (role == null)
    {
      oj.Logger.error("non-null component attribute is required for the ojComponent binding");
      return;
    }
    
    
    // Use ko.computed to track changes to the 'component' attribute
    ko.computed(
        function()
        { 
          // evaluate full property expression to ensure that Knockout adds subscriptions to any computed observables that
          // may be in the chain
          oj.ComponentBinding._evaluatePropertyExpression(bindingMap[roleAttrName], roleAttrName, attributeEvaluatorCache, 
                                                          bindingContext, false);
          if (stage == 0)
          {
            componentName = ko.utils.unwrapObservable(role);
          }
          else
          {
            disposed = true;
            bindingMap = null;
            
            oj.ComponentBinding._unregisterWritebacks(jelem);
            
            if (comp)
            {
              // Clean up after a component type change
              tracker.dispose();
              tracker = null;
              
              var destroyCallback = this._bindingOptions['beforeDestroy'];
              if (destroyCallback)
              {
                destroyCallback(element, comp, valueAccessor, allBindingsAccessor, bindingContext);
              }
              
              comp("destroy");
              comp = null;
              
              var l;
              for (l=0; l<registeredListers.length; l++)
              {
                registeredListers[l].dispose();
              }
              registeredListers = null;
            }
            
            this._initComponent(element, jelem, valueAccessor, allBindingsAccessor, bindingContext);
          }
          return null;
        },
        this/* 'this' object for the 'read' function*/,
        {'disposeWhenNodeIsRemoved' : element});
  }
  
  if (componentName != null)
  {
    comp = jelem[componentName];
      
    if ((typeof comp) === "function")
    {
      comp = comp.bind(jelem);
      
      var managedAttrMap = oj.ComponentBinding._resolveManagedAttributes(this._managedAttrOptions, bindingMap, componentName);
      var specifiedManagedAttrs = {};
      
      // Always use managed attribute behavior from the default instance
      var defaultInstance = oj.ComponentBinding.getDefaultInstance();
      if (this !== defaultInstance)
      {
        var defaultManagedMap = defaultInstance._getManagedAttributes(bindingMap, componentName);
        // Override default managed attribute map with values from this binding's map.
        // Note that there is no need to clone defaultManagedMap because a new instance gets created
        // every time _getManagedAttributes() is called
        oj.CollectionUtils.copyInto(defaultManagedMap, managedAttrMap);
        managedAttrMap = defaultManagedMap;
      }
      
      var propertyMap = {};
      tracker = new ComponentChangeTracker(comp, element, oj.ComponentBinding._changeQueue);
      
      var writablePropMap = 
      {
        '^slider$' : [{'event': 'slidechange', 'getter': _extractValueFromChangeEvent}],
        '^oj*': [{'event': 'ojoptionchange', 'getter': _extractOptionChange}]
      };    
      
      var binding = this;
      
      var handler = function()
        {
          var prop = this._property;
          
          // evaluate full property expression to ensure that Knockout adds subscriptions to any computed observables that
          // may be in the chain
          var exp = bindingMap[prop];
          
          if (!exp)
          {
            throw "Binding expression for property " + prop + " is not found";
          }
          
         
          var currentVal = oj.ComponentBinding._evaluatePropertyExpression(exp, prop, attributeEvaluatorCache, 
                      bindingContext, stage !== 0 && !disposed);

          
          if (stage === 0) // init, no change
          {
            var val = options[prop];
            var value = oj.ComponentBinding._toJS(val);
          
            var managedPropEntry = managedAttrMap[prop];
            if (managedPropEntry != null)
            {
              specifiedManagedAttrs[prop] = managedPropEntry;
              var initFunc = managedPropEntry.init;
              if (initFunc != null)
              {
                var initProps = initFunc(prop, value, element, comp, valueAccessor, 
                                         allBindingsAccessor, bindingContext) || {};
                oj.CollectionUtils.copyInto(propertyMap, initProps);
              }
            }
            else
            {
              propertyMap[prop] = value;
            }
          }
          // this is a real change
          else if (!disposed)
          {
            var v = oj.ComponentBinding._toJS(currentVal);
            
            if (managedAttrMap[prop] != null)
            {
              var updateFunc = managedAttrMap[prop].update;
              if (updateFunc != null) 
              {
                var updateProps = updateFunc(prop, v, element, comp, valueAccessor, 
                                              allBindingsAccessor, bindingContext) || {};
                
                var updateKeys = Object.keys(updateProps);
                
                for (var k = 0; k<updateKeys.length; k++)            
                {
                  var p = updateKeys[k]; 
                  tracker.addChange(p, updateProps[p]);
                }
              }
            }
            else
            {
            
              tracker.addChange(prop, v);
            }
          }
          
          return null;
        };
      
      var p;
      var optionKeys = Object.keys(options);
      for (var k=0; k<optionKeys.length; k++)
      {
        p = optionKeys[k];
        if (p !== roleAttrName)
        {
          // ko.computed is used to set up dependency tracking for the bindings's attribute
          // Any observable evaulated during the initial invocation of the function is going to be treated as a dependency
          // by Knockout. Once that dependency changes, the fuction below will be called again, in which case we will know
          // to deliver the change
          registeredListers.push(
              ko.computed(handler, {_property: p}/* 'this' object for the 'read' function*/,
                  {'disposeWhenNodeIsRemoved' : element}));
        }
      }
      
      oj.ComponentBinding._registerWritebacks(jelem, componentName, writablePropMap, 
                                              bindingMap, tracker,
                                              bindingContext, attributeEvaluatorCache);
      
      var mutationOptions = oj.ComponentBinding._extractDotNotationOptions(propertyMap);
      
      comp(propertyMap);
      
      for (var mo in mutationOptions)
      {
        comp('option', mo, mutationOptions[mo]);
      }
      
      var createCallback = this._bindingOptions['afterCreate'];
      if (createCallback)
      {
        createCallback(element, comp, valueAccessor, allBindingsAccessor, bindingContext);
      }
      
      oj.ComponentBinding._deliverCreateToManagedProps(specifiedManagedAttrs, element, comp, valueAccessor, 
                                                       allBindingsAccessor, bindingContext);
      
      
      propertyMap = null;
    }
    else
    {
      oj.Logger.error("Component %s is not found", componentName);
    }
  }
  
  stage = 1; // after init
};

// Returns a map of the custom binding's properties. Each key is the property name,
// and each value is a string representation of the property expression
/**
 * @private
 */
oj.ComponentBinding._getBindingValueMap = function(names, elem, bindingContext) 
{
  var map = {},
      bindingValue = null,
      provider = ko.bindingProvider.instance,
      keyValueArray, stringTrimRegex, n, e,
      selfVal = null, i, keyValueEntry;

  if (provider.getBindingsString) 
  {
    bindingValue = provider.getBindingsString(elem, bindingContext);  
  }
  else
  {
    bindingValue = elem.getAttribute("data-bind");
  }
  
  if (!bindingValue) {
    return map;
  }
  
  keyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(bindingValue);
  
  stringTrimRegex = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
  
  for (i=0; i<keyValueArray.length; i=i+1) 
  {
    keyValueEntry = keyValueArray[i];
    
    var bindingKey = keyValueEntry['key'].replace(stringTrimRegex, '');
    
    if (names.indexOf(bindingKey) >= 0) 
    {
      selfVal = keyValueEntry['value'];
      break;
    }
  }
  
  if (!selfVal) {
    return map;
  }
  
  // now parse this binding's key/value pairs
  keyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(selfVal);
  
  
  for (n=0; n<keyValueArray.length; n=n+1) 
  {
    e = keyValueArray[n];
    map[e['key'].replace(stringTrimRegex, '')] = e['value'].replace(stringTrimRegex, '');  
  }
  
  return map;
};


// Evaluates an individual custom binding property expression
/**
 * @private
 */
oj.ComponentBinding._evaluatePropertyExpression = function(expOrCallback, key, cache, bindingContext, evalSimpleExpr) 
{
  var info = cache[key];
  
  var isNew = (info === undefined);
  
  if ( isNew || (info.evaluator === null && info.simple && evalSimpleExpr))
  {
    info = _createEvaluator(expOrCallback, evalSimpleExpr, isNew);
    
    cache[key] = info;
  }
  
  return (info.evaluator && (evalSimpleExpr || !info.simple)) ? info.evaluator(bindingContext) : null;
};

/**
 * @private
 */
function _createEvaluator(expOrCallback, evalSimpleExpr, isNew)
{
  if (typeof expOrCallback !== "string")
  {
    expOrCallback = expOrCallback();
  }
  
  var evaluator = null;
  var isSimple = false;
  
  if (expOrCallback !== null)
  {
    if (isNew)
    {
      var first = expOrCallback.charAt(0);
      
      // Check whether the expression is a string literal (starts with a quote) and whether it contains any function calls
      if (first === "'" || first === "\"" || expOrCallback.indexOf("(") <= 0)
      {
        isSimple = true;
      }
    }
    else // if we have already processed this expression, but the evaluator has not been created, the expression must be simple
    {
      isSimple = true;
    }

    // Performance fix: avoid expsive eval when we know that the expression is not referencing any observables or functions
    if (!isSimple || evalSimpleExpr)
    {
      /*jslint evil:true */
      evaluator = new Function("$context", "with($context){with($data||{}){return " + expOrCallback + ";}}");
    }
  }
  
  return {evaluator: evaluator, simple: isSimple};
};

/**
 * @private 
 */
function _extractValueFromChangeEvent(event, eventData) 
{
  var prop = 'value';
  var nameVal = {};
  nameVal[prop] = eventData[prop];
  return nameVal;
};

/**
 * @private 
 */
function _extractOptionChange(event, eventData)
{
  var nameVal = {};
  var metadata = eventData['optionMetadata'];
  var shouldWrite = metadata ? "shouldWrite" === metadata['writeback']: false;
  if (shouldWrite)
  {
    nameVal[eventData['option']] = eventData['value'];  
  }
  return nameVal;
};

/**
 * @private
 */
oj.ComponentBinding.prototype._getManagedAttributes = function(bindingMap, componentName)
{
  return oj.ComponentBinding._resolveManagedAttributes(this._managedAttrOptions, bindingMap, componentName);
}

/**
 * @private
 */
oj.ComponentBinding._resolveManagedAttributes = function(optionMap, bindingMap, componentName)
{
  var managedAttrMap = {};
  
  var applicableOptions = [];
  
  var attrs_field = 'attributes';
  
  var traverseOptions = function(name, followLinks)
  {
    var managers = optionMap[name];
    if (managers != null)
    {
      for (var n=managers.length-1; n>=0; n--)
      {
        var opt = managers[n];
        
        if (opt[attrs_field] != null)
        {
          applicableOptions.push(opt);
        }
        if (followLinks)
        {
          var parents = opt['use'];
          if (parents != null)
          {
            parents = Array.isArray(parents) ? parents : [parents];
            for (var i=0; i<parents.length; i++)
            {
              traverseOptions(parents[i], true);
            }
          }
        }
      }
    }
  };
  
  traverseOptions(componentName, true);
  
  // If this is a JET component, check managed options registered for the ancestors
  var ojNamespace = 'oj';
  var widgetClass = $[ojNamespace][componentName];
  
  if (widgetClass != null)
  {
    var proto = Object.getPrototypeOf(widgetClass.prototype);
    while (proto != null && ojNamespace === proto['namespace'])
    {
      traverseOptions(proto['widgetName'], true)
      proto = Object.getPrototypeOf(proto);
    }
  }
  
  traverseOptions('@global', false);
  
  if (applicableOptions.length > 0)
  {
    var attrs = Object.keys(bindingMap);
    
    for (var k=0; k<attrs.length; k++)
    {
      var attr = attrs[k];
   
      for (var l=0; l<applicableOptions.length; l++)
      {
        var opts  = applicableOptions[l];
        
        var attributes = opts[attrs_field];
        
        if (attributes.indexOf(attr) >= 0)
        {
          managedAttrMap[attr] = {init: opts['init'], update:opts['update'], 
                                  afterCreate:opts['afterCreate']};
          break;
        }
      }
    }
  }
  
  return managedAttrMap;
};

/**
 * @private
 */
oj.ComponentBinding._HANDLER_NAMESPACE = ".ojWriteback";

/**
 * @private
 */
oj.ComponentBinding._unregisterWritebacks = function(jelem)
{
  if (jelem)
  {
    jelem.off(oj.ComponentBinding._HANDLER_NAMESPACE);
  }
}

/**
 * @private
 */
oj.ComponentBinding._registerWritebacks = function(jelem, componentName, writablePropMap, 
                                                   bindingMap, tracker,
                                                   bindingContext,
                                                   attributeEvaluatorCache)
{
  var cachedPropertyExpressionWriters = {};
  
  for (var pattern in writablePropMap)
  {
    if (componentName.match(pattern))
    {
      var eventInfos = writablePropMap[pattern];
      for (var i=0; i<eventInfos.length; i++)
      {
        var info = eventInfos[i];
        
        jelem.on(
          info['event'] + oj.ComponentBinding._HANDLER_NAMESPACE,
          { //JQuery will pass this object as event.data
            getter: info['getter']
          },
          function(evt, data)
          {
            // Prevent bubbling to parent DOM elements. Other event handlers will still be called
            evt.stopPropagation();
            
            var nameValues = evt.data.getter(evt, data);
            
            tracker.suspend();
            
            try
            {
              for (var name in nameValues)
              {
                var expr = bindingMap[name];
                
                if (expr)
                {
                  var target = oj.ComponentBinding._evaluatePropertyExpression(bindingMap[name], name, attributeEvaluatorCache, 
                                                            bindingContext, true);
                  
                  oj.ComponentBinding._writeValueToProperty(name, 
                                                            target, 
                                                            nameValues[name],
                                                            bindingMap[name],
                                                            bindingContext,
                                                            cachedPropertyExpressionWriters);
                }
              }
            }
            finally
            {
              tracker.resume();
            }
          }
        );
      }
      
      break;  
    }
  }
      
};

/**
 * @private
 */
oj.ComponentBinding._getPropertyWriterExpression = function(expression)
{ 
  var reserveddWords = ["true", "false", "null", "undefined"];
  
  if (expression == null || reserveddWords.indexOf(expression) >= 0)
  {
    return null;
  }

  // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
  // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
  // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).
  var assignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;

  var match = expression.match(assignmentTarget);
  
  if (match === null)
  {
    return null;
  }
  
  var target = match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
  
  return 'function(v){' + target + '=v;}';
};

/**
 * @private
 */
oj.ComponentBinding._writeValueToProperty = function(name, property, value,
                                                     propertyExpression,
                                                     bindingContext, 
                                                     cachedPropertyExpressionWriters)
{  
  if (property == null || !ko.isObservable(property))
  {    
    var func = oj.ComponentBinding._evaluatePropertyExpression(
      function()
      {
        return oj.ComponentBinding._getPropertyWriterExpression(propertyExpression);
      },
      name, 
      cachedPropertyExpressionWriters, 
      bindingContext,
      true);
    
    if (func)
    {
      func(value);
    }
  
  }
  else if (ko.isWriteableObservable(property))
  {
    property(value);
  }
};


/**
 * @private
 */
oj.ComponentBinding._toJS = function(prop) 
{
  // ko.toJS creates a cloned object for both plain javascript objects and Object subclasses. We need to avoid it
  // for the latter case to ensure that complex Model objects can be used as binding properties without being cloned
  
  prop = ko.utils.unwrapObservable(prop);
  
  if ((Array.isArray(prop) || oj.CollectionUtils.isPlainObject(prop)) && prop['ojConvertToJS'])
  {
    prop = ko.toJS(prop);
  }

  return prop;
};

/**
 * @private
 */
oj.ComponentBinding._extractDotNotationOptions = function(options)
{
  var mutationOptions = {};
  
  for (var opt in options)
  {
    if (opt.indexOf('.') >= 0)
    {
      mutationOptions[opt] = options[opt];
    }
  }
  
  for (var mo in mutationOptions)
  {
    delete options[mo];
  }
  
  return mutationOptions;
};

/**
 * @private
 */
oj.ComponentBinding._deliverCreateToManagedProps = function(managedAttrMap, element, comp, 
                                                                  valueAccessor, allBindingsAccessor, bindingContext)
{
  var props = Object.keys(managedAttrMap);
  for (var i=0; i<props.length; i++)
  {
    var prop = props[i];
    var entry = managedAttrMap[prop];
    var callback = entry.afterCreate;
    
    if (callback)
    {
      callback(prop, element, comp, valueAccessor, allBindingsAccessor, bindingContext);
    }
  }
  
};


/**
 * @private
 * @constructor
 * Global Change Queue Implementation
 * The queue is used to delay component updates until all model changes have been propagated
 * This is a private class that does not need to be xported
 */
function GlobalChangeQueue()
{
  this.Init();
}

// Subclass from oj.Object 
oj.Object.createSubclass(GlobalChangeQueue, oj.Object, "ComponentBinding.GlobalChangeQueue");

GlobalChangeQueue.prototype.Init = function()
{
  GlobalChangeQueue.superclass.Init.call(this);
  this._trackers = [];
  this._queue = [];
};

GlobalChangeQueue.prototype.registerComponentChanges = function(tracker)
{
  if (this._trackers.indexOf(tracker) === -1)
  {
    this._trackers.push(tracker);
    if (!this._delayTimer)
    {
      this._delayTimer = setTimeout(oj.Object.createCallback(this, this._deliverChangesImpl), 1);
    }
  }
};

GlobalChangeQueue.prototype.removeComponentChanges = function(tracker)
{
  var index = this._trackers.indexOf(tracker);
  if (index >= 0)
  {
    this._trackers.splice(index, 1);
  }
};

GlobalChangeQueue.prototype.deliverChanges = function()
{
  if (this._delayTimer)
  {
    clearTimeout(this._delayTimer);
  }
  this._deliverChangesImpl();
};

GlobalChangeQueue.prototype._deliverChangesImpl = function()
{
  var i;
  this._delayTimer = null;
  var trackers = this._trackers;
  this._trackers = [];
  
 
  for (i=0; i<trackers.length; i++)
  {
    var tracker = trackers[i];
    this._queue.push({tracker: tracker, changes: tracker.flushChanges()});
  }
  
  while (this._queue.length > 0)
  {
    var record = this._queue.shift();
    record.tracker.applyChanges(record.changes);
  }
};

/**
 * @private
 * @constructor
 * Keeps track of changes for a single component
 */
function ComponentChangeTracker(component, element, queue)
{
  this.Init(component, element, queue);
}

// Subclass from oj.Object 
oj.Object.createSubclass(ComponentChangeTracker, oj.Object, "ComponentBinding.ComponentChangeTracker");

/**
 * @param {Function} component
 * @param {Element} element
 * @param {Object} queue
 */
ComponentChangeTracker.prototype.Init = function(component, element, queue)
{
  ComponentChangeTracker.superclass.Init.call(this);
  this._component = component;
  this._element = element;
  this._queue = queue;
  this._changes = {};
  this._suspendCount = 0;
};


ComponentChangeTracker.prototype.addChange = function(property, value)
{
  if (this._isSuspended() || this._disposed)
  {
    return;
  }
  this._changes[property] = value;
  this._queue.registerComponentChanges(this);
};

ComponentChangeTracker.prototype.dispose = function()
{
  this._queue.removeComponentChanges(this);
  this._disposed = true;
};

ComponentChangeTracker.prototype.resume = function()
{
  oj.Assert.assert(this._suspendCount > 0, "ComponentChangeTracker._suspendCount underflow");
  this._suspendCount -= 1;
};

ComponentChangeTracker.prototype.suspend = function()
{
  this._suspendCount += 1;
};

ComponentChangeTracker.prototype.applyChanges = function(changes)
{
  // Check if the component is still "alive"
  if (oj.Components.getWidgetConstructor(this._element) != null)
  {
    
    var mutationOptions = oj.ComponentBinding._extractDotNotationOptions(changes);
    
    var flags = {'changed' : true}; // indicates that the callee does not need to diff the value
    
    this._component("option", changes, flags); 
    for (var mo in mutationOptions)
    {
      this._component("option", mo, mutationOptions[mo], flags);
    }
  }
};

ComponentChangeTracker.prototype.flushChanges = function()
{
  var changes = this._changes;
  this._changes = {};
  return changes;
};


ComponentChangeTracker.prototype._isSuspended = function()
{
  return (this._suspendCount >= 1);
};



/**
 * @private
 */
oj.ComponentBinding._changeQueue = new GlobalChangeQueue();

/**
 * @private
 */
oj.ComponentBinding._INSTANCE = oj.ComponentBinding.create(["ojComponent", "jqueryUI"]);

//
// Define a template source that allows the use of a knockout array (ko[])
// to provide storage for a template string.
//
// This simplifies template assignment and template usage for the user, as shown in the following example:
//
// Template Assignment:
//
//   ko.templates["myKey"] = templateText;
//
// Template Usage:
//
//   <div data-bind="template: {name: myKey}">
//
/*jslint browser: true*/

/**
 * @export
 */
oj.koStringTemplateEngine = {};

/**
 * @export
 */
oj.koStringTemplateEngine.install = function() 
{
    //define a template source that tries to key into an object first to find a template string

    var _templateText = {}; // Stores the text property for the template object.
    var _templateData = {}; // Stores the data property for the template object.

    // data = {},
    var _engine = new ko['nativeTemplateEngine']();

    /**
     *  @constructor
     *  @private
     */

    var StringTemplate = function(template) {

        this._templateName = template;

        this.text = function(value) 
	{
	    // When passed no parameters, return the template object.
            if (!value)
	    {
                return _templateText[this._templateName];
            }

            _templateText[this._templateName] = value;
        };

        this.data = function(key, value)
	{

            if (!_templateData[this._templateName]) {
		_templateData[this._templateName] = {};
            }

            if (arguments.length === 1) {
                return _templateData[this._templateName][key];
            }

            _templateData[this._templateName][key] = value;
        };
    };

    //
    // Override knockout's makeTemplateSource(), returning the new stringTemplate 
    //
    _engine['makeTemplateSource'] = function(template, templateDocument)
    {
	if (typeof template == "string") 
	{
            templateDocument = templateDocument || document;
            var elem = templateDocument.getElementById(template);

            if (elem) 
	    {
		return new ko['templateSources']['domElement'](elem);
	    }
            return new StringTemplate(template);
	}
        if ((template && (template.nodeType == 1)) || (template.nodeType == 8)) 
	{
            return new ko['templateSources']['anonymousTemplate'](template);
        }
    };

    //make the templates accessible
    // ko.templates = _templateText;
    ko.templates = _templateText;

    //make this new template engine our default engine
    ko['setTemplateEngine'](_engine);
};


/**
 * Returns a header renderer function executes the template specified in the binding attribute.
 * (for example, a knockout template).
 * @param {Object} bindingContext the ko binding context
 * @param {string} template the name of the template
 * @return {Function} the renderer function
 * @private
 */
function _getDataGridHeaderRenderer(bindingContext, template)
{
    return function(context)
    {
        var parent, childContext;

        parent = context['parentElement'];
        // runs the template
        // runs the template
        childContext = bindingContext['createChildContext'](context['data'], null, 
                           function(binding)
                           {
                               binding['$key'] = context['key'];
                               binding['$metadata'] = context['metadata'];
                               binding['$headerContext'] = context;
                           }
                       );
        ko['renderTemplate'](template, childContext, null, parent);

        // tell the datagrid not to do anything
        return null;
    };
}

/**
 * Returns a cell renderer function executes the template specified in the binding attribute.
 * (for example, a knockout template).
 * @param {Object} bindingContext the ko binding context
 * @param {string} template the name of the template
 * @return {Function} the renderer function
 * @private
 */
function _getDataGridCellRenderer(bindingContext, template)
{
    return function(context)
    {
        var parent, childContext;

        parent = context['parentElement'];
        // runs the template
        childContext = bindingContext['createChildContext'](context['data'], null, 
                           function(binding)
                           {
                               binding['$keys'] = context['keys'];
                               binding['$metadata'] = context['metadata'];
                               binding['$cellContext'] = context;
                           }
                       );
        ko['renderTemplate'](template, childContext, null, parent);

        // tell the datagrid not to do anything
        return null;
    };
}

oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'attributes': ["header", "cell"],
  'init': function(name, value, element, widgetConstructor, valueAccessor, allBindingsAccessor, bindingContext)
  {
    var row, rowTemplate, column, columnTemplate, cellTemplate;
    if (name === "header")
    {
        // find row template and creates a renderer
        row = value['row'];
        if (row != null)
        {
            rowTemplate = row['template'];
            if (rowTemplate != null)
            {
                row['renderer'] = _getDataGridHeaderRenderer(bindingContext, rowTemplate);
            }
        }

        // find column template and creates a renderer
        column = value['column'];
        if (column != null)
        {
            columnTemplate = column['template'];
            if (columnTemplate != null)
            {
                column['renderer'] = _getDataGridHeaderRenderer(bindingContext, columnTemplate);
            }
        }

        widgetConstructor({'header': value});
    }
    else if (name === "cell")
    {
        // find the cell template and creates a renderer
        cellTemplate = value['template'];
        if (cellTemplate != null)
        {
            value['renderer'] = _getDataGridCellRenderer(bindingContext, cellTemplate);
        }
        widgetConstructor({'cell': value});
    }
  },
  'update': function(name, value, element, widgetConstructor, valueAccessor, allBindingsAccessor, bindingContext)
  {
    var row, rowTemplate, column, columnTemplate, cellTemplate;
    if (name === "header")
    {
        // find row template and creates a renderer
        row = value['row'];
        if (row != null)
        {
            rowTemplate = row['template'];
            if (rowTemplate != null)
            {
                row['renderer'] = _getDataGridHeaderRenderer(bindingContext, rowTemplate);
            }
        }

        // find column template and creates a renderer
        column = value['column'];
        if (column != null)
        {
            columnTemplate = column['template'];
            if (columnTemplate != null)
            {
                column['renderer'] = _getDataGridHeaderRenderer(bindingContext, columnTemplate);
            }
        }

        return {'header': value};
    }
    else if (name === "cell")
    {
        // find the cell template and creates a renderer
        cellTemplate = value['template'];
        if (cellTemplate != null)
        {
            value['renderer'] = _getDataGridCellRenderer(bindingContext, cellTemplate);
        }
        return {'cell': value};
    }
    return null;
  },
      
  'for': 'ojDataGrid'
});

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true, devel: true*/

// TODO: do we have JSDoc / API doc for bindings?  (Latest answer: no for now, just doc it briefly in baseComponent's contextMenu option for now.)
// TODO: split up init and update so get from DOM on init only, and update only sets it on DOM.  That way, 
//       can update observable to null, without having to additionally clear DOM attr to avoid having it restored from DOM attr.
//       Vet with Max first.
// TODO: keep binding and DOM in synch, a la disabled option in JQUI, similar to todo for contextMenu feature on JET base class.
// TODO: share code with baseComponent._setupContextMenu?  Should this have any of the configurability of that method?
//       where would shared code live?
ko.bindingHandlers['ojContextMenu'] = 
{
  'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) 
  {
    var eventNamespace = ".ojContextMenu";
    $(element).off( eventNamespace );

    var menu = ko.utils.unwrapObservable(valueAccessor());
    // menu is selector like "#myMenuId", or null, or some malformed thing.

    if ($.type(menu) !== "string")
    {
      menu = element.getAttribute("contextmenu");
      if (menu)
        menu = "#" + menu;
    }

    if (menu) 
      menu = $(menu).data( "oj-ojMenu" );// if selector finds >1 element, .data() uses the first one.
                                         // if selector finds 0 elements, .data() returns nothing.
    
    if ( menu )
    {
      var $element = $(element);
      $element.on( "keydown" + eventNamespace + " " + "contextmenu" + eventNamespace, function( event ) {
        if (event.type === "contextmenu" || (event.which == 121 && event.shiftKey)) // right-click or Shift-F10
        {
          menu.open(event, {"launcher": $element, "initialFocus": "menu"});
          return false; // Don't show native context menu
        }

        return true;
      });
    }
        
//  if (!menu)
      // TODO: Max suggested logging a warning if menu is null.  Since setting null is the way you would turn off the ContextMenu functionality, 
      // should we really log?  If so, warning or just info?
  }
};



/*jslint browser: true, devel: true*/

/** 
 * @private
 * @const
 */
var _COLUMNS_ATTR = 'columns';

/** 
 * @private
 * @const
 */
var _COLUMNS_DEFAULT_ATTR = 'columnsDefault';

/** 
 * The row template will be used to render the row elements. 
 * The row, status, and component objects will be available 
 * in the template context.
 * @private
 * @const
 */
var _ROW_TEMPLATE_ATTR = 'rowTemplate';

/**
 * Create and return a renderer which the component will call. That renderer
 * will render the template.
 * @param {Object} bindingContext  Binding Context
 * @param {string} type  'cell' or 'header' or 'row'
 * @param {string} template  template name
 * @return {Object} Renderer
 * @private
 */
function _getTableColumnTemplateRenderer(bindingContext, type, template)
{
  var rendererOption = {};
  (function(template, type) {
    rendererOption = function(params) {
      var childContext = null;
      var parentElement = null;
      if (type == 'header')
      {
        // calling bindingContext.extend() creates a context with 
        // new properties without adding extra level to the parent hierarchy
        childContext = bindingContext['extend']({'$column': params['column'],
          '$headerContext': params['headerContext']});
        parentElement = params['headerContext']['parentElement'];
      }
      else if (type == 'cell')
      {
        var childData = params['row'];
        childContext = bindingContext['createChildContext'](childData, null,
          function(binding)
          {
            binding['$column'] = params['column'];
            binding['$cellContext'] = params['cellContext'];
          }
        );
        parentElement = params['cellContext']['parentElement'];
      }
      if (type == 'footer')
      {
        // calling bindingContext.extend() creates a context with 
        // new properties without adding extra level to the parent hierarchy
        childContext = bindingContext['extend']({'$column': params['column'],
          '$footerContext': params['footerContext']});
        parentElement = params['footerContext']['parentElement'];
      }
      ko['renderTemplate'](template, childContext, null, parentElement, 'replaceNode');
    };
  }(template, type));

  return rendererOption;
}

/**
 * Create and return a renderer which the component will call. That renderer
 * will render the template.
 * @param {string} template  template name
 * @return {Object} Renderer
 * @private
 */
function _getTableRowTemplateRenderer(bindingContext, template)
{
  return function(params) {
    var childData = params['row'];
    var childContext = bindingContext['createChildContext'](childData, null,
      function(binding)
      {
        binding['$rowContext'] = params['rowContext'];
      }
    );
    ko['renderTemplate'](template, childContext, null, params['rowContext']['parentElement'], 'replaceNode');
  };
}

oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
  {
    'attributes': [_COLUMNS_ATTR, _COLUMNS_DEFAULT_ATTR, _ROW_TEMPLATE_ATTR],
    'init': function(name, value, element, widgetConstructor, valueAccessor,
      allBindingsAccessor, bindingContext)
    {
      if (name == _COLUMNS_ATTR || name == _COLUMNS_DEFAULT_ATTR)
      {
        var i, template, footerTemplate, headerTemplate;
        for (i = 0; i < value.length; i++)
        {
          var column = value[i];
          template = column['template'];
          footerTemplate = column['footerTemplate'];
          headerTemplate = column['headerTemplate'];

          if (template != null)
          {
            column['renderer'] = _getTableColumnTemplateRenderer(bindingContext, 'cell', template);
          }
          if (footerTemplate != null)
          {
            column['footerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'footer', footerTemplate);
          }
          if (headerTemplate != null)
          {
            column['headerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'header', headerTemplate);
          }
        }
        if (name == _COLUMNS_ATTR)
        {
          widgetConstructor({'columns': value});
        }
        else
        {
          widgetConstructor({'columnsDefault': value});
        }
      }
      else if (name == _ROW_TEMPLATE_ATTR)
      {
        widgetConstructor({'rowRenderer': _getTableRowTemplateRenderer(bindingContext, value)});
      }
    },
    'update': function(name, value, element, widgetConstructor, valueAccessor,
      allBindingsAccessor, bindingContext)
    {
      if (name == _COLUMNS_ATTR || name == _COLUMNS_DEFAULT_ATTR)
      {
        var i, template, footerTemplate, headerTemplate;
        for (i = 0; i < value.length; i++)
        {
          var column = value[i];
          template = column['template'];
          footerTemplate = column['footerTemplate'];
          headerTemplate = column['headerTemplate'];

          if (template != null)
          {
            column['renderer'] = _getTableColumnTemplateRenderer(bindingContext, 'cell', template);
          }
          if (footerTemplate != null)
          {
            column['footerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'footer', footerTemplate);
          }
          if (headerTemplate != null)
          {
            column['headerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'header', headerTemplate);
          }
        }
        if (name == _COLUMNS_ATTR)
        {
          widgetConstructor({'columns': value});
        }
        else
        {
          widgetConstructor({'columnsDefault': value});
        }
      }
      else if (name == _ROW_TEMPLATE_ATTR)
      {
        return {'rowRenderer': _getTableRowTemplateRenderer(bindingContext, value)};
      }
      return null;
    },
    'for': 'ojTable'
  });

var _DAY_META_DATA = "dayMetaData";

function getMetaData(dayMetaData, position, params) {
  if(!dayMetaData || position === params.length) {
    return dayMetaData;
  }
  
  var nextPos = position + 1;
  return getMetaData(dayMetaData[params[position]], nextPos, params) || getMetaData(dayMetaData["*"], nextPos, params);
};

var _processDayMetaData = function(name, value, element, widgetConstructor, valueAccessor,
                                    allBindingsAccessor, bindingContext) 
{
  if (name === _DAY_META_DATA)
  {
    //as discussed within the API meeting it will set to dayFormatter
    
    widgetConstructor({'dayFormatter': !value ? null : function(dateInfo) {
      return getMetaData(value, 0, [dateInfo["fullYear"], dateInfo["month"], dateInfo["date"]]);
    }});
  }
};

/**
 * ojValue Behavior Definition and Injection
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojDayMetaData',
  
  'attributes': [_DAY_META_DATA],
               
  'init': _processDayMetaData,
  'update': _processDayMetaData
});

/**
 * Default declaration for ojInputDateTime
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputDateTime',
  'use': 'ojDayMetaData'
});

/**
 * Default declaration for ojInputDate
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputDate',
  'use': 'ojDayMetaData'
});

/**
 * Default declaration for ojInputTime
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputTime',
  'use': 'ojDayMetaData'
});
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true, devel: true*/

/**
 * Tracks the validity of a group of components bound to this observable. It also provides 
 * properties and methods that the page author can use to enforce form validation best practice.
 * 
 * <p>
 * Validity of components that are disabled or readOnly will not be tracked by this object.</li>
 * </p>
 * 
 * <p>
 * The <code class="prettyprint">invalidComponentTracker</code> binding attribute should be bound to 
 * a ko observable. At runtime the framework creates an instance of this type 
 * <code class="prettyprint">oj.InvalidComponentTracker</code> and sets it on the bound observable.<br/> 
 * This object can then be used by page authors to do the following - 
 * <ul>
 * <li>determine if there are invalid components tracked by this object that are currently showing 
 * errors.</li>
 * <li>determine if there are invalid components tracked by this object that are currently deferring 
 * showing errors.</li>
 * <li>set focus on the first invalid component in the tracked group</li>
 * <li>show all messages on all tracked components including deferred error messages, and set focus 
 * on the first invalid component.</li>
 * </ul>
 * </p>
 * 
 * @example <caption> Bind an observable to the <code class="prettyprint">invalidComponentTracker</code> and access oj.InvalidComponentTracker instance.</caption>
 * &lt;input id="username" type="text" required 
 *   data-bind="ojComponent: {component: 'ojInputText', value: userName, 
 *    invalidComponentTracker: tracker}">
 * &lt;input id="password" type="text" required 
 *   data-bind="ojComponent: {component: 'ojInputPassword', value: password, 
 *    invalidComponentTracker: tracker}">
 * 
 * &lt;script>
 * function MyViewModel() { 
 *   var self = this;
 *   var tracker = ko.observable();
 *   
 *   log = function ()
 *   {
 *     var trackerObj = ko.utils.unwrapObservable(self.tracker);
 *     console.log(trackerObj instanceof oj.InvalidComponentTracker); // true 
 *   }
 * }
 * &lt;/script>
 * 
 * @class oj.InvalidComponentTracker 
 * @constructor
 * @class
 * @export
 * @since 0.7
 */
oj.InvalidComponentTracker = function()
{
  this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.InvalidComponentTracker, oj.Object, "oj.InvalidComponentTracker");

// DOCLETS for public properties

/**
 * Whether there is at least one component (tracked by this object) that is invalid and is currently 
 * showing messages. 
 * 
 * 
 * @example <caption>Disable button using <code class="prettyprint">invalidShown</code> property:</caption>
 * &lt;input id="username" type="text" required 
 *   data-bind="ojComponent: {component: 'ojInputText', value: userName, 
 *    invalidComponentTracker: tracker}">
 * &lt;input id="password" type="text" required 
 *   data-bind="ojComponent: {component: 'ojInputPassword', value: password, 
 *    invalidComponentTracker: tracker}">
 * &lt;button type="button" data-bind="ojComponent: {component: 'ojButton', label: 'Create',
 *   disabled: tracker()['invalidShown']}"></button>
 *   
 * &lt;script>
 * var userName = ko.observable();
 * var password = ko.observable();
 * var tracker = ko.observable();
 * &lt;/script>
 * 
 * @member 
 * @name invalidShown
 * @access public
 * @instance
 * @default false 
 * @type {boolean}
 * @expose
 * @memberof! oj.InvalidComponentTracker
 */


/**
 * Whether there is at least one component that is invalid with deferred messages, i.e., messages 
 * that are currently hidden.
 * 
 * @example <caption>Enable button using <code class="prettyprint">invalidHidden</code> property:</caption>
 * &lt;input id="username" type="text" required 
 *   data-bind="ojComponent: {component: 'ojInputText', value: userName, 
 *    invalidComponentTracker: tracker}">
 * &lt;input id="password" type="text" required 
 *   data-bind="ojComponent: {component: 'ojInputPassword', value: password, 
 *    invalidComponentTracker: tracker}">
 * &lt;br/>
 * &lt;button type="button" data-bind="ojComponent: {component: 'ojButton', label: 'Create',
 *   disabled: !tracker()['invalidHidden']}"></button>
 * 
 * &lt;script>
 * var userName = ko.observable();
 * var password = ko.observable();
 * var tracker = ko.observable();
 * &lt;/script>
 * 
 * @member 
 * @name invalidHidden
 * @access public
 * @instance
 * @default false 
 * @type {boolean}
 * @expose
 * @memberof! oj.InvalidComponentTracker
 */
/**
 * Initializer
 * @protected
 * @memberof! oj.InvalidComponentTracker
 * @instance
 */
oj.InvalidComponentTracker.prototype.Init = function () 
{
  var self = this;
  oj.InvalidComponentTracker.superclass.Init.call(this);
  
  // INTERNAL PROPERTIES
  // all tracked components
  this._tracked = [];
  
  // tracks invalid components showing messages. indices correspond to this_tracked.
  this._invalid = [];
  
  // tracks invalid components hiding messages. Contains indices from tracked.
  this._invalidHidden = []; 
  
  // PUBLIC PROPERTIES
  this['invalidShown'] = false;
  this['invalidHidden'] = false;
};

/**
 * Sets focus on first invalid component currently showing an error. This method does not set focus 
 * on components that are invalid and deferring messages. To show hidden messages on all tracked 
 * components use the showMessages() method.
 * 
 * @return {boolean} true if we have an invalid component that we can focus on; false if unable to 
 * locate a component to focus on or there are no invalid components. 
 * @export
 * @see #showMessages
 * @memberof! oj.InvalidComponentTracker
 * @instance
 */
oj.InvalidComponentTracker.prototype.focusOnFirstInvalid = function()
{
  var firstInvalid = null, self = this, updateCounter = this._updateCounter;
  if (this['invalidShown'])
  {
    firstInvalid = this._getFirstInvalidComponent();
  }
  
  // always call focus handler on a timer; to give time for updates to be applied on component. 
  // oj.ComponentBinding.applyUpdates, happens on a timer.
  setTimeout(function () {
      // sometimes when this timer is called, firstInvalid may not have been determined 
      // yet. Or the invalid states could have changed in between the timer being set and the 
      // callback being called.
      firstInvalid = (updateCounter === self._updateCounter) ? 
                        firstInvalid || self._getFirstInvalidComponent() : self._getFirstInvalidComponent(); 
      if (firstInvalid)
      {
        // Call a protected method Focus() exposed on editable components for now.
        firstInvalid.call(firstInvalid, "Focus");
      }
    }, 1);
  
  return firstInvalid ? true : false;
};

/**
 * Shows hidden messages on all tracked components by calling showMessages() method on each tracked 
 * editable component. 
 * 
 * @example <caption>Show all hidden messages on tracked components:</caption>
 *  function ViewModel ()
 *  {
 *    self = this;
 *    var tracker = ko.observable();
 *   // ...
 *   
 *   showAllMessages : function ()
 *   {
 *      var trackerObj = ko.utils.unwrapObservable(self.tracker);
        return trackerObj.showMessages();
 *    }
 *  }
 * 
 * @export
 * @memberof! oj.InvalidComponentTracker
 * @instance
 * @see oj.editableValue#showMessages
 */
oj.InvalidComponentTracker.prototype.showMessages = function()
{
  var tr, len, index;
  
  if (this['invalidHidden'])
  {
    len = this._invalidHidden.length;
    for (index = 0; index < len; index++)
    {
      if (this._invalidHidden[index])
      {
        tr = this._tracked[index].call(tr, "showMessages");
      }
    }
  }
};

// P R I V A T E    M E T H O D S
/**
 * Gets the first invalid component and returns the component to focus on.
 * 
 * @returns the component instance that has focus or null
 * @private
 */
oj.InvalidComponentTracker.prototype._getFirstInvalidComponent = function ()
{
  var firstInvalid, focusable = null, idx = 0, len = this._invalid.length;
  
  // locate first invalid component and set focus on it
  for (idx = 0; idx < len; idx++)
  {
    firstInvalid = this._invalid[idx];
    if (firstInvalid)
    {
      return this._tracked[idx];
    }
  };

  return focusable;
};

/**
 * Updates the internal properties to reflect the current validity state of the component, using 
 * new messages.
 * 
 * @param {Object} component the component that has the new messages
 * @param {string} option 
 * @param {Array} value 
 * @returns {boolean} if internal state mutated; false otherwise
 * @private
 * @memberof! oj.InvalidComponentTracker
 * @instance
 */
oj.InvalidComponentTracker.prototype._update = function (component, option, value)
{
  var compValid = component.call(component, "isValid"), 
      trackedIndex = -1, item, mutated = true, result;
  
  // locate the index in tracked, for the component that was updated 
  $.each(this._tracked, function (index, item)
  {
    if (trackedIndex < 0 && item === component)
    {
      trackedIndex = index;
      return;
    }
  });

  switch (option)
  {
    case "messagesShown":
    case "messagesHidden":
      
      // add/update/remove from array as the case may be
      if (value)
      {
        if (trackedIndex < 0)
        {
          trackedIndex = this._tracked.push(component) - 1;
        }

        // reset 
        this._updateInvalidTracker(this._invalid, trackedIndex, false);
        this._updateInvalidTracker(this._invalidHidden, trackedIndex, false);

        if (!compValid)
        {
          var isDisabled = component.call(component, "option", "disabled"),
          isReadOnly = component.call(component, "option", "readOnly");
          
          if (option === "messagesShown")
          {
            if (oj.InvalidComponentTracker._hasInvalidMessages(value))
            {
              // if component is disabled or readOnly but has a messagesShowing tracker ignores 
              // tracking component in its 'invalidShown' list. This is because if property is bound 
              // to a button, and if the only invalid component showing messages is disabled then 
              // button would appear disabled visually, confusing the end-user. 
              // E.g., disabled component can be initialized with messagesCustom making it invalid and 
              // disabled.

              result = isDisabled || isReadOnly ? false : true;
              this._updateInvalidTracker(this._invalid, trackedIndex || 0, result);
            }
          }

          if (option === "messagesHidden")
          {
            if (oj.InvalidComponentTracker._hasInvalidMessages(value))
            {
              // deferred validation is never run when component is disabled or is readOnly.
              this._updateInvalidTracker(this._invalidHidden, trackedIndex || 0, true);
            }
          }
        }

        // update properties
        this._updateInvalidProperties();

        // every time messages mutates, we track it. 
        if (this._updateCounter === undefined)
        {
          this._updateCounter = 0;
        }
        this._updateCounter++;  
      }
      break;
      
    case "disabled":
    case "readOnly":
      
      // when component goes from enabled to disabled (or to readOnly) tracker updates invalidShown 
      // to be false, since the component cannot be showing errors visually. Same goes for 
      // invalidHidden.
      // 
      // when component goes from disabled (or readOnly) to enabled validations are re-run and 
      // component's messagesHidden and messagesShown are updated which result in invalidShown and 
      // invalidHidden to be updated. This case is not handled here.

      if (value)
      {
        this._updateInvalidTracker(this._invalid, trackedIndex || 0, false);
        this._updateInvalidTracker(this._invalidHidden, trackedIndex || 0, false);
        this._updateInvalidProperties();
      }
      break;
  }
  return mutated;
};

oj.InvalidComponentTracker.prototype._updateInvalidProperties = function ()
{
  // update properties
  this['invalidShown'] = this._invalid.indexOf(true) >= 0;
  this['invalidHidden'] = this._invalidHidden.indexOf(true) >= 0;
};

oj.InvalidComponentTracker.prototype._updateInvalidTracker = function (arr, trackedIndex, value)
{
  var i, mutated = false;
  
  if (trackedIndex >= 0)
  {
    // mark component as invalid or invalidHidden to match the trackedIndex
    arr.splice(trackedIndex, 1, value);
    mutated = true;
  }
  else
  {
    arr.push(value);
    mutated = true;
  }
  
  return mutated;
};

/**
 * helper to determine if we have invalid messages among the list of messages that are currently 
 * showing i.e., that are showing.
 * 
 * @param {!Array} messages list of all messages associated with component
 * @returns {boolean}
 * @private
 * @memberof! oj.InvalidComponentTracker
 * @instance
 */
oj.InvalidComponentTracker._hasInvalidMessages = function (messages)
{
  return !oj.Message.isValid(messages);
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*jslint browser: true, devel: true*/

// private to prevent creating a JSDoc page for this class.  The only thing we wish 
// to JSDoc is the invalidComponentTracker, which we're putting in EditableValue's output.
/**
 * An extension to oj.ComponentBinding, properties exposed on this binding are available 
 * to jet components that extend from oj.editableValue. 
 * 
 * @private
 * @constructor oj.ValueBinding 
 * @see oj.ComponentBinding
 * @see oj.editableValue
 * @since 0.6
 */
oj.ValueBinding = function(){};


/** 
 * <p>When this attribute is bound to an observable, the framework pushes an object of type {@link oj.InvalidComponentTracker}
 * onto the observable. The object itself tracks the validity of a group of editable components.
 * 
 * <p>When this attribute is present, the binding registers a listener for the <a href="#optionChange">optionChange</a>
 * event. This event is fired by JET editable components whenever its validity changes (i.e. when 
 * <a href="#messagesShown">messagesShown</a> or <a href="#messagesHidden">messagesHidden</a> 
 * options change). When the event is fired, the listener determines the current validity of the 
 * component and updates the tracker.
 * 
 * <p>
 * The observable bound to this attribute is often used with multiple component binding declarations 
 * as shown in the example below.
 * </p>
 * 
 * <p>
 * This attribute is only exposed via the <code class="prettyprint">ojComponent</code> binding, and 
 * is not a component option.
 * </p>
 * 
 * @example <caption>Track validity of multiple components using a single observable bound to the <code class="prettyprint">invalidComponentTracker</code> attribute:</caption>
 * &lt;input id="username" type="text" name="username" required 
 *   data-bind="ojComponent: {component: 'ojInputText', value: userName, 
 *                            invalidComponentTracker: tracker}">
 * 
 * &lt;input id="password" type="password" name="password" required 
 *   data-bind="ojComponent: {component: 'ojInputPassword', value: password, 
 *                            invalidComponentTracker: tracker}"/>
 *   
 * // ViewModel that defines the tracker observable
 * &lt;script>
 * function MemberViewModel() 
 * { 
 *   var self = this;
 *   
 *   self.tracker = ko.observable();
 *   
 *   self.userName = ko.observable();   
 *   self.password = ko.observable();
 * }
 * &lt;/script>
 * 
 * @example <caption>Use tracker property <code class="prettyprint">invalid</code> to disable button:</caption>
 * // button is disabled if there are components currently showing errors
 * &lt;button type="button" data-bind="ojComponent: {component: 'ojButton', label: 'Submit',
 *                                                disabled: tracker()['invalidShown']}"></button>
 * 
 * @ojbindingonly
 * @member
 * @name invalidComponentTracker
 * @memberof oj.editableValue
 * @instance
 * @type {oj.InvalidComponentTracker}
 * @default <code class="prettyprint">null</code>
 * @since 0.7
 */ 
/** prevent preceding jsdoc from applying to following line of code */

oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER = 'invalidComponentTracker';

// An listener is added for this event to listen to changes to the 'messagesHidden' or 
// 'messagesShown' options. The listener updates the InvalidComponentTracker.
oj.ValueBinding._EVENT_OPTIONCHANGE = "ojoptionchange";

// Options we are interested in listening to changes for.
oj.ValueBinding._OPTION_MESSAGES_SHOWN = 'messagesShown';
oj.ValueBinding._OPTION_MESSAGES_HIDDEN = 'messagesHidden';

// options that are managed primarily to detect changes for tracker to be notified.
oj.ValueBinding._OPTION_DISABLED = 'disabled';
oj.ValueBinding._OPTION_READONLY = 'readOnly';


// callback called when managed attribute is being updated
oj.ValueBinding._update = function(name, value, element, component, valueAccessor)
{
  var options = valueAccessor.call(), updateProps = {},
      ictObs = options[oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER], 
      icTracker = ko.utils.unwrapObservable(ictObs);
      
  if (name === oj.ValueBinding._OPTION_DISABLED || name === oj.ValueBinding._OPTION_READONLY)
  {
    // when either of these options are updated
    if (icTracker !== null && ko.isWriteableObservable(ictObs))
    {
      if (icTracker._update.call(icTracker, component, name, value))
      {
        // if _update mutates state
        ictObs.valueHasMutated();
      }
    }
    updateProps[name] = value; 
    return updateProps;
  }
};

// init callback for managed attributes. When managing options like disabled, readOnly
// this method is required to return values.
oj.ValueBinding._init = function(name, value)
{
  var initProps = {};
      
  initProps[name] = value; 
  return initProps;
};

/**
 * Called after component binding creates the component. 
 * @param {string} property 
 * @param {Element} element the element to which binding applied the componnet
 * @param {Function=} component the widget bridge 
 * @param {Object=} valueAccessor 
 * @private
 */
oj.ValueBinding._afterCreate = function (property, element, component, valueAccessor)  
{
  var initProps = {}, optionsSet = valueAccessor.call(), isICTOptionSet;
  
  switch (property)
  {
    case oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER:

      isICTOptionSet = optionsSet[property] ? true : false;
      
      if (isICTOptionSet)
      {
        // register a writeback for invalidComponentTracker property by registering an event listener
        //  for the optionChange event.
        oj.ValueBinding._registerInvalidComponentTrackerWriteback(property, optionsSet, element, component);
      }
      break;
      
  }
  
  return initProps;
};

/**
 * Listener for the optionChange event, it updates the invalidComponentTracker associated to the 
 * component that triggered the event.
 * 
 * @param {jQuery.event=} event
 * @private
 */
oj.ValueBinding._updateInvalidComponentTracker = function(event)
{
  var ictObs = event.data.tracker, icTracker = ko.utils.unwrapObservable(ictObs), 
      component = event.data.component, payload = arguments[1], option = payload['option'], 
      msgs = payload['value'];
  
  if (option === oj.ValueBinding._OPTION_MESSAGES_SHOWN || 
          option === oj.ValueBinding._OPTION_MESSAGES_HIDDEN)
  {
    if (ko.isWriteableObservable(ictObs))
    {
      if (icTracker._update.call(icTracker, component, option, msgs))
      {
        // if _update mutates state
        ictObs.valueHasMutated();
      }
    }
  }
};

/**
 * Called right before component is destroyed.
 *  
 * @param {Element} element
 * @private
 */
oj.ValueBinding._beforeDestroy = function (element) 
{
  var jelem = $(element);
  if (jelem)
  {
    jelem.off(oj.ValueBinding._EVENT_OPTIONCHANGE, oj.ValueBinding._updateInvalidComponentTracker);
  }
};

/**
 * Register a default callback for the 'optionChange' event. The callback writes the component and 
 * its validity to the invalidComponentTracker observable.
 * @param {string} property
 * @param {Object} options original options set on element 
 * @param {Element} element
 * @param {Function=} component
 * @private
 */
oj.ValueBinding._registerInvalidComponentTrackerWriteback = function(property, options, element, component)
{
  var ictObs = options[property], messagesShown, messagesHidden, eventData,
      icTracker = ko.utils.unwrapObservable(ictObs), jElem = $(element);

  // Create new intsance of InvalidComponentTracker if the observable is not set.
  if (ko.isObservable(ictObs))
  {
    // push new instance of oj.InvalidComponentTracker onto observable if none present.
    if (icTracker == null) // null or undefined
    {
      icTracker = new oj.InvalidComponentTracker();
      ictObs(icTracker);
    }
  }
  else
  {
    // tracker object is not an observable. 
    throw new Error('Binding attribute ' + oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER + 
            ' should be bound to a ko observable.');
  }
  
  if (icTracker !== null)
  {
    // update icTracker inital state using component's latest option values
    if (ko.isWriteableObservable(ictObs))
    {
      messagesShown = component.call(component, "option", oj.ValueBinding._OPTION_MESSAGES_SHOWN);
      messagesHidden = component.call(component, "option", oj.ValueBinding._OPTION_MESSAGES_HIDDEN);
      
      icTracker._update.call(icTracker, component, 
                              oj.ValueBinding._OPTION_MESSAGES_SHOWN, messagesShown);
      icTracker._update.call(icTracker, component, 
                              oj.ValueBinding._OPTION_MESSAGES_HIDDEN, messagesHidden);
      ictObs.valueHasMutated();
    }
    
    // register listener for optionChange event for future changes to messages* options
    eventData = {tracker : ictObs, component: component};
    jElem.on(oj.ValueBinding._EVENT_OPTIONCHANGE, eventData, 
      oj.ValueBinding._updateInvalidComponentTracker);
  }
};

/**
 * editableValue Behavior Definition and Injection
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'editableValue',
  'attributes': [oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER, 
                 oj.ValueBinding._OPTION_DISABLED,
                  oj.ValueBinding._OPTION_READONLY],
  'init': oj.ValueBinding._init,
  'update': oj.ValueBinding._update,
  'afterCreate': oj.ValueBinding._afterCreate,
  'beforeDestroy': oj.ValueBinding._beforeDestroy
});

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.DataSource
 * @classdesc Object representing data used by table and grid components
 * @property {Object} data data supported by the components
 * @param {Object} data data supported by the components
 * @constructor
 */
oj.DataSource = function(data)
{
    this.data = data;
    this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DataSource, oj.Object, "oj.DataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.DataSource.prototype.Init = function()
{
    this._eventHandlers = [];
    oj.DataSource.superclass.Init.call(this);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.DataSource.prototype.on = function(eventType, eventHandler)
{
    var foundEventHandler = false, i;
    for (i = 0; i < this._eventHandlers.length; i++)
    {
        if (this._eventHandlers[i]['eventType'] == eventType && 
            this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
        {
            foundEventHandler = true;
            break;
        }
    }
    if (!foundEventHandler) {
        this._eventHandlers.push({'eventType': eventType, 'eventHandlerFunc': eventHandler});
    }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.DataSource.prototype.off = function(eventType, eventHandler)
{
    var i;
    for (i = this._eventHandlers.length-1; i >= 0; i--)
    {
        if (this._eventHandlers[i]['eventType'] == eventType && 
            this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
        {
            this._eventHandlers.splice(i, 1);
            break;
        }
    }
};

/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {Object} event  event
 * @export
 */
oj.DataSource.prototype.handleEvent = function(eventType, event)
{
    var i;
    for (i = 0; i < this._eventHandlers.length; i++)
    {
        var eventHandler = this._eventHandlers[i];
        if (eventHandler['eventType'] == eventType)
        {
            eventHandler['eventHandlerFunc'](event);
        }
    }
};

/**
 * Determines whether this DataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired. 
 * @return {string|null} the capability of the specified feature.  Returns null if the feature is not recognized.
 * @export
 */
oj.DataSource.prototype.getCapability = function(feature)
{
    return null;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * Base class for all tree structure DataSource
 * @param {Object} data data supported by the component
 * @export
 * @extends oj.DataSource
 * @constructor
 */
oj.TreeDataSource = function(data)
{
    oj.TreeDataSource.superclass.constructor.call(this, data);
};


// Subclass TreeDataSource to DataSource
oj.Object.createSubclass(oj.TreeDataSource, oj.DataSource, "oj.TreeDataSource");

/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {Object} parent the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 * @export
 */
oj.TreeDataSource.prototype.getChildCount = function(parent)
{
    return -1;
};

/**
 * Fetch the children
 * @param {Object} parent the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count.
 * @param {number} range.start the start index of the range in which the children are fetched.
 * @param {number} range.count the size of the range in which the children are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation.
 * @param {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain 
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching.
 * @export
 */
oj.TreeDataSource.prototype.fetchChildren = function(parent, range, callbacks, options)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {Object} parent the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation.
 * @param {number=} options.start the index related to parent in which to begin fetching descendants from.  If this is not specified, then 
 * @param {number=} options.maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count.
 * @export
 */
oj.TreeDataSource.prototype.fetchDescendants = function(parent, callbacks, options)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction
 * @param {Object} criteria.key the key identifying the attribute (column) to sort on
 *        {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @export
 */
oj.TreeDataSource.prototype.sort = function(criteria, callbacks)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Returns the current sort criteria of the tree data.
 * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
 *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
 *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 */
oj.TreeDataSource.prototype.getSortCriteria = function()
{
    return {'key': null, 'direction': 'none'};
};

/**
 * Moves a row from one location to another (different position within the same parent or a completely different parent)
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @export
 */ 
oj.TreeDataSource.prototype.move = function(rowToMove, referenceRow, position, callbacks)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Checks whether a move operation is valid.
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @export
 */ 
oj.TreeDataSource.prototype.moveOK = function(rowToMove, referenceRow, position)
{
    return "valid";
};

/**
 * Determines whether this TreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort", 
 *        "move", "fetchDescendants", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".  
 *         For "fetchDescendants", the valid return values are: "enable", "disable", "suboptimal".  
 *         For "move", the valid return values are: "default", "none".  
 *         For "batchFetch", the valid return values are: "enable", "disable".  
 * @export
 */
oj.TreeDataSource.prototype.getCapability = function(feature)
{
    return null;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
 /**
 * Base class for FlattenedTreeDataGridDataSource and FlattenedTreeTableDataSource
 * @param {Object} treeDataSource the instance of TreeDataSource to flattened
 * @param {Object=} options the options set on the FlattenedDataSource
 * @constructor
 * @export
 * @extends oj.DataSource
 */
oj.FlattenedTreeDataSource = function(treeDataSource, options)
{
    this.m_wrapped = treeDataSource;
    this.m_options = options;
    oj.FlattenedTreeDataSource.superclass.constructor.call(this);
};

// Make FlattenedTreeDataSource subclass of oj.DataSource
oj.Object.createSubclass(oj.FlattenedTreeDataSource, oj.DataSource, "oj.FlattenedTreeDataSource");

/**
 * Initializes the data source.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.Init = function()
{
    var expanded;

    // super
    oj.FlattenedTreeDataSource.superclass.Init.call(this);

    // we have to react if the underlying TreeDataSource has changed
    this.m_wrapped.on('change', this._handleModelEvent.bind(this));

    // retrieves the fetch size against the underlying data source
    this.m_fetchSize = parseInt(this.m_options['fetchSize'], 10);
    if (isNaN(this.m_fetchSize))
    {
        this.m_fetchSize = 25;
    }
    // retrieves the maximum number of rows to fetch from the underlying data source
    // once the maximum count has been reached, this data source should stop fetching
    // until either a collapse occurs or a delete model change event.
    this.m_maxCount = parseInt(this.m_options['maxCount'], 10);
    if (isNaN(this.m_maxCount))
    {
        this.m_maxCount = 500;
    }

    // retrieves the initial expanded row keys.  If the expanded is specified to 'all',
    // then mark that all rows should be expanded initially.
    expanded = this.m_options['expanded'];
    if (Array.isArray(expanded))
    {
        this.m_expandedKeys = expanded;
    }
    else
    {
        if (expanded === 'all')
        {
            // if expand all, we'll need to keep track of collapsed keys instead
            this.m_collapsedKeys = [];
        }
        // keep track of expanded row keys
        this.m_expandedKeys = [];
    }

    // cache to keep track of indexes
    // PRIVATE.  Subclass should never need to access this directly.
    // and implementation might change to use different form of caching strategy.
    this.m_cache = [];
};

/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {Object} event  event
 * @export
 */
oj.FlattenedTreeDataSource.prototype.handleEvent = function(eventType, event)
{
    oj.FlattenedTreeDataSource.superclass.handleEvent.call(this, eventType, event);
};

/**
 * Destroy the data source.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.Destroy = function()
{
    // free internal cache
    delete this.m_cache;
    delete this.m_expandedKeys;

    // unload listener
    this.m_wrapped.off('change');

    // delegate to underlying data source
    if (this.m_wrapped.Destory)
    {
        this.m_wrapped.Destory();
    }
};

/**
 * Retrieves the fetch size
 * @return {number} the fetch size
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getFetchSize = function()
{
    return this.m_fetchSize;
};

/**
 * Retrieves the max count
 * @return {number} the max count
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getMaxCount = function()
{
    return this.m_maxCount;
};

/**
 * Retrieves the expanded row keys
 * @return {Array.<Object>|string} an array of expanded row keys or 'all' if 
 *         all rows are expanded.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.getExpandedKeys = function()
{
    return this.m_expandedKeys;
};

/**
 * Retreives the value of the specified option.
 * @param {string} option the option to retrieve the value.
 * @return {Object} the value of the specified option.  Returns null if the
 *         value is null or if the option is not recognized.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.getOption = function(option)
{
    if (this.m_options != null)
    {
        return this.m_options[option];
    }

    // unrecoginzed option or no options set
    return null;
};

/**
 * Retrieves the underlying TreeDataSource.
 * @return {Object} the underlying oj.TreeDataSource.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.getWrappedDataSource = function()
{
    return this.m_wrapped;
};

/**
 * Determine the actual fetch size to use.
 * @param {number} count the child count of the parent node to fetch on.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getFetchSizeToUse = function(count)
{
    var fetchSize, maxCount;

    fetchSize = this.getFetchSize();
    maxCount = this.getMaxCount();

    if (fetchSize === -1)
    {
        if (count === -1)
        {
            return maxCount;
        }
        return count;
    }
    else
    {
        if (count === -1)
        {
            return Math.min(fetchSize, count);
        }
        return fetchSize;
    } 
};

/**
 * Fetch a range of rows from the underlying data source.  This is a convenient method that
 * the subclasses should use to fetch from the underlying TreeDataSource.  This method will take
 * care of the index mapping between a flattened range to tree indexes.
 * @param {Object} range the range of rows to fetch.  This is the range in a flattened view.
 * @param {number} range.start the start of the range in a flattened view
 * @param {number} range.count the number of rows to fetch
 * @protected
 */ 
oj.FlattenedTreeDataSource.prototype.fetchRows = function(range, callbacks)
{
    // check if we should fetch rows from descendants result set or walk the tree
    // to retrieve children
    if (this._isExpandAll())
    {
        this._fetchRowsFromDescendants(range, callbacks);
    }
    else
    {
        this._fetchRowsFromChildren(range, callbacks);
    }
};

/**
 * Fetch a range of rows from the underlying TreeDataSource.  
 * @param {Object} range the range of rows to fetch.  This is the range in a flattened view.
 * @param {number} range.start the start of the range in a flattened view
 * @param {number} range.count the number of rows to fetch
 * @protected
 */ 
oj.FlattenedTreeDataSource.prototype._fetchRowsFromChildren = function(range, callbacks)
{
    var maxFetchSize, lastEntry, parent, count, index, depth, processed, nodeSet, fetchSize;

    // this condition should always be true since in high watermark scrolling we are
    // always asking for rows after the current last row
    if (range['start'] > this._getLastIndex())
    {
        maxFetchSize = this._getMaxFetchSize();
        // initial fetch
        if (this._getLastIndex() < 0)
        {
            // adjust fetch count if neccessary
            range['count'] = Math.min(maxFetchSize, range['count']);
            this.m_wrapped.fetchChildren(null, range, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, null, 0, range, 0, callbacks);}.bind(this)});

            return;
        }
        else if (maxFetchSize > 0)
        {
            lastEntry = this._getLastEntry();
            parent = lastEntry['parent'];
            count = this.m_wrapped.getChildCount(parent);
            index = lastEntry['index'];
            depth = lastEntry['depth'];

            // see if we are fetching within the parent
            if (count === -1 || index < count-1)
            {
                fetchSize = this._getFetchSizeToUse(count);
                range['start'] = index+1;
                if (count === -1)
                {
                    range['count'] = fetchSize;
                }
                else
                {
                    range['count'] = Math.min(maxFetchSize, Math.min(fetchSize, count - range['start']));
                }
                this.m_wrapped.fetchChildren(parent, range, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, parent, depth, range, count, callbacks);}.bind(this)});
            }
            else if (index === count-1)
            {
                // if this is the last child within the parent, then we are done
                nodeSet = new oj.EmptyNodeSet(null, range['start']);
                // invoke original success callback
                if (callbacks != null && callbacks['success'] != null)
                {
                    callbacks['success'].call(null, nodeSet);
                }
            }
            else
            {
                // fetch size is greater than the number of children remaining to fetch
                // so we'll need to go up the path (recursively if necessary) and see if
                // if we need to fetch from ancestors.
                processed = this._fetchFromAncestors(parent, depth, callbacks, maxFetchSize);
                if (!processed)
                {
                    // nothing is used from node set, just return a empty node set
                    nodeSet = new oj.EmptyNodeSet(null, range['start']);
                    // invoke original success callback
                    if (callbacks != null && callbacks['success'] != null)
                    {
                        callbacks['success'].call(null, nodeSet);
                    }
                }
            }
            return;
        }
    }

    // the only case we'll ended up here is if the max count has been reached or
    // for some reason the caller is asking for count = 0
    this.handleMaxCountReached(range, callbacks);
};

/**
 * Determine the maximum possible fetch size.
 * @return {number} the maximum fetch size
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getMaxFetchSize = function()
{
    return this.getMaxCount() - (this._getLastIndex()+1);
};

/**
 * Process success callback for fetchChildren operation before handing it back to original caller.
 * @param {Object} nodeSet the set of fetched nodes
 * @param {Object} parent the parent key of the fetch operation
 * @param {number} depth the depth of the nodes
 * @param {Object} range the request range for the fetch operation
 * @param {number} count the child count of the parent, -1 if count is unknown
 * @param {Object} callbacks the original callbacks passed to the fetch operation
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleFetchSuccess = function(nodeSet, parent, depth, range, count, callbacks)
{
    var toExpand, processed;

    // handle result nodeSet
    toExpand = [];
    // wrap it to inject additional metadata
    nodeSet = new oj.NodeSetWrapper(nodeSet, this.insertMetadata.bind(this), range);
    this._processNodeSet(nodeSet, parent, depth, toExpand);

    // if child count is unknown and the result fetched from parent is less than what we asked for 
    // and it's not a root node, go up one level and try to fetch results from its grandparent
    if (count === -1 && nodeSet.getCount() === 0 && parent != null && depth > 0)
    {
        processed = this._fetchFromAncestors(parent, depth, callbacks);
        if (!processed)
        {
            // if nothing is fetched from ancestors, then just return the original empty set
            if (callbacks != null && callbacks['success'] != null)
            {
                callbacks['success'].call(null, nodeSet);
            }
        }
    }
    else
    {
        // invoke original success callback
        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(null, nodeSet);
        }

        // see if there's rows that need to be expand
        this._expandRows(toExpand);
    }
};

/**
 * Go up ancestors and fetch build up fetch requests (if possible) until the fetch size is met.
 * @param {Object} parent the parent key of the fetch operation
 * @param {number} depth the depth of the nodes
 * @param {Object} callbacks the original callbacks passed to the fetch operation
 * @param {number=} maxFetchSize maximum fetch size, optional
 * @return {boolean} true if results are fetched, false if nothing is fetched
 * @private
 */
oj.FlattenedTreeDataSource.prototype._fetchFromAncestors = function(parent, depth, callbacks, maxFetchSize)
{
    var options, remainToFetch, current, i, currEntry, currDepth, count, index, countUnknown, range, fetchSize;

    if (maxFetchSize === undefined)
    {
        maxFetchSize = this._getMaxFetchSize();
    }

    // fetch size is greater than the number of children remaining to fetch
    // so we'll need to go up the path (recursively if necessary) and see if
    // if we need to fetch from ancestors.
    if (this._isBatchFetching())
    {
        options = {'queueOnly': true};
    }

    fetchSize = this._getFetchSizeToUse(-1);
    remainToFetch = fetchSize;
    current = this._getLastIndex();
    for (i=current-1; i>=0; i--)
    {
        currEntry = this._getEntry(i);
        currDepth = currEntry['depth'];
        if (currDepth < depth)
        {
            parent = currEntry['parent'];
            count = this.m_wrapped.getChildCount(parent);
            index = currEntry['index'];

            countUnknown = (count === -1);
            if (countUnknown || index < count-1)
            {
                range = {};
                range['start'] = index+1;
                if (countUnknown)
                {
                    range['count'] = Math.min(maxFetchSize, Math.max(0, remainToFetch));
                    // if count is unknown, we cannot do batch fetch
                    options = undefined;
                    // stop going up parents
                }
                else
                {
                    range['count'] = Math.min(maxFetchSize, Math.min(remainToFetch, count - range['start']));
                }

                // if there's nothing to fetch, quit
                if (range['count'] == 0)
                {
                    break;
                }
                
                // it's always attached at the end
                this.m_wrapped.fetchChildren(parent, range, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, parent, currDepth, range, count, callbacks);}.bind(this)}, options);

                // go up one level
                depth = currDepth;
                // update remaining fetch count
                remainToFetch = Math.max(0, remainToFetch - range['count']);

                // done if count is unknown or we've reach the root or we've reach total number of rows we want to fetch
                if (countUnknown || currDepth === 0 || remainToFetch === 0)                
                {
                    break;
                }
            }
        }
    }            

    // if batching is used, fire a final fetch children call to flush the queue
    if (options != undefined)
    {
        this.m_wrapped.fetchChildren(parent, {'start': range['count'], 'count': 0}, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, parent, currDepth, range, count, callbacks);}.bind(this)});
    }

    // return false if no results are fetched
    return (remainToFetch != fetchSize);
};

/**
 * Walk the node set and do whatever processing is neccessary.
 * @param {Object} nodeSet the node set to process
 * @param {Object} parent the parent key of the nodes
 * @param {number} depth the depth of the nodes
 * @param {Array.<Object>=} toExpand the set of keys to be expand.  It is populated by this method.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._processNodeSet = function(nodeSet, parent, depth, toExpand)
{
    var nodeStart, nodeCount, i, metadata, key;

    nodeStart = nodeSet.getStart();
    nodeCount = nodeSet.getCount();

    // walk the node set and populate the internal cache
    for (i=0; i<nodeCount; i++)
    {
        metadata = nodeSet.getMetadata(nodeStart+i);
        key = metadata['key'];

        this._addEntry(key, depth, nodeStart+i, parent);

        if (this._isExpanded(key))
        {
            // keep track of rows that needs to expand later
            toExpand.push(key);
        }
    }
};

/**
 * A hook for FlattenedTreeDataSource to inject additional metadata into the NodeSet
 * @param {Object} key the row key identifying the row
 * @param {Object} metadata the existing metadata to inject into
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.insertMetadata = function(key, metadata)
{
    if (this._isExpanded(key) && !metadata['leaf'])
    {
        // also update metadata with state info
        metadata['state'] = 'expanded';
    }
    else
    {
        // include state metadata for row expander to render correct icon
        if (metadata['leaf'])
        {
            metadata['state'] = 'leaf';
        }
        else
        {
            metadata['state'] = 'collapsed';
        }
    }
};

/**
 * Fetch a range of rows from the underlying TreeDataSource using the fetchDescendants method.
 * @param {Object} range the range of rows to fetch.  This is the range in a flattened view.
 * @param {number} range.start the start of the range in a flattened view
 * @param {number} range.count the number of rows to fetch
 * @protected
 */ 
oj.FlattenedTreeDataSource.prototype._fetchRowsFromDescendants = function(range, callbacks)
{
    // give implementation a hint of maximum to fetch, implementation can choose to ignore it
    var options = {'maxCount': this.getMaxCount()};

    // give implementation a hint of where to start, implementation can choose to ignore it
    if (this._getLastIndex() >= 0)
    {
        options['start'] = this._getEntry(this._getLastIndex())['key'];
    }

    // invoke method on TreeDataSource
    this.m_wrapped.fetchDescendants(null, {"success": function(nodeSet){this._handleFetchDescendantsSuccess(nodeSet, range, callbacks);}.bind(this)}, options);
};

/**
 * Process success callback for fetchDescendants operation before handing it back to original caller.
 * @param {Object} nodeSet the set of fetched nodes
 * @param {Object} range the request range for the fetch operation
 * @param {Object} callbacks the original callbacks passed to the fetch operation
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleFetchDescendantsSuccess = function(nodeSet, range, callbacks)
{
    var maxFetchSize, count, lastEntry, options, actualStart;

    // this condition should always be true since in high watermark scrolling we are
    // always asking for rows after the current last row
    if (range['start'] > this._getLastIndex())
    {
        maxFetchSize = this._getMaxFetchSize();
        count = Math.min(maxFetchSize, range['count']);

        // wrap it to inject additional metadata
        nodeSet = new oj.NodeSetWrapper(nodeSet, this.insertMetadata.bind(this));

        if (this._getLastIndex() >= 0)
        {
            // in fetchDescendants case, the result node set would probably contains more than what
            // we would return.  The issue is we can't really use range to filter the set since the 
            // range in the current view does not map one-to-one to the expand all node set as some 
            // node might have been collapsed before the fetch.
            // the solution is to use the last cached entry to find where new data starts in the
            // result node set, and use range count to limit what to return
            lastEntry = this._getLastEntry();
            options = {'index': 0, 'found': false, 'count': 0};
            this._processDescendantsNodeSet(nodeSet, null, 0, lastEntry, count, options);
            actualStart = options['index'] + 1;
        }
        else
        {
            // initial fetch case, just specify the count to limit result
            options = {'count': 0};
            this._processDescendantsNodeSet(nodeSet, null, 0, null, count, options);
            actualStart = 0;
        }

        if (callbacks != null && callbacks['success'] != null)
        {
            if (options != null)
            {
                if (options['count'] === 0)
                {
                    // nothing is used from node set, just return a empty node set
                    nodeSet = new oj.EmptyNodeSet(null, range['start']);
                }
                else 
                {
                    // wraps node set with a filter that only returns nodes that
                    // have not been fetched already
                    nodeSet = new oj.FlattenedNodeSet(nodeSet, actualStart);
                }
            }
            else
            {
                nodeSet = new oj.FlattenedNodeSet(nodeSet);
            }
            callbacks['success'].call(null, nodeSet);
        }

        return;
    }

    // the only case we'll ended up here is if the max count has been reached or
    // for some reason the caller is asking for count = 0
    this.handleMaxCountReached(range, callbacks);
};

/**
 * Walk the node set and do whatever processing is neccessary.
 * @param {Object} nodeSet the node set to process
 * @param {Object} parent the parent key of the nodes
 * @param {number} depth the depth of the nodes
 * @param {Object} lastEntry the last fetched entry
 * @param {number} maxCount the maximum number of rows to process
 * @param {Object=} options this object carries information collected in this method
 * @private
 */
oj.FlattenedTreeDataSource.prototype._processDescendantsNodeSet = function(nodeSet, parent, depth, lastEntry, maxCount, options)
{
    var nodeStart, nodeCount, i, metadata, key, childNodeSet;

    nodeStart = nodeSet.getStart();
    nodeCount = nodeSet.getCount();

    // walk the node set and populate the internal cache
    for (i=0; i<nodeCount; i++)
    {
        // see if we have enough results
        if (options['count'] == maxCount)
        {
            return;
        }

        metadata = nodeSet.getMetadata(nodeStart+i);
        key = metadata['key'];

        // see if we need to check depth
        if (options['checkDepth'])
        {
            if (lastEntry['depth'] === depth)
            {
                options['found'] = true;
                options['checkDepth'] = false;
            }
        }

        if (lastEntry == null || options['found'])
        {
            this._addEntry(key, depth, nodeStart+i, parent);

            options['count'] = options['count'] + 1;

            // include state metadata for row expander
            // in the fetchDescendants case the state is always 'expanded'
            if (metadata['leaf'])
            {
                metadata['state'] = 'leaf';
            }
            else
            {
                metadata['state'] = 'expanded';
            }
        }

        // mark we found the entry in node set that matches the last key
        // the rest of node set we can start pushing to cache
        if (lastEntry != null && !options['found'])
        {
            // we'll need to also check whether the last entry is expanded (or not leaf)
            // if it is collapsed, then we can't add any nodes from the node set until
            // we found child in the node set that has the same depth
            if (key === lastEntry['key'])
            {
                if (metadata['leaf'] || this._isExpanded(key))
                {
                    options['found'] = true;
                }
                else
                {
                    // collapsed.  Mark to check the depth of the next node before
                    // setting found to true.
                    options['checkDepth'] = true;
                }
            }
            else
            {
                options['index'] = options['index'] + 1;
            }
        }

        // process child node set, if any
        if (nodeSet.getChildNodeSet)
        {
            childNodeSet = nodeSet.getChildNodeSet(i);
            if (childNodeSet != null)
            {
                this._processDescendantsNodeSet(childNodeSet, key, depth+1, lastEntry, maxCount, options);
            }
        }
    }
};

/**
 * Expand the specified row.
 * @param {Object} rowKey the key of the row to expand
 * @export
 */
oj.FlattenedTreeDataSource.prototype.expand = function(rowKey)
{
    this._expand(rowKey);
};

/**
 * Expand the specified row with options
 * @param {Object} rowKey the key of the row to expand
 * @param {Object=} options additional options to pass to fetchChildren method
 * @private
 */
oj.FlattenedTreeDataSource.prototype._expand = function(rowKey, options)
{
    var count, fetchSize, maxCount, refIndex, queue, prevNodeSetInfo;

    count = this.m_wrapped.getChildCount(rowKey);
    fetchSize = this._getFetchSizeToUse(count);
    maxCount = this.getMaxCount();

    // if cache is full, check if the rowKey is the last row, if it's
    // the last row do nothing
    if (this._getLastIndex()+1 === maxCount)
    {
       refIndex = this.getIndex(rowKey);
       if (refIndex == maxCount-1)
       {
           // we'll still have to return an empty nodeset to trigger done to occur in handleExpandSuccess
           this.handleExpandSuccess(rowKey, new oj.EmptyNodeSet(rowKey, 0), 0, options);
           return;
       }
    }

    // nothing to do
    if (fetchSize == 0)
    {
        // we'll still have to return an empty nodeset to trigger done to occur in handleExpandSuccess
        this.handleExpandSuccess(rowKey, new oj.EmptyNodeSet(rowKey, 0), 0, options);
        return;
    }

    this.m_wrapped.fetchChildren(rowKey, {"start": 0, "count": fetchSize}, {"success": function(nodeSet){this.handleExpandSuccess(rowKey, nodeSet, count, options);}.bind(this)});
};

/**
 * Collapse the specified row.
 * @param {Object} rowKey the key of the row to collapse
 * @export
 */
oj.FlattenedTreeDataSource.prototype.collapse = function(rowKey)
{
    var rowIndex, parent, count, depth, lastIndex, i, j, keys;

    rowIndex = this.getIndex(rowKey) + 1;
    parent = this._getEntry(rowIndex-1);

    // keeping track of how many rows to remove
    count = 0;

    depth = parent['depth'];
    lastIndex = this._getLastIndex();
    for (j=rowIndex; j<lastIndex+1; j++)
    {
        var rowData = this._getEntry(j);
        var rowDepth = rowData['depth'];
        if (rowDepth > depth)
        {
            count = count + 1;
        }
        else if (rowDepth == depth)
        {
            break;
        }
    }

    // nothing to do
    if (count == 0)
    {
        return;
    }

    // remove from expanded keys or add to collapsed keys
    if (this._isExpandAll())
    {
        this.m_collapsedKeys.push(rowKey);
    }
    else
    {
        this._removeExpanded(rowKey);
    }

    // remove rows from view
    keys = [];
    for (i=0; i<count; i++)
    {
        keys.push({"key": this._getEntry(rowIndex+i)['key'], "index":rowIndex+i});
    }

    // remove from cache.  Note this has to be done before firing row remove event
    // since it could cause a fetch which relies on the internal cache being up to date.
    this._removeEntry(rowIndex, count);    

    // (firing of event to view)
    this.removeRows(keys);

    // fire datasource event
    this.handleEvent("collapse", {'rowKey':rowKey});
};

/**
 * Checks whether the row key is expanded.
 * @param {Object} rowKey the key of the row to inquire the state
 * @return {boolean} true if the row is/should be expanded.  False otherwise.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._isExpanded = function(rowKey)
{
    if (this._isExpandAll())
    {
        if (this.m_collapsedKeys && this.m_collapsedKeys.length > 0)
        {
            // call helper method to check collapsed keys
            return (this._getCollapsedKeyIndex(rowKey) === -1);
        }
        else
        {
            // everything expanded
            return true;
        }
    }
    else
    {
        if (this.m_expandedKeys && this.m_expandedKeys.length > 0)
        {
            // call helper method to check expanded keys
            return (this._getExpandedKeyIndex(rowKey) > -1);
        }
        else
        {
            // nothing expanded
            return false;
        }
    }
};

/**
 * Helper method to retrieve the index of the row key in the set of collapsed row keys
 * @param {Object} rowKey the key of the row
 * @return {number} the index of the key in the collapsed key array
 * @private
 */ 
oj.FlattenedTreeDataSource.prototype._getCollapsedKeyIndex = function(rowKey)
{
    return this._getKeyIndex(this.m_collapsedKeys, rowKey);
};

/**
 * Helper method to retrieve the index of the row key in the set of expanded row keys
 * @param {Object} rowKey the key of the row
 * @return {number} the index of the key in the expanded key array
 * @private
 */ 
oj.FlattenedTreeDataSource.prototype._getExpandedKeyIndex = function(rowKey)
{
    return this._getKeyIndex(this.m_expandedKeys, rowKey);
};

/**
 * Helper method to retrieve the index of the row key in a specified array
 * @param {Object} rowKey the key of the row
 * @return {number} the index of the key in the array
 * @private
 */ 
oj.FlattenedTreeDataSource.prototype._getKeyIndex = function(arr, rowKey)
{
    var i, index;

    index = -1;
    for (i=0; i<arr.length; i++)
    {
        if (arr[i] === rowKey)
        {
            index = i;
        }
    }

    return index;
}

/**
 * Remove the row key from the expanded cache
 * @param {Object} rowKey the key to remove
 * @private
 */
oj.FlattenedTreeDataSource.prototype._removeExpanded = function(rowKey)
{
    var index = this._getExpandedKeyIndex(rowKey);

    // index found, remove from array
    if (index > -1)
    {
        this.m_expandedKeys.splice(index, 1);    
    }
};

/**
 * Remove the row key from the collapsed cache
 * @param {Object} rowKey the key to remove
 * @private
 */
oj.FlattenedTreeDataSource.prototype._removeCollapsed = function(rowKey)
{
    var index = this._getCollapsedKeyIndex(rowKey);

    // index found, remove from array
    if (index > -1)
    {
        this.m_collapsedKeys.splice(index, 1);    
    }
};

/**
 * Callback method to handle fetch success on expand operation.
 * @param {Object} rowKey the key of the expanded row
 * @param {Object} nodeSet the node set that describes the children of the expanded row
 * @param {number} childCount the total number of children the expanded row has
 * @param {Object=} options optional parameters to the method
 * @param {Object=} options.queue a queue of expanded rows remaining to process (depth first traversal)
 * @param {Object=} options.prevNodeSetInfo.nodeSet the node set from a previous expand call
 * @param {number=} options.prevNodeSetInfo.firstIndex the ref index for the FIRST expand call, this is needed when firing the insert event, where the insertion point is the first index
 * @param {Object=} options.prevNodeSetInfo.firstKey the ref row key for the FIRST expand call, this is needed when firing the insert event, where the insertion point is the first row key
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.handleExpandSuccess = function(rowKey, nodeSet, childCount, options)
{
    var refIndex, rangeStart, rowStart, rowCount, parent, depth, metadata, key, toExpand, i, j, queue, prevNodeSetInfo, done, maxCount;

    // wrap it to inject additional metadata
    nodeSet = new oj.NodeSetWrapper(nodeSet, this.insertMetadata.bind(this));

    refIndex = this.getIndex(rowKey) + 1;
    rangeStart = refIndex;

    rowStart = nodeSet.getStart();
    rowCount = nodeSet.getCount();

    parent = this._getEntry(refIndex-1);
    depth = parent['depth']+1;

    toExpand = [];

    // go through the node set and insert an entry with info about the row into internal cache
    for (i=rowStart; i<rowCount; i++)
    {
        metadata = nodeSet.getMetadata(i);
        key = metadata['key'];
        if (this._isExpanded(key))
        {
            // expand it if the user specified it to be expand (or the
            // parent was previously collapsed before and now expanded again, 
            // the expanded child would need to be expanded also)
            toExpand.push(key);
        }

        // add to cache
        this._insertRow(refIndex, metadata, parent['key'], i, depth);

        refIndex++;
    }

    // keep track of expanded row or collapsed row for expand all case
    if (this._isExpandAll())
    {
        this._removeCollapsed(rowKey);
    }
    else
    {
        // check whether it's already in expanded keys, which is the case
        // if it is expanded by initial expansion
        if (this.m_expandedKeys.indexOf(rowKey) === -1)
        {
            this.m_expandedKeys.push(rowKey);
        }
    }

    // extract optional params
    if (options != undefined)
    {
        queue = options['queue'];
        prevNodeSetInfo = options['prevNodeSetInfo'];
    }

    // see if a previous nodeset has been set and merge with current one 
    // so that we have one nodeset that includes expanded children, a single row insert event
    // is fired and the nodeset will be in the proper order
    if (prevNodeSetInfo != undefined)
    {
        nodeSet = new oj.MergedNodeSet(prevNodeSetInfo['nodeSet'], nodeSet, rowKey);
    }

    // check if there's nothing else to expand and process queue is empty
    done = (toExpand.length == 0 && (queue === undefined || queue.length == 0));
    if (done)
    {
        // fire event to insert the expanded rows
        if (prevNodeSetInfo != undefined)
        {
            // use the reference insertion point from prevNodeSetInfo instead
            this.insertRows(prevNodeSetInfo['firstIndex'], prevNodeSetInfo['firstKey'], nodeSet);
        }
        else
        {
            this.insertRows(rangeStart, rowKey, nodeSet);
        }

        // if child count is > fetched or child count is unknown and requested fetch count is the same as result set size, 
        // then delete all rows that comes after the reference row so that we can trigger a fetch when user scroll to the end
        // ALSO delete all rows that comes after reference row if the reference row is the last row (according to max row count)
        maxCount = this.getMaxCount();
        if ((childCount === -1 && rowCount === this.getFetchSize()) || childCount > rowCount || refIndex == maxCount)
        {
            this._deleteAllRowsBelow(refIndex);
        }
        else if (this._getLastIndex() >= maxCount)
        {
            // also clean up rows that goes beyond max row count after expand
            this._deleteAllRowsBelow(maxCount);
        }

        if (prevNodeSetInfo != undefined)
        {
            // fire expand event for each row key cached in prevNodeSetInfo
            for (j=0; j<prevNodeSetInfo['keys'].length; j++)
            {
                this.handleEvent("expand", {'rowKey':prevNodeSetInfo['keys'][j]});
            }
        }

        // fire event
        this.handleEvent("expand", {'rowKey':rowKey});
    }
    else
    {
        // there are still child rows to expand
        // create queue if not yet created
        if (queue === undefined)
        {
            queue = [];
        }

        // push expanded rows to the queue
        if (toExpand.length > 0)
        {
            queue.push(toExpand);
        }

        // create prevNodeSetInfo if not yet created
        if (prevNodeSetInfo === undefined)
        {
            prevNodeSetInfo = {};
            // populate the initial insertion index and key, this is needed when we are actually firing
            // the insert event
            prevNodeSetInfo['firstIndex'] = rangeStart;
            prevNodeSetInfo['firstKey'] = rowKey;
            // cache of row keys for firing expand event when everything is done
            prevNodeSetInfo['keys'] = [];
        }

        // update the previous node set 
        prevNodeSetInfo['nodeSet'] = nodeSet;
        // update keys array for fire expand events later
        prevNodeSetInfo['keys'].push(rowKey);

        // expand any child rows that should be expanded
        this._syncExpandRows(queue, prevNodeSetInfo);
    }
};

/**
 * Expands the specified array of rows synchronously, i.e. one will not start until the previous one is finished.
 * @param {Object} queue the queue of a set of expanded row keys remaining to process 
 * @param {Object} prevNodeSetInfo node set from the previous expand call
 * @private 
 */ 
oj.FlattenedTreeDataSource.prototype._syncExpandRows = function(queue, prevNodeSetInfo)
{
    var last, key, options;

    // peek the last set of expanded rows from queue (since we are doing depth first traversal)
    last = queue[queue.length-1];    
    // then take the first row key from the set
    key = last.shift();
    // if this is the last item in the set, we can remove the set from queue
    if (last.length === 0)
    {
        queue.pop();
    }

    this._expand(key, {'prevNodeSetInfo': prevNodeSetInfo, 'queue': queue});    
};

/**
 * Expands the specified array of rows.  Use batch fetching if supported.
 * @param {Array.<Object>} keys an array of row keys.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._expandRows = function(keys)
{
    var options, i;

    // use batch fetching if supported so we'll have less trip to server.
    if (this._isBatchFetching())
    {
        options = {'queueOnly': true};
    }

    // expand each of the rows
    for (i=0; i<keys.length; i++)
    {
        // last expand should not have any options set to flush to batch queue
        if (i == keys.length-1)
        {
            this._expand(keys[i]);
        }            
        else
        {
            this._expand(keys[i], options);
        }            
    }
};

/**
 * Insert a single row of data into the cache
 * @param {number} index the index (based on flattened view) where this is inserted
 * @param {Object} metadata the metadata of the inserted node
 * @param {Object} parentKey the key of the parent node
 * @param {number} childIndex the index relative to its parent where this is inserted
 * @param {number} depth the depth of the node
 * @private
 */
oj.FlattenedTreeDataSource.prototype._insertRow = function(index, metadata, parentKey, childIndex, depth)
{
    var key, rowData;

    key = metadata['key'];

    if (index <= this._getLastIndex())    
    {
        this._addEntry(key, depth, childIndex, parentKey, index);
    }
    else
    {
        this._addEntry(key, depth, childIndex, parentKey);
    }
};

/**
 * Remove all rows below the row of the specified index including this row.
 * @param {number} index the index from which we start to delete rows 
 * @param {number=} count the number of rows to delete.  If not specified, then delete until the end.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._deleteAllRowsBelow = function(index, count)
{
    var keys, event;

    if (count == undefined)
    {
        count = this._getLastIndex()+1 - index;
    }

    keys = [];
    for (var i=0; i<count; i++)
    {
        keys.push({"row": this._getEntry(index+i)['key'], "index":index+i});
    }

    // update internal cache
    this._removeEntry(index, count);    

    // fire event to remove rows from view
    this.removeRows(keys);
};

/**
 * Handles model event from underlying TreeDataSource.
 * @param {Event} event the model change event
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleModelEvent = function(event)
{
    var operation, ancestors, parentKey, index;

    operation = event['operation'];
    ancestors = event['parent'];
    if (Array.isArray(ancestors))
    {
        // take the direct key of direct parent
        parentKey = ancestors[ancestors.length-1];
    }
    else
    {
        // single element or null, value is the parent key
        parentKey = ancestors;
    }
    index = event['index'];

    if (operation === 'insert')
    {
        this._handleInsertEvent(parentKey, index, event['data']);
    }
    else if (operation === 'delete')
    {
        this._handleDeleteEvent(parentKey, index);
    }
    else if (operation === 'refresh')
    {
        this._handleRefreshEvent(parentKey);
    }
};

/**
 * Handles insert event from TreeDataSource.
 * @param {Object} parentKey the key of the parent where the node is inserted
 * @param {number} index the index relative to its parent where the noce is inserted
 * @param {Object} nodeSet the node set containing the single insert data
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleInsertEvent = function(parentKey, index, nodeSet)
{
    var parentIndex, parent, depth, insertIndex, metadata;

    parentIndex = this.getIndex(parentKey);
    parent = this._getEntry(parentIndex);
    depth = parent['depth']+1;
    insertIndex = parentIndex + index + 1;

    // there should only be one row in the set
    metadata = nodeSet.getMetadata(nodeSet.getStart());

    // insert into cache
    this._insertRow(insertIndex, metadata, parentKey, index, depth)    
};

/**
 * Handles delete event from TreeDataSource.
 * @param {Object} parentKey the key of the parent where the node is inserted
 * @param {number} index the index relative to its parent where the noce is inserted
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleDeleteEvent = function(parentKey, index)
{
    var parentIndex, parent, startIndex, start, count, currentIndex, lastIndex, current;

    parentIndex = this.getIndex(parentKey);
    parent = this._getEntry(parentIndex);

    startIndex = parentIndex + index;
    start = this._getEntry(startIndex);

    // make sure the child data is valid
    oj.Assert.assert(start['parent'] === parent && start['depth'] === parent['depth']+1); 

    // remove the entry and all of its children from cache
    count = 1;
    currentIndex = startIndex + 1;
    lastIndex = this._getLastIndex();
    while (currentIndex <= lastIndex)
    {
        current = this._getEntry(currentIndex);
        // check if we have reached the last child of the deleted node
        if (current['depth'] != start['depth'])
        {
            break;
        }      
        currentIndex++;
    }

    // remove rows
    this._deleteAllRowsBelow(startIndex, count);
};

/**
 * Handles refresh event from TreeDataSource.
 * @param {Object} parentKey the key of the parent where the node is inserted
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleRefreshEvent = function(parentKey)
{
    if (parentKey == null)
    {
        // the entire tree is refreshed
        // clean up internal cache
        this.refresh();
    }
};

/**
 * Checks whether all rows should be expanded.
 * @return {boolean} true if expand all rows, false otherwise.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._isExpandAll = function()
{
    var capability = this.m_wrapped.getCapability('fetchDescendants');
    return (this.m_collapsedKeys != undefined && capability != null && capability != 'disable');
};

/**
 * Checks whether batch fetching is supported.
 * @return {boolean} true if batch fetching is supported, false otherwise.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._isBatchFetching = function()
{
    var capability = this.m_wrapped.getCapability('batchFetch');
    return (capability === 'enable');
};

/////////////////////////////// helper methods subclass should find useful //////////////////////////////////////////////
/**
 * Refresh the data source.  Clear out any state.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.refresh = function()
{
    // clear the cache
    this._clearAll();

    // todo: more work here to force fetch (remove then insert)
};

/**
 * Determine the flattened index for the specified key
 * @param {Object} rowKey the key to find the index
 * @return {number} the index representing the specified key.  Returns -1 if the index
 *         cannot be found.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getIndex = function(rowKey)
{
    var lastIndex, i, rowData;

    lastIndex = this._getLastIndex();
    for (i=0; i<=lastIndex; i++)
    {
        rowData = this._getEntry(i);
        if (rowData['key'] == rowKey)
        {
            return i;
        }
    }

    // can't find it, return -1
    return -1;
};

/**
 * Determines the key for the specified flattened index
 * @param {number} index the index in flattened view
 * @return {Object|null} the key for the specified index.  Returns null if the index has not been
 *         fetched yet or is invalid.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getKey = function(index)
{
    // ensure the index is valid and in range
    if (index < 0 || index > this._getLastIndex())
    {
        return null;
    }

    // just return from internal cache
    return this._getEntry(index)['key'];
};

/**
 * Returns the currently fetched range.
 * @return {Object} the fetched range (start, end).
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getFetchedRange = function()
{
    return {'start': 0, 'end': this._getLastIndex()+1};
};

///////////////////////////////////// methods subclass must override ////////////////////////////////////////////////////////
/**
 * Handles what happened when the maximum row count has been reached.
 * @param {Object} range the range of the fetch request which caused the max count to be reached.
 * @param {Object} callbacks the callbacks of the fetch request which caused the max count to be reached.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.handleMaxCountReached = function(range, callbacks)
{
    // send an error by default
    if (callbacks != null && callbacks['error'] != null)
    {
        callbacks['error'].call(null);
    }
};

/**
 * Abstract method to insert a set of rows into the DataGrid/Table
 * @param {number} insertAtIndex the flattened index of the node where the rows are inserted.
 * @param {Object} insertAtKey the key of the node where the rows are inserted (the parent key)
 * @param {Object} nodeSet the node set containing data/metadata of inserted rows
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.insertRows = function(insertAtIndex, insertAtKey, nodeSet)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Abstract method to remove the specified rows in the DataGrid/Table
 * @param {Array.<Object>} rowKeys an array of keys of the rows to be remove.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.removeRows = function(rowKeys)
{
    oj.Assert.failedInAbstractFunction();
};

///////////////////////////////// methods that manipulates the internal cache ///////////////////////////////////
/**
 * Retrieve the flattened index of the last entry fetched so far
 * @return {number} the flattened index of the last entry
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getLastIndex = function()
{
    return this.m_cache.length-1;
};

/**
 * Retrieve the metadata for the last entry fetched so far
 * @return {Object} the metadata for the last entry
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getLastEntry = function()
{
    return this.m_cache[this._getLastIndex()];
};

/**
 * Retrieve metadata info for the specified index.
 * @param {number} index the flattened index 
 * @return {Object} the metadata info
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getEntry = function(index)
{
    return this.m_cache[index];
};

/**
 * Add or insert entry to the cache
 * @param {Object} key the key
 * @param {number} depth the depth 
 * @param {number} index the index relative to its parent
 * @param {Object} parent the parent
 * @param {number=} insertAt insert the metadata entry at this flattened index
 * @private
 */
oj.FlattenedTreeDataSource.prototype._addEntry = function(key, depth, index, parent, insertAt)
{
    var rowData = new Object();
    rowData['key'] = key;
    rowData['depth'] = depth;
    rowData['index'] = index;
    rowData['parent'] = parent;

    if (insertAt === undefined)
    {
        this.m_cache.push(rowData);
    }
    else
    {
        this.m_cache.splice(insertAt, 0, rowData);
    }
};

/**
 * Remove entry from cache
 * @param {number} index the flattened index to start remove entry
 * @param {number} count how many entries to remove starting from the flattened index
 * @private
 */
oj.FlattenedTreeDataSource.prototype._removeEntry = function(index, count)
{
    this.m_cache.splice(index, count);
};

/**
 * Clears the internal cache
 * @private
 */
oj.FlattenedTreeDataSource.prototype._clearAll = function()
{
    this.m_cache.length = 0;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
//////////////////// _JsonTreeNodeDataSource ///////////////////////////////////

/**
 * Helper class to implement sort recursive features for tree.
 * @constructor
 * @private
 */
oj._JsonTreeNodeDataSource = function()
{
    this.id = null;
    this.depth = 0;
    this.parent = null;
    this.children = [];
    this.title = null;
    this.attr = null;
    this.leaf = null;
};

/**
 * Helper comparer method for ascending sort.
 * @private
 */
oj._JsonTreeNodeDataSource.prototype._ascending = function(key)
{
    return function(a, b) 
    {
        if (a.attr && b.attr) 
        {
            if (a.attr[key] && b.attr[key])
            {
                return a.attr[key] < b.attr[key] ? 0 : 1;
            }
        }
        return a[key] < b[key] ? 0 : 1;
    }
};

/**
 * Helper comparer method for descending sort.
 * @private
 */
oj._JsonTreeNodeDataSource.prototype._descending = function(key)
{
    return function(a, b) 
    {
        if (a.attr && b.attr) 
        {
            if (a.attr[key] && b.attr[key])
            {
                return a.attr[key] < b.attr[key] ? 1 : 0;
            }
        }
        return a[key] < b[key] ? 1 : 0;
    }
};

/**
 * Helper method for recursive sort.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key the key identifying the attribute to sort on
 *        {string} criteria.direction the sort direction, valid values are "ascending", "descending".
 * @private
 */
oj._JsonTreeNodeDataSource.prototype._sortRecursive = function(criteria)
{
    var key = criteria['key'];
    if (criteria['direction'] === 'ascending')
    {
        this.children.sort(this._ascending(key));
    }
    else if (criteria['direction'] === 'descending')
	{
		this.children.sort(this._descending(key));
	}
    for (var i = 0, l = this.children.length; i < l; i++)
    {
        this.children[i]._sortRecursive(criteria);
    }
    return this;
};

///////////// JsonTreeDataSource //////////////////   

/**
 * A json object based implementation of the TreeDataSource.
 * @param {Object} data the json object
 * @constructor
 * @export
 * @extends oj.TreeDataSource
 */
oj.JsonTreeDataSource = function(data)
{
    var tree;

    tree = new oj._JsonTreeNodeDataSource(); // that's the root node

    if (!data.id)
    {
        tree.id = "root";
    }

    this.data = this._createTreeDataSource(0, tree, data);

    oj.JsonTreeDataSource.superclass.constructor.call(this, tree);
};

// Subclass from oj.TreeDataSource
oj.Object.createSubclass(oj.JsonTreeDataSource, oj.TreeDataSource, "oj.JsonTreeDataSource");

/**
 * Initial the json object based data source.
 * @export
 */
oj.JsonTreeDataSource.prototype.Init = function()
{
    // call super
    oj.JsonTreeDataSource.superclass.Init.call(this);
};

/**
 * Returns tree based structure/object from json data.
 * @param {Object} target the final tree structure. 
 * @param {Object} source the json object.
 * @param {number=} depth used recursively for depth calculation.
 */
oj.JsonTreeDataSource.prototype._createTreeDataSource = function(c, target, source, depth)
{
    var children, node, child, prop, propr, prp, prpr, j;

    if (!depth)
    {
        depth = 0;
    }

    for (prop in source)
    {
        if (prop == "children" || (depth == 0 && source instanceof Array))
        {
            if (depth == 0 && source instanceof Array)
            {
                children = source;
            }
            else
            {
                children = source[prop];
            }

            depth++;
            for (j = 0; j < children.length; j++)
            {
                child = children[j];
                node = new oj._JsonTreeNodeDataSource();
                if (!child.id) 
                {
					c++;
                    if (!child.attr) 
                    {
                        node.id = 'rid_' + c;//Math.floor((Math.random() * 1000) + 1);
                    } 
                    else if (!child.attr.id) 
                    {
                        child.attr.id = 'rid_' + c;//Math.floor((Math.random() * 1000) + 1);
                    }
                }
                for (propr in child)
                {
                    for (prp in node)
                    {
                        if (propr == prp && propr != "children")
                        {    
                            node[prp] = child[propr];
                        }
                        if (prp == "depth")
                        {
                            node[prp] = depth;
                        }
                    }
                }
                target.children.push(node);
                for (prp in child)
                {
                    if (prp == "children")
                    {
                        this._createTreeDataSource(c, target.children[j], child, depth);
                    }
                }
            }
        }
    }
    return target;
};

/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {Object} parentKey the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 * @export
 */
oj.JsonTreeDataSource.prototype.getChildCount = function(parentKey)
{
    var parent;

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    if (parent.children)
    {
        return parent.children.length;
    }
    else
    {
        return 0;
    }
};

/**
 * Fetch the children
 * @param {Object} parentKey the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count.
 * @param {number} range.start the start index of the range in which the children are fetched.
 * @param {number} range.count the size of the range in which the children are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.JsonNodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation.
 * @param {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain 
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching.
 * @export
 */
oj.JsonTreeDataSource.prototype.fetchChildren = function(parentKey, range, callbacks, options)
{
    var i, childStart, childEnd, nodeSet, results, parent, node;

    childStart = 0;
    childEnd = 0;
    results = [];

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    if (!range)
    {
        range = [];
        range['start'] = 0;
        range['count'] = parent.children.length;
    }

    if (!range['count'])
    {
        range['count'] = parent.children.length;
    }

    if (!range['start'])
    {
        range['start'] = 0;
    }

    childStart = range['start'];
    childEnd = Math.min(parent.children.length, childStart + range['count']);

    // now populate results from data array
    for (i = childStart; i < childEnd; i += 1)
    {
        node = new oj._JsonTreeNodeDataSource();
        if(parent.children[i].attr)
        {
            node.attr = parent.children[i].attr;
        }
        if(parent.children[i].id)
        {
            node.id = parent.children[i].id;
        }
        if(parent.children[i].depth)
        {
            node.depth = parent.children[i].depth;
        }
        if(parent.children[i].title)
        {
            node.title = parent.children[i].title;
        }
        if(parent.children[i].parent)
        {
            node.parent = parent.children[i].parent;
        }
        if(parent.children[i].children.length > 0)
        {
            node.leaf = false;
        }
        else 
        {
            node.leaf = true;
        }
        results.push(node);
    }

    // invoke callback
    nodeSet = new oj.JsonNodeSet(childStart, childEnd, results, parentKey, parent.depth);

    // invoke original success callback
    if (callbacks != null && callbacks['success'] != null)
    {
        callbacks['success'].call(null, nodeSet);
    }
};

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {Object} parentKey the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.JsonNodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count.
 * @export
 */
oj.JsonTreeDataSource.prototype.fetchDescendants = function(parentKey, callbacks, maxCount)
{
    var range, i, childStart, childEnd, nodeSet, results, parent;

    childStart = 0;
    childEnd = 0;
    results = [];

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    range = [];
    range['start'] = 0;
    range['count'] = parent.children.length;

    childStart = range['start'];
    childEnd = Math.min(parent.children.length, childStart + range['count']);

    // now populate results from data array
    for (i = childStart; i < childEnd; i += 1)
    {       
	if(parent.children[i].children.length > 0)
        {
            parent.children[i].leaf = false;
        }
        else 
        {
            parent.children[i].leaf = true;
        }
        results.push(parent.children[i]); 
    }

    // invoke callback
    nodeSet = new oj.JsonNodeSet(0, results.length, results, parentKey, parent.depth);

    // invoke original success callback
    if (callbacks != null && callbacks['success'] != null)
    {
        callbacks['success'].call(null, nodeSet);
    }
};

/**
 * Moves a node from one location to another (different position within the same parent or a completely different parent)
 * @param {Object} nodeToMove the key of the node to move
 * @param {Object} referenceNode the key of the reference node which combined with position are used to determine 
 *        the destination of where the node should moved to.
 * @param {number|string} position The position of the moved node relative to the reference node.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference node's current children.
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @export
 */
oj.JsonTreeDataSource.prototype.move = function(nodeToMove, referenceNode, position, callbacks)
{
    var moveNode, refNode, moveNodeKey, refNodeKey, pos, parent, index;

    pos = position;
    moveNodeKey = nodeToMove;
    refNodeKey = referenceNode;

    if ((!refNodeKey || refNodeKey == this.data.id))
    {
        if (pos != "inside")
        {
            console.log("Error: root can not be the reference node if position equals to " + pos);
            return;
        }
        else
        {
            if (!refNodeKey)
            {
                refNodeKey = this.data.id;
            }
        }
    }

    //get node to move;
    moveNode = this._searchTreeById(null, moveNodeKey);
    //if the moveNode doesn't contain the reference node as its sub-tree the action is allowed
    if (!this._searchTreeById(moveNode, refNodeKey))
    {
        refNode = this._searchTreeById(null, refNodeKey);

        parent = this._getParentById(refNodeKey);
        //remove moveNode from the original position;
        this._removeFromTree(moveNode);
        if (pos == "inside")
        {
            this._updateDepth(moveNode, moveNode.depth - (refNode.depth + 1));
            refNode.children.push(moveNode);
        }
        else if (pos == "before")
        {
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            index = parent.children.indexOf(refNode);
            if (index > -1)
            {
                if (index != 0)
                {
                    parent.children.splice(index - 1, 0, moveNode);
                }
                else
                {
                    parent.children.unshift(moveNode);
                }
            }
        }
        else if (pos == "after")
        {
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            index = parent.children.indexOf(refNode);
            if (index > -1)
            {
                parent.children.splice(index, 0, moveNode);
            }
        }
        else if (pos == "first")
        {
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            parent.children.unshift(moveNode);
        }
        else if (pos == "last")
        {
            //update depth recursively
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            parent.children.push(moveNode);
        }

        // invoke original success callback
        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(null, this.data);
        }
    }
    else
    {
        console.log("Error: the node to move contains the reference node as its sub-tree.");
    }
};

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction
 * @param {Object} criteria.key the key identifying the attribute (column) to sort on
 *        {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @export
 */
oj.JsonTreeDataSource.prototype.sort = function(criteria, callbacks)
{
    var parent, parentKey;

    parentKey = null;

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    parent._sortRecursive(criteria);

    // invoke original success callback
    if (callbacks != null && callbacks['success'] != null)
    {
        callbacks['success'].call(null, parent);
    }
};

/**
 * @param {string|number} refNodeKey
 * @param {Object=} currNode
 * @return {Object|null} the node with required key value.
 * @private
 */
oj.JsonTreeDataSource.prototype._getParentById = function(refNodeKey, currNode)
{
    var i, parent = null, parentIsFound = false;

    if ((refNodeKey == this.data.id))
    {
        return null;
    }

    if (!currNode)
    {
        currNode = this.data;
    }

    if (currNode.children && currNode.children.length > 0)
    {
        for (i = 0; i < currNode.children.length; i++)
        {
            if ((currNode.children[i].id && currNode.children[i].id == refNodeKey) || (currNode.children[i].attr && currNode.children[i].attr.id == refNodeKey))
            {
                parentIsFound = true;
                return currNode;
                break;
            }
        }
        if (!parentIsFound)
        {
            for (i = 0; i < currNode.children.length; i++)
            {
                parent = this._getParentById(refNodeKey, currNode.children[i]);
                if (parent)
                {
                    parentIsFound = true;
                    return parent;
                    break;
                }
            }

        }
    }
    return parent;
};

/**
 * Helper method to traverse through the tree and return the node with required key.
 * @param {Object|null} currChild the start tree node.
 * @param {Object|null} parentKey the node key for search.
 * @return {Object|null} the node with required key value.
 * @private
 */
oj.JsonTreeDataSource.prototype._searchTreeById = function(currChild, parentKey)
{
    var i, result = null;

    if (!currChild)
    {
        currChild = this.data;
    }

    if ((currChild.id && currChild.id == parentKey) || (currChild.attr && currChild.attr.id == parentKey))
    {
        return currChild;
    }
    else if (currChild.children != null)
    {
        for (i = 0; i < currChild.children.length; i++)
        {
            if (result)
            {
                return result;
                break;
            }
            if ((currChild.children[i].id && currChild.children[i].id == parentKey) || (currChild.children[i].attr && currChild.children[i].attr.id == parentKey))
            {
                result = currChild.children[i];
            }
            else
            {
                result = this._searchTreeById(currChild.children[i], parentKey);
            }
        }
        return result;
    }
    return result;
};

/**
 * Helper method to update the node's depth alongside with its children.
 * @param {Object} currChild the node to update.
 * @param {number} offset the difference between current and updated depth values.
 * @private
 */
oj.JsonTreeDataSource.prototype._updateDepth = function(currChild, offset)
{
    var i;

    currChild.depth = currChild.depth - offset;

    if (currChild.children && currChild.children.length != 0)
    {
        for (i = 0; i < currChild.children.length; i++)
        {
            this._updateDepth(currChild.children[i], offset);
        }
    }
};


/**
 * Helper method to remove node from the tree (based on depth value).
 * @param {Object} currChild the node to remove.
 * @private
 */
oj.JsonTreeDataSource.prototype._removeFromTree = function(currChild)
{
    var parent, index, key;

    if (currChild.id)
    {
        key = currChild.id;
    }
    else if (currChild.attr)
    {
        key = currChild.attr.id;
    }

    parent = this._getParentById(key);
    if (!parent)
    {
        parent = this.data;
    }
    index = parent.children.indexOf(currChild);
    if (index > -1)
    {
        parent.children.splice(index, 1);
    }
};

/**
 * Determines whether this TreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort", 
 *        "move", "fetchDescendants", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".  
 *         For "fetchDescendants", the valid return values are: "enable", "disable", "suboptimal".  
 *         For "move", the valid return values are: "default", "none".  
 *         For "batchFetch", the valid return values are: "enable", "disable".  
 * @export
 */
oj.JsonTreeDataSource.prototype.getCapability = function(feature)
{
    if (feature === 'fetchDescendants')
    {
        return "enable";
    }
    else if (feature === 'sort')
    {
        return "default";
    }
    else if (feature === 'batchFetch')
    {
        return "disable";
    }
    else if (feature === 'move')
    {
        return "full";
    }
    else
    {
        return null;
    }
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.Row
 * @classdesc Object representing name/value pairs for a row of data
 *
 * @param {Object=} attributes Initial set of attribute/value pairs with which to seed this Row object 
 * @param {Object=} options 
 *                  rowSet: rowSet for this row
 *                  context: context for this row
 * @constructor
 */
oj.Row = function(attributes, options)
{
  oj.Row._init(this, attributes, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.Row, oj.Object, "Row.Row");

oj.Row.prototype.Init = function()
{
  oj.Row.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Row.
 * 
 * @type Object
 */
oj.Row.prototype.attributes = {};

/**
 * 
 * @export
 * @desc Attribute/value pairs for context held by the Row.
 * 
 * @type Object
 */
oj.Row.prototype.context = {};

/**
 * @export
 * @desc The Row's unique ID. Can be a String for single keys and Array for compound keys.
 * 
 * @type {string|Array}
 */
oj.Row.prototype.id = null;

/**
 * @export
 * @desc The name or Array of the row property(s) to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type {string|Array}
 */
oj.Row.prototype.idAttribute = null;

oj.Row._init = function(row, attributes, options, properties)
{
  var prop = null, attrCopy;

  row.Init();

  row.index = -1;

  options = options || {};
  row.attributes = {};

  // First, copy all properties passed in
  for (prop in properties)
  {
    if (properties.hasOwnProperty(prop))
    {
      row[prop] = properties[prop];
    }
  }
  
  row['rowSet'] = options['rowSet'];
  row['context'] = options['context'];
};

/**
 * Return a copy of the Row with identical attributes and settings
 * @export
 * @expose
 * @memberof! oj.Row
 * @instance
 */
oj.Row.prototype.clone = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Returns the value of the property from the Row.
 * @param {string} property Property to get from row
 * @return {Object} value of property
 * @export
 * @expose
 * @memberof! oj.Row
 * @instance
 */
oj.Row.prototype.get = function(property)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Set the value(s) of one or more attributes of the row
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in
 * @returns {Object||boolean} the row itself, false if failed
 * @export
 * @expose
 * @memberof! oj.Row
 * @instance
 */
oj.Row.prototype.set = function(property, value, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return all of the Row's attributes as an array
 * 
 * @returns {Array} array of all the Row's attributes
 * @export
 * @expose
 * @memberof! oj.Row
 * @instance
 */
oj.Row.prototype.keys = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return all of the Row's attributes values as an array
 * 
 * @returns {Array} array of all the Row's attributes values
 * @export
 * @expose
 * @memberof! oj.Row
 * @instance
 */
oj.Row.prototype.values = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return an array of attributes/value pairs found in the Row 
 * 
 * @returns {Object} returns the Row's attribute/value pairs as an object property bag
 * @export
 * @expose
 * @memberof! oj.Row
 * @instance
 */
oj.Row.prototype.pairs = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.RowSet
 * @classdesc Internal class used for RowSet of Row objects. Should not be used by application developers. 
 */
oj.RowSet = function(rows, options)
{
  // Initialize
  oj.RowSet._init(this, rows, options, null);
};

/**
 * @export
 * @desc If set, sort the rowSet using the given attribute of a row (if string); function(Row) returning a string attribute
 * by which the sort should take place; function(Row1, Row2) if a user-defined function comparing Row1 and Row2 (see the
 * JavaScript array.sort() for details)
 * 
 * @type {string|function(Object)|function(Object,Object)|null}
 */
oj.RowSet.prototype.comparator = null;

/**
 * @export
 * @desc Set to true if sort is supported.
 * 
 * @type boolean
 */
oj.RowSet.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.RowSet, oj.Object, "RowSet.RowSet");

oj.RowSet.prototype.Init = function()
{
  oj.RowSet.superclass.Init.call(this);
};

oj.RowSet._init = function(rowSet, rows, options, properties)
{
  var prop;
  rowSet._eventHandlers = [];
  rowSet.Init();

  // First, copy all properties passed in
  if (properties)
  {
    for (prop in properties)
    {
      if (properties.hasOwnProperty(prop))
      {
        rowSet[prop] = properties[prop];
      }
    }
  }
};

/**
 * Return the Row object found at the given index of the RowSet, or a promise object that will return the Row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the RowSet is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual RowSet or
 *                  if deferred is specified and true, at will return a jQuery promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.at = function(index, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Loads the data into the RowSet
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.fetch = function(options)
{
  oj.Assert.failedInAbstractFunction();
}

/**
 * Return the first Row object from the RowSet whose Row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the Row when done
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.get = function(id, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 
 * @return {number} The index of the given Row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.indexOf = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Determine if the RowSet has any Rows
 * 
 * @returns {boolean} true if RowSet is empty
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.isEmpty = function()
{
  oj.Assert.failedInAbstractFunction();
  return true;
};

/**
 * Return the length of the RowSet
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.size = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Sort the Rows in the RowSet
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.sort = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Return the total length of the RowSet
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.totalSize = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.on = function(eventType, eventHandler)
{
  var foundEventHandler = false, i;
  for (i = 0; i < this._eventHandlers.length; i++)
  {
    if (this._eventHandlers[i]['eventType'] == eventType &&
      this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
    {
      foundEventHandler = true;
      break;
    }
  }
  if (!foundEventHandler) {
    this._eventHandlers.push({'eventType': eventType, 'eventHandlerFunc': eventHandler});
  }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.off = function(eventType, eventHandler)
{
  var i;
  for (i = 0; i < this._eventHandlers.length; i++)
  {
    if (this._eventHandlers[i]['eventType'] == eventType &&
      this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
    {
      this._eventHandlers.remove(this._eventHandlers[i]);
      break;
    }
  }
};

/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {?} event  event
 * @private
 */
oj.RowSet.prototype._handleEvent = function(eventType, event)
{
  var i;
  for (i = 0; i < this._eventHandlers.length; i++)
  {
    var eventHandler = this._eventHandlers[i];
    if (eventHandler['eventType'] == eventType)
    {
      eventHandler['eventHandlerFunc'](event);
    }
  }
};

/**
 * @export
 * Event types
 * @enum {string}
 */
oj.RowSet.EventType =
  {
    /** Triggered when a Row is added to a RowSet */
    'ADD': "add",
    /** Triggered when a Row is removed from a RowSet */
    'REMOVE': "remove",
    /** Triggered when a RowSet is reset (see oj.RowSet.reset) */
    'RESET': "reset",
    /** Triggered when a RowSet is refreshed, generally from a collection */
    'REFRESH': "refresh",
    /** Triggered when a RowSet is sorted */
    'SORT': "sort",
    /** Triggered when a Row's attributes are changed */
    'CHANGE': "change",
    /** Triggered when a Row or RowSet has sent a request to the data service */
    'REQUEST': "request",
    /** Triggered when a Row or RowSet has been updated from the data service */
    'SYNC': "sync",
    /** Triggered when a Row has failed to update on the data service */
    'ERROR': "error"
  };

/**
 * @export
 * Event types
 * @enum {string}
 */
oj.RowSet._ROW_STATUSES =
  {
    _ADDED: 'added',
    _DELETED: 'deleted',
    _UPDATED: 'updated',
    _NONE: 'none'
  };
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.ArrayRow
 * @classdesc Object representing name/value pairs for a row of data
 *
 * @param {Object=} attributes Initial set of attribute/value pairs with which to seed this Row object 
 * @param {Object=} options 
 *                  rowSet: rowSet for this row
 * @constructor
 */
oj.ArrayRow = function(attributes, options)
{
  oj.ArrayRow._init(this, attributes, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.ArrayRow, oj.Row, "ArrayRow.ArrayRow");

oj.ArrayRow.prototype.Init = function()
{
  oj.ArrayRow.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Model.
 * 
 * @type Object
 */
oj.ArrayRow.prototype.attributes = {};

/**
 * @export
 * @desc The Row's unique ID. 
 * 
 * @type {string|Array}
 */
oj.ArrayRow.prototype.id = null;

/**
 * @export
 * @desc The name of the row property to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type {string|Array}
 */
oj.ArrayRow.prototype.idAttribute = null;

oj.ArrayRow._init = function(row, attributes, options, properties)
{
  var prop = null, attrCopy;

  row.Init();

  row.index = -1;

  options = options || {};
  row.attributes = attributes;

  // First, copy all properties passed in
  for (prop in properties)
  {
    if (properties.hasOwnProperty(prop))
    {
      row[prop] = properties[prop];
    }
  }
  
  row['idAttribute'] = options['idAttribute'];
  row['context'] = options['context'];
  row._setupId();
};

/**
 * @export
 * Return a copy of the Row with identical attributes and settings
 */
oj.ArrayRow.prototype.clone = function()
{
  var c = new this.constructor(), prop;

  for (prop in this)
  {
    // Shallow copy all but data
    if (this.hasOwnProperty(prop) && this[prop] !== this.attributes)
    {
      c[prop] = this[prop];
    }
  }
  // Deep copy data
  c.attributes = oj.ArrayRow._cloneAttributes(this.attributes, null);

  c._setupId();

  return c;
};

/**
 * Returns the value of the property from the Row.
 * @param {string} property Property to get from row
 * @return {Object} value of property
 * @export
 */
oj.ArrayRow.prototype.get = function(property)
{
  return this.attributes[property];
};

/**
 * Set the value(s) of one or more attributes of the row
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in
 * @returns {Object||boolean} the row itself, false if failed
 * @export
 */
oj.ArrayRow.prototype.set = function(property, value, options)
{
  var opts = {}, ignoreLastArg = false, prop, i, valid = true;

  if (arguments)
  {
    if (arguments.length > 0)
    {
      // Check if the last argument is not the first argument
      if (arguments.length > 1)
      {
        if (arguments[arguments.length - 1])
        {
          // Last arg is options: ignore later
          ignoreLastArg = true;
          opts = arguments[arguments.length - 1] || {};
        }
      }
      // Check if first arg is property bag
      if (oj.ArrayRow._hasProperties(property))
      {
        this._setProp(property, opts);
      }
      else
      {
        // Not a property bag?  We assume it's a series of property/value arguments
        for (i = 0; i < arguments.length; i += 2)
        {
          // Process the arg as long as its: defined, and isn't the last argument where we're supposed to ignore the last argument
          // due to it being 'options'
          if (arguments[i] !== undefined || i < arguments.length - 1 || (!ignoreLastArg && i === arguments.length - 1))
          {
            this._setProp(arguments[i], arguments[i + 1]);
          }
        }
      }
    }
  }
  return this;
};

/**
 * @export
 * Return all of the Row's attributes as an array
 * 
 * @returns {Array} array of all the Row's attributes
 */
oj.ArrayRow.prototype.keys = function()
{
  var prop, retArray = [];

  for (prop in this.attributes)
  {
    if (this.attributes.hasOwnProperty(prop))
    {
      retArray.push(prop);
    }
  }
  return retArray;
};

/**
 * @export
 * Return all of the Row's attributes values as an array
 * 
 * @returns {Array} array of all the Row's attributes values
 */
oj.ArrayRow.prototype.values = function()
{
  var prop, retArray = [];

  for (prop in this.attributes)
  {
    if (this.attributes.hasOwnProperty(prop))
    {
      retArray.push(this.get(prop));
    }
  }
  return retArray;
};

/**
 * @export
 * Return an array of attributes/value pairs found in the Row 
 * 
 * @returns {Object} returns the Row's attribute/value pairs as an object property bag
 */
oj.ArrayRow.prototype.pairs = function()
{
  var prop, retObj = [], item;
  for (prop in this.attributes)
  {
    if (this.attributes.hasOwnProperty(prop))
    {
      item = [];
      item.push(prop);
      item.push(this.get(prop));
      retObj.push(item);
      ;
    }
  }
  return retObj;
};

oj.ArrayRow.prototype._getIdAttr = function()
{
  return this['idAttribute'] || 'id';
};

// Might be a property value or a function
oj.ArrayRow.prototype._getProp = function(prop)
{
  if (this[prop] instanceof Function)
  {
    return this[prop]();
  }
  return this[prop];
};

oj.ArrayRow._hasProperties = function(object)
{
  var prop;
  if (object && object instanceof Object)
  {
    for (prop in object)
    {
      if (object.hasOwnProperty(prop))
      {
        return true;
      }
    }
  }
  return false;
};

oj.ArrayRow.prototype._setupId = function()
{
  var idAttr = this._getIdAttr();
  if ($.type(idAttr) === 'string')
  {
    this['id'] = this.attributes[idAttr];
  }
  else if ($.isArray(idAttr))
  {
    var i;
    this['id'] = [];
    for (i = 0; i < idAttr.length; i++)
    {
      this['id'][i] =  this.attributes[idAttr[i]];
    }
  }
};

oj.ArrayRow.prototype._setPropInternal = function(prop, value)
{
  if (!oj.Object.__innerEquals(this.attributes[prop], value))
  {
    this.attributes[prop] = value;
    this._setupId();
    oj.ArrayRowSet.superclass._handleEvent.call(this['rowSet'], oj.RowSet.EventType['CHANGE'], this);
    return true;
  }
  return false;
};

/**
 * @param {Object||string} prop
 * @param {Object} value
 * @returns {boolean}
 */
oj.ArrayRow.prototype._setProp = function(prop, value)
{
  if (prop == null)
  {
    return true;
  }

  var attrs = {}, p;

  if (arguments.length > 1)
  {
    attrs[prop] = value;
  }
  else
  {
    for (p in prop)
    {
      if (prop.hasOwnProperty(p))
      {
        attrs[p] = prop[p];
      }
    }
  }

  for (p in attrs)
  {
    if (attrs.hasOwnProperty(p))
    {
      this._setPropInternal(p, attrs[p]);
    }
  }
  return true;
};

oj.ArrayRow._cloneAttributes = function(oldData, newData)
{
  var prop;
  newData = newData || {};
  for (prop in oldData)
  {
    if (oldData.hasOwnProperty(prop)) {// && oldData[prop] !== undefined) {
      if (typeof (oldData[prop]) !== 'object')
      {
        // Only overwrite if not undefined
        if (newData.hasOwnProperty(prop))
        {
          if (oldData[prop] !== undefined)
          {
            newData[prop] = oldData[prop];
          }
        }
        else
        {
          newData[prop] = oldData[prop];
        }
      }
      else
      {
        newData[prop] = oj.ArrayRow._cloneAttributes(oldData[prop], null);
      }
    }
  }
  return newData;
};


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.ArrayRowSet
 * @classdesc Internal class used for RowSet of ArrayRow objects. Should not be used by application developers. 
 * 
 * @param {Array=} rows Set of row objects or JS array of data to put into rowSet at construction time 
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 */
oj.ArrayRowSet = function(rows, options)
{
  // Initialize
  oj.ArrayRowSet._init(this, rows, options, null);
};

/**
 * @export
 * @desc If set, sort the rowSet using the given attribute of a row (if string); function(Row) returning a string attribute
 * by which the sort should take place; function(Row1, Row2) if a user-defined function comparing Row1 and Row2 (see the
 * JavaScript array.sort() for details)
 * 
 * @type {string|function(Object)|function(Object,Object)|null}
 */
oj.ArrayRowSet.prototype.comparator = null;

/**
 * @export
 * @desc Set to true if sort is supported.
 * 
 * @type boolean
 */
oj.ArrayRowSet.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.ArrayRowSet, oj.RowSet, "ArrayRowSet.ArrayRowSet");

oj.ArrayRowSet.prototype.Init = function()
{
  oj.ArrayRowSet.superclass.Init.call(this);
};

oj.ArrayRowSet._init = function(rowSet, rows, options, properties)
{
  var prop;
  rowSet._eventHandlers = [];
  rowSet._startIndex = 0;

  rowSet.Init();

  // First, copy all properties passed in
  if (properties)
  {
    for (prop in properties)
    {
      if (properties.hasOwnProperty(prop))
      {
        rowSet[prop] = properties[prop];
      }
    }
  }

  // Check options
  options = options || {};

  rowSet._rows = [];
  rowSet._pagedRows = [];

  if (rows != null && rows !== undefined)
  {
    rowSet._idAttribute = 'id';
    if (options != null && options['idAttribute'] != null)
    {
      rowSet._idAttribute = options['idAttribute'];
    }
    rowSet._data = (rows instanceof Array) ? rows : rows();
    rowSet._rows = oj.ArrayRowSet._getRowArray(rowSet._data, rowSet._idAttribute, rowSet);
    rowSet._totalSize = rowSet._data.length;
        
    if (!(rows instanceof Array))
    {
      // subscribe to observableArray arrayChange event to get individual updates
      (/** @type {{subscribe: Function}} */(rows))['subscribe']
        (
          function(changes) 
          {
            var i, row, delIndx = 0;
            // check if they are all deletes. If so, just call reset
            var removeAll = true;
            for (i = 0; i < changes.length; i++)
            {
              if (changes[i]['status'] != 'deleted')
              {
                removeAll = false;
              }
            }
            if (rows().length == 0 && removeAll)
            {
              rowSet.reset();
              return;
            }
            
            // do two passes, first for deletes and the second for adds
            for (i = 0; i < changes.length; i++)
            {
              if (changes[i]['status'] === 'deleted')
              {
                row = new oj.ArrayRow(changes[i].value, {'idAttribute': rowSet._idAttribute});
                row['index'] = changes[i].index - delIndx;
                rowSet._removeInternal(row, changes[i].index - delIndx);
                delIndx++;
              }
            }
            for (i = 0; i < changes.length; i++)
            {
              if (changes[i]['status'] === 'added')
              {
                row = new oj.ArrayRow(changes[i].value, {'idAttribute': rowSet._idAttribute});
                row['index'] = changes[i].index;
                rowSet.add(row, {'at': changes[i].index});
              }
            } 
          }, null, 'arrayChange');
    }
  }
};

/**
 * Add an instance of this RowSet's Row(s) to the end of the RowSet.
 * @param {Object} m Row object (or array of rows) to add. These can be already-created instance of the oj.Row object, or sets of attribute/values, which will be wrapped by add().
 * @param {Object=} options at: splice the new Row into the RowSet at the value given (at:index) <p>
 *                          deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 *                          silent: if set, do not fire an add event 
 * 
 * @returns {Object} if deferred or virtual, return a promise when the set has completed
 * @export
 */
oj.ArrayRowSet.prototype.add = function(m, options)
{
  options = options || {};
  var index = options['at'];
  var deferred = options['deferred'];

  this._addToRowSet(m, index, options);

  if (deferred)
  {
    return oj.Object.__getPromise(function(resolve, reject) {
        resolve();
    });
  }
  return null;
};

/**
 * Return the Row object found at the given index of the RowSet, or a promise object that will return the Row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the RowSet is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual RowSet or
 *                  if deferred is specified and true, at will return a promise object which will call its then function,
 *                  passing the value at(index) 
 * @export
 */
oj.ArrayRowSet.prototype.at = function(index, options)
{
  options = options || {};
  var deferred = options['deferred'];

  if (index < 0 || index >= this._rows.length)
  {
    return null;
  }
  var row = this._rows[index];

  if (deferred)
  {
    return oj.Object.__getPromise(function(resolve, reject) {
        resolve(row);
    });
  }
  return row;
};

/**
 * @export
 * Return a copy of the RowSet
 * @return {Object} copy of the RowSet
 */
oj.ArrayRowSet.prototype.clone = function()
{
  var rs = new this.constructor(), i;

  var row;
  for (i = 0; i < this._rows.length; i = i + 1)
  {
    row = this.at(i, null);
    if (row)
    {
      rs.add(row.clone(), {'at': i});
    }
  }

  return rs;
};

/**
 * Loads the data into the RowSet
 * @param {Object=} options Options to control fetch<p>
 *                  success: a user callback called when the fetch has completed successfully.<p>
 *                  error: a user callback function called if the fetch fails.<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.ArrayRowSet.prototype.fetch = function(options)
{
  options = options || {};
  this._startFetch();
  try
  {
    this._pageSize = options['pageSize'] > 0 ? options['pageSize'] : -1;
    this._startIndex = options != null ? (options['startIndex'] != null ? options['startIndex'] : 0) : 0;
    this._pagedRows = oj.ArrayRowSet._getPagedRows(this._rows, this._startIndex, this._pageSize);
  }
  catch (err)
  {
    this._endFetch(options, err);
    return;
  }
  
  options['pageSize'] = this._pageSize;
  options['startIndex'] = this._startIndex;
  options['refresh'] = true;
  this._endFetch(options, null);
}

/**
 * Return the first Row object from the RowSet whose Row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {string|Array} id ID for which to return the Row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the Row when done
 * @export
 */
oj.ArrayRowSet.prototype.get = function(id, options)
{
  options = options || {};
  var deferred = options['deferred'];
  var i, j, row;
  var result = null;
  for (i = 0; i < this._rows.length; i = i + 1)
  {
    row = this._rows[i];
    if (row !== undefined)
    {
      if ($.isArray(row['id']) && $.isArray(id))
      {
        if (row['id'].length == id.length)
        {
          var equal = true;
          for (j = 0; j < id.length; j++)
          {
            if (row['id'][j] != id[j])
            {
              equal = false;
              break;
            }
          }
          if (equal)
          {
            result = row;
          }
        }
      }
      else if (row['id'] == id)
      {
        result = row;
      }
      if (result != null)
      {
        if (deferred)
        {
          return oj.Object.__getPromise(function(resolve, reject) {
            resolve(result);
        });
        }
        return result;
      }
    }
  }
  return null;
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 */
oj.ArrayRowSet.prototype.hasMore = function()
{
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 
 * @return {number} The index of the given Row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 */
oj.ArrayRowSet.prototype.indexOf = function(row, options)
{
  var location;
  options = options || {};
  var deferred = options['deferred'];

  if (deferred)
  {
    return this.get(row['id'], null).then(function(loc) {
      return loc.index;
    });
  }
  location = this.get(row['id']);

  return location.index;
};

/**
 * @export
 * Determine if the RowSet has any Rows
 * 
 * @returns {boolean} true if RowSet is empty
 */
oj.ArrayRowSet.prototype.isEmpty = function()
{
  return this._pagedRows.length === 0;
};

/**
 * Remove a Row from the RowSet, if found.
 * @param {Object} m Row object (or array of rows) to remove.
 * @param {Object=} options silent: if set, do not fire a remove event 
 * @export
 */
oj.ArrayRowSet.prototype.remove = function(m, options)
{
  options = options || {};
  this._removeInternal(m, -1, options);
};

/**
 * Remove and replace the RowSet's entire list of Rows with a new set of Rows, if provided. Otherwise, empty the RowSet.
 * @param {Object=} data Array of Row objects with which to replace the RowSet's data. 
 * @param {Object=} options silent: if set, do not fire an add event<p>
 * @export
 */
oj.ArrayRowSet.prototype.reset = function(data, options)
{
  var i;

  options = options || {};
  options['previousRows'] = this._rows;
  var silent = options['silent'];

  if (data === undefined || data == null || (data instanceof Array && data.length == 0))
  {
    for (i = 0; i < this._rows.length; i = i + 1)
    {
      if (this._rows[i])
      {
        this._rows[i]['rowSet'] = null;
      }
    }
    this._pagedRows = [];
    this._rows = [];
    this._totalSize = 0;
  }
  else
  {
    this._rows = [];
    this._pagedRows = [];
    this._totalSize = 0;

    if (data instanceof Array)
    {
      for (i = 0; i < data.length; i = i + 1)
      {
        this.add(/** @type oj.Row */ (data[i]), options);
      }
    }
    else
    {
      this.add(/** @type oj.Row */ (data), options);
    }
  }
  if (!silent)
  {
    oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['RESET'], null);
  }
};

/**
 * @export
 * Return the length of the RowSet
 * @returns {number} length of the RowSet
 */
oj.ArrayRowSet.prototype.size = function()
{
  return this._pagedRows.length;
};

/**
 * @export
 * Sort the Rows in the RowSet
 */
oj.ArrayRowSet.prototype.sort = function()
{
  var comparator = this['comparator'], self;

  // Check for comparator
  if (!this._hasComparator())
  {
    return;
  }

  self = this;
  this._rows.sort(function(a, b)
  {
    return oj.ArrayRowSet._sortFunc(a, b, comparator, self, self);
  });
  this._realignRowIndices(0, this._rows);
  this._pagedRows = oj.ArrayRowSet._getPagedRows(this._rows, this._startIndex, this._pageSize);
  this._sorted = true;
  oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['SORT'], null);
};

/**
 * @export
 * Return the total length of the RowSet
 * @returns {number} length of the RowSet
 */
oj.ArrayRowSet.prototype.totalSize = function()
{
  return this._totalSize;
};

/**
 * @param {Object} m Row instance or array of Rows or sets of attribute/values
 * @param {number} index Index value
 * @param {Object=} options silent: if set, do not fire an add event 
 */
oj.ArrayRowSet.prototype._addToRowSet = function(m, index, options)
{
  var i, j, row;
  options = options || {};
  var silent = options['silent'];
  
  if (!(m instanceof Array))
  {
    m = [m];
  }
  for (i = 0; i < m.length; i++)
  {
    row = m[i];
    
    if (!(row instanceof oj.ArrayRow))
    {
      row = new oj.ArrayRow(row, {'idAttribute': this._idAttribute});
    }
    
    // check if pagedRows is empty
    if (!this._pagedRows || this._pagedRows.length == 0)
    {
      this._pagedRows = oj.ArrayRowSet._getPagedRows(this._rows, this._startIndex, this._pageSize);
    }

    if (this._sorted == true && this._rows.length > 0)
    {
      var self = this;
      for (j = 0; j < this._rows.length; j++)
      {
        if (oj.ArrayRowSet._sortFunc(row, this._rows[j], this['comparator'], self, self) < 0)
        {
          this._rows.splice(j, 0, row);
          row['index'] = j;
          break;
        }
        else if (j == this._rows.length - 1)
        {
          this._rows.push(row);
          row['index'] = j + 1;
          break;
        }
      }
    }
    else
    {
      if (index === undefined)
      { 
        this._rows.push(row);
        row['index'] = this._rows.length - 1;
      }
      else
      {
        this._rows.splice(index + i, 0, row);
        row['index'] = index + i;
      }
    }
    
    row['rowSet'] = this;
    var endIndex = oj.ArrayRowSet._getEndIndex(this._rows, this._startIndex, this._pageSize);
    if (row['index'] <= endIndex)
    {
      this._pagedRows.splice(row['index'], 0, row);
    }
    this._totalSize++;
    
    if (row['index'] != this._rows.length - 1)
    {
      // re-align the row indices if this is not the last row
      this._realignRowIndices(0, this._rows);
    }
    
    if (!silent)
    {
      oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['ADD'], row);
    }
  }
}

oj.ArrayRowSet.prototype._getSortAttrs = function(sortStr)
{
  if (sortStr === undefined)
  {
    return [];
  }
  return sortStr.split(",");
};

oj.ArrayRowSet.prototype._getSortDirStr = function()
{
  if (this['sortDirection'] === -1)
  {
    return "dsc";
  }
  return "asc";
};

oj.ArrayRowSet.prototype._hasComparator = function()
{
  var comparator = this['comparator'];
  return comparator !== undefined && comparator !== null;
};

// Realign all the indices of the rows (after sort for example)
oj.ArrayRowSet.prototype._realignRowIndices = function(start, rows)
{
  var row;
  for (var i = start; i < rows.length; i++)
  {
    row = rows[i];
    if (row)
    {
      row['index'] = i;
    }
  }
};

oj.ArrayRowSet.prototype._removeInternal = function(m, index, options)
{
  var i, j, row;
  options = options || {};
  var silent = options['silent'];
  
  if (!(m instanceof Array))
  {
    m = [m];
  }
  for (i = 0; i < m.length; i++)
  {
    row = m[i];
    
    if (index < 0 || this._sorted == true)
    {
      if (this.get(row['id']) != null)
      {
        index = this.get(row['id']).index;
      }
    }

    if (index > -1)
    {
      // only unset the RowSet setting if it's mine
      if (row !== undefined && row.rowSet === this)
      {
        row.rowSet = null;
      }
      var endIndex = oj.ArrayRowSet._getEndIndex(this._rows, this._startIndex, this._pageSize);
      this._rows.splice(index, 1);
      if (index <= endIndex)
      {
        this._pagedRows.splice(index, 1);
      }
      this._totalSize--;
      this._realignRowIndices(0, this._rows);
      if (!silent)
      {
        var opt = {};
        options['index'] = index;
        if (row !== undefined)
        {
          if (!silent)
          {
            oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['REMOVE'], row);
          }
        }
      }
    }
  }
  
  return row;
};

oj.ArrayRowSet.prototype._setRow = function(index, row)
{
  this._rows[index] = row;
  row['index'] = index;
};

/**
 * Indicate starting fetch
 * @private
 */
oj.ArrayRowSet.prototype._startFetch = function()
{
  oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['REQUEST'], null);
};

/**
 * Indicate ending fetch
 * @private
 */
oj.ArrayRowSet.prototype._endFetch = function(options, e)
{
  options = options || {}; 
  var success = options['success'];
  var error = options['error'];
  
  if (e != null)
  {
    oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['ERROR'], e);
    
    if (error)
    { 
      error.call(this, options, e);
    }
  }
  else
  {
    oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['SYNC'], options);
    
    if (success)
    {
      success.call(this, options);
    }
  }
};

oj.ArrayRowSet._compareKeys = function(keyA, keyB, sortDirection)
{
  if (sortDirection === -1)
  {
    if (keyA < keyB)
    {
      return 1;
    }
    if (keyB < keyA)
    {
      return -1;
    }
  }
  else
  {
    if (keyA > keyB)
    {
      return 1;
    }
    if (keyB > keyA)
    {
      return -1;
    }
  }
  return 0;
};

oj.ArrayRowSet._getEndIndex = function(rows, startIndex, pageSize)
{
  var endIndex = rows.length - 1;
  
  if (pageSize > 0)
  {
    endIndex = startIndex + pageSize - 1;
    endIndex = endIndex > rows.length - 1 ? rows.length - 1 : endIndex;
  }
  
  return endIndex;
};

oj.ArrayRowSet._getKey = function(val, attr) {
  if (val instanceof oj.Row) {
    return val.get(attr);
  }
  if ($.isFunction(val[attr])) {
    return val[attr]();
  }
  return val[attr];
};

oj.ArrayRowSet._getPagedRows = function(rows, startIndex, pageSize)
{
  var endIndex = oj.ArrayRowSet._getEndIndex(rows, startIndex, pageSize);

  var pagedRowArray = [], i, row;
  for (i = 0; i <= endIndex; i++)
  {
    row = rows[i];
    row['index'] = i;
    pagedRowArray[i] = row;
  }

  return pagedRowArray;
};

oj.ArrayRowSet._getRowArray = function(values, idAttribute, rowSet)
{
  var endIndex = values.length - 1;

  var rowArray = [], i, prop;
  for (i = 0; i <= endIndex; i++)
  {
    var clonedRowValues = {};
    var rowValues = null;
    if (values[i] instanceof oj.Row)
    {
      rowValues = values[i].pairs();
    }
    else
    {
      rowValues = values[i];
    }
    for (prop in rowValues)
    {
      if (rowValues.hasOwnProperty(prop))
      {
        clonedRowValues[prop] = rowValues[prop];
      }
    }
    var row = new oj.ArrayRow(clonedRowValues, {'idAttribute': idAttribute});
    row['index'] = i;
    rowArray[i] = row;
    row['rowSet'] = rowSet;
  }

  return rowArray;
};

oj.ArrayRowSet._sortFunc = function(a, b, comparator, rowSet, self)
{
  var keyA, keyB, i, retVal;

  if ($.isFunction(comparator))
  {
    // How many args?
    if (comparator.length === 1)
    {
      // "sortBy" comparator option
      keyA = comparator.call(self, a);
      keyB = comparator.call(self, b);
      var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(",") : [keyA];
      var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(",") : [keyB];
      for (i = 0; i < attrs1.length; i++)
      {
        retVal = oj.ArrayRowSet._compareKeys(attrs1[i], attrs2[i], rowSet['sortDirection']);
        if (retVal !== 0)
        {
          return retVal;
        }
      }
      return 0;
    }
    // "sort" comparator option
    return comparator.call(self, a, b);
  }
  // String option
  if (oj.StringUtils.isString(comparator))
  {
    var attrs = comparator.split(",");

    for (i = 0; i < attrs.length; i++)
    {
      keyA = oj.ArrayRowSet._getKey(a, attrs[i]);
      keyB = oj.ArrayRowSet._getKey(b, attrs[i]);
      retVal = oj.ArrayRowSet._compareKeys(keyA, keyB, rowSet['sortDirection']);
      if (retVal !== 0)
      {
        return retVal;
      }
    }
  }
  return 0;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * Convenient class that represents an empty node set
 * @param {Object} parent the parent key
 * @param {number} start the start index
 * @constructor
 * @export
 */
oj.EmptyNodeSet = function(parent, start)
{
    this.m_parent = parent;
    this.m_start = start;
};

/**
 * Gets the parent
 * @return {Object} the key of the parent.
 * @export
 */
oj.EmptyNodeSet.prototype.getParent = function()
{
    return this.m_parent;
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.  
 * @export
 */
oj.EmptyNodeSet.prototype.getStart = function()
{
    return this.m_start;
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.EmptyNodeSet.prototype.getCount = function()
{
    return 0;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.
 * @export
 */
oj.EmptyNodeSet.prototype.getData = function(index)
{
    return null;
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) state - state of the node, valid values are 'expanded', 'collapsed', 'leaf'. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.EmptyNodeSet.prototype.getMetadata = function(index)
{
    return null;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * Combines two NodeSets together into one.
 * @param {Object} nodeSet1 the first node set
 * @param {Object} nodeSet2 the second node set
 * @param {Object} mergeAt the row key on the first node set where the second node set is merge to 
 * @constructor
 * @export
 */
oj.MergedNodeSet = function(nodeSet1, nodeSet2, mergeAt)
{
    this.m_nodeSet1 = nodeSet1;
    this.m_nodeSet2 = nodeSet2;
    this.m_mergeAt = this._findIndex(mergeAt);
};

/**
 * Retrieve the index of the key within the first node set
 * Which is going to be the index where the two node set merge
 * @param {Object} key the key to find the index
 * @return {number} the index of the key within the first node set, if index is not found, then the last index of the first node set is returned.
 * @private
 */
oj.MergedNodeSet.prototype._findIndex = function(key)
{
    var start, end, i, rowKey;

    start = this.m_nodeSet1.getStart();
    end = start + this.m_nodeSet1.getCount();
    for (i=start; i<end; i++)
    {
        rowKey = this.m_nodeSet1.getMetadata(i)['key'];
        if (key === rowKey)
        {
            return i;
        }
    }

    // if the point cannot be found, the merge happens at the end
    return (end-1);
};

/**
 * Gets the parent
 * @return {Object} the key of the parent.
 * @export
 */
oj.MergedNodeSet.prototype.getParent = function()
{
    // returns the parent of the top node set
    return this.m_nodeSet1.getParent();
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.  
 * @export
 */
oj.MergedNodeSet.prototype.getStart = function()
{
    // returns the start of the top node set
    return this.m_nodeSet1.getStart();
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.MergedNodeSet.prototype.getCount = function()
{
    // return the total count of both node sets
    return this.m_nodeSet1.getCount() + this.m_nodeSet2.getCount();
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.
 * @export
 */
oj.MergedNodeSet.prototype.getData = function(index)
{
    var result, set, relIndex;

    result = this._getRelativeIndex(index);
    set = result['set'];
    relIndex = result['index'];

    return set.getData(relIndex);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) state - state of the node, valid values are 'expanded', 'collapsed', 'leaf'. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.MergedNodeSet.prototype.getMetadata = function(index)
{
    var result, set, relIndex;

    result = this._getRelativeIndex(index);
    set = result['set'];
    relIndex = result['index'];

    return set.getMetadata(relIndex);
};

/**
 * Calculate the relative index to the appropriate node set based on where the
 * merge point is.
 * @private
 */
oj.MergedNodeSet.prototype._getRelativeIndex = function(index)
{
    if (index <= this.m_mergeAt)
    {
        return {'set': this.m_nodeSet1, 'index': index};
    }
    else
    {
        var count = this.m_nodeSet2.getCount();
        var end = this.m_mergeAt + count;
        if (index > end)
        {
            // first set
            return {'set': this.m_nodeSet1, 'index': index - count};
        }   
        else
        {
            // second set
            return {'set': this.m_nodeSet2, 'index': index - (this.m_mergeAt+1)};
        }
    }
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * Wraps around the NodeSet to provide additional metadata
 * @param {Object} nodeSet the node set to wrap
 * @param {function(Object, Object)} metadataCallback callback to inject additional metadata information
 * @param {Object=} range the requested range
 * @constructor
 * @export
 */
oj.NodeSetWrapper = function(nodeSet, metadataCallback, range)
{
    this.m_nodeSet = nodeSet;
    this.m_callback = metadataCallback;
    this.m_range = range;
};

/**
 * Gets the parent
 * @return {Object} the key of the parent.
 * @export
 */
oj.NodeSetWrapper.prototype.getParent = function()
{
    return this.m_nodeSet.getParent();
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.  
 * @export
 */
oj.NodeSetWrapper.prototype.getStart = function()
{
    // if the requested start is a subset of the result set, adjust
    // accordingly
    if (this.m_range != null)
    {
        return this.m_range['start'];
    }
    else
    {
        return this.m_nodeSet.getStart();
    }
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.NodeSetWrapper.prototype.getCount = function()
{
    var nodeStart, nodeCount;

    nodeStart = this.m_nodeSet.getStart();
    nodeCount = this.m_nodeSet.getCount();

    // if the requested start is a subset of the NodeSet, adjust
    // accordingly
    if (this.m_range != null)
    {
        if (this.m_range['start'] > nodeStart)
        {
            nodeCount = Math.min(0, nodeCount - (this.m_range['start'] - nodeStart));
        }
        else if (this.m_range['start'] < nodeStart)
        {
            // this is an invalid NodeSet, so just return 0
            nodeCount = 0;
        }
    }

    return nodeCount;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.
 * @export
 */
oj.NodeSetWrapper.prototype.getData = function(index)
{
    return this.m_nodeSet.getData(index);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) state - state of the node, valid values are 'expanded', 'collapsed', 'leaf'. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.NodeSetWrapper.prototype.getMetadata = function(index)
{
    var metadata, rowKey;

    metadata = this.m_nodeSet.getMetadata(index);
    metadata['index'] = index;
    metadata['parentKey'] = this.getParent();
    rowKey = metadata['key'];

    // inject additional metadata
    this.m_callback.call(null, rowKey, metadata);

    return metadata;
};

/**
 * Gets the node set child of the specified index.
 * @param {number} index the index of the node/row in which we want to retrieve the child node set
 * @return {Object|null} the child node set representing the child tree data.
 * @export
 */
oj.NodeSetWrapper.prototype.getChildNodeSet = function(index) 
{
    var result;
    if (this.m_nodeSet.getChildNodeSet)
    {
        result = this.m_nodeSet.getChildNodeSet(index);
        if (result != null)
        {
            // wraps the child nodeset too
            return new oj.NodeSetWrapper(result, this.m_callback);
        }
    }
    return null;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * A JsonNodeSet represents a collection of nodes.  The JsonNodeSet is an object returned by the success callback
 * of the fetchChildren method on TreeDataSource.  
 * @constructor
 * @export
 */
oj.JsonNodeSet = function(startNode, endNode, data, currKey, depth)
{
    // assert startNode/endNode are number
    oj.Assert.assertNumber(startNode, null);
    oj.Assert.assertNumber(endNode, null);

    this.m_depth = depth;
    this.m_key = currKey;
    this.m_startNode = startNode;
    this.m_endNode = endNode;
    this.m_nodes = data;
};

/**
 * Gets the parent key for this result set.  
 * @return {Object} the parent key for this result set. 
 * @export
 */
oj.JsonNodeSet.prototype.getParent = function()
{
    return this.m_key;
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.
 * @export	
 */
oj.JsonNodeSet.prototype.getStart = function()
{
    return this.m_startNode;
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.
 * @export	
 */
oj.JsonNodeSet.prototype.getCount = function()
{
    return Math.max(0, this.m_endNode - this.m_startNode);
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.  oj.RowData should be returned for data that represents a row
 *         with a number of columns.
 * @export
 */
oj.JsonNodeSet.prototype.getData = function(index)
{
    // make sure index are valid
    oj.Assert.assert(index <= this.m_endNode && index >= this.m_startNode);

    // adjust to relative index
    index = index - this.m_startNode;

    if (this.m_nodes[index])
        return this.m_nodes[index].attr;
    else
        return null;
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) leaf - boolean, true if it's a leaf, false otherwise. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.JsonNodeSet.prototype.getMetadata = function(index)
{
    var metadata = [];

    // make sure index are valid
    oj.Assert.assert(index <= this.m_endNode && index >= this.m_startNode);

    // adjust to relative index
    index = index - this.m_startNode;

    metadata["key"] = this.m_nodes[index].id ? this.m_nodes[index].id : this.m_nodes[index].attr.id;
    metadata["leaf"] = this.m_nodes[index].leaf;
    metadata["depth"] = this.m_nodes[index].depth;

    if(metadata["leaf"] == null)
    {
        if (this.m_nodes[index].children && this.m_nodes[index].children.length > 0)
        {
            metadata["leaf"] = false;
        }
        else
        {
            metadata["leaf"] = true;
        }
    }

    return metadata;
};

/**
 * Helper method to update the node's depth recursively with its children.
 * @param {Object} currChild the node to update.
 * @param {number} offset the difference between current and updated depth values.
 * @private
 */
oj.JsonNodeSet.prototype._updateDepth = function (currChild, offset)
{
    var i;

    offset++;
    currChild.depth = offset;

    if (currChild.children && currChild.children.length != 0)
    {
        for (i = 0; i < currChild.children.length; i++)
	{
            this._updateDepth(currChild.children[i], offset);
	}
    }
};

/**
 * Gets the node set child of the specified index.
 * @param {number} index the index of the node/row in which we want to retrieve the child node set
 * @return {oj.JsonNodeSet|null} the child node set representing the child tree data.
 * @export
 */
oj.JsonNodeSet.prototype.getChildNodeSet = function(index) {

    var results, key, depth, i;

    // make sure index are valid
    oj.Assert.assert(index <= this.m_endNode && index >= this.m_startNode);

    // adjust to relative index
    index = index - this.m_startNode;

    depth = this.m_nodes[index].depth;
    results = this.m_nodes[index].children;
    if(results.length == 0)
    {
        return null;
    }
    key = this.m_nodes[index].id ? this.m_nodes[index].id : this.m_nodes[index].attr.id;
    for(i = 0; i < results.length; i++)
    {
        this._updateDepth(results[i], depth);
    }

    return new oj.JsonNodeSet(0, results.length, results, key, 0);
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * Flattens a hierarchical node set, which can happen in node set returned from
 * fetchDescendants call.
 * @param {Object} nodeSet the node set to flatten
 * @param {number=} actualStart in the fetch descendant case the result set would
 *        be a subset of the node set.  This param gives the exact start index in the
 *        wrapped node set where the result should start.
 * @constructor
 * @export
 */
oj.FlattenedNodeSet = function(nodeSet, actualStart)
{
    this.m_nodeSet = nodeSet;
    this.m_start = actualStart;
};

/**
 * Gets the parent
 * @return {Object} the key of the parent.
 * @export
 */
oj.FlattenedNodeSet.prototype.getParent = function()
{
    return this.m_nodeSet.getParent();
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.  
 * @export
 */
oj.FlattenedNodeSet.prototype.getStart = function()
{
    // if explicit start index is specified, use it, otherwise
    // delegate to wrapped node set
    if (this.m_start != undefined)
    {
        return this.m_start;
    }
    else
    {
        return this.m_nodeSet.getStart();
    }
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.FlattenedNodeSet.prototype.getCount = function()
{
    // see if it's calculated already
    if (this.m_count === undefined)
    {
        this.m_count = this._getCount(this.m_nodeSet, 0);

        // if explicit start is specified (subset), need to take that into
        // account when calculating total count
        if (this.m_start != undefined)
        {
            this.m_count = this.m_count - this.m_start;
        }
    }

    return this.m_count;
};

/**
 * Recursive function to calculate the total number of nodes in the node set.
 * @param {Object} nodeSet the node set to calculate count
 * @param {number} total the total number of nodes so far 
 * @return {number} the total number of nodes
 * @private
 */
oj.FlattenedNodeSet.prototype._getCount = function(nodeSet, total)
{
    var start, count, i, child;

    start = nodeSet.getStart();
    count = nodeSet.getCount();
    total = total + count;

    // if there's child node set
    if (nodeSet.getChildNodeSet)
    {
        for (i=0; i<count; i++)
        {
            child = nodeSet.getChildNodeSet(i+start);
            if (child != null)
                total = this._getCount(child, total); 
        }
    }

    return total;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.
 * @export
 */
oj.FlattenedNodeSet.prototype.getData = function(index)
{
    return this._getDataOrMetadata(this.m_nodeSet, index, {'index': this.m_nodeSet.getStart()}, this._getData);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) state - state of the node, valid values are 'expanded', 'collapsed', 'leaf'. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.FlattenedNodeSet.prototype.getMetadata = function(index)
{
    return this._getDataOrMetadata(this.m_nodeSet, index, {'index': this.m_nodeSet.getStart()}, this._getMetadata);
};

/**
 * Callback function to retrieve metadata of specified index in node set
 * @param {Object} nodeSet the node set to retrieve metadata from
 * @param {number} index the index to retrieve metadata from
 * @return {Object} the metadata
 * @private
 */
oj.FlattenedNodeSet.prototype._getMetadata = function(nodeSet, index)
{
    return nodeSet.getMetadata(index);
};

/**
 * Callback function to retrieve data of specified index in node set
 * @param {Object} nodeSet the node set to retrieve data from
 * @param {number} index the index to retrieve data from
 * @return {Object} the data
 * @private
 */
oj.FlattenedNodeSet.prototype._getData = function(nodeSet, index)
{
    return nodeSet.getData(index);
};

/**
 * Retrieve data or metadata (depending on callback function) from the node set
 * @param {Object} nodeSet the node set to retrieve data from
 * @param {number} index the index to retrieve data from
 * @param {Object} current contains the current index keep track by the method
 * @param {function(Object, number)} func the callback function to retrieve data or metadata
 * @return {Object} the data or metadata
 * @private
 */
oj.FlattenedNodeSet.prototype._getDataOrMetadata = function(nodeSet, index, current, func)
{
    var start, count, i, currIndex, child, result;

    // walk the node set recursively until we found the index
    start = nodeSet.getStart();
    count = nodeSet.getCount();
    for (i=0; i<count; i++)
    {
        currIndex = current['index'];
        // found the index
        if (currIndex === index)
            return func.call(this, nodeSet, i+start);

        current['index'] = currIndex+1;
        // if there's child node set
        if (nodeSet.getChildNodeSet)
        {
            child = nodeSet.getChildNodeSet(i+start);
            if (child != null)
            {
                result = this._getDataOrMetadata(child, index, current, func); 
                if (result != null)
                    return result;
            }
        }
    }       

    return null;
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * The base class for DataGridDataSource.  
 * @export
 * @extends oj.DataSource
 * @constructor
 */
oj.DataGridDataSource = function(data)
{
    // oj.DataSource would calls Init
    oj.DataGridDataSource.superclass.constructor.call(this, data);
};

// Subclass DataGridDataSource to DataSource
oj.Object.createSubclass(oj.DataGridDataSource, oj.DataSource, "oj.DataGridDataSource");

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.DataGridDataSource.prototype.getCount = function(axis)
{
    return 0;
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "exact" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "exact".
 * @export
 */
oj.DataGridDataSource.prototype.getCountPrecision = function(axis)
{
    return "exact";
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.DataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRange Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRange.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRange.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRange.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.DataGridDataSource.prototype.fetchCells = function(cellRange, callbacks, callbackObjects)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object} a Promise object which when resolved returns an object containing the keys for each axis
 * @export
 */
oj.DataGridDataSource.prototype.keys = function(indexes)
{
    oj.Assert.failedInAbstractFunction();
    return null;
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object} a Promise object which when resolved returns an object containing the index for each axis
 * @export
 */
oj.DataGridDataSource.prototype.indexes = function(keys)
{
    oj.Assert.failedInAbstractFunction();
    return null;
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.  Specifies null to reset sort state.
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.DataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Moves a row from one location to another.
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {string} position The position of the moved row relative to the reference row.  
 *        Valid values are: "before", "after" 
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */ 
oj.DataGridDataSource.prototype.move = function(rowToMove, referenceRow, position, callbacks, callbackObjects)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Checks whether a move operation is valid.
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {string} position The position of the moved row relative to the reference row.  
 *        Valid values are: "before", "after".
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @export
 */ 
oj.DataGridDataSource.prototype.moveOK = function(rowToMove, referenceRow, position)
{
    return "valid";
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none", "row", "column".  
 *         For "move", the valid return values are: "row", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 */
oj.DataGridDataSource.prototype.getCapability = function(feature)
{
    return null;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * The base class for PagingDataSource.
 * @export
 * @class oj.PagingDataSource
 * @classdesc Decorator for DataSource to enable paging functionality to be used by the paging control.
 * @param {Object} dataSource
 * @param {Object|null} options Array of options for the PagingControlDataSource
 * @constructor
 */
oj.PagingDataSource = function(dataSource, options)
{
  this.dataSource = dataSource;
  this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.PagingDataSource, oj.DataSource, "oj.PagingDataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.PagingDataSource.prototype.Init = function()
{
  oj.PagingDataSource.superclass.Init.call(this);
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 *                  success: a user callback called when the fetch has completed successfully. The callback is called passing the PagingDataSource object and the fetch options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the PagingDataSource object and the fetch options argument.<p>
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.fetch = function(options)
{
  oj.Assert.failedInAbstractFunction();
  return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.next = function()
{
  oj.Assert.failedInAbstractFunction();
  return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @return {Promise} promise object triggering done when complete..
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.previous = function()
{
  oj.Assert.failedInAbstractFunction();
  return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 */
oj.PagingDataSource.prototype.setPageSize = function(n)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * @export
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.startIndex = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.size = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.totalSize = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Event types
 * @enum {string}
 */
oj.PagingDataSource.EventType =
  {
    /** Triggered when a Row is added to a PagingDataSource */
    'ADD': "add",
    /** Triggered when a Row is removed from a PagingDataSource */
    'REMOVE': "remove",
    /** Triggered when a PagingDataSource is reset */
    'RESET': "reset",
    /** Triggered when a PagingDataSource has been updated by a fetch */
    'SYNC': "sync",
    /** Triggered when a PagingDataSource has been refreshed */
    'REFRESH': "refresh",
    /** Triggered when a PagingDataSource has been sorted */
    'SORT': "sort"
  };

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * The ojPagingControl component provides paging functionality.
 * 
 * <h3>Events:</h3>
 * <ul>
 * </ul>
 * 
 * @example  <caption>Initialize the paging control via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="paging" data-bind="ojComponent: {component: 'ojPagingControl', data: pagingDatasource, pageSize: 10}"&gt;
 *     
 * 
 * @class
 * @constructor
 * @name oj.ojPagingControl
 * @augments oj.baseComponent
 */
(function() {
  oj.__registerWidget("oj.ojPagingControl", $['oj']['baseComponent'],
    {
      version: '1.0.0',
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',
      options:
        {
          /** 
           * The data to bind to the component.
           * <p>
           * Must be of type oj.PagingDataSource {@link oj.PagingDataSource} 
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @type {oj.PagingDataSource}
           * @default <code class="prettyprint">null</code>
           */
          data: null,
          /** 
           * Options for when the component width is too narrow to accomodate specified controls
           * <p>
           * Valid values are:
           * <ul>
           *   <li>fit: Display as many controls as can fit in the component width</li>
           *   <li>none: Display all specified controls. Controls which cannot fit will be truncated.</li>
           * </ul>
           * <p>
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @type {string}
           * @default <code class="prettyprint">fit</code>
           */
          overflow: 'fit',
          /** 
           * Page size.
           * <p>
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @type {number}
           * @default <code class="prettyprint">25</code>
           */
          pageSize: 25,
          /** 
           * Options for page mode. 
           * <p>
           * Supported options are:
           * <ul>
           *   <li>layout: Array of paging navigation controls to be displayed.
           *   <ul>Valid array values are:
           *     <li>auto: Component decides which controls to display</li>
           *     <li>all: Display all controls</li>
           *     <li>input: Display the page input control</li>
           *     <li>rangeText: Display the page range text control</li>
           *     <li>pages: Display the page links</li>
           *     <li>nav: Display the navigation arrows</li>
           *   </ul>
           *   </li>
           *   <li>maxPageLinks: The maximum number of page links to display. 
           *   An ellipsis '...' will be displayed for pages which exceed the maximum.
           *   maxPageLinks must be greater than 4.</li>
           * </ul>
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @type {Object.<string, Array|number>}
           * @property {Array} layout Array of paging navigation controls to be displayed
           * @property {number} maxPageLinks The maximum number of page links to display
           * @default <code class="prettyprint">{layout: ['auto'], maxPageLinks: 6}</code>
           * @example <caption>Initialize the paging control with the <code class="prettyprint">pageOptions</code> option specified:</caption>
           * &lt;div id="paging" data-bind="ojComponent: {component: 'ojPagingControl', data: pagingDatasource, pageSize: 10, pageOptions: {layout: ['auto', 'input', 'rangeText'], maxPageLinks: 8}}"&gt;
           */
          pageOptions: {'layout': ['auto'], 'maxPageLinks': 6},
          /** 
           * Options for loadMore mode. 
           * <p>
           * Supported options are:
           * <ul>
           *   <li>maxCount: Integer</li>
           * </ul> 
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @type {Object.<string, number>}
           * @property {number} maxCount The maximum number items to display
           * @default <code class="prettyprint">{maxCount: 500}</code>
           */
          loadMoreOptions: {'maxCount': 500},
          /** 
           * Paging mode. 
           * <p>
           * Valid values are:
           * <ul>
           *   <li>page: Display paging control in pagination mode</li>
           *   <li>loadMore: Display paging control in high watermark mode</li>
           * </ul>
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @type {string}
           * @default <code class="prettyprint">page</code>
           */
          mode: 'page',
          /** 
           * Translations for the component
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @type {Object.<string, string>}
           * @property {string} labelAccPaging Paging control label for screen readers
           * @property {string} labelAccNavFirstPage First page label for screen readers
           * @property {string} labelAccNavLastPage Last page label for screen readers
           * @property {string} labelAccNavNextPage Next page label for screen readers
           * @property {string} labelAccNavPreviousPage Previous page label for screen readers
           * @property {string} labelAccNavPage Current page label for screen readers
           * @property {string} labelLoadMore Load more link text
           * @property {string} labelNavInputPage Current page label
           * @property {string} labelNavInputPageMax Maximum page label
           * @property {string} labelNavInputPageSummary Page item summary
           * @property {string} msgItemRange Item range text for known row count
           * @property {string} msgItemRangeUnknown Item range text for unknown row count
           * @property {string} tipNavInputPage Current page tip
           * @property {string} tipNavPageLink Current page link tip 
           * @property {string} tipNavNextPage Next page button tip
           * @property {string} tipNavPreviousPage Previous page button tip
           * @property {string} tipNavFirstPage First page button tip
           * @property {string} tipNavLastPage Last page button tip
           */
          translations: {}
        },
      /**
       * @private
       * @const
       */
      _BUNDLE_KEY:
        {
          _LABEL_ACC_PAGING:                              'labelAccPaging',
          _LABEL_ACC_NAV_FIRST_PAGE:                      'labelAccNavFirstPage',
          _LABEL_ACC_NAV_LAST_PAGE:                       'labelAccNavLastPage',
          _LABEL_ACC_NAV_NEXT_PAGE:                       'labelAccNavNextPage',
          _LABEL_ACC_NAV_PREVIOUS_PAGE:                   'labelAccNavPreviousPage',
          _LABEL_ACC_NAV_PAGE:                            'labelAccNavPage',
          _LABEL_LOAD_MORE:                               'labelLoadMore',
          _LABEL_NAV_INPUT_PAGE:                          'labelNavInputPage',
          _LABEL_NAV_INPUT_PAGE_MAX:                      'labelNavInputPageMax',
          _LABEL_NAV_INPUT_PAGE_SUMMARY:                  'labelNavInputPageSummary',
          _MSG_ITEM_RANGE:                                'msgItemRange',
          _MSG_ITEM_RANGE_UNKNOWN:                        'msgItemRangeUnknown',
          _TIP_NAV_INPUT_PAGE:                            'tipNavInputPage',
          _TIP_NAV_PAGE_LINK:                             'tipNavPageLink',
          _TIP_NAV_NEXT_PAGE:                             'tipNavNextPage',
          _TIP_NAV_PREVIOUS_PAGE:                         'tipNavPreviousPage',
          _TIP_NAV_FIRST_PAGE:                            'tipNavFirstPage',
          _TIP_NAV_LAST_PAGE:                             'tipNavLastPage',
          _ERR_PAGE_INVALID_SUMMARY:                      'pageInvalid.summary',
          _ERR_PAGE_INVALID_DETAIL:                       'pageInvalid.detail',
          _ERR_DATA_INVALID_TYPE_SUMMARY:                 'dataInvalidType.summary',
          _ERR_DATA_INVALID_TYPE_DETAIL:                  'dataInvalidType.detail',
          _ERR_MAXPAGELINKS_INVALID_SUMMARY:              'maxPageLinksInvalid.summary',
          _ERR_MAXPAGELINKS_INVALID_DETAIL:               'maxPageLinksInvalid.detail'
        },
      /**
       * @private
       * @const
       */
      _MARKER_STYLE_CLASSES:
        {
          _WIDGET:                                        'oj-component',
          _ACTIVE:                                        'oj-active',
          _CLICKABLE_ICON:                                'oj-clickable-icon',
          _DISABLED:                                      'oj-disabled',
          _ENABLED:                                       'oj-enabled',
          _FOCUS:                                         'oj-focus',
          _HOVER:                                         'oj-hover',
          _SELECTED:                                      'oj-selected'
        },
      /**
       * @private
       * @const
       */
      _CSS_CLASSES:
        {
          _PAGING_CONTROL_CLASS:                          'oj-pagingcontrol',
          _PAGING_CONTROL_ACC_LABEL_CLASS:                'oj-pagingcontrol-acc-label',
          _PAGING_CONTROL_CONTENT_CLASS:                  'oj-pagingcontrol-content',
          _PAGING_CONTROL_LOAD_MORE_CLASS:                'oj-pagingcontrol-loadmore',
          _PAGING_CONTROL_LOAD_MORE_LINK_CLASS:           'oj-pagingcontrol-loadmore-link',
          _PAGING_CONTROL_LOAD_MORE_RANGE_CLASS:          'oj-pagingcontrol-loadmore-range',
          _PAGING_CONTROL_NAV_CLASS:                      'oj-pagingcontrol-nav',
          _PAGING_CONTROL_NAV_ARROW_CLASS:                'oj-pagingcontrol-nav-arrow',
          _PAGING_CONTROL_NAV_ARROW_SECTION_CLASS:        'oj-pagingcontrol-nav-arrow-section',
          _PAGING_CONTROL_NAV_PAGE_CLASS:                 'oj-pagingcontrol-nav-page',
          _PAGING_CONTROL_NAV_PAGE_ACC_LABEL_CLASS:       'oj-pagingcontrol-nav-page-acc-label',
          _PAGING_CONTROL_NAV_LABEL_CLASS:                'oj-pagingcontrol-nav-label',
          _PAGING_CONTROL_NAV_INPUT_SECTION_CLASS:        'oj-pagingcontrol-nav-input-section',
          _PAGING_CONTROL_NAV_INPUT_CLASS:                'oj-pagingcontrol-nav-input',
          _PAGING_CONTROL_NAV_INPUT_MAX_CLASS:            'oj-pagingcontrol-nav-input-max',
          _PAGING_CONTROL_NAV_INPUT_SUMMARY_CLASS:        'oj-pagingcontrol-nav-input-summary',
          _PAGING_CONTROL_NAV_PAGES_SECTION_CLASS:        'oj-pagingcontrol-nav-pages-section',
          _PAGING_CONTROL_NAV_PAGES_LINKS_CLASS:          'oj-pagingcontrol-nav-pages-links',
          _PAGING_CONTROL_NAV_FIRST_CLASS:                'oj-pagingcontrol-nav-first',
          _PAGING_CONTROL_NAV_FIRST_ACC_LABEL_CLASS:      'oj-pagingcontrol-nav-first-acc-label',
          _PAGING_CONTROL_NAV_PREVIOUS_CLASS:             'oj-pagingcontrol-nav-previous',
          _PAGING_CONTROL_NAV_PREVIOUS_ACC_LABEL_CLASS:   'oj-pagingcontrol-nav-previous-acc-label',
          _PAGING_CONTROL_NAV_NEXT_CLASS:                 'oj-pagingcontrol-nav-next',
          _PAGING_CONTROL_NAV_NEXT_ACC_LABEL_CLASS:       'oj-pagingcontrol-nav-next-acc-label',
          _PAGING_CONTROL_NAV_LAST_CLASS:                 'oj-pagingcontrol-nav-last',
          _PAGING_CONTROL_NAV_LAST_ACC_LABEL_CLASS:       'oj-pagingcontrol-nav-last-acc-label',
          _PAGING_CONTROL_NAV_FIRST_ICON_CLASS:           'oj-pagingcontrol-nav-first-icon',
          _PAGING_CONTROL_NAV_PREVIOUS_ICON_CLASS:        'oj-pagingcontrol-nav-previous-icon',
          _PAGING_CONTROL_NAV_NEXT_ICON_CLASS:            'oj-pagingcontrol-nav-next-icon',
          _PAGING_CONTROL_NAV_LAST_ICON_CLASS:            'oj-pagingcontrol-nav-last-icon',
          _WIDGET_ICON_CLASS:                             'oj-component-icon',
          _HIDDEN_CONTENT_ACC_CLASS:                      'oj-helper-hidden-accessible'
        },
      /**
       * @private
       * @const
       * @type {string}
       */
      _DATA_ATTR_PAGE_NUM: 'data-oj-pagenum',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_ENABLED: 'enabled',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_DISABLED: 'disabled',
      /**
       * @private
       * @const
       */
      _MODE:
        {
          _LOAD_MORE:   'loadMore',
          _PAGE:        'page'
        },
      _PAGE_OPTION_LAYOUT:
        {
          _AUTO:  'auto',
          _ALL: 'all',
          _INPUT: 'input',
          _RANGE_TEXT: 'rangeText',
          _PAGES: 'pages',
          _NAV:   'nav'
        },
      /**** start Public APIs ****/

      /**
       * Load the first page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {Promise} promise object triggering done when complete.
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">firstPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "firstPage" );
       */
      'firstPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          this._startIndex = 0;
          return data.fetch({'startIndex': 0});
        }
        return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
      },
      /**
       * Load the previous page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {Promise} promise object triggering done when complete.
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">previousPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "previousPage" );
       */
      'previousPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          var page = this._getCurrentPage();
          // can only go to previous page if on 2nd page or greater
          if (page > 1)
          {
            this._startIndex = this._getStartIndexForPage(page - 1);
            if (this._startIndex < 0) {
                // Guard against walking too far "left"
                this._startIndex = 0;
            }
            return data.fetch({'startIndex': this._startIndex});
          }
        }
        return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
      },
      /**
       * Load the next page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {Promise} promise object triggering done when complete.
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">nextPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "nextPage" );
       */
      'nextPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          var page = this._getCurrentPage();
          if (page + 1 <= this._getTotalPages() || this._getTotalPages() < 0) 
          {
            this._startIndex = this._getStartIndexForPage(page + 1);
            return data.fetch({'startIndex': this._startIndex});
          }
        }
        return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
      },
      /**
       * Load the last page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {Promise} promise object triggering done when complete.
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">lastPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "lastPage" );
       */
      'lastPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          if (this._getTotalPages() > 0)
          {
            this._startIndex = this._getStartIndexForPage(this._getTotalPages());
            return data.fetch({'startIndex': this._startIndex});
          }
        }
        return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
      },
      /**
       * Load the specified page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @param {number} page  Page number. 
       * @return {Promise} promise object triggering done when complete.
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">page</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "page", 5 );
       */
      'page': function(page)
      {
        var data = this._getData();
        if (data != null)
        {
          if (this._getTotalPages() > 0) {
            this._startIndex = this._getStartIndexForPage(page);
            return data.fetch({'startIndex': this._startIndex});
          }
        }
        return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
      },
      /**
       * Load the next set of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {Promise} promise object triggering done when complete.
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">loadNext</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "loadNext" );
       */
      'loadNext': function()
      {
        var data = this._getData();
        if (data != null)
        {
          return data.next();
        }
        return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
      },
      /**
       * Refresh the paging control.
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @export
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "refresh" );
       */
      'refresh': function()
      {
        this._super();
        if (this._fetchTimer != null)
        {
          this._fetchTimer = null;
          var data = this._getData();
          if (data != null)
          {
            data.setPageSize(this.options['pageSize']);
            data.fetch({'startIndex': this._startIndex});
          }
        }
        this._refresh(true);
      },
      /**
       * Return the subcomponent node represented by the documented locator attribute values.
       * 
       * To lookup the paging control page number navigation input text:
       *          subId: 'oj-pagingcontrol-nav-input'
       *          
       * To lookup the paging control's current maximum page text:
       *          subId: 'oj-pagingcontrol-nav-input-max'
       *          
       * To lookup the paging control's current summary page text:
       *          subId: 'oj-pagingcontrol-nav-input-summary'
       *          
       * To lookup the paging control's first button:
       *          subId: 'oj-pagingcontrol-nav-first'
       *          
       * To lookup the paging control's next button:
       *          subId: 'oj-pagingcontrol-nav-next'
       *          
       * To lookup the paging control's previous button:
       *          subId: 'oj-pagingcontrol-nav-previous'
       *          
       * To lookup the paging control's last button:
       *          subId: 'oj-pagingcontrol-nav-last'
       *          
       * To lookup the paging control's page buttons:
       *          subId: 'oj-pagingcontrol-nav-page'
       *          index: page number
       *          
       * @override
       * @param {Object} locator An Object containing at minimum a subId property whose value is a string 
       * @return {Element|null} the subcomponent located by the subId string passed in locator, if found.
       * @export
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * 
       */
      'getNodeBySubId': function(locator)
      {
        if (locator == null)
        {
          return this.element ? this.element[0] : null;
        }

        var subId = locator['subId'];

        if (subId === 'oj-pagingcontrol-nav-input')
        {
          return this._getPagingControlNavInput();
        }
        else if (subId === 'oj-pagingcontrol-nav-input-max')
        {
            return this._getPagingControlContainer().find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_MAX_CLASS);
        }
        else if (subId === 'oj-pagingcontrol-nav-input-summary')
        {
            return this._getPagingControlContainer().find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SUMMARY_CLASS);
        }
        else if (subId === 'oj-pagingcontrol-nav-first')
        {
            return this._getPagingControlContainer().find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_CLASS);
        }
        else if (subId === 'oj-pagingcontrol-nav-next')
        {
            return this._getPagingControlContainer().find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_CLASS);
        }
        else if (subId === 'oj-pagingcontrol-nav-previous')
        {
            return this._getPagingControlContainer().find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_CLASS);
        }
        else if (subId === 'oj-pagingcontrol-nav-last')
        {
            return this._getPagingControlContainer().find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_CLASS);
        }
        else if (subId === 'oj-pagingcontrol-nav-page')
        {
            var index = locator['index'];
            return this._getPagingControlContainer().find("[" + this._DATA_ATTR_PAGE_NUM + "=" + index +"]");
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },              
      
      /**** end Public APIs ****/

      /**** start internal widget functions ****/
      
      /**
       * @override
       * @protected
       * @instance
       * @memberof! oj.ojPagingControl
       */
      _ComponentCreate : function ()
      {
        this._super();
        this._registerDataSourceEventListeners();
        this._draw();
        this._registerResizeListener(this._getPagingControlContainer());
        this._on(this._events);
        
        var self = this;
        setInterval(
          function()
          {
            if (self._refreshTimer != null)
            {
              self._refreshInternal();
              self._refreshTimer = null;
            }
        }, 50);
        setInterval(
          function()
          {
            if (self._fetchTimer != null)
            {
              var data = self._getData();
              if (data != null)
              {
                data.setPageSize(self.options['pageSize']);
                data.fetch({'startIndex': self._startIndex});
                self._fetchTimer = null;
              }
            }
        }, 100);
      },
      /**
       * @override
       * @private
       */
      _destroy: function()
      {
        this._unregisterDataSourceEventListeners();
      },
      /**
       * @override
       * @private
       */
      _draw: function()
      {
        var options = this.options;
        // add main css class to element
        this.element.addClass(this._CSS_CLASSES._PAGING_CONTROL_CLASS);
        this.element.addClass(this._MARKER_STYLE_CLASSES._WIDGET);
        this._startIndex = 0;

        this._createPagingControlAccLabel();
        this._createPagingControlContent();
        if (options['mode'] == this._MODE._LOAD_MORE)
        {
          this._createPagingControlLoadMore();
          this._createPagingControlLoadMoreLink();
          this._createPagingControlLoadMoreRange();
        }
        else
        {
          this._createPagingControlNav();
        }
      },
      /**
       * @override
       * @private
       */
      _events:
        {
          /**
           * invoke loading next page of data
           */
          'click .oj-pagingcontrol-loadmore-link': function(event)
          {
            this['loadNext']();
            event.preventDefault();
          },
          /**
           * invoke loading page of data
           */
          'click .oj-pagingcontrol-nav-page': function(event)
          {
            var pageNum = $(event.target).attr('data-oj-pagenum');
            this['page'](pageNum);  
            event.preventDefault();
          },
          /**
           * invoke loading first page of data
           */
          'click .oj-pagingcontrol-nav-first': function(event)
          {
            this['firstPage']();
            event.preventDefault();
          },
          /**
           * invoke loading previous page of data
           */
          'click .oj-pagingcontrol-nav-previous': function(event)
          {
            this['previousPage']();
            event.preventDefault();
          },
          /**
           * invoke loading next page of data
           */
          'click .oj-pagingcontrol-nav-next': function(event)
          {
            this['nextPage']();
            event.preventDefault();
          },
          /**
           * invoke loading last page of data
           */
          'click .oj-pagingcontrol-nav-last': function(event)
          {
            this['lastPage']();
            event.preventDefault();
          },
          /**
           * prevent submission of form on enter
           */
          'keypress .oj-pagingcontrol-nav-input': function(event)
          {
            var keyCode = event.which;
            
            if (keyCode == 13)
            {
              event.preventDefault();
            }
          },
          /**
           * Add oj-active
           */
          'mousedown .oj-pagingcontrol-nav-first': function(event)
          {
            $(event.target).addClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Add oj-active
           */
          'mousedown .oj-pagingcontrol-nav-previous': function(event)
          {
            $(event.target).addClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Add oj-active
           */
          'mousedown .oj-pagingcontrol-nav-next': function(event)
          {
            $(event.target).addClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Add oj-active
           */
          'mousedown .oj-pagingcontrol-nav-last': function(event)
          {
            $(event.target).addClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseup .oj-pagingcontrol-nav-first': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseup .oj-pagingcontrol-nav-previous': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseup .oj-pagingcontrol-nav-next': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseup .oj-pagingcontrol-nav-last': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseleave .oj-pagingcontrol-nav-first': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseleave .oj-pagingcontrol-nav-previous': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseleave .oj-pagingcontrol-nav-next': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          },
          /**
           * Remove oj-active
           */
          'mouseleave .oj-pagingcontrol-nav-last': function(event)
          {
            $(event.target).removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            event.preventDefault();
          }
        },
      /**
       * @param {boolean} immediate  refresh immediately
       * @private
       */
      _refresh: function(immediate)
      {
        if (immediate)
        {
          this._refreshInternal();
        }
        else
        {
          this._refreshTimer = true;
        }
      },
      /**
       * @override
       * @private
       */
      _refreshInternal: function()
      {
        if (this._data != this.options['data'])
        {
          this._clearCachedDataMetadata();
          this._fetchTimer = true;
        }
        
        if (this.options['mode'] == this._MODE._LOAD_MORE)
        {
          // hide loadMore if there are no more rows to fetch
          var data = this._getData();
          var pagingControlLoadMore = this._getPagingControlLoadMore();
          if (data != null && data.size() == data.totalSize())
          {
            pagingControlLoadMore.css('display', 'none');
          }
          else
          {
            pagingControlLoadMore.css('display', '');
            this._refreshPagingControlLoadMoreRange();
          }
        }
        else
        {
          this._refreshPagingControlNav();
        }
      },
      /**
       * @override
       * @private
       */
      _setOption: function(key, value)
      {
        this._superApply(arguments);
        this._fetchTimer = true;
        this._refresh(true);
      },
      /**** end internal widget functions ****/

      /**** start internal functions ****/
      /**
       * Clear any cached data metadata
       * @private
       */
      _clearCachedDataMetadata: function()
      {
        if (this._data != null)
        {
          this._unregisterDataSourceEventListeners();
        }
        this._data = null;
        this._startIndex = 0;
      },
      /**
       * Clear cached range text DOM
       * @private
       */
      _clearCachedDomLoadMoreRange: function()
      {
        this._cachedDomPagingControlLoadMoreRange = null;
      },
      /**
       * Clear any cached DOM nav elements
       * @private
       */
      _clearCachedDomPagingControlNav: function()
      {
        this._cachedDomPagingControlNav = null;
        this._cachedDomPagingControlNavInput = null;
        this._cachedDomPagingControlNavInputSummary = null;
      },
      /**
       * Return the current page
       * @return {number} Current page.
       * @throws {Error}
       * @private
       */
      _getCurrentPage: function()
      {
        if (this._startIndex == 0)
        {
          return 1;
        }
        return Math.ceil((this._startIndex + 1) / this.options['pageSize']);
      },
      /**
       * Return the datasource object defined for this paging control
       * @return {Object} Datasource object.
       * @throws {Error}
       * @private
       */
      _getData: function()
      {
        if (!this._data && this.options['data'] != null)
        {
          var data = this.options['data'];
          if (data instanceof oj.PagingDataSource)
          {
            this._data = data;
          }
          else
          {
            var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_DATA_INVALID_TYPE_SUMMARY);
            var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_DATA_INVALID_TYPE_DETAIL);
            throw new Error(errSummary + '\n' + errDetail);
          }
          this._data.setPageSize(this.options['pageSize']);
          this._dataMetadata = this.options['data'];
          // In case we get a delayed setting of the data property--check to rebind the listeners
          this._registerDataSourceEventListeners();
          var self = this;
          setTimeout(function(){self._initFetch()}, 0);
        }
        return this._data;
      },
      /**
       * Return the item range text
       * @return {String} Item range text.
       * @throws {Error}
       * @private
       */
      _getItemRangeText: function()
      {
        var data = this._getData();
        var pageFrom = this._startIndex;
        var itemRangeText = this.getTranslatedString(this._BUNDLE_KEY._MSG_ITEM_RANGE, {'pageFrom': pageFrom, 'pageTo': 0, 'pageTotal': 0});
        if (data != null)
        {
          var pageTo = parseInt(this._startIndex, 10) + parseInt(data.size(), 10);
          pageFrom = pageTo > 0 ? pageFrom + 1 : 0;
          if (data.totalSize() != -1)
          {
            pageTo = pageTo > data.totalSize() ? data.totalSize() : pageTo;
            itemRangeText = this.getTranslatedString(this._BUNDLE_KEY._MSG_ITEM_RANGE, {'pageFrom': pageFrom, 'pageTo': pageTo, 'pageTotal': data.totalSize()});
          }
          else
          {
            itemRangeText = this.getTranslatedString(this._BUNDLE_KEY._MSG_ITEM_RANGE_UNKNOWN, {'pageFrom': pageFrom, 'pageTo': pageTo});
          }
        }
        return itemRangeText;
      },
      /**
       * Return maximum number of page links
       * @return {number} Max page links.
       * @private
       */
      _getMaxPageLinks: function()
      {
        var maxPageLinks = this.options['pageOptions']['maxPageLinks'];
        return maxPageLinks;
      },
      /**
       * Return the start index for the page
       * @param {number} page page number.
       * @return {number} start index.
       * @throws {Error}
       * @private
       */
      _getStartIndexForPage: function(page)
      {
        var startIndex = (page - 1) * this.options['pageSize'];
        var totalPages = this._getTotalPages();

        if (startIndex < 0)
        {
          oj.Logger.error('Value must be greater than 0');
        }
        else if (totalPages > 0 && page > totalPages)
        {
          oj.Logger.error('Value cannot be greater than the total number of pages');
        }
        return startIndex;
      },
      /**
       * Return the total number of pages
       * @return {number} Total pages.
       * @throws {Error}
       * @private
       */
      _getTotalPages: function()
      {
        var data = this._getData();
        var totalSize = 0;
        if (data != null)
        {
          totalSize = data.totalSize();
        }
        return totalSize == -1 ? -1 : Math.ceil(totalSize / this.options['pageSize']);
      },
      /**
       * Callback handler for fetch completed in the datasource.
       * status message.
       * @param {Object} event 
       * @private
       */
      _handleDataFetchEnd: function(event)
      {
        this._refresh();
      },
      /**
       * Callback handler for reset in the datasource.
       * status message.
       * @param {Object} event 
       * @private
       */
      _handleDataReset: function(event)
      {
        this._startIndex = 0;
        this._getData().setPageSize(this.options['pageSize']);        
        this._refresh(true);
        this._getData().fetch({'startIndex': this._startIndex, 'reset':true});        
      },
      /**
       * Callback handler for refresh in the datasource.
       * status message.
       * @param {Object} event 
       * @private
       */
      _handleDataRefresh: function(event)
      {
        this._refresh();
        this._getData().fetch({'startIndex': this._startIndex});        
      },
      /**
       * Callback handler for sort in the datasource.
       * status message.
       * @param {Object} event 
       * @private
       */
      _handleDataSort: function(event)
      {
        // Do a reset if the paging mode is loadmore, otherwise just refresh
        if (this.options['mode'] == this._MODE._LOAD_MORE) {
            this._handleDataReset(event);
        }
        else {
            this._handleDataRefresh(event);
        }
      },
      /**
       * Callback handler for row added into the datasource.
       * status message.
       * @param {Object} event
       * @private
       */
      _handleDataRowAdd: function(event)
      {
        if (this.options['mode'] == this._MODE._PAGE)
        {
          var data = this._getData();
          var totalSize = 0;
          if (data != null)
          {
            totalSize = data.totalSize();
          }
          var pageSize = this.options['pageSize'];
          var rowIdx = event.index;
          var currentPage = this._getCurrentPage();
          var startIndex = this._getStartIndexForPage(currentPage);

          if (startIndex != this._startIndex ||
              (rowIdx >= startIndex && (rowIdx < startIndex + pageSize) && totalSize > pageSize))
          {
            // this means that the add caused the pages to shift or
            // the row was added to the current page and the first page is full already
            // so we need to re-fetch the current page
            this._startIndex = startIndex;
            this._fetchTimer = true;
          }
        }
        this._refresh();
      },
      /**
       * Callback handler for row removed in the datasource.
       * status message.
       * @param {Object} event
       * @private
       */
      _handleDataRowRemove: function(event)
      {
        if (this._getTotalPages() <= 0)
        {
          this._startIndex = 0;
        }
        else if (this._getCurrentPage() > this._getTotalPages())
        {
          // if the number of pages decreased due to the removal, then
          // reset the startIndex
          this._startIndex = this._getStartIndexForPage(this._getTotalPages());
          this._fetchTimer = true;
        }
        if (this._getTotalPages() > 1)
        {
          this._fetchTimer = true;
        }
        this._refresh();
      },
      /**
       * Callback handler for page change.
       * @param {Object} event
       * @private
       */
      _handlePageChange: function(event, data)
      {
        try
        {
          if (data.value != this._getCurrentPage())
          {
            if (!isNaN(data.value) && data.value > 0)
            {
              this['page'](data.value);
            }
          }
        }
        catch (err)
        {
          var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_PAGE_INVALID_SUMMARY);
          var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_PAGE_INVALID_DETAIL);
          oj.Logger.error(errSummary + '\n' + errDetail);
        }
      },
      /**
       * Do an initial fetch
       * @private
       */
      _initFetch: function()
      {
        // do an initial fetch if there aren't enough rows to fill the first page
        // and there are more rows to fetch 
        if (this._getData() != null &&
            this._getData().size() < this.options['pageSize'] &&
            (this._getData().totalSize() < 0 || this._getData().totalSize() >= this._getData().size()))
        {
          this._getData().setPageSize(this.options['pageSize']);
          this._getData().fetch({'startIndex': this._startIndex, 'fetchType': 'init'});
        }
      },
      /**
       * @override
       * @private
       */
      _refreshPagingControlLoadMoreRange: function()
      {
        var pagingControlLoadMoreRange = this._getPagingControlLoadMoreRange();
        pagingControlLoadMoreRange[0].parentNode.removeChild(pagingControlLoadMoreRange[0]);
        this._createPagingControlLoadMoreRange();
        this._clearCachedDomLoadMoreRange();
      },
      /**
       * @override
       * @private
       */
      _refreshPagingControlNav: function()
      {
        var overflowOption = this.options['overflow'];
        var pagingControlContent = this._getPagingControlContent();
        pagingControlContent.empty();
        this._clearCachedDomPagingControlNav();
        this._createPagingControlNav();
        this._refreshPagingControlNavArrows();
        
        if (overflowOption == 'fit')
        {
          // dynamically hide controls based on available width
          var elementWidth = this.element.width();
          var pagingControlNavArrowSection = this._getPagingControlNavArrowSection();
          var pagingControlNavInputSection = this._getPagingControlNavInputSection();
          var pagingControlNavPageLinks = this._getPagingControlNavPageLinks();
          var pagingControlNavInputSummary = this._getPagingControlNavInputSummary();
          var pagingControlNavArrowSectionWidth = pagingControlNavArrowSection != null ? pagingControlNavArrowSection[0].offsetWidth:0;
          var pagingControlNavInputSectionWidth = pagingControlNavInputSection != null ? pagingControlNavInputSection[0].offsetWidth:0;
          var pagingControlNavPageLinksWidth = pagingControlNavPageLinks != null ? pagingControlNavPageLinks.width():0;
          var pagingControlNavInputSummaryWidth = pagingControlNavInputSummary != null ? pagingControlNavInputSummary.width():0;
          var pagingControlNavWidth = pagingControlNavArrowSectionWidth + pagingControlNavInputSectionWidth;
          
          if (pagingControlNavWidth > elementWidth)
          {
            if (pagingControlNavWidth 
                - pagingControlNavPageLinksWidth <= elementWidth)
            {
              // hide only the page links
              pagingControlNavPageLinks.css('display', 'none'); 
            }
            else if (pagingControlNavWidth 
                     - pagingControlNavPageLinksWidth 
                     - pagingControlNavInputSummaryWidth <= elementWidth)
            {
              // hide the range text too
              if (pagingControlNavPageLinks != null)
              {
                pagingControlNavPageLinks.css('display', 'none');
              }
              if (pagingControlNavInputSummary != null)
              {
                pagingControlNavInputSummary.css('display', 'none');
              }
            }
            else
            {
              // hide the arrows too
              if (pagingControlNavPageLinks != null)
              {
                pagingControlNavPageLinks.css('display', 'none');
              }
              if (pagingControlNavInputSummary != null)
              {
                pagingControlNavInputSummary.css('display', 'none');
              }
              if (pagingControlNavArrowSection != null)
              {
                pagingControlNavArrowSection.css('display', 'none'); 
              }
            }
          }
          else if (pagingControlNavWidth > 0)
          {
            if (pagingControlNavPageLinks != null)
            {
              pagingControlNavPageLinks.css('display', '');
            }
            if (pagingControlNavInputSummary != null)
            {
              pagingControlNavInputSummary.css('display', '');
            }
            if (pagingControlNavArrowSection != null)
            {
              pagingControlNavArrowSection.css('display', '');
            }
          }
        }
      },
      /**
       * @override
       * @private
       */
      _refreshPagingControlNavArrows: function()
      {
        var pagingControlNavArrowSection = this._getPagingControlNavArrowSection();
        var pagingControlNavFirst = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_CLASS);
        if (pagingControlNavFirst && pagingControlNavFirst.length > 0)
        {
          pagingControlNavFirst = $(pagingControlNavFirst[0]);
          
          if (this._getCurrentPage() == 1)
          {
            pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavFirst.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavFirst.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavFirst.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavFirst.attr('tabindex', '0');
          }
        }
        var pagingControlNavPrevious = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_CLASS);
        if (pagingControlNavPrevious && pagingControlNavPrevious.length > 0)
        {
          pagingControlNavPrevious = $(pagingControlNavPrevious[0]);
          
          if (this._getCurrentPage() == 1)
          {
            pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavPrevious.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavPrevious.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavPrevious.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavPrevious.attr('tabindex', '0');
          }
        }
        var pagingControlNavLast = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_CLASS);
        if (pagingControlNavLast && pagingControlNavLast.length > 0)
        {
          pagingControlNavLast = $(pagingControlNavLast[0]);
          
          if (this._getCurrentPage() == this._getTotalPages() || this._getTotalPages() === 0)
          {
            pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavLast.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavLast.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavLast.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavLast.attr('tabindex', '0');
          }
        }
        var pagingControlNavNext = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_CLASS);
        if (pagingControlNavNext && pagingControlNavNext.length > 0)
        {
          pagingControlNavNext = $(pagingControlNavNext[0]);
          
          if (this._getCurrentPage() == this._getTotalPages() || this._getTotalPages() === 0)
          {
            pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavNext.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavNext.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavNext.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavNext.attr('tabindex', '0');
          }
        }
      },
      /**
       * Register event listeners which need to be registered datasource. 
       * @private
       */
      _registerDataSourceEventListeners: function()
      {
        // register the listeners on the datasource
        var data = this._getData();
        if (data != null)
        {
          this._unregisterDataSourceEventListeners();
          
          this._dataSourceEventHandlers = [];
          this._dataSourceEventHandlers.push({'eventType': oj.PagingDataSource.EventType['ADD'], 'eventHandler': this._handleDataRowAdd.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.PagingDataSource.EventType['REMOVE'], 'eventHandler': this._handleDataRowRemove.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.PagingDataSource.EventType['RESET'], 'eventHandler': this._handleDataReset.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.PagingDataSource.EventType['REFRESH'], 'eventHandler': this._handleDataRefresh.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.PagingDataSource.EventType['SYNC'], 'eventHandler': this._handleDataFetchEnd.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.PagingDataSource.EventType['SORT'], 'eventHandler': this._handleDataSort.bind(this)});

          var i, ev;
          for (i = 0; i < this._dataSourceEventHandlers.length; i++) {
            ev = data.on(this._dataSourceEventHandlers[i]['eventType'], this._dataSourceEventHandlers[i]['eventHandler']);
            if (ev) {
                this._dataSourceEventHandlers[i]['eventHandler'] = ev;
            }
            
        }
        }
      },
      /**
       * Register event listeners for resize the container DOM element.
       * @param {jQuery} element  DOM element
       * @private
       */
      _registerResizeListener: function(element)
      {         
        if (!this._isResizeListenerAdded)
        {
          var self = this;
          oj.DomUtils.addResizeListener(element[0], function(width, height)
                                                    {
                                                      self._refresh();
                                                    });
          this._isResizeListenerAdded = true;
        }
      },
      /**
       * Unregister event listeners which are registered on datasource. 
       * @private
       */
      _unregisterDataSourceEventListeners: function()
      {
        var data = this._getData();
        // unregister the listeners on the datasource
        if (this._dataSourceEventHandlers != null && data != null)
        {
          var i;
          for (i = 0; i < this._dataSourceEventHandlers.length; i++)
            data.off(this._dataSourceEventHandlers[i]['eventType'], this._dataSourceEventHandlers[i]['eventHandler']);
        }
      },
      /**** end internal functions ****/
      /**
       * Create a span element for acc purposes
       * @param {string} text span text
       * @param {string} className css class
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createAccLabelSpan: function(text, className)
      {
        var accLabel = $(document.createElement('span'));
        accLabel.addClass(className);
        accLabel.addClass(this._CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
        accLabel.append(text);

        return accLabel;
      },
      /**** start internal DOM functions ****/
      /**
       * Create the acc paging control label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccLabel: function()
      {
        var pagingControlContainer = this._getPagingControlContainer();
        var pagingControlAccLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_PAGING);
        var pagingControlAccLabel = this._createAccLabelSpan(pagingControlAccLabelText, this._CSS_CLASSES._PAGING_CONTROL_ACC_LABEL_CLASS);
        var pagingControlAccLabelId = this.element.attr('id') + '_oj_pgCtrl_acc_label';
        pagingControlAccLabel.attr('id', pagingControlAccLabelId);
        pagingControlContainer.append(pagingControlAccLabel);

        return pagingControlAccLabel;
      },
      /**
       * Create the acc page link label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavPageLabel: function()
      {
        var pagingControlAccNavPageLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_PAGE);
        var pagingControlAccNavPageLabel = this._createAccLabelSpan(pagingControlAccNavPageLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGE_ACC_LABEL_CLASS);

        return pagingControlAccNavPageLabel;
      },
      /**
       * Create the acc first page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavFirstLabel: function()
      {
        var pagingControlAccNavFirstLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_FIRST_PAGE);
        var pagingControlAccNavFirstLabel = this._createAccLabelSpan(pagingControlAccNavFirstLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_ACC_LABEL_CLASS);

        return pagingControlAccNavFirstLabel;
      },
      /**
       * Create the acc last page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavLastLabel: function()
      {
        var pagingControlAccNavLastLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_LAST_PAGE);
        var pagingControlAccNavLastLabel = this._createAccLabelSpan(pagingControlAccNavLastLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_ACC_LABEL_CLASS);

        return pagingControlAccNavLastLabel;
      },
      /**
       * Create the acc next page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavNextLabel: function()
      {
        var pagingControlAccNavNextLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_NEXT_PAGE);
        var pagingControlAccNavNextLabel = this._createAccLabelSpan(pagingControlAccNavNextLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_ACC_LABEL_CLASS);

        return pagingControlAccNavNextLabel;
      },
      /**
       * Create the acc previous page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavPreviousLabel: function()
      {
        var pagingControlAccNavPreviousLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_PREVIOUS_PAGE);
        var pagingControlAccNavPreviousLabel = this._createAccLabelSpan(pagingControlAccNavPreviousLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_ACC_LABEL_CLASS);

        return pagingControlAccNavPreviousLabel;
      },
      /**
       * Create an paging content div
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlContent: function()
      {
        var pagingControlContainer = this._getPagingControlContainer();
        var pagingControlContent = $(document.createElement('div'));
        pagingControlContent.addClass(this._CSS_CLASSES._PAGING_CONTROL_CONTENT_CLASS);
        var pagingControlAccLabelId = this._getPagingControlAccLabel().attr('id');
        pagingControlContent.attr('role', 'navigation');
        pagingControlContent.attr('aria-labelledby', pagingControlAccLabelId);
        pagingControlContainer.append(pagingControlContent);

        return pagingControlContent;
      },
      /**
       * Create an paging load more div
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlLoadMore: function()
      {
        var pagingControlContent = this._getPagingControlContent();
        var pagingControlLoadMore = $(document.createElement('div'));
        pagingControlLoadMore.addClass(this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_CLASS);
        pagingControlContent.append(pagingControlLoadMore);

        return pagingControlLoadMore;
      },
      /**
       * Create an paging load more link
       * @return {jQuery} jQuery a DOM element
       * @private
       */
      _createPagingControlLoadMoreLink: function()
      {
        var pagingControlLoadMore = this._getPagingControlLoadMore();
        var pagingControlLoadMoreLink = $(document.createElement('a'));
        pagingControlLoadMoreLink.addClass(this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_LINK_CLASS);
        var loadMoreText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_LOAD_MORE);
        pagingControlLoadMoreLink.append(loadMoreText);
        pagingControlLoadMoreLink.attr('tabindex', '0');
        pagingControlLoadMoreLink.attr('href', '#');
        pagingControlLoadMore.append(pagingControlLoadMoreLink);

        return pagingControlLoadMoreLink;
      },
      /**
       * Create an paging load more link
       * @return {jQuery} jQuery a DOM element
       * @private
       */
      _createPagingControlLoadMoreRange: function()
      {
        var data = this._getData();
        var pagingControlLoadMore = this._getPagingControlLoadMore();
        var pagingControlLoadMoreRange = $(document.createElement('span'));
        pagingControlLoadMoreRange.addClass(this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_RANGE_CLASS);
        var loadMoreRangeText = this._getItemRangeText();
        pagingControlLoadMoreRange.append(loadMoreRangeText);
        pagingControlLoadMore.append(pagingControlLoadMoreRange);

        return pagingControlLoadMoreRange;
      },
      /**
       * Create the paging nav bar div
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlNav: function()
      {
        var options = this.options;
        var pageOptionLayout = options['pageOptions']['layout'];
        if (pageOptionLayout == null)
        {
          pageOptionLayout = [this._PAGE_OPTION_LAYOUT._AUTO];
        }
        var pagingControlContent = this._getPagingControlContent();
        var pagingControlNav = $(document.createElement('div'));
        pagingControlNav.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_CLASS);
        pagingControlContent.append(pagingControlNav);

        // page input section
        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._ALL, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._INPUT, pageOptionLayout) != -1)
        {
          var pagingControlNavInputSection = $(document.createElement('div'));
          pagingControlNavInputSection.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SECTION_CLASS);
          pagingControlNav.append(pagingControlNavInputSection);
          var pagingControlNavLabel = $(document.createElement('label'));
          pagingControlNavLabel.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_LABEL_CLASS);
          var navInputPageLabel = this.getTranslatedString(this._BUNDLE_KEY._LABEL_NAV_INPUT_PAGE);
          pagingControlNavLabel.append(navInputPageLabel);
          pagingControlNavInputSection.append(pagingControlNavLabel);

          var pagingControlNavInput = $(document.createElement('input'));
          pagingControlNavInput.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_CLASS);
          var navInputPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_INPUT_PAGE);
          this._focusable(this.element);
          pagingControlNavInput.attr('title', navInputPageTip);
          pagingControlNavInput.attr('tabindex', '0');
          pagingControlNavInput.val(this._getCurrentPage());
          pagingControlNavLabel.append(pagingControlNavInput);
          var maxPageVal = 0;
          
          if (this._getTotalPages() > 0)
          {
            maxPageVal = this._getTotalPages();
            var pagingControlNavMaxLabel = $(document.createElement('span'));
            pagingControlNavMaxLabel.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_MAX_CLASS);
            var navInputPageMaxLabel = this.getTranslatedString(this._BUNDLE_KEY._LABEL_NAV_INPUT_PAGE_MAX, {'pageMax': maxPageVal});
            pagingControlNavMaxLabel.append(navInputPageMaxLabel);
            pagingControlNavInputSection.append(pagingControlNavMaxLabel);
          }
          else
          {
            maxPageVal = this._getCurrentPage() + 1;
          }
          pagingControlNavInput.ojInputText({'rootAttributes': {'style':"width: auto; min-width: 0;"}, 'optionChange': this._handlePageChange.bind(this), 'validators': [{'type': 'numberRange', 'options': {'min': 1, max: maxPageVal}}]});
          
          if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
              $.inArray(this._PAGE_OPTION_LAYOUT._ALL, pageOptionLayout) != -1 ||
              $.inArray(this._PAGE_OPTION_LAYOUT._RANGE_TEXT, pageOptionLayout) != -1)
          {
            var pagingControlNavSummaryLabel = $(document.createElement('span'));
            pagingControlNavSummaryLabel.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SUMMARY_CLASS);
            var itemRangeText = this._getItemRangeText();
            var navInputPageSummaryLabel = this.getTranslatedString(this._BUNDLE_KEY._LABEL_NAV_INPUT_PAGE_SUMMARY, {'pageSummary': itemRangeText});
            pagingControlNavSummaryLabel.append(navInputPageSummaryLabel);
            pagingControlNavInputSection.append(pagingControlNavSummaryLabel);
          }
        }

        // nav arrow section
        var pagingControlNavArrowSection = $(document.createElement('div'));
        pagingControlNavArrowSection.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_SECTION_CLASS);
        pagingControlNav.append(pagingControlNavArrowSection);
        
        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._ALL, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._NAV, pageOptionLayout) != -1)
        {
          var pagingControlNavFirst = $(document.createElement('a'));
          pagingControlNavFirst.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_CLASS);
          pagingControlNavFirst.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_CLASS);
          pagingControlNavFirst.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_ICON_CLASS);
          pagingControlNavFirst.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navFirstPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_FIRST_PAGE);
          this._hoverable(pagingControlNavFirst);
          this._focusable(pagingControlNavFirst);
          pagingControlNavFirst.attr('title', navFirstPageTip);
          pagingControlNavFirst.attr('tabindex', '0');
          pagingControlNavFirst.attr('href', '#');
          var pagingControlNavFirstAccLabel = this._createPagingControlAccNavFirstLabel();
          pagingControlNavFirst.append(pagingControlNavFirstAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavFirst);

          var pagingControlNavPrevious = $(document.createElement('a'));
          pagingControlNavPrevious.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_CLASS);
          pagingControlNavPrevious.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_CLASS);
          pagingControlNavPrevious.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_ICON_CLASS);
          pagingControlNavPrevious.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navPreviousPageTip= this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_PREVIOUS_PAGE);
          this._hoverable(pagingControlNavPrevious);
          this._focusable(pagingControlNavPrevious);
          pagingControlNavPrevious.attr('title', navPreviousPageTip);
          pagingControlNavPrevious.attr('tabindex', '0');
          pagingControlNavPrevious.attr('href', '#');
          var pagingControlNavPreviousAccLabel = this._createPagingControlAccNavPreviousLabel();
          pagingControlNavPrevious.append(pagingControlNavPreviousAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavPrevious);
        }

        // nav pages section
        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._ALL, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._PAGES, pageOptionLayout) != -1)
        {
          var pagingControlNavPagesSection = $(document.createElement('div'));
          pagingControlNavPagesSection.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGES_SECTION_CLASS);
          pagingControlNavArrowSection.append(pagingControlNavPagesSection);
          this._createPagingControlNavPages(pagingControlNavPagesSection, this._getMaxPageLinks());
        }

        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._ALL, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._NAV, pageOptionLayout) != -1)
        {
          var pagingControlNavNext = $(document.createElement('a'));
          pagingControlNavNext.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_CLASS);
          pagingControlNavNext.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_CLASS);
          pagingControlNavNext.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_ICON_CLASS);
          pagingControlNavNext.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navNextPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_NEXT_PAGE);
          this._hoverable(pagingControlNavNext);
          this._focusable(pagingControlNavNext);
          pagingControlNavNext.attr('title', navNextPageTip);
          pagingControlNavNext.attr('tabindex', '0');
          pagingControlNavNext.attr('href', '#');
          var pagingControlNavNextAccLabel = this._createPagingControlAccNavNextLabel();
          pagingControlNavNext.append(pagingControlNavNextAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavNext);

          var pagingControlNavLast = $(document.createElement('a'));
          pagingControlNavLast.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_CLASS);
          pagingControlNavLast.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_CLASS);
          pagingControlNavLast.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_ICON_CLASS);
          pagingControlNavLast.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navLastPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_LAST_PAGE);
          this._hoverable(pagingControlNavLast);
          this._focusable(pagingControlNavLast);
          pagingControlNavLast.attr('title', navLastPageTip);
          pagingControlNavLast.attr('tabindex', '0');
          pagingControlNavLast.attr('href', '#');
          var pagingControlNavLastAccLabel = this._createPagingControlAccNavLastLabel();
          pagingControlNavLast.append(pagingControlNavLastAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavLast);
        }

        return pagingControlNav;
      },
      /**
       * Create the page links
       * @param {jQuery} parentDiv parent element
       * @param {number} numLinks number of page links
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlNavPages: function(parentDiv, numLinks)
      {
        if (numLinks < 5)
        {
          var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_MAXPAGELINKS_INVALID_SUMMARY);
          var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_MAXPAGELINKS_INVALID_DETAIL);
          throw new Error(errSummary + '\n' + errDetail);
        }
        var pagingControlNavPagesLinks = $(document.createElement('div'));
        pagingControlNavPagesLinks.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGES_LINKS_CLASS);
        parentDiv.append(pagingControlNavPagesLinks);
        var totalPages = this._getTotalPages();
        var currentPage = this._getCurrentPage();
        
        var numPagesToAdd = numLinks;
        // this will hold our page list
        var pageList = [];

        if (currentPage >= 1)
        {
          var i;
          if (totalPages != -1 && totalPages <= numPagesToAdd)
          {
            // always add the first page
            pageList[0] = 1;
            
            // just enumerate the pages
            for (i = 1; i < totalPages; i++)
            {
              pageList[i] = i + 1;
            }
          }
          else
          {
            // add the first, current, and last page
            pageList.push(1);
            if (currentPage != 1)
            {
              pageList.push(currentPage);
            }
            // add last page if known row count
            if (currentPage != totalPages && totalPages != -1)
            {
              pageList.push(totalPages);
            }
            numPagesToAdd = numPagesToAdd - pageList.length;
            // keep adding before the current page till we get to the
            // first page or we've added numPagesToAdd - 1.
            // If the last page or 2nd to last page then add until numPagesToAdd
            var pageBeforeCurrent = currentPage - 1;
            // number of pages to add after current
            var numPagesAfterCurrent = 1;
            // if at last page or second to last page then don't add any pages
            // after current
            if (currentPage == totalPages || currentPage == totalPages - 1)
            {
              numPagesAfterCurrent = 0;
            }
            while (numPagesToAdd > numPagesAfterCurrent && pageBeforeCurrent > 1)
            {
              pageList.push(pageBeforeCurrent);
              pageBeforeCurrent--;
              numPagesToAdd--;
            }
            // keep adding after the current page
            var pageAfterCurrent = currentPage + 1;
            // if unknown row count, only add one page after current
            if (totalPages == -1)
            {
              numPagesToAdd = 1;
            }
            while (numPagesToAdd > 0 && (pageAfterCurrent <= totalPages || totalPages == -1))
            {
              pageList.push(pageAfterCurrent);
              pageAfterCurrent++;
              numPagesToAdd--;
            }
          }

          // sort the pageList array
          var compareNumbers = function (a, b) {
            return a - b;
          };
          
          pageList.sort(compareNumbers);

          for (i = 0; i < pageList.length; i++)
          {
            var pageNum = pageList[i];
            this._createPagingControlNavPage(pagingControlNavPagesLinks, pageNum);
            // check if we have a gap
            if (i != pageList.length - 1)
            {
              if (pageNum != pageList[i + 1] - 1)
              {
                this._createPagingControlNavPage(pagingControlNavPagesLinks, -1);
              }
            }
          }
          if (totalPages == -1)
          {
            this._createPagingControlNavPage(pagingControlNavPagesLinks, -1);
          }
        }
        return pagingControlNavPagesLinks;
      },
      /**
       * Create the page link or page gap
       * @param {jQuery} parentDiv parent element
       * @param {number} pageNum page number
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlNavPage: function(parentDiv, pageNum)
      {
        var currentPage = this._getCurrentPage();
        var pagingControlNavPage = null;
        if (pageNum == -1)
        {
          pagingControlNavPage = $(document.createElement('span'));
          pagingControlNavPage.append("...");
          parentDiv.append(pagingControlNavPage);
        }
        else
        {          
          if (currentPage == pageNum)
          {
             pagingControlNavPage = $(document.createElement('div'));
             pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._SELECTED);
             pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._ACTIVE);
             pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
             pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
          }
          else
          {
            pagingControlNavPage = $(document.createElement('a'));
            pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._SELECTED);
            pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
          }
          pagingControlNavPage.attr('data-oj-pagenum', pageNum);
          pagingControlNavPage.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGE_CLASS);
          var pageTitle = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_PAGE_LINK, {'pageNum': pageNum.toString()});
          this._hoverable(pagingControlNavPage);
          this._focusable(pagingControlNavPage);
          pagingControlNavPage.attr('title', pageTitle);
          pagingControlNavPage.attr('tabindex', '0');
          pagingControlNavPage.attr('href', '#');
          // create the acc label for the page link
          var accPageLabel = this._createPagingControlAccNavPageLabel();
          pagingControlNavPage.append(accPageLabel);
          pagingControlNavPage.append(pageNum.toString());
          this._hoverable(pagingControlNavPage);
          parentDiv.append(pagingControlNavPage);
        }
        return pagingControlNavPage;
      },
      /**
       * Return the paging content acc label
       * @return {jQuery|null} jQuery div DOM element
       * @private
       */
      _getPagingControlAccLabel: function()
      {
        var pagingControlContainer = this._getPagingControlContainer();
        var pagingControlContentAccLabel = null;
        
        if (pagingControlContainer)
        {
          pagingControlContentAccLabel = pagingControlContainer.find('.' + this._CSS_CLASSES._PAGING_CONTROL_ACC_LABEL_CLASS);
          if (pagingControlContentAccLabel && pagingControlContentAccLabel.length > 0)
          {
            pagingControlContentAccLabel = $(pagingControlContentAccLabel.get(0));
          }
        }
        
        return pagingControlContentAccLabel;
      },
      /**
       * Return the paging container
       * @return {jQuery|null} jQuery div DOM element
       * @private
       */
      _getPagingControlContainer: function()
      {
        return $(this.element);
      },
      /**
       * Return the paging content
       * @return {jQuery|null} jQuery div DOM element
       * @private
       */
      _getPagingControlContent: function()
      {
        if (!this._cachedDomPagingControlContent)
        {
          var pagingControlContainer = this._getPagingControlContainer();
          var pagingControlContent = null;
          if (pagingControlContainer)
          {
            pagingControlContent = pagingControlContainer.find('.' + this._CSS_CLASSES._PAGING_CONTROL_CONTENT_CLASS);
            if (pagingControlContent && pagingControlContent.length > 0)
            {
              this._cachedDomPagingControlContent = $(pagingControlContent.get(0));
            }
          }
        }

        return this._cachedDomPagingControlContent;
      },
      /**
       * Return the Load More div
       * @return {jQuery|null} jQuery a DOM element
       * @private
       */
      _getPagingControlLoadMore: function()
      {
        if (!this._cachedDomPagingControlLoadMore)
        {
          var pagingControlContent = this._getPagingControlContent();
          var pagingControlLoadMore = null;
          if (pagingControlContent)
          {
            pagingControlLoadMore = pagingControlContent.children('.' + this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_CLASS);
            if (pagingControlLoadMore && pagingControlLoadMore.length > 0)
            {
              this._cachedDomPagingControlLoadMore = $(pagingControlLoadMore.get(0));
            }
          }
        }

        return this._cachedDomPagingControlLoadMore;
      },
      /**
       * Return the Load More link
       * @return {jQuery|null} jQuery a DOM element
       * @private
       */
      _getPagingControlLoadMoreLink: function()
      {
        if (!this._cachedDomPagingControlLoadMoreLink)
        {
          var pagingControlLoadMore = this._getPagingControlLoadMore();
          var pagingControlLoadMoreLink = null;
          if (pagingControlLoadMore)
          {
            pagingControlLoadMoreLink = pagingControlLoadMore.children('.' + this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_LINK_CLASS);
            if (pagingControlLoadMoreLink && pagingControlLoadMoreLink.length > 0)
            {
              this._cachedDomPagingControlLoadMoreLink = $(pagingControlLoadMoreLink.get(0));
            }
          }
        }

        return this._cachedDomPagingControlLoadMoreLink;
      },
      /**
       * Return the Load More Range
       * @return {jQuery|null} jQuery span DOM element
       * @private
       */
      _getPagingControlLoadMoreRange: function()
      {
        if (!this._cachedDomPagingControlLoadMoreRange)
        {
          var pagingControlLoadMore = this._getPagingControlLoadMore();
          var pagingControlLoadMoreRange = null;
          if (pagingControlLoadMore)
          {
            pagingControlLoadMoreRange = pagingControlLoadMore.children('.' + this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_RANGE_CLASS);
            if (pagingControlLoadMoreRange && pagingControlLoadMoreRange.length > 0)
            {
              this._cachedDomPagingControlLoadMoreRange = $(pagingControlLoadMoreRange.get(0));
            }
          }
        }

        return this._cachedDomPagingControlLoadMoreRange;
      },
      /**
       * Return the paging nav bar
       * @return {jQuery|null} jQuery a DOM element
       * @private
       */
      _getPagingControlNav: function()
      {
        if (!this._cachedDomPagingControlNav)
        {
          var pagingControlContent = this._getPagingControlContent();
          var pagingControlNav = null;
          if (pagingControlContent)
          {
            pagingControlNav = pagingControlContent.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_CLASS);
            if (pagingControlNav && pagingControlNav.length > 0)
            {
              this._cachedDomPagingControlNav = $(pagingControlNav.get(0));
            }
          }
        }

        return this._cachedDomPagingControlNav;
      },
      /**
       * Return the paging nav input
       * @return {jQuery|null} jQuery input DOM element
       * @private
       */
      _getPagingControlNavInput: function()
      {
        if (!this._cachedDomPagingControlNavInput)
        {
          var pagingControlNav = this._getPagingControlNav();
          var pagingControlNavInput = null;
          if (pagingControlNav)
          {
            pagingControlNavInput = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_CLASS);
            if (pagingControlNavInput && pagingControlNavInput.length > 0)
            {
              this._cachedDomPagingControlNavInput = $(pagingControlNavInput.get(0));
            }
          }
        }

        return this._cachedDomPagingControlNavInput;
      },
      /**
       * Return the paging nav input summary
       * @return {jQuery|null} jQuery input DOM element
       * @private
       */
      _getPagingControlNavInputSummary: function()
      {
        if (!this._cachedDomPagingControlNavInputSummary)
        {
          var pagingControlNav = this._getPagingControlNav();
          var pagingControlNavInputSummary = null;
          if (pagingControlNav)
          {
            pagingControlNavInputSummary = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SUMMARY_CLASS);
            if (pagingControlNavInputSummary && pagingControlNavInputSummary.length > 0)
            {
              this._cachedDomPagingControlNavInputSummary = $(pagingControlNavInputSummary.get(0));
            }
          }
        }

        return this._cachedDomPagingControlNavInputSummary;
      },
      /**
       * Return the page links
       * @private
       */
      _getPagingControlNavPageLinks: function()
      {
        var pagingControlNav = this._getPagingControlNav();
        var pagingControlNavPageLinks = null;
        if (pagingControlNav)
        {
          pagingControlNavPageLinks = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGES_LINKS_CLASS);
          if (pagingControlNavPageLinks && pagingControlNavPageLinks.length > 0)
          {
            pagingControlNavPageLinks = $(pagingControlNavPageLinks.get(0));
          }
        }

        return pagingControlNavPageLinks;
      },
      /**
       * Return the nav arrows
       * @private
       */
      _getPagingControlNavArrowSection: function()
      {
        var pagingControlNav = this._getPagingControlNav();
        var pagingControlNavArrowSection = null;
        if (pagingControlNav)
        {
          pagingControlNavArrowSection = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_SECTION_CLASS);
          if (pagingControlNavArrowSection && pagingControlNavArrowSection.length > 0)
          {
            pagingControlNavArrowSection = $(pagingControlNavArrowSection.get(0));
          }
          else
          {
            return null;
          }
        }

        return pagingControlNavArrowSection;
      }
      ,
      /**
       * Return the nav input section
       * @private
       */
      _getPagingControlNavInputSection: function()
      {
        var pagingControlNav = this._getPagingControlNav();
        var pagingControlNavInputSection = null;
        if (pagingControlNav)
        {
          pagingControlNavInputSection = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SECTION_CLASS);
          if (pagingControlNavInputSection && pagingControlNavInputSection.length > 0)
          {
            pagingControlNavInputSection = $(pagingControlNavInputSection.get(0));
          }
          else
          {
            return null;
          }
        }

        return pagingControlNavInputSection;
      }
      /**** end internal DOM functions ****/
    })
}());
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * An array based implementation of the DataGridDataSource.
 * @param {Array|Object} data the data in the form of array or observable array.
 * @param {Object=} options the options specific to this DataGridDataSource.
 * @param {Array=} options.columns an array of columns to return as column headers.
 * @param {string=} options.rowHeader the key to the header designated as the row header.
 * @export
 * @constructor
 * @extends oj.DataGridDataSource
 */
oj.ArrayDataGridDataSource = function(data, options)
{
    var errSummary, errDetail;
    if (!(data instanceof Array) &&
            (typeof (data) != 'function' &&
                    typeof (data.subscribe) != 'function'))
    {
        // we only support Array or ko.observableArray. To
        // check for observableArray, we can't do instanceof check because it's
        // a function. So we just check if it contains a subscribe function.
        errSummary = '_ERR_DATA_INVALID_TYPE_SUMMARY';
        errDetail = '_ERR_DATA_INVALID_TYPE_DETAIL';
        throw new Error(errSummary + '\n' + errDetail);
    }
    if (options != null)
    {
        this.rowHeaderKey = options['rowHeader'];
    }
    this._startIndex = 0;
    this._pageSize = -1;

    oj.ArrayDataGridDataSource.superclass.constructor.call(this, data);
};

// Subclass from oj.DataGridDataSource
oj.Object.createSubclass(oj.ArrayDataGridDataSource, oj.DataGridDataSource, "oj.ArrayDataGridDataSource");

/**
 * Initial the array based data source.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.Init = function()
{
    // suck out the column definition from data
    this.columns = this._getColumnsForScaffolding(this.getDataArray());
    this._initializeRowKeys();

    //if the data is an observable array subscribe to array change notifications
    if (typeof (this.data) == 'function')
    {
        this.data['subscribe'](this._subscribe.bind(this), null, 'arrayChange');
    }

    // call super
    oj.ArrayDataGridDataSource.superclass.Init.call(this);
};

/**
 * Initialize the generated row keys.
 * @private
 */
oj.ArrayDataGridDataSource.prototype._initializeRowKeys = function()
{
    var data;
    data = this.getDataArray();
    for (this.lastKey = 0; this.lastKey < data.length; this.lastKey += 1)
    {
        //inject the row key into the object
        data[this.lastKey]['ojKey'] = this.lastKey.toString();
    }
};

/**
 * Get the column headers from the data, if it is an array of arrays with no row header key set,
 * gets the column number as the column header.
 * @param {Object} data the data to extract the column information.
 * @return {Array} the columns extracted from the data.
 * @private
 */
oj.ArrayDataGridDataSource.prototype._getColumnsForScaffolding = function(data)
{
    var propertyName, columns;
    if ((typeof data.length !== 'number') || data.length === 0)
    {
        return [];
    }

    columns = [];
    for (propertyName in data[0])
    {
        if (data[0].hasOwnProperty(propertyName))
        {
            if (!(this.rowHeaderKey != undefined && propertyName == this.rowHeaderKey))
            {
                columns.push(propertyName);
            }
        }
    }

    return columns;
};

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return this.size();
    }

    if (axis === "column")
    {
        return this.columns.length;
    }

    return 0;
};

/**
 * Retrieve the data for the header of a specified index.
 * @param {string} axis the axis of the header.  Valid values are "row" and "column".
 * @param {number} index the index in which to get the data.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getHeaderData = function(axis, index)
{
    var data;
    if (axis === 'row')
    {
        data = this.getDataArray();
        //add the start index to the index for paging
        index += this._startIndex;
        // if row header is specified
        if (this.rowHeaderKey != undefined)
        {
            return data[index][this.rowHeaderKey];
        }
        else if (data.length > 0 && data[0] instanceof Array)
        {
            // generate default row header for two dimensional array
            if (this._getRowKeyByIndex(index) === undefined)
            {
                return index.toString();
            }
            else
            {
                return this._getRowKeyByIndex(index);
            }
        }
        else
        {
            return null;
        }
    }
    else if (axis === 'column')
    {
        return this.columns[index];
    }
};

/**
 * Retrieve the metadata for the header of a specified index.
 * @param {string} axis the axis of the header.  Valid values are "row" and "column".
 * @param {number} index the index in which to get the metadata.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getHeaderMetadata = function(axis, index)
{
    if (axis === 'row')
    {
        if (this.rowHeaderKey != undefined)
        {
            return {'key': this._getRowKeyByIndex(index + this._startIndex)};
        }
    }

    return {'key': this.getHeaderData(axis, index)};
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    var axis, start, count, end, headerSet, data;

    axis = headerRange.axis;
    start = headerRange.start;
    count = headerRange.count;

    oj.Assert.assert(axis === 'row' || axis === 'column');
    oj.Assert.assert(start < this.getCount(axis));
    oj.Assert.assert(count > 0);

    start = Math.max(0, start);
    if (axis === "column")
    {
        end = Math.min(this.columns.length, start + count);
    }
    else
    {
        data = this.getDataArray();
        // check if no row header is available
        if (this.rowHeaderKey === undefined && !(data.length > 0 && data[0] instanceof Array))
        {
            // header count = 0
            end = start;
        }
        else
        {
            end = Math.min(data.length, start + count);
            if (this._pageSize > 0)
            {
                end = Math.min(end, this.totalSize() - this._startIndex);
            }
        }
    }
    headerSet = new oj.ArrayHeaderSet(start, end, axis, this);

    if (callbacks != null && callbacks['success'] != null)
    {
        // make sure callbackObjects is not null
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }
        callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
    }
};

/**
 * Retrieve the data for the cell of a specified indexes.
 * @param {number} row the row index in which to get the data.
 * @param {number} column the column index in which to get the data.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getCellData = function(row, column)
{
    var col = this.columns[column];
    return this.getDataArray()[row + this._startIndex][col];
};

/**
 * Retrieve the metadata for the cell of a specified indexes.
 * @param {number} row the row index in which to get the data.
 * @param {number} column the column index in which to get the data.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getCellMetadata = function(row, column)
{
    var keys = {"row": this._getRowKeyByIndex(row + this._startIndex), "column": this.columns[column]};
    return {"keys": keys};
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
    var i, cellRange, rowStart, rowEnd, cellSet, colStart, colEnd;

    // extract the start and end row/column info from cellRanges (there should only be two, one for each axis)
    for (i = 0; i < cellRanges.length; i += 1)
    {
        cellRange = cellRanges[i];
        oj.Assert.assert(cellRange['axis'] === 'row' || cellRange['axis'] === 'column');
        oj.Assert.assert(cellRange['start'] < this.getCount(cellRange['axis']));
        oj.Assert.assert(cellRange['count'] > 0);
        if (cellRange['axis'] === "row")
        {
            rowStart = cellRange['start'];
            rowEnd = Math.min(this.size(), rowStart + cellRange['count']);
            if (this._pageSize > 0)
            {
                rowEnd = Math.min(rowEnd, this.totalSize() - this._startIndex);
            }
        }
        else if (cellRange['axis'] === "column")
        {
            colStart = cellRange['start'];
            colEnd = Math.min(this.columns.length, colStart + cellRange['count']);
        }
    }

    // check for errors
    if (rowEnd === undefined || colEnd === undefined)
    {
        if (callbacks != null && callbacks['error'] != null)
        {
            // make sure callbackObjects is not null
            if (callbackObjects == null)
            {
                callbackObjects = {};
            }
            callbacks['error'].call(callbackObjects['error']);
        }
        return;
    }

    cellSet = new oj.ArrayCellSet(rowStart, rowEnd, colStart, colEnd, this);

    if (callbacks != null && callbacks['success'] != null)
    {
        // make sure callbackObjects is not null
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }
        callbacks['success'].call(callbackObjects['success'], cellSet, cellRanges);
    }

    //communicates with paging control to indicate fetch end
    if (this._pageSize > 0)
    {
        oj.DataGridDataSource.superclass.handleEvent.call(this, 'sync', true);
    }
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Promise} a promise object containing the key for each axis
 * @export
 */
/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {string|number|null} indexes.row the index for the row axis
 * @param {string|number|null} indexes.column the index for the column axis
 * @return {Promise} a Promise object which upon resolution will pass in an object containing the keys for each axis
 * @export
 */
oj.ArrayDataGridDataSource.prototype.keys = function(indexes)
{
    var rowIndex = indexes['row'], columnIndex = indexes['column'];
    return oj.Object.__getPromise(function(resolve, reject) {
        resolve({"row": this._getRowKeyByIndex(rowIndex + this._startIndex), "column": this.columns[columnIndex]});
    }.bind(this));
};

/**
 * Returns the row and column index based on the keys. In a paging case returns the 
 * index on the page, not the absolute index in the array.
 * @param {Object} keys the key for each axis
 * @param {string|number|null} keys.row the key for the row axis
 * @param {string|number|null} keys.column the key for the column axis
 * @return {Promise} a promise object containing the index for each axis
 * @export
 */
oj.ArrayDataGridDataSource.prototype.indexes = function(keys)
{
    var rowKey = keys['row'], columnKey = keys['column'];
    return oj.Object.__getPromise(function(resolve, reject) {
        resolve({"row": this._getRowIndexByKey(rowKey) - this._startIndex, "column": this.columns.indexOf(columnKey)});
    }.bind(this));
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    var sortArray = [], newColumns = [], i, headerIndex, axis, headerKey, direction;

    axis = criteria['axis'];
    headerKey = criteria['key'];
    direction = criteria['direction'];

    // make sure callbackObjects is non null
    if (callbacks != null && callbackObjects == null)
    {
        callbackObjects = {};
    }

    if (axis === 'column')
    {
        this.getDataArray().sort(this._naturalSort(direction, headerKey));

        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(callbackObjects['success']);
        }
    }
    else if (axis === 'row')
    {
        headerIndex = this._getRowIndexByKey(headerKey);
        //rebuild the array to sort on
        for (i = 0; i < this.columns.length; i += 1)
        {
            sortArray[i] = this.getDataArray()[headerIndex][this.columns[i]];
        }

        //sort the given array with no headerKye specified
        sortArray.sort(this._naturalSort(direction));

        //reorder the columns property
        for (i = 0; i < this.columns.length; i += 1)
        {
            newColumns[i] = this.columns[sortArray.indexOf(this.getDataArray()[headerIndex][this.columns[i]])];
        }

        this.columns = newColumns;
        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(callbackObjects['success']);
        }
    }
    else
    {
        if (callbacks !== null && callbacks['error'] != null)
        {
            callbacks['error'].call(callbackObjects['error'], "Invalid axis value");
        }
    }
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For sort, the valid return values are: "full", "none".  Returns null if the
 *         feature is not recognized.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getCapability = function(feature)
{
    if (feature === 'sort')
    {
        // array based data source supports column sorting only
        return 'column';
    }
    if (feature === 'move')
    {
        return 'row';
    }
    return null;
};

/**
 * Get a comparator fuicntion for natural sorting of objects
 * @param {string} direction ascending, descending 
 * @param {string|number=} key the key or index to perform the sort on
 * @returns {function(Object, Object)|undefined} a comapartor function, dependent on direction
 * @private
 */
oj.ArrayDataGridDataSource.prototype._naturalSort = function(direction, key)
{
    if (direction === 'ascending')
    {
        return function(a, b)
        {
            var as, bs;
            //Get the values the array we're sorting
            if (key != undefined)
            {
                //if the sorting item is an array it will be indexed with strings of ints and needs
                //to be accessed using ints not strings
                if (a instanceof Array)
                {
                    a = a[parseInt(key, 10)];
                    b = b[parseInt(key, 10)];
                }
                else
                {
                    a = a[key];
                    b = b[key];
                }
            }
            //Strings of numbers return false, so we can compare strings of numebers with numbers                
            as = isNaN(a);
            bs = isNaN(b);
            //If they are strings, check to see if they are dates, if they are, turn the string to a sortable date formatted string           
            if (a instanceof Date) {
                a = a.toISOString();
                as = true;
            }
            if (b instanceof Date) {
                b = b.toISOString();
                bs = true;
            }
            //both are string
            if (as && bs)
            {
                return a < b ? -1 : a === b ? 0 : 1;
            }
            //only a is a string
            if (as)
            {
                return 1;
            }
            //only b is a string
            if (bs)
            {
                return -1;
            }
            //both are numbers
            return a - b;
        };
    }
    if (direction === 'descending')
    {
        return function(a, b)
        {
            var as, bs;
            if (key != undefined)
            {
                //if the sorting item is an array it will be indexed with strings of ints and needs
                //to be accessed using ints not strings                
                if (a instanceof Array)
                {
                    a = a[parseInt(key, 10)];
                    b = b[parseInt(key, 10)];
                }
                else
                {
                    a = a[key];
                    b = b[key];
                }
            }
            as = isNaN(a);
            bs = isNaN(b);
            if (a instanceof Date) {
                a = a.toISOString();
                as = true;
            }
            if (b instanceof Date) {
                b = b.toISOString();
                bs = true;
            }
            if (as && bs)
            {
                return a > b ? -1 : a === b ? 0 : 1;
            }
            if (as)
            {
                return -1;
            }
            if (bs)
            {
                return 1;
            }
            return b - a;
        };
    }

    // only if direction is not recognized
    return;
};

/**
 * Moves a row from one location to another.
 * @param {Object} moveKey the key of the row to move
 * @param {Object} atKey the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {string} position The position of the moved row relative to the reference row.  
 *        Valid values are: "before", "after" 
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.move = function(moveKey, atKey, position, callbacks, callbackObjects)
{
    var moveKeyIndex, moveData, atKeyIndex, event, data;

    //remove the data from the array, but hold on to it
    moveKeyIndex = this._getRowIndexByKey(moveKey);
    moveData = this.data.splice(moveKeyIndex, 1)[0];

    //fire the delete event to the datagrid
    if (this.data instanceof Array)
    {
        event = this._getModelEvent('delete', moveKey, null, moveKeyIndex, -1);
        this.handleEvent("change", event);
    }

    //add the stored data back into the array
    if (atKey === null)
    {
        this.data.push(moveData);
    }
    else
    {
        atKeyIndex = this._getRowIndexByKey(atKey);
        this.data.splice(atKeyIndex, 0, moveData);
    }

    //fire the insert event to the datagrid
    if (this.data instanceof Array)
    {
        event = this._getModelEvent('insert', moveKey, null, atKeyIndex, -1);        
        this.handleEvent("change", event);
    }
};

/**
 * Gets the data array, if the data property is a function call it, else return data
 * @return {Object|Array} the array of the data
 * @private
 */
oj.ArrayDataGridDataSource.prototype.getDataArray = function()
{
    if (typeof (this.data) === 'function')
    {
        return this.data();
    }
    return this.data;
};

/**
 * Gets the row index of a given row key
 * @param {string|number|Object|null} key the key to get row index of
 * @return {number} the index with a certain key, -1 if the key doesn't exist
 * @private
 */
oj.ArrayDataGridDataSource.prototype._getRowIndexByKey = function(key)
{
    var i, data = this.getDataArray();
    for (i = 0; i < data.length; i++)
    {
        if (data[i]['ojKey'] === key)
        {
            return i;
        }
    }
    return -1;
};

/**
 * Gets the row key stored at a given index
 * @param {number} index the index to get row key of
 * @return {string|number|null} the key at index, null if the index doesn't exist
 * @private
 */
oj.ArrayDataGridDataSource.prototype._getRowKeyByIndex = function(index)
{
    var data = this.getDataArray();
    if (data[index])
    {
        return data[index]['ojKey'];
    }
    return null;
};

/**
 * Returns an Object for an event 
 * @param {string} operation the operation done on the model
 * @param {Object|string|number|null} rowKey the key for the row axis
 * @param {Object|string|number|null} columnKey the key for the column axis
 * @param {number=} rowIndex the index for the row axis
 * @param {number=} columnIndex the index for the column axis
 * @param {boolean=} silent should the event be silent
 * @return {Object} an object containing the the source, operation, and keys of the event
 * @protected
 */
oj.ArrayDataGridDataSource.prototype._getModelEvent = function(operation, rowKey, columnKey, rowIndex, columnIndex, silent)
{
    var event = {};
    event['source'] = this;
    event['operation'] = operation;
    event['keys'] = {'row': rowKey, 'column': columnKey};
    event['indexes'] = {'row': rowIndex, 'column': columnIndex};
    event['silent'] = silent;
    return event;
};

/**
 * Subscribe to knockout events
 * @param {Array} changes an array of change objects fired by an observable array
 * @private
 */
oj.ArrayDataGridDataSource.prototype._subscribe = function(changes)
{
    var i, rowData, rowKey, rowIndex, added = false, move = false, keys = [], indexes = [], event, beforeDelCount = 0, change;

    // first loop though the changes, 
    for (i = 0; i < changes.length; i++)
    {
        change = changes[i];
        // if a model was moved using a reverseAll or a sort, just refresh the grid
        if (change['moved'] !== undefined)
        {
            move = true;
            event = this._getModelEvent('refresh', null, null);        
            this.handleEvent("change", event);
            break;
        }
        
        // check if there were any adds, this way the delete will know to be fired silently
        if (change['status'] === 'added')
        {
            added = true;
        }
        
        // track the number of models deleted before the page so the index to remove can be tracked      
        if (this._pageSize > 0 && change['status'] === 'deleted')
        {
            if (change['index'] < this._startIndex)
            {
                beforeDelCount++;
            }
        }
    }
    
    //if we moved a model we just refreshed
    if (!move)
    {        
        //loop through changes looking for deletes
        for (i = 0; i < changes.length; i++)
        {
            change = changes[i];
            if (change['status'] === 'deleted')
            {
                rowData = change['value'];
                rowIndex = change['index'];
                if (this._pageSize > 0)
                {
                    //if paging and a delete before need to remove the 0 index, but that key is lcoated at a new index
                    if (rowIndex < this._startIndex)
                    {
                        rowIndex = 0;
                        rowKey = this._getRowKeyByIndex(this._startIndex - beforeDelCount);
                        beforeDelCount--;
                    }
                    //if paging and a delete inside remove that index
                    else if (rowIndex < this._startIndex + this._pageSize)
                    {
                        rowIndex -= this._startIndex;
                        rowKey = rowData['ojKey'];
                    }
                    //else delete after and it doesn't matter
                }
                else
                {
                    rowKey = rowData['ojKey'];
                }                
                //collect the deletes to do in one batch delete
                keys.push({'row': rowKey, 'column': -1});
                indexes.push({'row': rowIndex, 'column': -1});
            }
        }
        
        // batch delete all deletes
        if (keys.length > 0)
        {
            event = {'source': this, 'operation': 'delete', 'keys': keys, 'indexes': indexes, 'silent': added};
            this.handleEvent("change", event);
        }
        
        //loop through changes looking for adds
        for (i = 0; i < changes.length; i++)
        {
            change = changes[i];
            if (change['status'] === 'added')
            {
                rowData = change['value'];   
                rowIndex = change['index'];               
                //if no key add inject one into the add object based on the last assigned key          
                if (rowData['ojKey'] == null)
                {
                    rowData['ojKey'] = this.lastKey.toString();
                    this.lastKey++;
                }
                //if the add is on the page or before
                if (this._pageSize > 0 && rowIndex < (this._startIndex + this._pageSize))
                {
                    //if add is on a previous page insert a row at the startIndex
                    if (rowIndex < this._startIndex)
                    {
                        rowIndex = 0;
                        rowKey = this._getRowKeyByIndex(this._startIndex);
                    }
                    //if add is on the current page insert a row at the index - startIndex
                    else
                    {
                        rowIndex = change['index'] - this._startIndex;
                        rowKey = this._getRowKeyByIndex(rowIndex);               
                    }
                    //add at the given index and remove from the end of the page silently
                    event = this._getModelEvent('insert', rowKey, null, rowIndex, -1);                            
                    this.handleEvent("change", event);
                    event = this._getModelEvent('delete', this._getRowKeyByIndex(this._startIndex + this._pageSize), null, this._pageSize, -1, true);                            
                    this.handleEvent("change", event);                     
                }
                else
                {
                    //add at the given index and remove from the end of the page silently
                    rowKey = rowData['ojKey'];
                    event = this._getModelEvent('insert', rowKey, null, rowIndex, -1);                            
                    this.handleEvent("change", event);
                }
            }
        }
    }
};

//////// methods to support paging   ////////
/**
 * Perform a fetch call from the options specified
 * @expose
 * @memberof! oj.ArrayDataGridDataSource
 * @instance
 */
oj.ArrayDataGridDataSource.prototype.fetch = function(options)
{
    this._startIndex = options != null ? (options['startIndex'] != null ? options['startIndex'] : 0) : 0;
    this.handleEvent("change", {'operation': 'sync', 'pageSize': this._pageSize});
};

/**
 * Set or change the number of models in a page
 * @export
 * @param {number} n page size
 */
oj.ArrayDataGridDataSource.prototype.setPageSize = function(n) {
    var oldSize = this._pageSize;
    this._pageSize = n;
    if (oldSize < 0)
    {
        this.fetch({startIndex: this._startIndex});
    }
};

/**
 * @export
 * Get the length of the collection. -1 if an initial fetch has not been
 * done yet. Default to the size of the collection. If pageSize is set then
 * limit it.
 * @returns {number} length of the collection
 * @expose
 * @memberof! oj.ArrayDataGridDataSource
 * @instance
 */
oj.ArrayDataGridDataSource.prototype.size = function()
{
    if (this._pageSize != null && this._pageSize > 0)
    {
        if (this.getDataArray()['length'] > this._pageSize)
        {
            return this._pageSize;
        }
    }
    return this.getDataArray()['length'];
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.ArrayDataGridDataSource
 * @instance
 */
oj.ArrayDataGridDataSource.prototype.totalSize = function()
{
    return this.getDataArray()['length'];
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.ArrayDataGridDataSource
 * @instance
 */
oj.ArrayDataGridDataSource.prototype.hasMore = function()
{
    return false;
};
//////// testing methods to get properties /////////

/**
 * Gets the rowHeaderKey property.  This is an internal method for testing and should not be used by application.
 * @return {string|null} the row header key
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getRowHeaderKey = function()
{
    return this.rowHeaderKey;
};

/**
 * Gets the columns property.  This is an internal method for testing and should not be used by application.
 * @return {Array|null} the keys of the column headers
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getColumns = function()
{
    return this.columns;
};

/**
 * Gets the data property.  This is an internal method for testing and should not be used by application.
 * @return {Array|Object|null} the underlying array data.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getData = function()
{
    return this.data;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/*jslint browser: true*/
/**
 * @export    
 * This class captures all translation resources and style classes used by the DataGrid.
 * This should be populated with information extracted through the framework and set on the DataGrid.
 * Internal.  Developers should never use this class.
 * @constructor
 */
oj.DataGridResources = function(rtlMode, translationFunction)
{
    this.rtlMode = rtlMode;
    this.translationFunction = translationFunction;
    this.styles = {};
    this.styles['datagrid'] = "oj-datagrid";
    this.styles['cell'] = "oj-datagrid-cell";
    this.styles['cellcontent'] = "oj-datagrid-cell-content";
    this.styles['celltext'] = "oj-datagrid-cell-text";
    this.styles['banded'] = "oj-datagrid-banded";
    this.styles['row'] = "oj-datagrid-row";
    this.styles['databody'] = "oj-datagrid-databody";
    this.styles['topcorner'] = "oj-datagrid-top-corner";
    this.styles['bottomcorner'] = "oj-datagrid-bottom-corner";
    this.styles['rowheaderspacer'] = "oj-datagrid-row-header-spacer";
    this.styles['colheaderspacer'] = "oj-datagrid-column-header-spacer";
    this.styles['status'] = "oj-datagrid-status";
    this.styles['emptytext'] = "oj-datagrid-empty-text";
    this.styles['header'] = "oj-datagrid-header";                
    this.styles['headercell'] = "oj-datagrid-header-cell";
    this.styles['headercelltext'] = "oj-datagrid-header-cell-text";
    this.styles['headercellcontent'] = "oj-datagrid-header-cell-content";
    this.styles['rowheader'] = "oj-datagrid-row-header";
    this.styles['colheader'] = "oj-datagrid-column-header";
    this.styles['colheadercell'] = "oj-datagrid-column-header-cell";
    this.styles['rowheadercell'] = "oj-datagrid-row-header-cell";
    this.styles['scroller-mobile'] = "oj-datagrid-scroller-touch";
    this.styles['scroller'] = "oj-datagrid-scroller";
    this.styles['scrollers'] = "oj-datagrid-scrollers";
    this.styles['focus'] = "oj-focus";
    this.styles['hover'] = "oj-hover";
    this.styles['active'] = "oj-active";
    this.styles['selected'] = "oj-selected";
    this.styles['disabled'] = "oj-disabled";
    this.styles['enabled'] = "oj-enabled";
    this.styles['default'] = "oj-default";
    this.styles['sortcontainer'] = "oj-datagrid-sort-icon-container";
    this.styles['sortascending'] = "oj-datagrid-sort-ascending-icon";
    this.styles['sortdescending'] = "oj-datagrid-sort-descending-icon";
    this.styles['icon'] = "oj-component-icon";
    this.styles['clickableicon'] = "oj-clickable-icon-nocontext";    
    this.styles['info'] = "oj-helper-hidden-accessible";
    this.styles['rowexpander'] = "oj-rowexpander";
    this.styles['cut'] = "oj-datagrid-cut";
    this.styles['selectaffordancetop'] = "oj-datagrid-touch-selection-affordance-top";
    this.styles['selectaffordancebottom'] = "oj-datagrid-touch-selection-affordance-bottom";
    this.styles['toucharea'] = "oj-datagrid-touch-area";
    
    this.styles['draggable'] = "oj-draggable";
    this.styles['drag'] = "oj-drag";
    this.styles['drop'] = "oj-drop";
    this.styles['activedrop'] = "oj-active-drop";
    this.styles['validdrop'] = "oj-valid-drop";
    this.styles['invaliddrop'] = "oj-invalid-drop";
    
    this.commands = {};
    this.commands['sortCol'] = "oj-datagrid-sortCol";
    this.commands['sortColAsc'] = "oj-datagrid-sortColAsc";
    this.commands['sortColDsc'] = "oj-datagrid-sortColDsc";
    this.commands['sortRow'] = "oj-datagrid-sortRow";
    this.commands['sortRowAsc'] = "oj-datagrid-sortRowAsc";
    this.commands['sortRowDsc'] = "oj-datagrid-sortRowDsc";
    this.commands['resize'] = "oj-datagrid-resize";
    this.commands['resizeWidth'] = "oj-datagrid-resizeWidth";
    this.commands['resizeHeight'] = "oj-datagrid-resizeHeight";
    this.commands['cut'] = "oj-datagrid-cut";
    this.commands['paste'] = "oj-datagrid-paste";
    
    this.attributes = {};
    this.attributes['key'] = "data-oj-key";
    this.attributes['resizable'] = "data-oj-resizable";
    this.attributes['sortable'] = "data-oj-sortable";    
    this.attributes['sortDir'] = "data-oj-sortdir";    
    this.attributes['expander'] = "data-oj-expander";    
    this.attributes['expanderIndex'] = "data-oj-expander-index";    
    this.attributes['container'] = oj.Components._OJ_CONTAINER_ATTR;
};

/**
 * Whether the reading direction is right to left.
 * @return {boolean} true if reading direction is right to left, false otherwise.
 * @export
 */
oj.DataGridResources.prototype.isRTLMode = function()
{
    return (this.rtlMode === "rtl") ? true : false;
};

/**
 * Gets the translated text
 * @param {string} key the key to the translated text
 * @param {Array=} args optional arguments to format the translated text
 * @return {string|null} the translated text
 * @export
 */
oj.DataGridResources.prototype.getTranslatedText = function(key, args)
{
    return this.translationFunction(key, args);
};

/**
 * Gets the mapped style class
 * @param {string} key the key to the style class
 * @return {string|null} the style class
 * @export
 */
oj.DataGridResources.prototype.getMappedStyle = function(key)
{
    if (key != null)
    {
        return this.styles[key];
    }
    return null;
};

/**
 * Gets the mapped command class
 * @param {string} key the key to the command class
 * @return {string|null} the command class
 * @export
 */
oj.DataGridResources.prototype.getMappedCommand = function(key)
{
    if (key != null)
    {
        return this.commands[key];
    }
    return null;
};

/**
 * Gets the mapped attribute
 * @param {string} key the key to the attribute
 * @return {string|null} the attribute
 * @export
 */
oj.DataGridResources.prototype.getMappedAttribute = function(key)
{
    if (key != null)
    {
        return this.attributes[key];
    }
    return null;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class 
 * @name oj.ojDataGrid
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="datagridOverview-section">
 *   JET DataGrid Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#datagridOverview-section"></a>
 * </h3>
 * <p>Description:</p>
 * <p>A JET DataGrid is a themable, WAI-ARIA compliant component that displays data in a cell oriented grid.  Data inside the DataGrid can be associated with row and column headers.  Page authors can customize the content rendered inside cells and headers.</p>
 *
 * <h3 id="data-section">
 *   Data
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
 * </h3>
 * <p>The JET DataGrid gets its data from a DataGridDataSource.  There are several types of DataGridDataSource that are provided out of the box:</p>
 * <ul>
 * <li>oj.ArrayDataGridDataSource</li>
 * <li>oj.CollectionDataGridDataSource</li>
 * <li>oj.PagingDataGridDataSource</li>
 * <li>oj.FlattenedTreeDataGridDataSource</li>
 * </ul>
 *
 * <p>oj.ArrayDataGridDataSource - Use this when the underlying data is a static array.  The ArrayDataGridDataSource supports both single array (in which case each item in the array represents a row of data in the DataGrid) and two dimensional array (in which case each item in the array represents a cell in the DataGrid).  See the documentation for oj.ArrayDataGridDataSource for more details on the available options.</p>
 *
 * <p>oj.CollectionDataGridDataSource - Use this when oj.Collection is the model for the underlying data.  Note that the DataGrid will automatically react to model event from the underlying oj.Collection.  See the documentation for oj.CollectionDataGridDataSource for more details on the available options.</p>
 *
 * <p>oj.PagingDataGridDataSource - Use this when the DataGrid is driven by an associating ojPagingControl.  See the documentation for oj.PagingDataGridDataSource for more details on the available options.</p>
 *
 * <p>oj.FlattenedTreeDataGridDataSource - Use this when hierarchical data is displayed in the DataGrid.  The FlattenedDataGridDataSource takes an oj.TreeDataSource and adapts that to the DataGridDataSource.  The ojRowExpander works with the FlattenedTreeDataGridDataSource to enable expanding/collapsing of rows.</p>
 *
 * <p>Developer can also create their own DataSource by extending the oj.DataGridDataSource class.  See the cookbook for an example of a custom DataGridDataSource.</p>
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * <p>When a data cell has focus:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>The first Tab into the DataGrid moves focus to the first cell of the first row.  The second Tab moves focus to the next focusable element outside of the DataGrid.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Left Arrow</kbd></td>
 *       <td>Moves focus to the cell of the previous column within the current row.  There is no wrapping at the beginning or end of the columns.  If a row header is present, then the row header next to the first column of the current row will gain focus.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Right Arrow</kbd></td>
 *       <td>Moves focus to the cell of the next column within the current row.  There is no wrapping at the beginning or end of the columns.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Up Arrow</kbd></td>
 *       <td>Moves focus to the cell of the previous row within the current column.  There is no wrapping at the beginning or end of the rows.  If a column header is present, then the column header above the first row of the current column will gain focus.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Down Arrow</kbd></td>
 *       <td>Moves focus to the cell of the next row within the current column.  There is no wrapping at the beginning or end of the rows.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Moves focus to the first (available) cell of the current row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Moves focus to the last (available) cell of the current row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Page Up</kbd></td>
 *       <td>Moves focus to the first (available) cell in the current column.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Page Down</kbd></td>
 *       <td>Moves focus to the last (available) cell in the current column.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Contrl+Space</kbd></td>
 *       <td>Selects all the cells of the current column.  This is only available if multiple cell selection mode is enabled.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Space</kbd></td>
 *       <td>Selects all the cells of the current row.  This is only available if multiple cell selection mode is enabled.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Arrow</kbd></td>
 *       <td>Extends the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+F8</kbd></td>
 *       <td>Freezes the current selection, therefore allowing user to move focus to another location to add additional cells to the current selection.  This is used to accomplish non-contiguous selection.  Use the Esc key or press Shift+F8 again to exit this mode.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+F10</kbd></td>
 *       <td>Brings up the context menu.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+X</kbd></td>
 *       <td>Marks the current row to move if dnd is enabled and the datasource supports move operation.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+V</kbd></td>
 *       <td>Move the row that is marked to directly under the current row.  If the row with the focused cell is the last row, then it will be move to the row above the current row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+Alt+5</kbd></td>
 *       <td>Read the context and content of the current cell to the screen reader.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>When a column header cell has focus:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Left Arrow</kbd></td>
 *       <td>Moves focus to the previous column header.  There is no wrapping at the beginning or end of the column headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Right Arrow</kbd></td>
 *       <td>Moves focus to the next column header.  There is no wrapping at the beginning or end of the column headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Down Arrow</kbd></td>
 *       <td>Moves focus to the cell of the first row directly below the column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Toggle the sort order of the column if the column is sortable.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+F10</kbd></td>
 *       <td>Brings up the context menu.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>When a row header cell has focus:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Up Arrow</kbd></td>
 *       <td>Moves focus to the previous row header.  There is no wrapping at the beginning or end of the row headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Down Arrow</kbd></td>
 *       <td>Moves focus to the next row header.  There is no wrapping at the beginning or end of the row headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Right Arrow</kbd></td>
 *       <td>Moves focus to the cell of the first column directly next to the row header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Left Arrow</kbd></td>
 *       <td>Moves focus to the cell of the first column directly next to the row header in RTL direction.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Toggle the sort order of the row if the row is sortable.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 *
 * <p>Since <code class="prettyprint">role="application"</code> is used in the data grid, application should always apply an <code class="prettyprint">aria-label</code> to the data grid element so that it can distinguish from other elements with application role.</p>
 *
 * <h3 id="context-section">
 *   Header Context And Cell Context
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
 * </h3>
 *
 * <p>For all header and cell options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular header or cell.  This gives developers the flexibility to return different value depending on the context.</p>
 *
 * <p>For header options, the context paramter contains the following keys:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>axis</kbd></td>
 *       <td>The axis of the header.  Possible values are 'row' and 'column'.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>component</kbd></td>
 *       <td>A reference to the DataGrid component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>index</kbd></td>
 *       <td>The index of the header, where 0 is the index of the first header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>key</kbd></td>
 *       <td>The key of the header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>data</kbd></td>
 *       <td>The data object for the header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentElement</kbd></td>
 *       <td>The header cell element.  The renderer can use this to directly append content to the header cell element.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>For cell options, the context paramter contains the following keys:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>component</kbd></td>
 *       <td>A reference to the DataGrid component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>datasource</kbd></td>
 *       <td>A reference to the data source object.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>indexes</kbd></td>
 *       <td>The object that contains both the zero based row index and column index in which the cell is bound to.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>keys</kbd></td>
 *       <td>The object that contains both the row key and column key which identifies the cell.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>data</kbd></td>
 *       <td>The data object for the cell.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentElement</kbd></td>
 *       <td>The data cell element.  The renderer can use this to directly append content to the data cell element.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>If a FlattenedTreeDataGridDataSource is used, the following additional contextual information are available:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>depth</kbd></td>
 *       <td>The depth of the row.  The depth of root row is 0.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>index</kbd></td>
 *       <td>The index of the row relative to its parent.  The index of the first child is 0.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>state</kbd></td>
 *       <td>The state of the row.  Possible values are "expanded", "collapsed", "leaf".</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentKey</kbd></td>
 *       <td>The key of the parent row.  For root row the parent key is null.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>Note that a custom DataGridDataSource can return additional header and cell context information.  Consult the documentation of the DataGridDataSource API for details.</p>
 *
 * <h3 id="context-section">
 *   Selection
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selection-section"></a>
 * </h3>
 *
 * <p>The DataGrid supports both cell based and row based selection mode, which developers can specify using the selectionMode option.  For each mode developers can also specify whether single or multiple cells/rows can be selected.</p>
 * <p>Developers can specify or retrieve selection from the DataGrid using the selection option.  A selection in DataGrid consists of an array of ranges.  Each range contains the following keys: startIndex, endIndex, startKey, endKey.  Each of the keys contains value for 'row' and 'column'.  If endIndex and endKey are not specified, that means the range is unbounded, i.e. the cells of the entire row/column are selected.</p>
 *
 * <h3 id="menu-section">
 *   Context menu
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#menu-section"></a>
 * </h3>
 *
 * <p>The DataGrid has a default context menu for operations such as header resize and sort.  Developers can also specify their own context menu by using the contextMenu option.  See the option for details.</p>
 * 
 * <h3 id="geometry-section">
 *   Geometry Management
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#geometry-section"></a>
 * </h3>
 *
 * <p>If the DataGrid is not styled with a fixed size, then it will responds to a change to the size of its container.  Note that unlike Table the content of the cell does not affect the height of the row.  The height of the rows must be pre-determined and specified by the developer or a default size will be used.</p>
 *
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>The order of the column headers will be rendered in reverse order in RTL reading direction.  The location of the row header will also be different between RTL and LTR direction.  It is up to the developers to ensure that the content of the header and data cell are rendered correctly according to the reading direction.</p>
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the datagrid must be <code class="prettyprint">refresh()</code>ed.  
 *
 * <h3 id="rtl-section">
 *   Templating Alignment
 *   <a class="bookmarkable-link" title="Templating Alignment" href="#templating-section"></a>
 * </h3>
 * <p>When using stamped content through templates, it is required to add specific class name's to obtain the default cell content alignment. In the case of header templates, add the class name <code class="prettyprint">oj-datagrid-header-cell-text</code>. In the cell template case add the class name <code class="prettyprint">oj-datagrid-cell-text</code> to obtain default cell alignment. These classes styles and default behavior are themable.</p>
*/
oj.__registerWidget('oj.ojDataGrid', $['oj']['baseComponent'],
{
    widgetEventPrefix: 'oj',
    options:
            {
                /**
                 * Row banding and column banding intervals within the data grid body.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, number>}
                 * @default <code class="prettyprint">{ "row":0, "column":0 }</code>
                 * @property {number} row row banding interval
                 * @property {number} column column banding interval
                 * 
                 * @example <caption>Initialize the data grid with the row banding interval set to every other row:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "bandingInterval": {"row":1} });
                 * 
                 * @example <caption>Get or set the <code class="prettyprint">rowBanding</code> option, after initialization:</caption>
                 * // get the bandingInterval object
                 * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "bandingInterval" );
                 * 
                 * // set the bandingInterval to every 2 rows and every other column
                 * $( ".selector" ).ojDataGrid( "option", "bandingInterval", {"row":2, "column":1 } );
                 */
                bandingInterval: {'row': 0, 'column': 0},
                /**
                 * The data source for the DataGrid must be an extension of oj.DataGridDataSource. 
                 * See the data source section in the introduction for out of the box data source types.
                 * To specify a row header key or index of an ArrayDataGridDataSource pass in an Object as such:
                 * {"data": oj.DataGridDataSource, "rowHeader":string|number}
                 * If the data attribute is not specified, an empty data grid is displayed.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {oj.DataGridDataSource}
                 * @default <code class="prettyprint">null</code>
                 * 
                 * @example <caption>Initialize the data grid with a one-dimensional array:</caption>
                 * $( ".selector" ).ojDataGrid({ "data": new oj.ArrayDataGridDataSource([1,2,3])});
                 * 
                 * @example <caption>Initialize the data grid with a two-dimensional array:</caption>
                 * $( ".selector" ).ojDataGrid({ "data": new oj.ArrayDataGridDataSource(['X','X','O'],['O','X','O'],['O','O','X'])});
                 * 
                 * @example <caption>Initialize the data grid with a two-dimensional array and set an index for row headers:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":{"rowHeader":2 , "data": new oj.ArrayDataGridDataSource(['1','2','Cat'],['1','4','Dog'],['5','1','Bird']) }});
                 * 
                 * @example <caption>Initialize the data grid with an oj.Collection:</caption>
                 * $( ".selector" ).ojDataGrid({ "data": new oj.CollectionDataGridDataSource(collection)});
                 * 
                 * @example <caption>Initialize the data grid with an oj.Collection and specify a row header:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":{ "data":new oj.CollectionDataGridDataSource(collection), "rowHeader":'key' }});
                 * 
                 * @example <caption>Initialize the data grid with a custom data source</caption>
                 * $( ".selector" ).ojDataGrid({ "data":new CustomDataSource()});
                 */
                data: null,
                /**
                 * The text to display when there are no data in the Grid. If it is not defined, 
                 * then a default empty text is extracted from the resource bundle.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {String|null}
                 * @default <code class="prettyprint">"No data to display."</code>
                 * 
                 * @example <caption>Initialize the data grid with the empty text set to 'no data':</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "emptyText": "no data" });
                 */
                emptyText: null,
                /**
                 * Display or hide the horizontal or vertical grid lines in the data body. Gridlines are
                 * visible by default, and must be set to 'hidden' in order to be hidden.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, string>}
                 * @default <code class="prettyprint">{"horizontal": "visible", "vertical": "visible"}</code>
                 * @property {string} horizontal horizontal gridlines, valid values are: "hidden", "visible"
                 * @property {string} vertical vertical gridlines, valid values are: "hidden", "visible"
                 * 
                 * @example <caption>Initialize the data grid with only horizontal gridlines visible:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "gridlines": {"horizontal": "visible", "vertical": "hidden"} });
                 */
                gridlines: {'horizontal': 'visible', 'vertical': 'visible'},
                /**
                 * The index or key of the row and/or column to display initially in the data grid. 
                 * Only key or index should be specified, if they both are the grid will scroll initially
                 * to the key values.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, Object>|null}
                 * @default <code class="prettyprint">null</code>
                 * @property {Object} index scroll to a given row and column index of the datagrid
                 * @property {number} index.row row index to scroll to
                 * @property {number} index.column column index to scroll to
                 * @property {Object} key scroll to a given row and column key of the datagrid
                 * @property {string} key.row row key to scroll to
                 * @property {string} key.column column key to scroll to
                 * 
                 * @example <caption>Initialize the data grid to scroll to row index 5 and column index 7:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "scrollPosition": {"index":{"row": 5, "column": 7}}});
                 * 
                 * @example <caption>Initialize the data grid to scroll to row key 'id5' and column key 'id7':</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "scrollPosition": {"key":{"row": "id5", "column": "id7"}}}); 
                 */
                scrollPosition: null,
                /**
                 * Specifies whether row/cell selection can be made and the cardinality 
                 * of each (single/multiple/none) selection in the Grid. Only one of the properties, row or column,
		 * should be set at at time. Selection is initially disabled, but setting the value to null will disable
                 * selection.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, string>|null}
                 * @default <code class="prettyprint">null</code>
                 * @property {string} row set row selection mode, valid values are: "single", "multiple"
                 * @property {string} cell set cell selection mode, valid values are: "single", "multiple"
                 * 
                 * @example <caption>Initialize the data grid to enable single row selection:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "selectionMode": {"row":"single"}});
                 * 
                 * @example <caption>Initialize the data grid to enable multiple cell selection:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "selectionMode": {"cell":"multiple"}});
                 */
                selectionMode: null,
                /**
                 * Enables or disables reordering the rows within the same datagrid using drag and drop.</br></br>
                 * Specify an object with the property "reorder" set to <code class="prettyprint">{'row':'enable'}</code> to enable
                 * reordering.  Setting the <code class="prettyprint">"reorder"</code> property to <code class="prettyprint">{'row':'disable'}</code>,
                 * or setting the <code class="prettyprint">"dnd"</code> property to <code class="prettyprint">null</code> (or omitting
                 * it), disables reordering support. There must be move capability on the datasource to support this feature.
                 * 
                 * @type {Object}
                 * @property {Object} reorder an object with property row
                 * @property {string} reorder.row row reordering within the datagrid: "enable", "disable"
                 * 
                 * @default <code class="prettyprint">{reorder: {row :'disable'}}</code>
                 * @expose
                 * @instance
                 * @memberof! oj.ojDataGrid
                 * 
                 * @example <caption>Initialize the data grid to enable single row reorder:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "dnd" : {"reorder":{"row":"enable"}}});
                 */
                dnd : {reorder: {row :'disable'}},    
                /**
                 * Specifies the mechanism used to scroll the data inside the data grid. possible values are: auto(datagrid will decide), loadMoreOnScroll, and scroll.
                 * When loadMoreOnScroll is specified, additional data are fetched when the user scrolls to the bottom of the data grid.
                 * When scroll is specified, then virtual scrolling is used meaning only rows/columns visibile in the viewport are fetched.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {string|null}
                 * @default <code class="prettyprint">null</code>
                 * 
                 * @example <caption>Initialize the data grid to use virtualized scrolling:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "scrollPolicy": "scroll"});
                 */
                scrollPolicy: "auto",                
                /**
                 * Specifies the current selections in the data grid. 
                 * Returns an array of range objects, or an empty array if there's no selection.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Array.<Object>}
                 * @default <code class="prettyprint">[]</code>
                 * 
                 * @example <caption>Get the current selection:</caption>
                 * $( ".selector" ).ojDataGrid("option", "selection");
                 * 
                 * @example <caption>Set a row selection on the grid during initialization:</caption>
                 * $(".selector").ojDataGrid({"selection", [{startIndex: {"row":1}, endIndex:{"row":3}}]});
                 * 
                 * @example <caption>Set a cell selection on the grid during initialization:</caption>
                 * $(".selector").ojDataGrid({"selection", [{startIndex: {"row":1, "column":2}, endIndex: {"row":3, "column":4}}]});
                 *
                 * @example <caption>Set a row selection on the grid after initialization:</caption>
                 * $(".selector").ojDataGrid("option", "selection", [{startIndex: {"row":1}, endIndex:{"row":3}}]);
                 * 
                 * @example <caption>Set a cell selection on the grid after initialization:</caption>
                 * $(".selector").ojDataGrid("option", "selection", [{startIndex: {"row":1, "column":2}, endIndex: {"row":3, "column":4}}]);
                 */
                selection: [],                
                /** @expose */
                header: {
                    /** @expose */
                    row: {
                        /**
                         * The CSS style class to apply to row headers in the data grid. If a string is specified
                         * the class will be added to all row header cells. 
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string to be set as a className.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.row.className
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with row header style calss set to 'rhstyle':</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"className":"rhstyle"} } });
                         * 
                         * @example <caption>Get or set the <code class="prettyprint">className</code> option, after initialization:</caption>
                         * // get the className string
                         * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "header.row.className" );
                         * 
                         * // set the className string to a function of the headerContext
                         * $( ".selector" ).ojDataGrid( "option", "header.row.className", function(headerContext){return headerContext['index'] % 2 == 0 ? 'even':'odd'}});
                         */
                        className: null,
                        /**
                         * The renderer function that renders the content of the row header. See <a href="#context-section">headerContext</a>
                         * in the introduction to see the object passed into the row header renderer function.
                         * The function returns either a String or a DOM element of the content inside the row header.
                         * If the developer chooses to manipulate the row header element directly, the function should return 
                         * nothing. If no renderer is specified, the Grid will treat the header data as a String.
                         * 
                         * @expose 
                         * @alias header.row.renderer
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with row header renderer that capitalizes each character in the row header cells:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"renderer": function(headerContext) {
                         *                                            return headerContext['key'].toUpperCase();}}}});
                         *
                         * @example <caption>Get or set the <code class="prettyprint">renderer</code> option, after initialization:</caption>
                         * // get the renderer function
                         * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "row.header.renderer" );
                         * 
                         * // set the renderer function
                         * $( ".selector" ).ojDataGrid( "option", "row.header.renderer", myFunction});
                         */
                        renderer: null,
                        /**
                         * Enable or disable width or height resize along the row headers. Note 
                         * that for row header, a function cannot be used with "height". 
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string of enable or disable.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.row.resizable
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {Object.<string, string>|Object.<string, function(Object)>|null}
                         * @default <code class="prettyprint">{"width": "disable", "height": "disable"}</code>
                         * @property {string} width row width resizable valid values are: "enable", "disable"
                         * @property {string} height row header height resizable valid values are: "enable", "disable"
                         *
                         * @example <caption>Initialize the data grid with row header height resizable only:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"resizable": {"height":"enable"}}}});
                         * 
                         * @example <caption>Initialize the data grid with every other row header height resizable:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"resizable": {"height":function(headerContext){ return headerContext['index'] % 2 === 0 ? 'enable':'disable'; }}}}}); 
                         */
                        resizable: {width: 'disable', height: 'disable'},
                        /**
                         * Enable or disable sorting on the field bounded by this header. The 
                         * data source associated with the DataGrid must have the sort function defined.
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string of auto, enable, or disable.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.row.sortable
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|string}
                         * @default <code class="prettyprint">"auto"</code>
                         * @ojvalue {string} "auto" get the sortable property from the data source
                         * @ojvalue {string} "enable" enable sorting on row headers
                         * @ojvalue {string} "disable" disable sorting on row headers
                         * 
                         * @example <caption>Initialize the data grid with row header sort disabled:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"sortable": "disable"}}});
                         *
                         * @example <caption>Initialize the data grid with every other row header sort enabled:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"sortable": function(headerContext){ return headerContext['index'] % 2 === 0 ? 'auto':'disable'; }}}}); 
                         * 
                         */
                        sortable: 'auto',
                        /**
                         * The inline style to apply to row headers in the data grid. If a string is specified
                         * the class will be added to all row header cells.
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.row.style
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with row headers to have green backgrounds:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {style: "background-color: green"}}});
                         * 
                         * @example <caption>Initialize the data grid with every other row header to have a green background:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {style: function(headerContext) {
                         *                                            if (headerContext['index'] % 2 === 0)
                         *                                               return "background-color: green";
                         *                                            return;}}}});           
                         */
                        style: null
                    },
                    /** @expose */
                    column: {
                        /**
                         * The CSS style class to apply to column headers in the data grid. If a string is specified
                         * the class will be added to all column header cells. 
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string to be set as a className.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.column.className
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with column header style calss set to 'chstyle':</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"className":"chstyle"} } });
                         * 
                         * @example <caption>Get or set the <code class="prettyprint">className</code> option, after initialization:</caption>
                         * // get the className string
                         * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "header.column.className" );
                         * 
                         * // set the className string to a function of the headerContext
                         * $( ".selector" ).ojDataGrid( "option", "header.column.className", function(headerContext){return headerContext['index'] % 2 == 0 ? 'even':'odd'}});
                         */
                        className: null,
                        /**
                         * The renderer function that renders the content of the column header. See <a href="#context-section">headerContext</a>
                         * in the introduction to see the object passed into the column header renderer function.
                         * The function returns either a String or a DOM element of the content inside the column header.
                         * If the developer chooses to manipulate the column header element directly, the function should return 
                         * nothing. If no renderer is specified, the Grid will treat the header data as a String.
                         * 
                         * @expose 
                         * @alias header.column.renderer
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with column header renderer that capitalizes each character in the column header cells:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"renderer": function(headerContext) {
                         *                                            return headerContext['key'].toUpperCase();}}}});
                         *
                         * @example <caption>Get or set the <code class="prettyprint">renderer</code> option, after initialization:</caption>
                         * // get the renderer function
                         * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "column.header.renderer" );
                         * 
                         * // set the renderer function
                         * $( ".selector" ).ojDataGrid( "option", "column.header.renderer", myFunction});
                         */
                        renderer: null,
                        /**
                         * Enable ro disable width or height resize along the column headers. Note 
                         * that for column header, a function cannot be used with "height". 
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string of enable or disable.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.column.resizable
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {Object.<string, string>|Object.<string, function(Object)>|null}
                         * @default <code class="prettyprint">{"width": "disable", "height": "disable"}</code>
                         * @property {string} width column width resizable valid values are: "enable", "disable"
                         * @property {string} height column header height resizable valid values are: "enable", "disable"
                         *
                         * @example <caption>Initialize the data grid with column header width resizable only:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"resizable": {"width":"enable"}}}});
                         * 
                         * @example <caption>Initialize the data grid with every other column header width resizable:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"resizable": {"width":function(headerContext){ return headerContext['index'] % 2 === 0 ? 'enable':'disable'; }}}}}); 
                         */
                        resizable: {'width': 'disable', 'height': 'disable'},
                        /**
                         * Enable or disable sorting on the field bounded by this header. The 
                         * data source associated with the DataGrid must have the sort function defined.
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string of auto, enable, or disable.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.column.sortable
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|string}
                         * @default <code class="prettyprint">"auto"</code>
                         * @ojvalue {string} "auto" get the sortable property from the data source
                         * @ojvalue {string} "enable" enable sorting on column headers
                         * @ojvalue {string} "disable" disable sorting on column headers
                         * 
                         * @example <caption>Initialize the data grid with column header sort disabled:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"sortable": "disable"}}});
                         *
                         * @example <caption>Initialize the data grid with every other column header sort enabled:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"sortable": function(headerContext){ return headerContext['index'] % 2 === 0 ? 'auto':'disable'; }}}}); 
                         * 
                         */
                        sortable: 'auto',
                        /**
                         * The inline style to apply to column headers in the data grid. If a string is specified
                         * the class will be added to all column header cells. 
                         * A function can be specified with this option.  The function would take a single parameter, headerContext, and must return
                         * a string.  See <a href="#context-section">headerContext</a> for details.
                         * 
                         * @expose 
                         * @alias header.column.style
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with column headers to have green backgrounds:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {style: "background-color: green"}}});
                         * 
                         * @example <caption>Initialize the data grid with every other column header to have a green background:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {style: function(headerContext) {
                         *                                            if (headerContext['index'] % 2 === 0)
                         *                                               return "background-color: green";
                         *                                            return;}}}});           
                         */
                        style: null
                    }
                },
                /** @expose */
                cell: {
                    /**
                     * The CSS style class to apply to cells in the data grid body. If a string is specified
                     * the class will be added to all cells.
                     * A function can be specified with this option.  The function would take a single parameter, cellContext, and must return
                     * a string to be set as a className.  See <a href="#context-section">cellContext</a> for details.
                     * 
                     * @expose 
                     * @alias cell.className
                     * @memberof! oj.ojDataGrid
                     * @instance
                     * @type {function(Object)|string|null}
                     * @default <code class="prettyprint">null</code>
                     * 
                     * @example <caption>Initialize the data grid with the cell style class set to 'myCellStyle':</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell":{"className":"myCellStyle"} });
                     * 
                     * @example <caption>Get or set the <code class="prettyprint">className</code> option, after initialization:</caption>
                     * // get the className string
                     * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "cell.className" );
                     * 
                     * // set the className string to a function of the cellContext
                     * $( ".selector" ).ojDataGrid( "option", "cell.className", function(cellContext){return cellContext['index'] % 2 == 0 ? 'even':'odd'}});
                     */
                    className: null,
                    /**
                     * The renderer function that renders the content of the cell. See <a href="#context-section">cellContext</a>
                     * in the introduction to see the object passed into the cell renderer function.
                     * The function returns either a String or a DOM element of the content inside the data body cell.
                     * If the developer chooses to manipulate the cell element directly, the function should return 
                     * nothing. If no renderer is specified, the Grid will treat the cell data as a String.
                     * 
                     * @expose 
                     * @alias cell.renderer
                     * @memberof! oj.ojDataGrid
                     * @instance
                     * @type {function(Object)|null}
                     * @default <code class="prettyprint">null</code>
                     * 
                     * @example <caption>Initialize the data grid with cell renderer that capitalizes each character in the cell:</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell": {"renderer": function(cellContext) {
                     *                                            return cellContext['key'].toUpperCase();}}});
                     *
                     * @example <caption>Get or set the <code class="prettyprint">renderer</code> option, after initialization:</caption>
                     * // get the renderer function
                     * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "cell.renderer" );
                     * 
                     * // set the renderer function
                     * $( ".selector" ).ojDataGrid( "option", "cell.renderer", myFunction});
                     */
                    renderer: null,
                    /**
                     * The CSS style to apply directly to cells in the data grid body. If a string is specified
                     * the style will be added to all cells. 
                     * A function can be specified with this option.  The function would take a single parameter, cellContext, and must return
                     * a string.  See <a href="#context-section">cellContext</a> for details.
                     * 
                     * @expose 
                     * @alias cell.style
                     * @memberof! oj.ojDataGrid
                     * @instance
                     * @type {function(Object)|string|null}
                     * @default <code class="prettyprint">null</code>
                     * 
                     * @example <caption>Initialize the data grid with cells to have green backgrounds:</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell":{style: "background-color: green"}});
                     * 
                     * @example <caption>Initialize the data grid with every other cell to have a green background using a function:</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell": {style: function(cellContext) {
                     *                                            if (cellContext['index'] % 2 === 0)
                     *                                               return "background-color: green";
                     *                                            return;}}});           
                     */
                    style: null
                },

                /**
                 * Triggered when a portion of the data grid is resized
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {Element} ui.header the key of the header which was resized
                 * @property {string} ui.size the new pixel size string (ex: '75px')
                 *
                 * @example <caption>Initialize the data grid with the <code class="prettyprint">resize</code> callback specified:</caption>
                 * $( ".selector" ).ojDataGrid({
                 *     "resize": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojresize</code> event:</caption>
                 * $( ".selector" ).on( "ojresize", function( event, ui ) {} );
                 */
                resize: null,				

                /**
                 * Triggered when a sort is performed on the data grid
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {Element} ui.header the key of the header which was sorted on				 
                 * @property {string} ui.direction the direction of the sort ascending/descending
                 * 
                 * @example <caption>Initialize the data grid with the <code class="prettyprint">sort</code> callback specified:</caption>
                 * $( ".selector" ).ojDataGrid({
                 *     "sort": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojsort</code> event:</caption>
                 * $( ".selector" ).on( "ojsort", function( event, ui ) {} );
                 */
                sort: null,

                /**
                 * Fired whenever a supported component option changes, whether due to user interaction or programmatic
                 * intervention.  If the new value is the same as the previous value, no event will be fired.
                 *
                 * Currently there is one supported option, <code class="prettyprint">"selection"</code>.  Additional
                 * options may be supported in the future, so listeners should verify which option is changing
                 * before taking any action.
                 *
                 * @expose
                 * @event
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {string} ui.option the name of the option that is changing
                 * @property {Object} ui.previousValue the previous value of the option
                 * @property {Object} ui.value the current value of the option
                 * @property {Object} ui.optionMetadata information about the option that is changing
                 * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
                 *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
                 *
                 */
                 optionChange: null
	
                
                /**
                 * Identifies the JET Menu that the component should launch as a context menu on right-click or
                 * <kbd>Shift-F10</kbd>. If specified, the browser's native context menu will be replaced by the
                 * specified JET Menu.
                 * 
                 * <p>To specify a JET context menu on a DOM element that is not a JET component, see the
                 * <code class="prettyprint">ojContextMenu</code> binding.  
                 * 
                 * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the
                 * context menu via the standard HTML5 syntax shown in the below example.  When the component is
                 * initialized, the context menu thus specified will be set on the component.
                 *
                 * <p>When defining a contextMenu, ojDataGrid will provide built-in behavior for "edit" style functionality
                 *  (e.g. cut/copy/paste) if the following format for menu &lt;li&gt; item's is used (no &lt;a&gt; 
                 *  elements are required):
                 *  
                 * <ul><li> &lt;li data-oj-command="oj-datagrid-['commandname']" /&gt;</li></ul>
                 * 
                 * <p>The available translated text will be applied to menu items defined this way.
                 * 
                 * <p>The supported commands:
                 * <table class="keyboard-table">
                 *   <thead>
                 *     <tr>
                 *       <th>Default Function</th>
                 *       <th>data-oj-command value</th>
                 *     </tr>
                 *   </thead>
                 *   <tbody>
                 *     <tr>
                 *       <td><kbd>Resize menu</kbd> (contains width and height resize)</td>
                 *       <td>oj-datagrid-resize</td>
                 *     </tr>
                 *     <tr>
                 *       <td>Sort Row menu</kbd> (contains ascending and descending sort)</td>
                 *       <td>oj-datagrid-sortRow</td>
                 *     </tr>
                 *     <tr>
                 *       <td>Sort Column menu</kbd> (contains ascending and descending sort)</td>
                 *       <td>oj-datagrid-sortCol</td>
                 *     </tr>
                 *     <tr>
                 *       <td><kbd>Resize Width</kbd></td>
                 *       <td>oj-datagrid-resizeWidth</td>
                 *     </tr>
                 *     <tr>
                 *       <td><kbd>Resize Height</kbd></td>
                 *       <td>oj-datagrid-resizeHeight</td>
                 *     </tr> 
                 *     <tr>
                 *       <td><kbd>Sort Row Ascending</kbd></td>
                 *       <td>oj-datagrid-sortRowAsc</td>
                 *     </tr>
                 *     <tr>
                 *       <td><kbd>Sort Row Descending</kbd></td>
                 *       <td>oj-datagrid-sortRowDsc</td>
                 *     </tr>			
                 *     <tr>
                 *       <td><kbd>Sort Column Ascending</kbd></td>
                 *       <td>oj-datagrid-sortColAsc</td>
                 *     </tr>
                 *     <tr>
                 *       <td><kbd>Sort Column Descending</kbd></td>
                 *       <td>oj-datagrid-sortColDsc</td>
                 *     </tr>			
                 *     <tr>
                 *       <td><kbd>Cut</kbd></td>
                 *       <td>oj-datagrid-cut</td>
                 *     </tr>		
                 *     <tr>
                 *       <td><kbd>Paste</kbd></td>
                 *       <td>oj-datagrid-paste</td>
                 *     </tr>		
                 * </tbody></table>
                 * 
                 *
                 * <p>The JET Menu should be initialized before any component using it as a context menu.
                 * 
                 * @member
                 * @name contextMenu
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {string | null}
                 * @default <code class="prettyprint">null</code>
                 * 
                 * @example <caption>Initialize a JET Data Grid with a context menu:</caption>
                 * // via recommended HTML5 syntax:
                 * &lt;div id="myDataGrid" contextmenu="myMenu" data-bind="ojComponent: { ... }>
                 * 
                 * // via JET initializer (less preferred) :
                 * $( ".selector" ).ojDataGrid({ "contextMenu": "#myContextMenu"  ... } });
                 * 
                 * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option for
                 *      an ojDataGrid after initialization:</caption>
                 * // getter
                 * var menu = $( ".selector" ).ojDataGrid( "option", "contextMenu" );
                 * 
                 * // setter
                 * $( ".selector" ).ojDataGrid( "option", "contextMenu", "#myContextMenu"} );
                 */                
            },
    /**
     * Create the grid
     * @override
     * @memberof! oj.ojDataGrid
     * @protected
     */
    _ComponentCreate: function()
    {
        this._super();
        this.root = this.element[0];
        this.rootId = this.root.getAttribute('id');        
        this.grid = new DvtDataGrid();    
	this.redrawSet = {'data':'all', 'header':['className','renderer','style','template']}; //vvc    
    },
    /**
     * Initialize the grid after creation
     * @protected
     * @override
     * @memberof! oj.ojDataGrid
     */        
    _AfterCreate: function () 
    {     
        var self = this;

        // unregister existing resize listener before emptying out the root
        this._unregisterResizeListener(this.root);

        $(this.root).empty();
        this._super();          
        this.resources = new oj.DataGridResources(this._GetReadingDirection(), this._getTranslation.bind(self));
        this._setDataSource();
        // sets the initial (or default) selection on internal grid
        this._setSelection();

        this._addContextMenu();    
        if (this.datasource != null)
        {
            this.grid.SetDataSource(this.datasource);
        }
        this.grid.SetOptions(this.options);
        this.grid.SetResources(this.resources);
        this.grid.SetCreateContextCallback(this._modifyContext.bind(self));

        //listen for resizing, selection, sort and trigger relevent events
        this.grid.addListener('resize', function(details)
        {
            self._trigger('resize', details['event'], details['ui']);
        });
        this.grid.addListener('select', function(details)
        {
            self._fireOptionChange("selection", details['ui']['previousSelection'], details['ui']['selection'], details['event']);
        });
        this.grid.addListener('sort', function(details)
        {
            self._trigger('sort', details['event'], details['ui']);
        });
        this.grid.addListener('keydown', function(details)
        {
            self._trigger('keydown', details['event'], details['ui']);
        });
        this.grid.addListener('active', function(details)
        {
            self._trigger('active', details['event'], details['ui']);
        });
        
        //  Possible handler for contextmenu touch support
        // _OpenContextMenu requires a jquery event object
        //this.grid.addListener('contextmenu', function(details)
        //{
             //contextmenu 
        //   var menu = $("#" + self.options.contextMenu['menu']).data( "oj-ojMenu" );
        //   var e = jQuery.Event( "touchend" );
        //   e.originalEvent = details['event'];
        //  self._OpenContextMenu(menu,  e);
        //});
        
        this.grid.render(this.root);   

        // register a resize listener        
        if (this.datasource != null)
        {
            this._registerResizeListener(this.root);
        }
    },
    /**
     * Redraw the entire data grid after having made some external modifications.
     *      
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojDataGrid
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojDataGrid( "refresh" );
     */
    refresh: function()
    {
        this._super();	

        // unregister existing resize listener before emptying out the root
        this._unregisterResizeListener(this.root);

        $(this.root).empty();
        this._setDataSource();
        if (this.datasource != null)
        {
            this.grid.SetDataSource(this.datasource);
        }
        this.grid.SetOptions(this.options);
        this.grid.SetResources(this.resources);        
        this.grid.refresh(this.root);

        if (this.datasource != null)
        {
            // register a resize listener        
            this._registerResizeListener(this.root);
        }
    },
    /**
     * Destroy the grid
     * @memberof! oj.ojDataGrid
     * @private
     */
    _destroy: function()
    {
        this.grid.destroy();
        this._unregisterResizeListener(this.root);
        $(this.root).empty();
    },

    /**
     * Fires an optionChange event 
     * @param {String} key the key of option that changed
     * @param {Object} previousValue the previous value
     * @param {Object} value the new value
     * @param {Event} originalEvent  
     *
     * @private
     */
    _fireOptionChange: function(key, previousValue, value, originalEvent) 
    {
      var ui = {
        "option": key,
        "previousValue": previousValue,
        "value": value,
        // (originalEvent is non-null) iff (option change is due to user interaction) 
        // iff (binding should write back the value)
        "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
      };
      this._trigger('optionChange', originalEvent, ui);
    },

    /**
     * Sets multiple options 
     * @param {Object} options the options object
     * @param {Object} flags additional flags for option
     * @override
     * @private
     */
    _setOptions: function( options, flags ) //vvc
    { 
	var isRefresh;

        if(!this.datasource)
        {
            // not initialized yet, just call super
            this._super(options, flags);

            // if datasource is one of the options specified, then re-render the grid
            if (options['data'] != null)
            {
                this.refresh();
            }
        }
        else
        {            
            // check whether a full refresh is needed
            isRefresh = this._shouldRefresh(options);
            // update options
            this._super(options, flags);

            if(isRefresh)
            {
                //redraw whole grid if required 
                this.refresh();
            }
            else
            {
                //or process updated option(s) through the DvtDataGrid
                this.grid.UpdateOptions(options);
            }
        }
    },

    /**
     * Determine if the entire datagrid should refresh based on which options are updated.
     * @param {Object} options the options object
     * @return {boolean} true if datagrid should refresh, false otherwise
     * @private
     */
    _shouldRefresh: function(options)
    { 
        var i, key, isRefresh, elm, itm, opt;

        //Traversing through the header object to retreave option value 
        //header -> column/row -> resizable -> width/heigh

        isRefresh = false;

        for (key in options) 
        {
            if(key in this.redrawSet)
            {
                if (key === "data")
                {
                    isRefresh = true;
                    break;
                }
                //Walk through the header object to retrieve the option value 
                else if(key == "header")
                {
                    for(elm in options["header"])
                    {
                        if(elm == "column" || elm == "row" || elm == "cell")
                        {
                            for(itm in options["header"][elm])
                            {
                                //And check this option against the redraw list,
                                //if the option is in it and its value is different from original
                                //then assign 'true' to the isRefresh flag
                                for(i =0; i < this.redrawSet["header"].length; i++)
                                {
                                    if(itm == this.redrawSet["header"][i])
                                    {
                                        for(opt in this.options["header"][elm])
                                        {
                                            if(opt == itm)
                                            {
                                                if(options["header"][elm][itm] != this.options["header"][elm][itm])
                                                {
                                                    isRefresh = true;
                                                    break;
                                                }
                                            }
                                        }                                                                         
                                    }
                                }
                                if(isRefresh)
                                {
                                    break;
                                }
                            }
                        }
                        if(isRefresh)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    for(opt in this.options)
                    {
                        if(opt == key)
                        {
                            if(!oj.Object.compareValues(options[key],this.options[opt]))
                            {
                                isRefresh = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        return isRefresh;
    },
                        
    /**
     * Checks if resize is enabled along a given axis width/height
     * @private	 
     * @param {string} axis column/row
     * @param {string} direction width/height
     * @return {boolean} true if resize is not set to 'disable'
     */
    _isResizeEnabled: function(axis, direction)
    {
        return this.options['header'][axis]['resizable'][direction] !== 'disable';
    },
            
    /**
     * Checks if sorting is enabled along a given axis
     * @private	 
     * @param {string} axis column/row
     * @return {boolean} true if sorting is not set to 'disable'
     */
    _isSortEnabled: function(axis)
    {
        return this.options['header'][axis]['sortable'] !== 'disable';
    },
            
    /**
     * Add a default context menu to the grid if there is none. If there is
     * a context menu set on the grid options we use that one. Add listeners
     * for context menu before show and select. 
     * @private	 
     */
    _addContextMenu: function()
    {
        var self, menuContainer, rootId, resizeMenu = null, sortMenu = null, moveMenu = null, listItems, temp, sortCapability;
        self = this;

        if (this.options["contextMenu"] == null)
        {
            if (this.datasource != null) {
                menuContainer = $('<ul>');
                menuContainer.css('display', 'none').attr('id', this.rootId + 'contextmenu');
                $(this.root).append(menuContainer);
                if (this._isResizeEnabled('column', 'width') || this._isResizeEnabled('column', 'height') ||
                        this._isResizeEnabled('row', 'width') || this._isResizeEnabled('row', 'height'))
                {
                    resizeMenu = this._buildContextMenuItem('resize');
                }
                
                sortCapability = this.datasource.getCapability('sort');
                if (this._isSortEnabled('column'))
                {                
                    if (sortCapability === 'column' || sortCapability === 'full')
                    {
                        sortMenu = this._buildContextMenuItem('sortCol');
                    }
                }
                if (this._isSortEnabled('row'))
                {
                    if (sortCapability === 'row' || sortCapability === 'full')
                    {
                        if (sortMenu != null)
                        {
                            sortMenu = sortMenu.add(this._buildContextMenuItem('sortRow'));
                        }
                        else
                        {
                            sortMenu = this._buildContextMenuItem('sortRow');                            
                        }
                    }                    
                }

                if (this.options['dnd']['reorder'] === 'enable')
                {
                    switch (this.datasource.getCapability('move'))
                    {
                        case 'none':
                            break;
                        default:
                            moveMenu = $(this._buildContextMenuListItem('cut')).add($(this._buildContextMenuListItem('paste')));
                    }
                }
                menuContainer.append(resizeMenu).append(sortMenu).append(moveMenu);
                menuContainer.ojMenu();
                this._setOption("contextMenu", '#' + menuContainer.attr('id'));
                menuContainer.on("ojbeforeopen", this._handleContextMenuBeforeShow.bind(this));
                menuContainer.on("ojselect", this._handleContextMenuSelect.bind(this));
            }
        }
        else
        {
            menuContainer = $(this.options["contextMenu"]);
            listItems = menuContainer.find('[data-oj-command]');
            listItems.each(function(){
                var command;
                if ($(this).children('a').length === 0)
                {
                    command = $(this).attr('data-oj-command').split("-");
                    $(this).replaceWith(self._buildContextMenuItem(command[command.length-1]));
                }
            });
            menuContainer.ojMenu('refresh');
            menuContainer.on("ojbeforeopen", this._handleContextMenuBeforeShow.bind(this));
            menuContainer.on("ojselect", this._handleContextMenuSelect.bind(this));
        }
    },
            
    /**
     * Builds a menu for a command, takes care of submenus where appropriate
     * @param {string} command the command that the datagrid should build a menu item for
     * @private	 
     */            
    _buildContextMenuItem: function(command)
    {
        if (command === 'resize')
        {
            return $(this._buildContextMenuListItem('resize')).append($('<ul></ul>').append($(this._buildContextMenuListItem('resizeWidth'))).append($(this._buildContextMenuListItem('resizeHeight'))));
        }
        else if(command === 'sortCol')
        {
            return $(this._buildContextMenuListItem('sortCol')).append($('<ul></ul>').append($(this._buildContextMenuListItem('sortColAsc'))).append($(this._buildContextMenuListItem('sortColDsc'))));
        }
        else if(command === 'sortRow')
        {
            return $(this._buildContextMenuListItem('sortRow')).append($('<ul></ul>').append($(this._buildContextMenuListItem('sortRowAsc'))).append($(this._buildContextMenuListItem('sortRowDsc'))));
        }        
        else if (Object.keys(this.resources.commands).indexOf(command) != -1)
        {
            return $(this._buildContextMenuListItem(command));         
        }
    },
            
    /**
     * Builds a context menu list item from a command
     * @param {string} command the string to look up command value for as well as translation
     * @return {string} an HTML string containing a list item and a  
     * @private	 
     */
    _buildContextMenuListItem: function(command)
    {
        return '<li data-oj-command=' + this._getMappedCommand(command) + '>' + this._buildContextMenuLabel(command) + '</li>';
    },
    /**
     * Builds a context menu label by looking up command translation
     * @param {string} command the string to look up translation for
     * @return {string} an HTML string containing a label  
     * @private	 
     */
    _buildContextMenuLabel: function(command)
    {
        // convert to the translation key convention
        var key = 'label' + command.charAt(0).toUpperCase() + command.slice(1);
        return '<a href="#">' + this._getTranslation(key) + '</a>';
    },        
            
    /**
     * Get the context menu from the grid
     * @return {Array.<Element>|Element} the context menu element that is set in the options
     * @private	 
     */
    _getContextMenu: function()
    {
        return $(this.options["contextMenu"]).get(0);
    },
    /**
     * Get a translation from the translation resources or one the user set
     * @param {string} key the key of the translation to look up
     * @param {Array|Object|null} args the arguments to pass into the translated string
     * @return {string} the string returned from the resources
     * @private	 
     */
    _getTranslation: function(key, args)
    {        
        return this.getTranslatedString(key, args);
    },
    /**
     * Callback from the resize dialog box, which sends the results to the grid
     * @param {Event} event the event that triggered the dialog button press
     * @private	 
     */
    _handleResizeDialog: function(event)
    {
        var value = $('#' + this.rootId + 'spinner').ojInputNumber("option", "value");
        $('#' + this.rootId + 'dialog').remove();
        this.grid.handleContextMenuReturn(this.contextMenuEvent, this.menuItemFunction, value);
        this.contextMenuEvent['target'].focus();
    },
    /**
     * Build the html for the resize dialog and add it to the root node
     * @param {string} title the header title for the dialog
     * @param {number} initialSize the initial size to put in the spinner
     * @private	 
     */            
    _buildResizeDialog: function(title, initialSize)
    {
        var dialog, dialogBody, spinner, dialogFooter, dialogOKButton;
        //create the base dialog
        dialog =  $('#' + this.rootId + 'dialog');
        spinner = $('#' + this.rootId + 'spinner');
        if (dialog.length === 0 || spinner.length === 0)
        {
            dialog = $('<div>');
            dialog.attr('id', this.rootId + 'dialog');
            dialog.attr('title', title);
            dialogBody = $('<div class="oj-dialog-body"></div>');
            dialogFooter = $('<div class="oj-dialog-footer"></div>');
            dialog.append(dialogBody).append(dialogFooter);

            //create the dialog content
            spinner = $('<input id="' + this.rootId + 'spinner"/>');
            dialogOKButton = $('<button>');

            dialogBody.append(spinner);
            dialogFooter.append(dialogOKButton);
            $(this.root).append(dialog);
        
            dialogOKButton.ojButton({component: 'ojButton', label: 'OK'});
            dialogOKButton.on('click', this._handleResizeDialog.bind(this));
        }
        spinner.ojInputNumber({component: 'ojInputNumber', max:1000, min:20, step:1, value:initialSize});
        dialog.ojDialog({initialVisibility:'show', position:{my: "center center", at: "center center", collision:"none", of:$(this.root)}});
    },
    /**
     * Handle an ojselect event on a menu item, if sort call the handler on the core.
     * If resize prompt the user with a dialog box
     * @param {Event} event event triggering context menu
     * @param {Object} ui an object containing the menu item that was selected
     * @private	 
     */
    _handleContextMenuSelect: function(event, ui)
    {
        var initialSize, parent;
        
        this.menuItemFunction = ui.item.attr('data-oj-command');
        if (this.menuItemFunction === this._getMappedCommand('sortColAsc') || this.menuItemFunction === this._getMappedCommand('sortColDsc')
            || this.menuItemFunction === this._getMappedCommand('cut') || this.menuItemFunction === this._getMappedCommand('paste'))
        {
            this.grid.handleContextMenuReturn(this.contextMenuEvent, this.menuItemFunction, null);
            //this.contextMenuEvent['target'].focus();
        }
        else if (this.menuItemFunction === this._getMappedCommand('resizeWidth') || this.menuItemFunction === this._getMappedCommand('resizeHeight'))
        {
            parent = this._findFirstAncestor($(this.contextMenuEvent['target']), "oj-datagrid-headercell");
            if (parent != null)
            {
                initialSize = this.menuItemFunction === this._getMappedCommand('resizeWidth') ? parent.outerWidth() : parent.outerHeight();
            }
            else
            {
                initialSize = this.menuItemFunction === this._getMappedCommand('resizeWidth') ? $(this.contextMenuEvent['target']).outerWidth() : $(this.contextMenuEvent['target']).outerHeight();
            }
            this._buildResizeDialog(ui.item.text(), initialSize);
        }
    },
    /**
     * Handle an ojbeforeopen event on the context menu. Set the position correctly for keyboard events and store the Keyboard/Mouse event that called the context menu
     * @param {Event} event event triggering context menu
     * @param {Object} ui an object containing the menu item that was selected
     * @private	 
     */
    _handleContextMenuBeforeShow: function(event, ui)
    {
        var contextMenu, cell, header, capabilities;
        contextMenu = $(this._getContextMenu());
        
        this.contextMenuEvent = event['originalEvent']['originalEvent'];
        
        // TODO: Rather than setting "position" in this beforeOpen listener, probably better to 
        // override _OpenContextMenu() and pass "position" in its call to menu.open().  That way, 
        // if the app wants to tweak the position in its beforeOpen listener, its success 
        // doesn't depend on who gets their listeners registered first.
        if (this.contextMenuEvent['type'] === 'keydown')
        {
            ui.openOptions.position = {"my": "start top", "at": "start bottom", "of": this.contextMenuEvent['target']};
        }
        else
        {
            ui.openOptions.position = {"my": "start top", "at": "start bottom"};
        }

        cell = this._findFirstAncestor($(this.contextMenuEvent['target']).eq(0), this._getMappedStyle('cell'));
        if (cell != null)
        {
            capabilities = this._getCellCapability(cell);
        }
        else
        {
            header = this._findFirstAncestor($(this.contextMenuEvent['target']).eq(0), this._getMappedStyle('headercell'));
            capabilities = this._getHeaderCapability(header);
        }

        this._manageContextMenu(capabilities);
    },    
    /**
     * Add the disabled class to the menu item with a given command
     * @param {string} command the command to add the diabled attribute to
     * @private	 
     */            
    _addContextMenuCapability: function(command)
    {
        var contextMenu;
        contextMenu = $(this._getContextMenu());
        if (!contextMenu.find("[data-oj-command=" + command + "]").hasClass('oj-disabled'))
        {
            contextMenu.find("[data-oj-command=" + command + "]").addClass('oj-disabled');
        }
    },
    /**
     * Remove the disabled class to the menu item with a given command
     * @param {string} command the command to remove the diabled attribute to
     * @private	 
     */                    
    _removeContextMenuCapability: function(command)
    {
        $(this._getContextMenu()).find("[data-oj-command=" + command + "]").removeClass('oj-disabled');
    },
    /**
     * Based on an object containing the capabilities, add or remove the disable attribute
     * @param {Object} capabilities an object with keys of resizable, sortable
     * @private	 
     */              
    _manageContextMenu: function(capabilities)
    {
        var property, command;
        for (property in capabilities)
        {
            if (capabilities.hasOwnProperty(property))
            {
                command = this.resources.getMappedCommand(property);
                if (capabilities[property] === 'disable')
                {
                    this._addContextMenuCapability(command);
                }
                else
                {
                    this._removeContextMenuCapability(command);
                }
            }
        }
    },
            
    /**
     * Find the first ancestor of an element with a specific class name
     * @param {Object} element the element to find the nearest class name to
     * @param {string} className the class name to look for
     * @return {Object|null} the element with the className, if there is none returns null 
     * @private	 
     */                  
    _findFirstAncestor: function(element, className) {
        var parents;
        if (element.hasClass(className))
        {
            return element;
        }
        parents = element.parents("."+className);
        if (parents.length != 0)
        {
            return parents.eq(0);
        }
        return null;
    },
    /**
     * Find the index of a cell
     * @param {Object} element the cell to find the index of
     * @return {Object} an object containing rowIndex and columnIndex 
     * @private	 
     */                     
    _findCellIndex: function(element) {
        var row, rowIndex, columnIndex;
        row = element.parent();
        columnIndex = row.children().index(element);
        rowIndex = row.parent().children().index(row) - 1;
        return {'rowIndex': rowIndex, 'columnIndex': columnIndex};
    },
            
    /**
     * Find the headers corresponding to a cell indicies
     * @param {Object} index the index to find the headers at
     * @return {Object} an object containing rowHeader and columnHeader 
     * @private	 
     */                     
    _findHeadersByCellIndex: function(index) {
        var rowHeader, columnHeader;
        rowHeader = this._getRowHeader().children().eq(0).children().eq(index['rowIndex'] + 1);
        columnHeader = this._getColumnHeader().children().eq(0).children().eq(index['columnIndex']);
        return {'rowHeader': rowHeader, 'columnHeader': columnHeader};
    },       
            
    /**
     * Get the root grid as a jquery object
     * @private	 
     */			
    _getGrid: function()
    {
        return $(this.root);
    },     
	
    /**
     * Get the column header container as a jquery object 
     * @private	 
     */	            
    _getColumnHeader: function() {
        return $('#' + this.rootId + '\\:columnHeader');
    },
	
    /**
     * Get the row header container as a jquery object 
     * @private	 
     */	                 
    _getRowHeader: function() {
        return $('#' + this.rootId + '\\:rowHeader');
    },
	
    /**
     * Get the databody container as a jquery object 
     * @private	 
     */  
    _getDatabody: function() {
        return $('#' + this.rootId + '\\:databody');
    },
            
    /**
     * Get the databody rows as a jquery object 
     * @private	 
     */        
    _getDatabodyRows: function() {
        return $('#' + this.rootId + '\\:databody .'+ this._getMappedStyle('row'));
    },            
    
    /**
     * Get the capabilities for context menu opened on a cell
     * @param {Object} cell the cell with context menu opened on it
     * @return {Object} capabilities object with props resizeWidth, resizeHeight, sortRow, sortCol
     * @private	 
     */		
    _getCellCapability: function(cell) {
        var index, headers, capabilities, rowHeader, columnHeader;
        index = this._findCellIndex(cell);
        headers = this._findHeadersByCellIndex(index);
        capabilities = {resizeWidth: 'disable', resizeHeight: 'disable', sortRow: 'disable', sortCol: 'disable'};
        rowHeader = headers['rowHeader'];
        columnHeader = headers['columnHeader'];
        if (columnHeader.length !== 0)
        {
            if (columnHeader.attr(this._getMappedAttribute('resizable')) === 'true')
            {
                capabilities['resizeWidth'] = 'enable';
            }
            if (columnHeader.attr(this._getMappedAttribute('sortable')) === 'true')
            {
                capabilities['sortCol'] = 'enable';
            }
        }
        if (rowHeader.length !== 0)
        {
            if (rowHeader.attr(this._getMappedAttribute('resizable')) === 'true')
            {
                capabilities['resizeHeight'] = 'enable';
            }
            if (rowHeader.attr(this._getMappedAttribute('sortable')) === 'true')
            {
                capabilities['sortRow'] = 'enable';
            }
        }
        return capabilities;
    },

    /**
     * Get the capabilities for context menu opened on a header
     * @param {Object} header the header with context menu opened on it
     * @return {Object} capabilities object with props resizeWidth, resizeHeight, sortRow, sortCol
     * @private	 
     */		
    _getHeaderCapability: function(header) {
        var capabilities;
        capabilities = {resizeWidth: 'disable', resizeHeight: 'disable', sortRow: 'disable', sortCol: 'disable'};
        if (header !== null)
        {
            if (header.hasClass(this._getMappedStyle('colheadercell')))
            {
                if (header.attr(this._getMappedAttribute('resizable')) === 'true')
                {
                    capabilities['resizeWidth'] = 'enable';
                }
                capabilities['resizeHeight'] = this._isResizeEnabled('column', 'height') ? 'enable' : 'disable';
                if (header.attr(this._getMappedAttribute('sortable')) === 'true')
                {
                    capabilities['sortCol'] = 'enable';
                }
            }
            else
            {
                if (header.attr(this._getMappedAttribute('resizable')) === 'true')
                {
                    capabilities['resizeHeight'] = 'enable';
                }
                capabilities['resizeWidth'] = this._isResizeEnabled('row', 'width') ? 'enable' : 'disable';
                if (header.attr(this._getMappedAttribute('sortable')) === 'true')
                {
                    capabilities['sortRow'] = 'enable';
                }
            }
        }
        return capabilities;
    },

    /**
     * @private	 
     */	
    _setDataSource: function()
    {
        if (this.options['data'] != null)
        {
            this.datasource = this.options['data'];
        }
        else
        {
            this.datasource = null;
        }
    },
       
    /**
     * Sets selection on internal grid from options
     * @private	 
     */	
    _setSelection: function()
    {
        var selection = this.options['selection'];
        if (selection != null)
        {
            this.grid.SetSelection(selection);
        }
    },

    /**
     * Modify the header and cell context before passing to the renderer.
     * @param {Object} context the header or cell context.
     * @private
     */
    _modifyContext: function(context)
    {
        context['component'] = this;
    },

    /**
     * Sets accessible context information about the current active cell.
     * Invoked by row expander to set accessible context info on the datagrid (and
     * the info is then read by the screen reader)
     * @param {Object} context
     * @private
     */
    _setAccessibleContext: function(context)
    {
        this.grid.SetAccessibleContext(context);
    },

    /**
     * Unregister event listeners for resize the container DOM element.
     * @param {Element} element  DOM element
     * @private
     */
    _unregisterResizeListener: function(element)
    {
        if (element && this._resizeHandler)
        {
            // remove existing listener
            oj.DomUtils.removeResizeListener(element, this._resizeHandler);    
        }
    },

    /**
     * Register event listeners for resize the container DOM element.
     * @param {Element} element  DOM element
     * @private
     */
    _registerResizeListener: function(element)
    {         
        if (element)
        {
            if (this._resizeHandler == null)
            {
                this._resizeHandler = this._handleResize.bind(this);
            }

            oj.DomUtils.addResizeListener(element, this._resizeHandler);
        }
    },

    /**
     * The resize handler.
     * @param {number} width the new width
     * @param {number} height the new height
     * @private
     */
    _handleResize: function(width, height)
    {
        if (width > 0 && height > 0)
        {
            this.grid.HandleResize(width, height);
        }
    },
        
    /**
     * Return the subcomponent node represented by the documented locator attribute values.
     * <p>
     * To lookup a cell the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-datagrid-cell'</li>
     * <li><b>rowIndex</b>: the zero based row index</li>
     * <li><b>columnIndex</b>: the zero based column index</li>
     * </ul>          
     *          
     * To lookup a header the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-datagrid-header'</li>
     * <li><b>axis</b>: 'column'/'row'</li>
     * <li><b>index</b>: the zero based row/column index</li>
     * </ul>
     *          
     * To lookup a sort icon the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-datagrid-sort-icon'</li>
     * <li><b>axis</b>: 'column'/'row'</li>
     * <li><b>index</b>: the zero based row/column index</li>                
     * </ul>
     * 
     * @expose
     * @memberof! oj.ojDataGrid
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *         the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Array.<(Element|null)>|Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
        var subId, header, rowIndex,columnIndex, index, axis;
        if (locator == null)
        {
          return this.element ? this.element[0] : null;
        }

        subId = locator['subId'];
        if (subId === 'oj-datagrid-cell')
        {
            rowIndex = locator['rowIndex'] -  this.grid.getStartRow();
            columnIndex = locator['columnIndex'] -  this.grid.getStartColumn();
            return this._getDatabodyRows().eq(rowIndex).children().eq(columnIndex).get(0);
        }
        else if (subId === 'oj-datagrid-sort-icon' || subId === 'oj-datagrid-header')
        {
            axis = locator['axis'];
            index = locator['index'];
            if (axis === 'column')
            {
                header = $('#' + this.rootId + '\\:columnHeader .' + this._getMappedStyle('headercell')).eq(index - this.grid.getStartColumnHeader());
            }
            else if (axis === 'row')
            {
                header = $('#' + this.rootId + '\\:rowHeader .' + this._getMappedStyle('headercell')).eq(index - this.grid.getStartRowHeader());
            }
            
            if (subId === 'oj-datagrid-sort-icon')
            {
                return header.children('.' + this._getMappedStyle('sortcontainer')).children().get(0);
            }
            return header.get(0);
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
    },              
          
    /**
     * Get the mapped style from the resources
     * @param {string} key style mapping key
     * @private
     */
    _getMappedStyle: function(key)
    {
        return this.resources.getMappedStyle(key);
    },
            
    /**
     * Get the mapped attribute from the resources
     * @param {string} key attribute mapping key
     * @private
     */
    _getMappedAttribute: function(key)
    {
        return this.resources.getMappedAttribute(key);
    },
            
    /**
     * Get the mapped command from the resources
     * @param {string} key command mapping key
     * @private
     */
    _getMappedCommand: function(key)
    {
        return this.resources.getMappedCommand(key);
    }             
});

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * A CellSet represents a collection of cells.  The CellSet is an object returned by the success callback
 * of the fetchCells method on DataGridDataSource.  The FlattenedTreeCellSet is a FlattenedDataGridDataSource specific 
 * implementation of methods on CellSet. 
 * @param {number} startRow the start row index of the cell set
 * @param {number} endRow the end row index of the cell set
 * @param {number} startColumn the start column index of the cell set
 * @param {number} endColumn the end column index of the cell set
 * @param {Object} nodeSet the node set in which this cell set wraps around
 * @param {Array|null} columns the set of column keys
 * @constructor
 * @export
 */
oj.FlattenedTreeCellSet = function(startRow, endRow, startColumn, endColumn, nodeSet, columns)
{
    // assert startRow/startColumn are number
    oj.Assert.assertNumber(startRow, null);
    oj.Assert.assertNumber(endRow, null);
    oj.Assert.assertNumber(startColumn, null);
    oj.Assert.assertNumber(endColumn, null);
    oj.Assert.assertArrayOrNull(columns);

    this.m_startRow = startRow;
    this.m_endRow = endRow;
    this.m_startColumn = startColumn;
    this.m_endColumn = endColumn;
    this.m_nodeSet = nodeSet;
    this.m_columns = columns;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the data from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object} the data object for the specified index.
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getData = function(indexes)
{
    var relIndex, row, column, columnKey, rowData;

    // convert to relative index
    relIndex = this._getRelIndexes(indexes);
    if (relIndex == null)
    {
        return null;
    }

    row = relIndex[0];
    column = relIndex[1];

    // make sure index are valid
    oj.Assert.assert(row < this.m_nodeSet.getStart()+this.m_nodeSet.getCount() && column < this.m_columns.length);

    columnKey = this.m_columns[column];
    rowData = this.m_nodeSet.getData(row);
    if (rowData != null)
    {
        if (rowData.get)
        {
            return rowData.get(columnKey);
        }
        else
        {
            return rowData[columnKey];
        }
    }
    return null;
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the metadata from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return the metadata object for the specific index.  The metadata that the DataGrid supports are: 
 *         1) keys - the key (of each axis) of the cell.
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getMetadata = function(indexes)
{
    var relIndex, row, column, columnKey, metadata, rowKey;

    // convert to relative index
    relIndex = this._getRelIndexes(indexes);
    if (relIndex == null)
    {
        return null;
    }

    row = relIndex[0];
    column = relIndex[1];

    // make sure index are valid
    oj.Assert.assert(row < this.m_nodeSet.getStart()+this.m_nodeSet.getCount() && column < this.m_columns.length);

    columnKey = this.m_columns[column];

    metadata = this.m_nodeSet.getMetadata(row);
    rowKey = metadata['key'];

    metadata['keys'] = {"row": rowKey, "column": columnKey};

    return metadata;
};

/**
 * Helper method to validate and retrieve the relative indexes.
 * @param {Object} indexes the row and column index
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object.<number, number>} the relative indexes
 * @private
 */
oj.FlattenedTreeCellSet.prototype._getRelIndexes = function(indexes)
{
    var row, column;

    oj.Assert.assertObject(indexes);

    if (this.m_nodeSet == null || this.m_nodeSet.length == 0)
    {
        return null;
    }

    // map to the index in nodeSet
    row = indexes['row'] - this.m_startRow + this.m_nodeSet.getStart();
    column = indexes['column'];

    // make sure index are valid
    oj.Assert.assertNumber(row, null);
    oj.Assert.assertNumber(column, null);
    oj.Assert.assert(row >= 0 && column >= 0); 

    return [row, column];
};

/**
 * Gets the start index of the result set for the specified axis.
 * @param {string} axis the axis in which to inquire the actual count of the result set.  
 *        Valid values are "row" and "column".
 * @return {number} the start of the index of the result set for the specified axis.  
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getStart = function(axis)
{
    if (axis === "row")
    {
        return this.m_startRow;
    }

    if (axis === "column")
    {
        return this.m_startColumn;
    }

    return 0;
};

/**
 * Gets the actual count of the result set for the specified axis. 
 * @param {string} axis the axis in which to inquire the actual count of the result set.  
 *        Valid values are "row" and "column".
 * @return {number} the actual count of the result set for the specified axis.  
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return Math.min(this.m_endRow - this.m_startRow, this.m_nodeSet.getCount());
    }
    
    if (axis === "column")
    {
        return this.m_endColumn - this.m_startColumn;
    }

    return 0;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * A HeaderSet represents a collection of headers.  The HeaderSet is an object returned by the success callback
 * of the fetchHeaders method on DataGridDataSource.  This is an OJ collection specific implementation of the HeaderSet.
 * @param {number} start the start index of header set.
 * @param {number} end the end index of the header set.
 * @param {Array} headers the array of headers.  Required for column headers.
 * @param {Object=} nodeSet the node set containing data about the row header.  Required for row headers.
 * @param {string=} rowHeader the id of the row header column.  Required for row headers.
 * @constructor
 * @export
 */
oj.FlattenedTreeHeaderSet = function(start, end, headers, nodeSet, rowHeader)
{
    // assert start/end are number
    oj.Assert.assertNumber(start, null);
    oj.Assert.assertNumber(end, null);
    oj.Assert.assertArrayOrNull(headers);

    this.m_start = start;
    this.m_end = end;
    this.m_headers = headers;
    this.m_nodeSet = nodeSet;
    this.m_rowHeader = rowHeader;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the header in which we want to retrieve the header from.  
 * @return {Object} the data object for the specific index.
 * @export
 */
oj.FlattenedTreeHeaderSet.prototype.getData = function(index)
{
    var rowData;

    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 

    // row or column header
    if (this.m_rowHeader != null && this.m_nodeSet != null)
    {
        rowData = this.m_nodeSet.getData(index);
        if (rowData != null)
            return rowData.get(this.m_rowHeader);
        else
            return null;
    }
    else
    {
        return this.m_headers[index];
    }
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source can optionally return are:
 *  1) sortDirection - the initial sort direction of the header.  Valid values are "ascending" and "descending".
 *  2) key - the key of the row/column header.
 * @param {number} index the index of the header in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.FlattenedTreeHeaderSet.prototype.getMetadata = function(index)
{
    var data;

    if (this.m_rowHeader != null && this.m_nodeSet != null)
    {
        return this.m_nodeSet.getMetadata(index);
    }
    else
    {
        data = this.getData(index);
        return {'key': data};
    }
};

/**
 * Gets the actual count of the result set.
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.FlattenedTreeHeaderSet.prototype.getCount = function()
{
    if (this.m_rowHeader != null && this.m_nodeSet != null)
    {
        return Math.min(this.m_nodeSet.getCount(), this.m_end - this.m_start);
    }
    else
    {
        return Math.max(0, this.m_end - this.m_start);
    }
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
 /**
 * A CellSet represents a collection of cells.  The CellSet is an object returned by the success callback
 * of the fetchCells method on DataGridDataSource.  This implementation of CellSet is used by the
 * array DataGridDataSource.   
 * @param {number} startRow the start row index of the cell set
 * @param {number} endRow the end row index of the cell set
 * @param {number} startColumn the start column index of the cell set
 * @param {number} endColumn the end column index of the cell set
 * @param {Object} callback the callback to invoke on to retrieve data and metadata. 
 * @constructor
 * @export
 */
oj.ArrayCellSet = function(startRow, endRow, startColumn, endColumn, callback)
{
    // assert startRow/startColumn are number
    oj.Assert.assertNumber(startRow, null);
    oj.Assert.assertNumber(endRow, null);
    oj.Assert.assertNumber(startColumn, null);
    oj.Assert.assertNumber(endColumn, null);

    this.m_startRow = startRow;
    this.m_endRow = endRow;
    this.m_startColumn = startColumn;
    this.m_endColumn = endColumn;
    this.m_callback = callback;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the data from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object} the data object for the specified index.
 * @export
 */
oj.ArrayCellSet.prototype.getData = function(indexes)
{
    return this.m_callback.getCellData(indexes['row'], indexes['column']);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the metadata from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object} the metadata object for the specific index.  The metadata that the DataGrid supports are: 
 *         1) keys - the key (of each axis) of the cell.
 * @export
 */
oj.ArrayCellSet.prototype.getMetadata = function(indexes)
{
    return this.m_callback.getCellMetadata(indexes['row'], indexes['column']);
};

/**
 * Gets the start index of the result set for the specified axis.  Valid values are "row" and "column".
 * @param {string} axis the axis in which to inquire the actual count of the result set.
 * @return {number} the start index of the result set for the specified axis.  
 * @export
 */
oj.ArrayCellSet.prototype.getStart = function(axis)
{
    if (axis == "row")
    {
        return this.m_startRow;
    }
    else if (axis == "column")
    {
        return this.m_startColumn;
    }

    return -1;
};

/**
 * Gets the actual count of the result set for the specified axis.  Valid values are "row" and "column".
 * @param {string} axis the axis in which to inquire the actual count of the result set.
 * @return {number} the actual count of the result set for the specified axis.  
 * @export
 */
oj.ArrayCellSet.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return Math.max(0, this.m_endRow - this.m_startRow);
    }
    
    if (axis === "column")
    {
        return Math.max(0, this.m_endColumn - this.m_startColumn);
    }

    return 0;
};

////// testing methods to get properties //////
/**
 * Gets the start row property
 * @return {number} the start row
 * @export
 */
oj.ArrayCellSet.prototype.getStartRow = function()
{
    return this.m_startRow;
};

/**
 * Gets the start column property
 * @return {number} the start column
 * @export
 */
oj.ArrayCellSet.prototype.getStartColumn = function()
{
    return this.m_startColumn;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * The DataGrid specific implementation of the FlattenedTreeDataSource class.
 * @param {Object} treeDataSource the instance of TreeDataSource to flattened
 * @param {Object=} options the options set on this data source.  See documentation for a list
 *        of supported options.
 * @constructor
 * @export
 * @extends oj.FlattenedTreeDataSource
 */
oj.FlattenedTreeDataGridDataSource = function(treeDataSource, options)
{
    oj.FlattenedTreeDataGridDataSource.superclass.constructor.call(this, treeDataSource, options);
};

// Subclass from oj.FlattenedTreeDataSource
oj.Object.createSubclass(oj.FlattenedTreeDataGridDataSource, oj.FlattenedTreeDataSource, "oj.FlattenedTreeDataGridDataSource");

/**
 * Initializes the data source.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.Init = function()
{
    oj.FlattenedTreeDataGridDataSource.superclass.Init.call(this);

    this.m_columns = oj.FlattenedTreeDataGridDataSource.superclass.getOption.call(this, 'columns');
    this.m_rowHeader = oj.FlattenedTreeDataGridDataSource.superclass.getOption.call(this, 'rowHeader');
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "exact" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "exact".
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.getCountPrecision = function(axis)
{
    // always returns estimate row count to ensure high watermark scrolling is used.
    if (axis === "row")
    {
        return "estimate";
    }

    return "actual";
};

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.getCount = function(axis)
{
    // always returns -1 to ensure high watermark scrolling is used.
    if (axis === "row")
    {
        return -1;
    }

    if (axis === "column")
    {
        return this.m_columns.length;
    }

    return 0;
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    var axis, headerSet;

    axis = headerRange['axis'];
    if (axis === "column")
    {
        headerSet = new oj.FlattenedTreeHeaderSet(headerRange['start'], headerRange['start']+headerRange['count'], this.m_columns);
    }
    else if (axis === "row")
    {
        if (this.m_rowHeader != null)
        {
            // assumes that a fetch header request is immediately followed by a fetch cells request
            // avoid doing two fetch requests for the same set of data, wait until fetch cells request is available
            // before handling the header request
            // since the two fetches are converge on fetchCell, the range should always be in sync
            this.m_fetchHeaderRequest = {'range': headerRange, 'callbacks': callbacks, 'callbackObjects': callbackObjects};
            return;
        }
        else
        {
            // no row header, return empty result set
            headerSet = new oj.ArrayHeaderSet(headerRange['start'], headerRange['start'], axis, null);
        }
    }

    if (headerSet != null)
    {
        if (callbacks != null && callbacks['success'] != null)
        {
            // todo: get rid of callbackObjects
            if (callbackObjects == null)
            {
                callbackObjects = {};
            }	            
            callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
        }
    }
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
    var i, cellRange, rowStart, rowCount;

    // extract row range information needed to make the fetchRows call
    for (i=0; i<cellRanges.length; i++)
    {
        cellRange = cellRanges[i];   
        if (cellRange['axis'] == "row")
        {
            rowStart = cellRange['start'];
            rowCount = cellRange['count'];
            break;
        }
    }

    oj.FlattenedTreeDataGridDataSource.superclass.fetchRows.call(this, {'start': rowStart, 'count': rowCount}, {"success": function(nodeSet){this._handleFetchRowsSuccess(nodeSet, cellRanges, callbacks, callbackObjects, 0);}.bind(this), "error": function(status){this._handleFetchRowsError(status, {'start': rowStart, 'count': rowCount}, callbacks, callbackObjects);}.bind(this)}); 
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object.<Object, Object>} an object containing the keys for each axis
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.keys = function(indexes)
{
    var rowIndex, colIndex, rowKey, colKey;

    rowIndex = indexes['row'];
    colIndex = indexes['column'];

    // if it hasn't been fetched yet or invalid column index, return null
    if (rowIndex > oj.FlattenedTreeDataGridDataSource.superclass.getFetchedRange.call(this)['end'] || colIndex > this.m_columns.length)
        return null;

    rowKey = oj.FlattenedTreeDataGridDataSource.superclass.getKey.call(this, rowIndex);
    colKey = this.m_columns[colIndex];

    return {"row": rowKey, "column": colKey};
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object.<number, number>} indexes an object containing the index for each axis. 
 *         Return null if the indexes cannot be found.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.indexes = function(keys)
{
    var rowIndex, colIndex, rowKey, colKey, i;

    rowKey = keys['row'];
    colKey = keys['column'];

    // call helper method to find the flattened index
    rowIndex = oj.FlattenedTreeDataGridDataSource.superclass.getIndex.call(this, rowKey);
    // for column index, just search through the column keys array
    for (i=0; i<this.m_columns.length; i++)
    {
        if (this.m_columns[i] === colKey)
        {
            colIndex = i;
            break;
        }
    }

    // make sure the indexes are valid
    if (rowIndex >= 0 && colIndex >= 0)
    {
        return {"row": rowIndex, "column": colIndex};
    }

    // can't find it
    return null;
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    var dataSource = oj.FlattenedTreeDataGridDataSource.superclass.getWrappedDataSource.call(this);

    // delegates to the underlying TreeDataSource but intercept the success callback so that we can clear the cache
    return dataSource.sort(criteria, {"success": function(){this._handleSortSuccess(callbacks, callbackObjects);}.bind(this), "error": callbacks['error']});
};

/**
 * Handles sort success callback.
 * @param {Object} callbacks the original callbacks for the sort operation
 * @param {Object} callbackObjects the original callbackObjects for the sort operation
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleSortSuccess = function(callbacks, callbackObjects)
{
    // reset state
    this.refresh();

    // invoke original sort success callback
    if (callbacks['success'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }	            
        callbacks['success'].call(callbackObjects['success']);
    }
};

/**
 * Moves a row from one location to another (different position within the same parent or a completely different parent)
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {string} position The position of the moved row relative to the reference row.  Valid values are: "before", "after".
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @export
 */ 
oj.FlattenedTreeDataGridDataSource.prototype.move = function(rowToMove, referenceRow, position, callbacks)
{
    var dataSource = oj.FlattenedTreeDataGridDataSource.superclass.getWrappedDataSource.call(this);

    // delegates to the underlying TreeDataSource.  TreeDataSource is responsible for firing the appropriate model change
    // event so that the FlattenedTreeDataSource state are updated correctly.
    dataSource.move(rowToMove, referenceRow, position, callbacks);
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none", "row", "column".  
 *         Returns null if the feature is not recognized.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.getCapability = function(feature)
{
    var dataSource = oj.FlattenedTreeDataGridDataSource.superclass.getWrappedDataSource.call(this);

    // just delegates to the underlying TreeDataSource
    if (dataSource.getCapability(feature) === 'default')
    {
        return 'column';
    }
    else
    {
        return 'none';
    }
};

/**
 * A hook for FlattenedTreeDataSource to inject additional metadata into the NodeSet
 * @param {Object} key the row key identifying the row
 * @param {Object} metadata the existing metadata to inject into
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.insertMetadata = function(key, metadata)
{
    // just call super
    oj.FlattenedTreeDataGridDataSource.superclass.insertMetadata.call(this, key, metadata);
};

/**
 * Callback method to handle success callback for fetchRows operation on FlattenedTreeDataSource.
 * @param {Object} nodeSet the result node set from the fetchRows called.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleFetchRowsSuccess = function(nodeSet, cellRanges, callbacks, callbackObjects)
{
    var i, cellRange, rowStart, rowCount, columnStart, columnCount, headerRange, cellSet;

    // extract range information
    for (i=0; i<cellRanges.length; i++)
    {
        cellRange = cellRanges[i];   
        if (cellRange['axis'] == "row")
        {
            rowStart = cellRange['start'];
            rowCount = cellRange['count'];
        }
        else if (cellRange['axis'] == "column")
        {
            columnStart = cellRange['start'];
            columnCount = cellRange['count'];
        }
    }

    // checks whether there is an outstanding fetch header request with the same range
    if (this.m_fetchHeaderRequest)
    {
        headerRange = this.m_fetchHeaderRequest['range'];
        if (headerRange['start'] == rowStart && headerRange['count'] == rowCount)
        {
            // handle row header request
            this._handleRowHeaderFetchSuccess(nodeSet, headerRange, this.m_fetchHeaderRequest['callbacks'], this.m_fetchHeaderRequest['callbackObjects']);
        }
        this.m_fetchHeaderRequest = null;
    }

    // create wrapper
    cellSet = new oj.FlattenedTreeCellSet(rowStart, rowStart+rowCount, columnStart, columnStart+columnCount, nodeSet, this.m_columns);
    // invoke success callback
    if (callbacks['success'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }            
        callbacks["success"].call(callbackObjects['success'], cellSet, cellRanges);
    }
};

/**
 * Callback method to handle error callback for fetchRows operation on FlattenedTreeDataSource.
 * @param {Object} status the error status.
 * @param {Object} range Information about the row range.  
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleFetchRowsError = function(status, range, callbacks, callbackObjects)
{
    var headerRange, headerCallbacks, headerCallbackObjects;

    // checks whether there is an outstanding fetch header request with the same range
    if (this.m_fetchHeaderRequest)
    {
        headerRange = this.m_fetchHeaderRequest['range'];
        if (headerRange['start'] == range['start'] && headerRange['count'] == range['count'])
        {
            // invoke error callback on fetch header
            headerCallbacks = this.m_fetchHeaderRequest['callbacks'];
            headerCallbackObjects = this.m_fetchHeaderRequest['callbackObjects'];

            if (headerCallbacks['error'])
            {
                // todo: get rid of callbackObjects
                if (headerCallbackObjects == null)
                {
                    headerCallbackObjects = {};
                }            
                headerCallbacks['error'].call(headerCallbackObjects['error'], status);
            }
        }
        this.m_fetchHeaderRequest = null;
    }

    // invoke error callback
    if (callbacks['error'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }            
        callbacks["success"].call(callbackObjects['error'], status);
    }
};

/**
 * Handles header fetch success request based on results from fetch cell operation.
 * @param {Object} nodeSet the result node set from the fetchRows called.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleRowHeaderFetchSuccess = function(nodeSet, headerRange, callbacks, callbackObjects)
{
    // create wrapper
    var headerSet = new oj.FlattenedTreeHeaderSet(headerRange['start'], headerRange['start']+headerRange['count'], this.m_columns, nodeSet, this.m_rowHeader);
    // invoke success callback
    if (callbacks['success'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }            
        callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
    }
};

/**
 * Implementation of abstract method to insert a set of rows into the DataGrid
 * @param {number} insertAtIndex the flattened index of the node where the rows are inserted.
 * @param {Object} insertAtRowKey the key of the node where the rows are inserted (the parent key)
 * @param {Object} nodeSet the node set containing data/metadata of inserted rows
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.insertRows = function(insertAtIndex, insertAtRowKey, nodeSet)
{
    var cellSet, event;

    // create a CellSet that wraps around a RowSet 
    cellSet = new oj.FlattenedTreeCellSet(insertAtIndex, insertAtIndex+nodeSet.getCount(), 0, this.m_columns.length, nodeSet, this.m_columns);

    // construct model insert event with a set of rows to insert
    event = {};
    event['source'] = this;
    event['operation'] = 'insert';
    event['result'] = cellSet;
    event['keys'] = {"row": insertAtRowKey};

    oj.FlattenedTreeDataGridDataSource.superclass.handleEvent.call(this, "change", event);
};

/**
 * Implementation of bstract method to remove the specified rows in the DataGrid
 * @param {Array.<Object>} rowKeys an array of keys of the rows to be remove.
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.removeRows = function(rowKeys)
{
    var keys, i, event;
    
    // extract the keys
    keys = [];
    for (i=0; i<rowKeys.length; i++)
    {
        keys.push({"row": rowKeys[i]['key']});
    }

    // construct model delete event with a set of row keys to delete
    event = {};
    event['source'] = this;
    event['operation'] = 'delete';
    event['keys'] = keys;

    oj.FlattenedTreeDataGridDataSource.superclass.handleEvent.call(this, "change", event);
};

/**
 * Handles the case when the maximum number of rows have been reached
 * @param {Object} range the range of the fetch request that cause the max count to be reached
 * @param {number} range.start the start index of the range
 * @param {number} range.count the count of the range
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.handleMaxCountReached = function(range, callbacks)
{
    var empty = new oj.EmptyNodeSet(null, range['start']);
    callbacks["success"].call(null, empty);
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
/**
 * @export
 * @class oj.PagingDataGridDataSource
 * @classdesc Object representing data used by the paging component
 * @param {oj.DataGridDataSource|null} dataSource
 * @param {Object|null} options Array of options for the PagingControlDataSource
 * @extends oj.PagingDataSource
 * @constructor
 */
oj.PagingDataGridDataSource = function(dataSource, options)
{
    // Initialize
    if (!(dataSource instanceof oj.DataGridDataSource))
    {
        // we only support Array, oj.Collection, or ko.observableArray. To
        // check for observableArray, we can't do instanceof check because it's
        // a function. So we just check if it contains a subscribe function.
        throw new oj.Message('Not a datagridatasource', 'Not a datagridatasource', oj.Message.SEVERITY_LEVEL['ERROR']);
    }
    this.dataSource = dataSource;
    this._startIndex = 0;
    this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.PagingDataGridDataSource, oj.PagingDataSource, "oj.PagingDataGridDataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.PagingDataGridDataSource.prototype.Init = function()
{
    oj.PagingDataGridDataSource.superclass.Init.call(this);
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.fetch = function(options)
{
    this._initialized = true;
    this._startIndex = options.startIndex;

    this.dataSource.setPageSize(this._currentPageSize);

    var self = this;
    return oj.Object.__getPromise(function(resolve, reject) {
        self.dataSource.fetch(options);
        resolve();
    });
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.hasMore = function() {
    return this.dataSource.hasMore();
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.next = function()
{
    if (this.dataSource.totalSize() > this._startIndex)
    {
        this._currentPageSize = this._currentPageSize + this._pageSize;
        this.dataSource.setPageSize(this._currentPageSize);
        return this.fetch({startIndex: this._startIndex});
    }
    return oj.Object.__getPromise(function(resolve, reject) {
        reject();
    });
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.previous = function()
{
    if (this._startIndex != 0 || this._startIndex != -1)
    {
        this._startIndex = this._startIndex - this._pageSize;
        this._startIndex = this._startIndex < 0 ? 0 : this._startIndex;
        this._currentPageSize = this._currentPageSize + this._pageSize;
        this.dataSource.setPageSize(this._currentPageSize);
        return this.fetch({startIndex: this._startIndex});
    }
    return oj.Object.__getPromise(function(resolve, reject) {
        reject();
    });
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 */
oj.PagingDataGridDataSource.prototype.setPageSize = function(n) {
    this._pageSize = n;
    this._currentPageSize = this._startIndex + n;
    this.dataSource.setPageSize(this._currentPageSize);
};

/**
 * @export
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.startIndex = function() {
    return this._startIndex;
};

/**** start delegated functions ****/


/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown. In the case of paging returns the total number of rows/colums on the page.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.PagingDataGridDataSource.prototype.getCount = function(axis)
{
    return this.dataSource.getCount(axis);
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "actual" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "actual".
 * @export
 */
oj.PagingDataGridDataSource.prototype.getCountPrecision = function(axis)
{
    return this.dataSource.getCountPrecision(axis);
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.PagingDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    var headerSet;
    if (this._initialized == null)
    {
        headerSet = new oj.ArrayHeaderSet(0, 0, headerRange.axis, null);
        if (callbacks != null && callbacks['success'])
        {
            callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
        }
    }
    else
    {
        this.dataSource.fetchHeaders(headerRange, callbacks, callbackObjects);
    }
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.PagingDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
    var cellSet;
    if (this._initialized == null)
    {
        cellSet = new oj.ArrayCellSet(0, 0, 0, 0, null);
        if (callbacks != null && callbacks['success'])
        {
            callbacks['success'].call(callbackObjects['success'], cellSet, cellRanges);
        }
    }
    else
    {
        this.dataSource.fetchCells(cellRanges, callbacks, callbackObjects);
    }
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object.<Object, Object>} an object containing the keys for each axis
 * @export
 */
oj.PagingDataGridDataSource.prototype.keys = function(indexes)
{
    return this.dataSource.keys(indexes);
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object.<number, number>} indexes an object containing the index for each axis
 * @export
 */
oj.PagingDataGridDataSource.prototype.indexes = function(keys)
{
    return this.dataSource.indexes(keys);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.PagingDataGridDataSource.prototype.on = function(eventType, eventHandler)
{
    var dataSource = (/** @type {{on: Function}} */ (this.dataSource));
    dataSource.on(eventType, eventHandler);
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.PagingDataGridDataSource.prototype.off = function(eventType, eventHandler)
{
    var dataSource = (/** @type {{off: Function}} */ (this.dataSource));
    dataSource.off(eventType, eventHandler);
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For sort, the valid return values are: "full", "none".  Returns null if the
 *         feature is not recognized.
 * @export
 */
oj.PagingDataGridDataSource.prototype.getCapability = function(feature)
{
    return this.dataSource.getCapability(feature);
};

/**
 * @export
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @expose
 * @memberof! oj.PagingDataGridDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.size = function()
{
    if (this._initialized == null)
    {
        return -1;
    }
    return this.dataSource.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.PagingDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    this.dataSource.sort(criteria, callbacks, callbackObjects);
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.PagingDataGridDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.totalSize = function()
{
    if (this._initialized == null)
    {
        return -1;
    }
    return this.dataSource.totalSize();
};

/**
 * Move a model to a new index in the collection, if atKey is null adds to the end
 * @param {string|number} moveKey the key of the model that should be moved
 * @param {string|number|null} atKey the key of the model that the moved model should be inserted before
 * @export
 */
oj.PagingDataGridDataSource.prototype.move = function(moveKey, atKey)
{
    this.dataSource.move(moveKey, atKey);
};

/**** end delegated functions ****/



/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * A HeaderSet represents a collection of headers.  The HeaderSet is an object returned by the success callback
 * of the fetchHeaders method on DataGridDataSource.  This implementation of HeaderSet is used by the
 * array DataGridDataSource.   
 * @param {number} start the start index of the header set.
 * @param {number} end the end index of the header set.
 * @param {string} axis the axis of the header, value is either 'row' or 'column'.
 * @param {Object} callback the callback to invoke on to retrieve data and metadata. 
 * @constructor
 * @export
 */
oj.ArrayHeaderSet = function(start, end, axis, callback)
{
    // assert start/end are number
    oj.Assert.assertNumber(start, null);
    oj.Assert.assertNumber(end, null);

    this.m_start = start;
    this.m_end = end;
    this.m_axis = axis;
    this.m_callback = callback;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the header in which we want to retrieve the header from.  
 * @return {Object} the data object for the specific index.
 * @export
 */
oj.ArrayHeaderSet.prototype.getData = function(index)
{
    if (this.m_callback == null)
    {
        return null;
    }

    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 

    return this.m_callback.getHeaderData(this.m_axis, index);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source can optionally return are:
 *  1) sortDirection - the initial sort direction of the header.  Valid values are "ascending" and "descending".
 *  2) key - the key of the row/column header.
 * @param {number} index the index of the header in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.ArrayHeaderSet.prototype.getMetadata = function(index)
{
    if (this.m_callback == null)
    {
        return null;
    }

    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 

    return this.m_callback.getHeaderMetadata(this.m_axis, index);
};

/**
 * Gets the actual count of the result set.
 *
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.ArrayHeaderSet.prototype.getCount = function()
{
    if (this.m_callback == null)
    {
        return 0;
    }

    return Math.max(0, this.m_end - this.m_start);
};

/**
 * Gets the start index of the result set.
 * @return {number} the start index of the result set.
 * @export
 */
oj.ArrayHeaderSet.prototype.getStart = function()
{
    return this.m_start;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 * 
 * You may obtain a copy of the Apache License and the GPL License at:
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */
/**
 * @private
 */
  var _ComboUtils = {
    KEY:
    {
      TAB : 9,
      ENTER : 13,
      ESC : 27,
      SPACE : 32,
      LEFT : 37,
      UP : 38,
      RIGHT : 39,
      DOWN : 40,
      SHIFT : 16,
      CTRL : 17,
      ALT : 18,
      PAGE_UP : 33,
      PAGE_DOWN : 34,
      HOME : 36,
      END : 35,
      BACKSPACE : 8,
      DELETE : 46,

      isControl : function (e)
      {
        var k = e.which;
        switch (k)
        {
        case _ComboUtils.KEY.SHIFT:
        case _ComboUtils.KEY.CTRL:
        case _ComboUtils.KEY.ALT:
          return true;
        }
        if (e.metaKey)
          return true;
        return false;
      },

      isFunctionKey : function (k)
      {
        k = k.which ? k.which : k;
        return k >= 112 && k <= 123;
      }
    },

    lastMousePosition: {x : 0, y : 0},
    nextUid: (function () {var counter = 1; return function () { return counter++; };}()),

    //TODO:
    scrollBarDimensions: null,
    
    //_ComboUtils
    /*
     * 4-10 times faster .each replacement
     * it overrides jQuery context of element on each iteration
     */
    each2: function(list, c)
    {
      var j = $(list[0]),
      i = -1,
      l = list.length;
      while (
        ++i < l
          && (j.context = j[0] = list[i])
          && c.call(j[0], i, j) !== false //i=index, j=jQuery object
      )
      {};
      return list;
    },

    //_ComboUtils
    measureScrollbar: function()
    {
      var $template = $("<div class='oj-listbox-measure-scrollbar'></div>");
      $template.appendTo('body');
      var dim =
        {
          width : $template.width() - $template[0].clientWidth,
          height : $template.height() - $template[0].clientHeight
        };
      $template.remove();
      return dim;
    },

    //_ComboUtils
    /*
     * Splits the string into an array of values, trimming each value. 
     * An empty array is returned for nulls or empty
     */
    splitVal: function(string, separator)
    {
      var val,
      i,
      l;
      if (string === null || string.length < 1)
        return [];
      val = string.split(separator);
      for (i = 0, l = val.length; i < l; i = i + 1)
        val[i] = $.trim(val[i]);
      return val;
    },

    //_ComboUtils
    getSideBorderPadding: function(element)
    {
      return element.outerWidth(false) - element.width();
    },

    //_ComboUtils
    installKeyUpChangeEvent: function(element)
    {
      var key = "keyup-change-value";
      element.on("keydown", function ()                 
        {
          if ($.data(element, key) === undefined)
          {
            $.data(element, key, element.val());
          }
        });

      element.on("keyup", function (e)
        {
          if (e.which === _ComboUtils.KEY.ENTER)
          {
            e.stopPropagation();
            return;
          }
          var val = $.data(element, key);
          if (val !== undefined && element.val() !== val)
          {
            $.removeData(element, key);
            element.trigger("keyup-change");
          }
        });
    },

    //_ComboUtils
    /*
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    installFilteredMouseMove: function(element)
    {
      element.on("mousemove", function (e)
        {
          var lastpos = _ComboUtils.lastMousePosition;
          if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY)
          {
            $(e.target).trigger("mousemove-filtered", e);
            _ComboUtils.lastMousePosition.x = e.pageX;
            _ComboUtils.lastMousePosition.y = e.pageY;
          }
        });
    },

    //_ComboUtils
    thunk: function(formula)
    {
      var evaluated = false,
      value;
      return function ()
        {
          if (evaluated === false)
          {
            value = formula();
            evaluated = true;
          }
          return value;
        };
    },

    //_ComboUtils
    _focus: function($el)
    {
      if ($el[0] === document.activeElement)
        return;

      /* set the focus in a 0 timeout - that way the focus is set after the processing
         of the current event has finished - which seems like the only reliable way
         to set focus */
      window.setTimeout(function ()
        {
          var el = $el[0],
          pos = $el.val().length,
          range;
          $el.focus();

          /* make sure el received focus so we do not error out when trying to manipulate the caret.
             sometimes modals or others listeners may steal it after its set */
          if ($el.is(":visible") && el === document.activeElement)
          {
            /* after the focus is set move the caret to the end, necessary when we val()
               just before setting focus */
            if (el.setSelectionRange)
              el.setSelectionRange(pos, pos);
            else if (el.createTextRange)
            {
              range = el.createTextRange();
              range.collapse(false);
              range.select();
            }
          }
        }, 0);
    },

    //_ComboUtils
    getCursorInfo: function (el)
    {
      el = $(el)[0];
      var offset = 0;
      var length = 0;
      if ('selectionStart' in el)
      {
        offset = el.selectionStart;
        length = el.selectionEnd - offset;
      }
      else if ('selection' in document)
      {
        el.focus(); //Fixed???
        var sel = document.selection.createRange();
        length = document.selection.createRange().text.length;
        sel.moveStart('character', -el.value.length);
        offset = sel.text.length - length;
      }
      return {offset : offset, length : length};
    },

    //_ComboUtils
    killEvent: function(event)
    {
      event.preventDefault();
      event.stopPropagation();
    },

    //_ComboUtils
    killEventImmediately: function(event)
    {
      event.preventDefault();
      event.stopImmediatePropagation();
    },

    //_ComboUtils
    defaultEscapeMarkup: function(markup)
    {
      var replace_map =
      {
        '\\' : '&#92;',
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        "'" : '&#39;'
      };
      return String(markup).replace(/[&<>"'\\]/g, function (match)
        {
          return replace_map[match];
        });
    },

    //_ComboUtils
    /*
     * Produces a query function that works with a local array
     */
    local: function(options, optKeys)
    {
      var data = options, // data elements
          dataText,
          tmp,
          // function used to retrieve the text portion of a data item that is matched against the search
          text = function (item)
            {
              return "" + item['label'];
            };

      if ($.isArray(data))
      {
        tmp = data;
        data =
          {
            results : tmp
          };
      }
      if ($.isFunction(data) === false)
      {
        tmp = data;
        data = function ()
          {
            return tmp;
          };
      }
      var dataItem = data();
      //select with no options
      if (dataItem && dataItem.text)
      {
        text = dataItem.text;
        // if text is not a function we assume it to be a key name
        if (!$.isFunction(text))
        {
          // we need to store this in a separate variable because in the next step data gets reset 
          // and data.text is no longer available
          dataText = dataItem.text; 
          text = function (item)
            {
              return item[dataText];
            };
        }
      }
      return function (query)
        {
          var t = query.term,
          filtered =
            {
              results : []
            },
          process;
          if (t === "")
          {
            query.callback(data());
            return;
          }
          process = function (datum, collection, keys)
            {
              var group,
              attr;
              datum = datum[0];
              
              // key mappings
              if (!datum['label'] &&(keys && keys['label'])) {
                datum['label'] = datum[keys['label']];
                delete datum[keys['label']];
              }
              if (!datum['value'] && (keys && keys['value'])) {
                datum['value'] = datum[keys['value']];
                delete datum[keys['value']];
              }
              if (!datum['children'] && (keys && keys['children'])) {
                datum['children'] = datum[keys['children']];
                delete datum[keys['children']];
              }
                
              if (datum['children'])
              {
                group = {};
                for (attr in datum)
                {
                  if (datum.hasOwnProperty(attr))
                    group[attr] = datum[attr];
                }
                group.children = [];
                _ComboUtils.each2($(datum['children']), function (i, childDatum)
                 {
                   process(childDatum, group.children, (keys && keys['childKeys']) ? keys['childKeys'] : null);
                 });

                //Bug 18903692 - group labels participate in the filtering
                //Reverted. In the nested data case, group may be selectable. Without putting the 
                //group data in the collection, we will find no match and new entry may be created for combobox
                if (group.children.length || query.matcher(t, text(group), datum))
                {
                  collection.push(group);
                }
              }
              else
              {
                if (query.matcher(t, text(datum), datum))
                {
                  collection.push(datum);
                }
              }
            };
          if(data()){
            _ComboUtils.each2($(data().results), function (i, datum)
              {
                process(datum, filtered.results, optKeys);
              });  
          }  
          query.callback(filtered);
        };
    },

    //_ComboUtils
    checkFormatter: function (ojContext, formatter, formatterName)
    {
      if ($.isFunction(formatter))
        return true;
      if (!formatter)
        return false;

      throw new Error(formatterName + " must be a function or a false value");
    },

    //_ComboUtils
    /*
     * Creates a new class
     */
    clazz: function(SuperClass, methods)
    {
      var constructor = function ()  {};
      oj.Object.createSubclass(constructor, SuperClass, '');
      constructor.prototype = $.extend(constructor.prototype, methods);
      return constructor;
    }

  };


  var _AbstractOjChoice = _ComboUtils.clazz(Object,
    {
      //_AbstractOjChoice
      _bind : function (func)
      {
        var self = this;
        return function ()
        {
          func.apply(self, arguments);
        };
      },

      //_AbstractOjChoice
      _init : function (opts)
      {
        var results,
        search,
        className = this._classNm,
        elemName = this._elemNm,
        resultsSelector = ".oj-listbox-results";

        this.ojContext = opts.ojContext;
        this.opts = opts = this._prepareOpts(opts);
        this.id = opts.id;

        // destroy if called on an existing component
        if (opts.element.data(elemName) !== undefined &&
          opts.element.data(elemName) !== null)
        {
          opts.element.data(elemName)._destroy();
        }
        this.container = this._createContainer();

        //Bug 18871897 - ojselect - rootAttributes are not propagated to generated jet component
        var rootAttr = this.opts.rootAttributes;
        this.containerId = (rootAttr && rootAttr.id) ? 
          rootAttr.id :
          "ojChoiceId_" + (opts.element.attr("id") || "autogen" + _ComboUtils.nextUid());

        this.containerSelector = "#" + this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
        this.container.attr("id", this.containerId);
        // cache the body so future lookups are cheap
        this.body = _ComboUtils.thunk(function ()
          {
            return opts.element.closest("body");
          }
          );
        this.container.attr("style", opts.element.attr("style"));
        this.elementTabIndex = this.opts.element.attr("tabindex");

        // swap container for the element
        this.opts.element
        .data(elemName, this)
        .attr("tabindex", "-1")
        .before(this.container);
        this.container.data(elemName, this);
        this.dropdown = this.container.find(".oj-listbox-drop");
        this.dropdown.data('ojlistbox', this);
        this.dropdown.on("click", _ComboUtils.killEvent);

        // since the dropdown popup is reparented to the body, it looses associate in the dom.
        // establish linkage between the dropdown and the select and combobox.
        var surrogateId = this.containerId;
        this.dropdown.attr(oj.DomUtils.SURROGATE_ID, surrogateId);

        this.results = results = this.container.find(resultsSelector);

        //TODO: should combobox use .oj-listbox-search .oj-listbox-input
//        this.search = search = this.container.find("input." + className + "-input");
        if (className == "oj-select")
          search = this.container.find("input." + "oj-listbox-input");
        else
          search = this.container.find("input." + className + "-input");
        this.search = search;

        this.queryCount = 0;
        this.resultsPage = 0;
        this.context = null;

        // initialize the container
        this._initContainer();
        this.container.on("click", _ComboUtils.killEvent);
        _ComboUtils.installFilteredMouseMove(this.results);
        this.dropdown.on("mousemove-filtered touchstart touchmove touchend", resultsSelector, this._bind(this._highlightUnderEvent));
        // do not propagate change event from the search field out of the component
        $(this.container).on("change", "." + className + "-input", function (e)
        {
          e.stopPropagation();
        }
        );
        $(this.dropdown).on("change", "." + className + "-input", function (e)
        {
          e.stopPropagation();
        }
        );
        _ComboUtils.installKeyUpChangeEvent(search);
        search.on("keyup-change input paste", this._bind(this._updateResults));
        search.on("focus", function ()
        {
          search.addClass(className + "-focused");
        }
        );
        search.on("blur", function ()
        {
          search.removeClass(className + "-focused");
        }
        );
        this.dropdown.on("mouseup", resultsSelector, this._bind(function (e)
          {
            if ($(e.target).closest(".oj-listbox-result-selectable").length > 0)
            {
              this._highlightUnderEvent(e);
              this._selectHighlighted(null, e);
            }
          }
          ));
        // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
        // for mouse events outside of itself so it can close itself. since the dropdown is now outside the combobox's
        // dom it will trigger the popup close, which is not what we want
        this.dropdown.on("click mouseup mousedown", function (e)
        {
          e.stopPropagation();
        }
        );
        if ($.isFunction(this.opts.initSelection))
        {


          ///support ko options-binding
          this._initSelection();
        }
        var disabled = opts.element.prop("disabled");
        if (disabled === undefined)
          disabled = false;
        this._enable(!disabled);
        var readonly = opts.element.prop("readonly");
        if (readonly === undefined)
          readonly = false;
        this._readonly(readonly);
        // Calculate size of scrollbar
        _ComboUtils.scrollBarDimensions = _ComboUtils.scrollBarDimensions || 
                                          _ComboUtils.measureScrollbar();
        this.autofocus = opts.element.prop("autofocus");
        opts.element.prop("autofocus", false);
        if (this.autofocus)
          this._focus();

        var clickAwayHandler = $(document).data("ojChoiceClickAwayHandler-" + elemName);
        if (!clickAwayHandler) {
            var clickAwayListener = function(event) {

                var dropdown = $("#oj-listbox-drop"),
                    arrow = ".oj-combobox-arrow",
                    self;
                if ($(event.target).closest(dropdown).length)
                    return;

                if (dropdown.length > 0) {
                    self = dropdown.data('ojlistbox');
                    if (self.opts.selectOnBlur) {
                        self._selectHighlighted({
                                noFocus: true
                            }, event ///pass original event
                        );
                    }
                    self.close(event);
                }
            };
            document.addEventListener("mousedown", clickAwayListener, true);
            clickAwayHandler = {
                listener: clickAwayListener,
                components: []
            };
            clickAwayHandler.components.push(this);
            $(document).data("ojChoiceClickAwayHandler-" + elemName, clickAwayHandler);
        } else {
            clickAwayHandler.components.push(this);
        }
      },

      //_AbstractOjChoice
      _destroy : function ()
      {
        var element = this.opts.element,
            ojcomp = element.data(this._elemNm);

        this.close();
        if (this.propertyObserver)
        {
          delete this.propertyObserver;
          this.propertyObserver = null;
        }
        if (ojcomp !== undefined)
        {
          ojcomp.container.remove();
          ojcomp.dropdown.remove();
          element
          .removeAttr("aria-hidden")
          .removeData(this._elemNm)
          .off("." + this._classNm)
          .prop("autofocus", this.autofocus || false);
          if (this.elementTabIndex)
          {
            element.attr(
            {
              tabindex : this.elementTabIndex
            }
            );
          }
          else
          {
            element.removeAttr("tabindex");
          }
          element.show();
        }

        var clickAwayHandler = $(document).data("ojChoiceClickAwayHandler-" + this._elemNm);
        var index = clickAwayHandler.components.indexOf(this);
        if (index > -1) {
            clickAwayHandler.components.splice(index, 1);
            if (!clickAwayHandler.components.length) {
                document.removeEventListener("mousedown", clickAwayHandler.listener, true);
                $(document).removeData("ojChoiceClickAwayHandler-" + this._elemNm);
            }
        }
      },

      //_AbstractOjChoice
      /*
       * Processes option element and return data object
       */
      _optionToData : function (element)
      {
        if (element.is("option"))
        {
          return {
            value : element.prop("value"),
            label : element.text(),
            element : element.get(),
            css : element.attr("class"),
            disabled : element.prop("disabled"),
            locked : (element.attr("locked") === "locked") || (element.data("locked") === true)
          };
        }
        else if (element.is("optgroup"))
        {
          return {
            label : element.attr("label"),
            children : [],
            element : element.get(),
            css : element.attr("class")
          };
        }
      },

      //_AbstractOjChoice
      /*
       * Prepares the option items to display in the drop down
       */
      _prepareOpts : function (opts)
      {
        var element,
        datalist,
        self = this;

        element = opts.element;
        var tagName = element.get(0).tagName.toLowerCase();
        if (tagName === "input" && element.attr("list"))
        {
          this.datalist = datalist = $('#' + element.attr("list"));
        }

        ///ojselect
        else if (tagName === "select" && element.children().length > 0)
        {
          this.datalist = datalist = element;
        }

        opts = $.extend({},
          {
            populateResults : function (container, results, query, showPlaceholder)
            {
              var populate,
              id = this.opts.id;

              populate = function (results, container, depth, showPlaceholder)
              {
                var i,
                l,
                result,
                selectable,
                disabled,
                node,
                label,
                innerContainer,
                formatted;

                //Bug 18827605 - ojselect does not show placeholder text when data option is specified
                ///ojselect only add placeholder to dropdown if there is no search filter
                var placeholder = self._getPlaceholder();
                if (showPlaceholder && placeholder !== null && ! query.term)
                {
                  //create placeholder item
                  result = {
                    value: '',
                    label: placeholder
                  };

                  node = $("<li></li>");
                  node.addClass("oj-listbox-placeholder oj-listbox-results-depth-0 oj-listbox-result oj-listbox-result-selectable");
                  node.attr("role", "presentation");

                  label = $(document.createElement("div"));
                  label.addClass("oj-listbox-result-label");
                  label.attr("id", "oj-listbox-result-label-" + _ComboUtils.nextUid());
                  label.attr("role", "option");

                  formatted = opts.formatResult(result, self.opts.escapeMarkup);
                  if (formatted !== undefined)
                    label.text(formatted);

                  node.append(label);

                  node.data(self._elemNm, result);
                  container.append(node);
                }

                for (i = 0, l = results.length; i < l; i = i + 1)
                {
                  result = results[i];
                  disabled = (result.disabled === true);
                  selectable = (!disabled) && (id(result) !== undefined);

                  node = $("<li></li>");
                  node.addClass("oj-listbox-results-depth-" + depth);
                  node.addClass("oj-listbox-result");
                  node.addClass(selectable ? "oj-listbox-result-selectable" : "oj-listbox-result-unselectable");
                  if (disabled)
                  {
                    node.addClass("oj-disabled");
                  }
                  if (result.children)
                  {
                    node.addClass("oj-listbox-result-with-children");
                  }
                  node.attr("role", "presentation");

                  label = $(document.createElement("div"));
                  label.addClass("oj-listbox-result-label");
                  label.attr("id", "oj-listbox-result-label-" + _ComboUtils.nextUid());
                  label.attr("role", "option");
                  if (disabled)
                    label.attr("aria-disabled", "true");

                  formatted = opts.formatResult(result, self.opts.escapeMarkup);
                  if (formatted !== undefined)
                  {
                    label.text(formatted);
                  }

                  node.append(label);

                  if (result.children && result.children.length > 0)
                  {
                    innerContainer = $("<ul></ul>");
                    innerContainer.addClass("oj-listbox-result-sub");
                    ///ojselect placehholder
                    populate(result.children, innerContainer, depth + 1, false);
                    node.append(innerContainer);
                  }

                  node.data(self._elemNm, result);
                  container.append(node);
                }
              };

              ///ojselect placehholder
              populate(results, container, 0, showPlaceholder);
            }
          }, _ojChoice_defaults, opts);
                        
        opts.id = function (e)
        {
          return e['value'];
        };
          
        opts.formatResult = function (result, escapeMarkup)
        {
          var markup = [], label;
          label = result['label'];
          markup.push(opts.escapeMarkup(label));
          return markup.join("");
        };
        
        opts.formatSelection = function (data, container, escapeMarkup)
        {
          return (data && data['label']) ? escapeMarkup(data['label']) : undefined;
        };
        
        if (tagName !== "select" && opts["manageNewEntry"] !== null)
        {
          opts["manageNewEntry"] = function (term)
          {
            var entry = {};
            entry['value'] = entry['label'] = $.trim(term);
            return entry;
          }
        }

        if (datalist)
        {
          opts.query = this._bind(function (query)
            {
              var data =
              {
                results : [],
                more : false
              },
              term = query.term,
              children,
              process;

              process = function (element, collection)
              {
                var group;
                if (element.is("option"))
                {
                  if (query.matcher(term, element.text(), element))
                  {
                    collection.push(self._optionToData(element));
                  }
                }
                else if (element.is("optgroup"))
                {
                  group = self._optionToData(element);
                  _ComboUtils.each2(element.children(), function (i, elm)
                  {
                    process(elm, group.children);
                  }
                  );
                  if (group.children.length > 0)
                  {
                    collection.push(group);
                  }
                }
              };

              children = datalist.children();

              ///ojselect remove existing placeholder item
              if (this._getPlaceholder() !== undefined && children.length > 0 &&
                  children.first().attr("value") == "")
              {
                children = children.slice(1);
              }

              _ComboUtils.each2(children, function (i, elm)
              {
                process(elm, data.results);
              }
              );
              query.callback(data);
            }
            );
        }
        else if ("options" in opts)
        {
          opts.query = _ComboUtils.local(opts.options, opts.optionsKeys ? opts.optionsKeys : null);
        }

        return opts;
      },

      //_AbstractOjChoice
      _triggerSelect : function (data)
      {
        var evt = $.Event(this._elemNm + "-selecting",
          {
            val : this.id(data),
            object : data
          }
          );
        this.opts.element.trigger(evt);
        return !evt.isDefaultPrevented();
      },

      //_AbstractOjChoice
      _isInterfaceEnabled : function ()
      {
        return this.enabledInterface === true;
      },

      //_AbstractOjChoice
      _enableInterface : function ()
      {
        var enabled = this._enabled && !this._readonly,
        disabled = !enabled;

        if (enabled === this.enabledInterface)
          return false;

        this.container.toggleClass("oj-disabled", disabled);
        this.close();
        this.enabledInterface = enabled;

        return true;
      },

      //_AbstractOjChoice
      _enable : function (enabled)
      {
        if (enabled === undefined)
          enabled = true;
        if (this._enabled === enabled)
          return;
        this._enabled = enabled;

        this.opts.element.prop("disabled", !enabled);
        this._enableInterface();
      },

      //_AbstractOjChoice
      _disable : function ()
      {
        this._enable(false);
      },

      //_AbstractOjChoice
      _readonly : function (enabled)
      {
        if (enabled === undefined)
          enabled = false;
        if (this._readonly === enabled)
          return false;
        this._readonly = enabled;

        this.opts.element.prop("readonly", enabled);
        this._enableInterface();
        return true;
      },

      //_AbstractOjChoice
      _opened : function ()
      {
        return this.container.hasClass("oj-listbox-dropdown-open");
      },

      //_AbstractOjChoice
      _positionDropdown : function ()
      {
        var $dropdown = this.dropdown,
        offset = this.container.offset(),
        height = this.container.outerHeight(false),
        width = this.container.outerWidth(false),
        dropHeight = $dropdown.outerHeight(false),
        $window = $(window),
        windowWidth = $window.width(),
        windowHeight = $window.height(),
        viewPortRight = $window.scrollLeft() + windowWidth,
        viewportBottom = $window.scrollTop() + windowHeight,
        dropTop = offset.top + height,
        dropLeft = offset.left,
        enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
        enoughRoomAbove = (offset.top - dropHeight) >= this.body().scrollTop(),
        dropWidth = $dropdown.outerWidth(false),
        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
        aboveNow = $dropdown.hasClass("oj-listbox-drop-above"),
        bodyOffset,
        above,
        changeDirection,
        css,
        resultsListNode;

        // always prefer the current above/below alignment, unless there is not enough room
        if (aboveNow)
        {
          above = true;
          if (!enoughRoomAbove && enoughRoomBelow)
          {
            changeDirection = true;
            above = false;
          }
        }
        else
        {
          above = false;
          if (!enoughRoomBelow && enoughRoomAbove)
          {
            changeDirection = true;
            above = true;
          }
        }

        //if we are changing direction we need to get positions when dropdown is hidden;
        if (changeDirection)
        {
          $dropdown.hide();
          offset = this.container.offset();
          height = this.container.outerHeight(false);
          width = this.container.outerWidth(false);
          dropHeight = $dropdown.outerHeight(false);
          viewPortRight = $window.scrollLeft() + windowWidth;
          viewportBottom = $window.scrollTop() + windowHeight;
          dropTop = offset.top + height;

          ///ojselect move 1px up to cover up the border bottom of the select box
          if (!above && this._hasSearchBox())
            dropTop -= 1;

          dropLeft = offset.left;
          dropWidth = $dropdown.outerWidth(false);
          enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
          $dropdown.show();
        }

        ///ojselect move 1px up to cover up the border bottom of the select box
        else if (!above && this._hasSearchBox())
          dropTop -= 1;

/* Don't think we expose this option
        if (this.opts.dropdownAutoWidth)
        {
          resultsListNode = $(".oj-listbox-results", $dropdown)[0];
          $dropdown.addClass("oj-listbox-drop-auto-width");
          $dropdown.css('width', '');
          // Add scrollbar width to dropdown if vertical scrollbar is present
          dropWidth = $dropdown.outerWidth(false) + 
            (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : 
             _ComboUtils.scrollBarDimensions.width);
          dropWidth > width ? width = dropWidth : dropWidth = width;
          enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
        }
        else
        {
          this.container.removeClass("oj-listbox-drop-auto-width");
        }
*/

        // fix positioning when body has an offset and is not position: static
        if (this.body().css('position') !== 'static')
        {
          bodyOffset = this.body().offset();
          dropTop -= bodyOffset.top;
          dropLeft -= bodyOffset.left;
        }

        if (!enoughRoomOnRight)
        {
          dropLeft = offset.left + width - dropWidth;
        }

        css =
        {
          left : dropLeft,
          width : width
        };

        if (above)
        {
          css.bottom = windowHeight - offset.top;
          css.top = 'auto';
          this.container.addClass("oj-listbox-drop-above");
          $dropdown.addClass("oj-listbox-drop-above");
        }
        else
        {
          css.top = dropTop;
          css.bottom = 'auto';
          this.container.removeClass("oj-listbox-drop-above");
          $dropdown.removeClass("oj-listbox-drop-above");
        }

        $dropdown.css(css);
      },

      //_AbstractOjChoice
      _shouldOpen : function (e)
      {
        var event;

        if (this._opened())
          return false;
        if (this._enabled === false || this._readonly === true)
          return false;

        event = $.Event(this._elemNm + "-opening");
        this.opts.element.trigger(event);
        return !event.isDefaultPrevented();
      },

      //_AbstractOjChoice
      _clearDropdownAlignmentPreference : function ()
      {
        // clear the classes used to figure out the preference of where the dropdown should be opened
        this.container.removeClass("oj-listbox-drop-above");
        this.dropdown.removeClass("oj-listbox-drop-above");
      },

      //_AbstractOjChoice
      /**
       * Opens the dropdown
       *
       * @return {boolean} whether or not dropdown was opened. This method will return false if, for example,
       * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
       * @ignore
       */
      open : function (e)
      {
        if (!this._shouldOpen(e))
          return false;
        this._opening();
        return true;
      },
      
      //_AbstractOjChoice
      _opening : function ()
      {
        var cid = this.containerId,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid;

        //this._clearPlaceholder();
        this.container.addClass("oj-listbox-dropdown-open");

        this._clearDropdownAlignmentPreference();

        if (this.dropdown[0] !== this.body().children().last()[0])
        {
          this.dropdown.detach().appendTo(this.body());
        }

       
       this.dropdown.appendTo(this.body());

        // move the global id to the correct dropdown
        $("#oj-listbox-drop").removeAttr("id");
        this.dropdown.attr("id", "oj-listbox-drop");

        // show the elements
        
        this._positionDropdown();
        this.dropdown.show();
        this._positionDropdown();

        ///select: accessibility
        this._getActiveContainer().attr("aria-expanded", true);

        // attach listeners to events that can change the position of the container and thus require
        // the position of the dropdown to be updated as well so it does not come unglued from the container
        var that = this;
        this.container.parents().add(window).each(function ()
        {
          $(this).on(resize + " " + scroll + " " + orient, function (e)
          {
            that._positionDropdown();
          }
          );
        }
        );

      },

      //_AbstractOjChoice
      close : function (event)
      {
        if (!this._opened())
          return;

        var cid = this.containerId,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid;

        // unbind event listeners
        this.container.parents().add(window).each(function ()
        {
          $(this).off(scroll).off(resize).off(orient);
        }
        );

        this._clearDropdownAlignmentPreference();

        this.dropdown.removeAttr("id");
        this.dropdown.hide();
        this.container.removeClass("oj-listbox-dropdown-open");
        this.results.empty();

        ///select: accessibility
        this._getActiveContainer().attr("aria-expanded", false);
      },

      //_AbstractOjChoice
      _clearSearch : function ()  {},

      //_AbstractOjChoice
      _ensureHighlightVisible : function ()
      {
        var results = this.results,
        children,
        index,
        child,
        hb,
        rb,
        y,
        more;

        index = this._highlight();

        if (index < 0)
          return;

        if (index == 0)
        {
          // if the first element is highlighted scroll all the way to the top,
          // that way any unselectable headers above it will also be scrolled
          // into view
          results.scrollTop(0);
          return;
        }

        children = this._findHighlightableChoices().find(".oj-listbox-result-label");
        child = $(children[index]);
        hb = child.offset().top + child.outerHeight(true);

        // if this is the last child lets also make sure oj-combobox-more-results is visible
        if (index === children.length - 1)
        {
          more = results.find("li.oj-listbox-more-results");
          if (more.length > 0)
          {
            hb = more.offset().top + more.outerHeight(true);
          }
        }

        rb = results.offset().top + results.outerHeight(true);
        if (hb > rb)
        {
          results.scrollTop(results.scrollTop() + (hb - rb));
        }
        y = child.offset().top - results.offset().top;

        // make sure the top of the element is visible
        if (y < 0 && child.css('display') != 'none')
        {
          results.scrollTop(results.scrollTop() + y); // y is negative
        }
      },

      //_AbstractOjChoice
      _findHighlightableChoices : function ()
      {
        return this.results.find(".oj-listbox-result-selectable:not(.oj-disabled, .oj-selected)");
      },

      //_AbstractOjChoice
      _moveHighlight : function (delta)
      {
        var choices = this._findHighlightableChoices(),
        index = this._highlight();
        while (index >= -1 && index < choices.length)
        {
          index += delta;
          var choice = $(choices[index]);
          if (choice.hasClass("oj-listbox-result-selectable") && !choice.hasClass("oj-disabled") && 
              !choice.hasClass("oj-selected"))
          {
            this._highlight(index);
            break;
          }
        }
      },

      //_AbstractOjChoice
      _highlight : function (index)
      {
        var choices = this._findHighlightableChoices(),
        choice,
        data;

        if (arguments.length === 0)
        {
          return choices.get().indexOf(choices.filter(".oj-hover")[0]);
        }

        if (index >= choices.length)
          index = choices.length - 1;
        if (index < 0)
          index = 0;

        this._removeHighlight();

        choice = $(choices[index]);
        choice.addClass("oj-hover");

        // ensure assistive technology can determine the active choice
        ///select: accessibility
        this._getActiveContainer().attr("aria-activedescendant", 
                                        choice.find(".oj-listbox-result-label").attr("id"));
          
        this._ensureHighlightVisible();
      },

      //_AbstractOjChoice
      _removeHighlight : function ()
      {
        this.results.find(".oj-hover").removeClass("oj-hover");
      },

      //_AbstractOjChoice
      _highlightUnderEvent : function (event)
      {
        var el = $(event.target).closest(".oj-listbox-result-selectable");
        if (el.length > 0 && !el.is(".oj-hover"))
        {
          var choices = this._findHighlightableChoices();
          this._highlight(choices.index(el));
        }
        else if (el.length == 0)
        {
          // if we are over an unselectable item remove all highlights
          this._removeHighlight();
        }
      },

      //_AbstractOjChoice
      _updateResults : function (initial)
      {
        var search = this.search,
        results = this.results,
        opts = this.opts,
        data,
        self = this,
        input,
        term = search.val(),
        lastTerm = $.data(this.container, this._classNm + "-last-term"),
        // sequence number used to drop out-of-order responses
        queryNumber;

        // prevent duplicate queries against the same term
        if (initial !== true && lastTerm && (term === lastTerm))
          return;

        $.data(this.container, this._classNm + "-last-term", term);

        function postRender()
        {
          self._positionDropdown();
        }

        function render(html)
        {
          results.html(html);
          postRender();
        }

        queryNumber = ++this.queryCount;

        this._removeHighlight();
        input = this.search.val();
        if (input !== undefined && input != null && initial !== true)
        {
          term = input;
        }
        else
        {
          term = "";
        }

        this.resultsPage = 1;

        opts.query(
        {
          element : opts.element,
          term : term,
          page : this.resultsPage,
          context : null,
          matcher : opts.matcher,
          callback : this._bind(function (data)
          {
            var def; // default choice

            // ignore old responses
            if (queryNumber != this.queryCount)
            {
              return;
            }

            // ignore a response if the oj-combobox has been closed before it was received
            if (!this._opened())
            {
              return;
            }

            // save context, if any
            this.context = (!data || data.context === undefined) ? null : data.context;
            // create a default choice and prepend it to the list

            if ((!data || data.results.length === 0) && _ComboUtils.checkFormatter(self.ojContext, opts.formatNoMatches, "formatNoMatches"))
            {
              if (this._classNm == "oj-select")
                render("<li class='" + "oj-listbox-no-results'>" + opts.formatNoMatches(self.ojContext, search.val()) + "</li>");
              else
                this.close();
              return;
            }

            results.empty();

            self.opts.populateResults.call(this, results, data.results,
              {
                term : search.val(),
                page : this.resultsPage,
                context : null
              },
              this._showPlaceholder()
            );
            this._postprocessResults(data, initial);
            postRender();
          }
          )
        }
        );
      },

      //_AbstractOjChoice
      _cancel : function (event)
      {
        this.close(event);
      },

      //_AbstractOjChoice
      _focusSearch : function ()
      {
        _ComboUtils._focus(this.search);
      },

      //_AbstractOjChoice
      _selectHighlighted : function (options, event)
      {
        var index = this._highlight(),
        highlighted = this.results.find(".oj-hover"),
        data = highlighted.closest(".oj-listbox-result").data(this._elemNm);

        if (data)
        {
          this._highlight(index);
          this._onSelect(data, options, event);
        }
        else if (options && options.noFocus)
        {
          this.close(event);
        }
      },

      //_AbstractOjChoice
      _getPlaceholder : function ()
      {
        return this.opts.element.attr("placeholder") ||
        this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
        this.opts.element.data("placeholder") ||
        this.opts.placeholder;
      },
      
      //_AbstractOjChoice
      _setPlaceholder : function ()
      {
        var placeholder = this._getPlaceholder();

        if (!placeholder)
          return;
        this.search.attr("placeholder", placeholder);
        this.container.removeClass(this._classNm + "-allowclear");
      },

      //_AbstractOjChoice
      _initContainerWidth : function ()
      {
        function resolveContainerWidth()
        {
          var style,
          attrs,
          matches,
          i,
          l,
          attr;

          // check if there is inline style on the element that contains width
          style = this.opts.element.attr('style');
          if (style !== undefined)
          {
            attrs = style.split(';');
            for (i = 0, l = attrs.length; i < l; i = i + 1)
            {
              attr = attrs[i].replace(/\s/g, '');
              matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
              if (matches !== null && matches.length >= 1)
                return matches[1];
            }
          }
        };

        var width = resolveContainerWidth.call(this);
        if (width !== null)
        {
          this.container.css("width", width);
        }
      },

      //_AbstractOjChoice
      getVal: function () {
        return this.ojContext.option("value");
      },


      //_AbstractOjChoice
      ///pass original event
      setVal: function (val, event) {
        if (typeof val === "string")
        {
          //Bug 19231311 - select needs implementation fixes...
          // 1. _SetValue() compares the value passed in to the last saved display value. This is 
          // from ADF and is useful for comapring display values for inputs but since combo sets an 
          // array, this check is not needed.
          // 2. To bypass the check call this method when the value has changed and with the 
          // additional parameter. 
          this.ojContext._SetValue([val], event, {doValueChangeCheck: false});
        }
        else
        {
          //Bug 19231311 - select needs implementation fixes...
          this.ojContext._SetValue(val, event, {doValueChangeCheck: false});
        }
        // also set on the input element
        this.opts.element.val(val);
      },

      //_AbstractOjChoice
      ///ojselect placeholder
      _showPlaceholder : function ()
      {
        return false;
      },

      //_AbstractOjChoice
      ///select: accessibility
      _getActiveContainer : function ()
      {
        return this.search;
      },

      //_AbstractOjChoice
      _hasSearchBox : function ()
      {
        return (this.opts.minimumResultsForSearch !== undefined &&
          this.container._hasSearchBox !== undefined);
      }

    }
    );

  var _ojChoice_defaults =
  {
    closeOnSelect : true,
    openOnEnter : true,
    formatNoMatches : function (ojContext, val)
    {
//      return ojContext.getTranslatedString("noMatchesFound");
      return "No matches found";
    },
    id : function (e)
    {
      return e.id;
    },
    matcher : function (term, text)
    {
      return ('' + text).toUpperCase().indexOf(('' + term).toUpperCase()) >= 0;
    },

    separator : ",",
    escapeMarkup : _ComboUtils.defaultEscapeMarkup,
    blurOnChange : false,
    selectOnBlur : false
  };


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 *
 * You may obtain a copy of the Apache License and the GPL License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */
  /**
   * @private
   */
  var _AbstractSingleChoice = _ComboUtils.clazz(_AbstractOjChoice,
    {
      //_AbstractSingleChoice
      _enableInterface : function ()
      {
        if (_AbstractSingleChoice.superclass._enableInterface.apply(this, arguments))
        {
          this.search.prop("disabled", !this._isInterfaceEnabled());
        }
      },

      //_AbstractSingleChoice
      _focus : function ()
      {
        if (this._opened())
        {
          this.close();
        }
      },

      //_AbstractSingleChoice
      _destroy : function ()
      {
        $("label[for='" + this.search.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
        _AbstractSingleChoice.superclass._destroy.apply(this, arguments);
      },

      //_AbstractSingleChoice
      _clear : function (event)
      {
        var data = this.selection.data(this._elemNm);
        if (data)
        {
        // guard against queued quick consecutive clicks

          //This method will be invoked with or without event but 'data' will be null when it is invoked without event.
          //This logic is intended to clear the existing value when user manualy removes text in placeholder input box(which only happens for Combobox).
          //Ideally we should pass event, when we invoke _SetValue() if it is invoked on a UI action. So adding a warning message if event is null.
          if(!event)
             oj.Logger.warn("Event should not be null when user modified the value in UI");
          this.setVal([], event);
          this.search.val("");
          this.selection.removeData(this._elemNm);
        }
        this._setPlaceholder();
      },

      //_AbstractSingleChoice
      _initSelection : function ()
      {
        var selected,
        element,
        self = this;


        ///support ko options-binding
//        if (this.datalist || this.getVal())
//        {
          if (this.datalist)
            element = this.datalist;
          else
            element = this.opts.element;
          this.opts.initSelection.call(null, element, this._bind(this._updateSelectedOption));
//        }
      },

      //_AbstractSingleChoice
      _containerKeydownHandler : function (e)
      {
        if (!this._isInterfaceEnabled())
          return;

        if (e.which === _ComboUtils.KEY.PAGE_UP || e.which === _ComboUtils.KEY.PAGE_DOWN)
        {
          // prevent the page from scrolling
          _ComboUtils.killEvent(e);
          return;
        }

        switch (e.which)
        {
        case _ComboUtils.KEY.UP:
        case _ComboUtils.KEY.DOWN:
          if (this._opened())
          {
            this._moveHighlight((e.which === _ComboUtils.KEY.UP) ? -1 : 1);
          }
          else
          {
            this.open(e);
          }
          _ComboUtils.killEvent(e);
          return;

        case _ComboUtils.KEY.ENTER:
          this._selectHighlighted(null, e);
          _ComboUtils.killEvent(e);
          return;

        case _ComboUtils.KEY.TAB:
          this.close(e);
          return;

        case _ComboUtils.KEY.ESC:
          this._cancel(e);
          _ComboUtils.killEvent(e);
          return;
        }

        ///ojselect: used by select
        this._userTyping = true;

        if (!this._opened())
          this.open(e);
      },

      //_AbstractSingleChoice
      _containerKeyupHandler : function (e)
      {
        if (this._isInterfaceEnabled())
        {
          if (!this._opened())
            this.open(e);
        }
      },

      //_AbstractSingleChoice
      _initContainer : function ()
      {
        var selection,
        container = this.container,
        dropdown = this.dropdown,
        idSuffix = _ComboUtils.nextUid(),
        elementLabel;

        this.selection = selection = container.find("." + this._classNm + "-choice");
        //Bug 19335259 - ojselect missing id attribute on oj-select-choice div
        selection.attr("id", this._classNm + "-choice-" + idSuffix);

        elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
        if (!elementLabel.attr("id"))
          elementLabel.attr('id', this._classNm + "-label-" + idSuffix);

        // add aria associations
        selection.find("." + this._classNm + "-input").attr("id", this._classNm + "-input-" + idSuffix);
        this.results.attr("id", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-owns", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-labelledby", elementLabel.attr("id"));

        selection.on("keydown", this._bind(this._containerKeydownHandler));
        //selection.on("keyup-change input", this._bind(this._containerKeyupHandler));

        selection.on("mousedown", "abbr", this._bind(function (e)
          {
            if (!this._isInterfaceEnabled())
              return;
            this._clear(e);
            _ComboUtils.killEventImmediately(e);
            this.close(e);
            this.selection.focus();
          }
          ));

        selection.on("mousedown", this._bind(function (e)
          {
            ///prevent user from focusing on disabled select
            if (this.opts.element.prop("disabled"))
              _ComboUtils.killEvent(e);

            if (this._opened())
            {
              this.close(e);
            }
            else if (this._isInterfaceEnabled())
            {
              this.open(e);
            }
            this.search.focus();
          }
          ));

        selection.on("focus", this._bind(function (e)
          {
            _ComboUtils.killEvent(e);
          }
          ));

        this.search.on("blur", this._bind(function (e)
          {
            if (this.search.val() !== undefined && (this.results.children().length <= 0)) {
              // Call _onSelect if no previous data and there is typed in text
              // or the previous data is different from typed in text
              if (this.opts["manageNewEntry"]) {
                if ((!this.selection.data("ojcombobox") && this.search.val() !== "")
                    || (this.selection.data("ojcombobox") && this.selection.data("ojcombobox").label !== this.search.val())) {
                  var data = this.opts["manageNewEntry"](this.search.val());
                  this._onSelect(data, null, e);
                }
              } else if (this.opts["manageNewEntry"] == null) {
                var data = this.selection.data(this._elemNm);
                if (this.search.val() == "")
                  this._clear(e);
                else if (!data && this.search.val() !== "") 
                  this._clearSearch();
                else {
                  var formatted = this.opts.formatSelection(data, this.search, this.opts.escapeMarkup);
                  if (formatted !== undefined) 
                  {
                    this.search.val(formatted);
                  }
                }
              }
            }
            this.search.removeClass(this._classNm + "-focused");
          }
          ));

        this._initContainerWidth();

        this.opts.element.hide()
            .attr("aria-hidden", true);

        this._setPlaceholder();

      },

      //_AbstractSingleChoice
      _prepareOpts : function ()
      {
        var opts = _AbstractSingleChoice.superclass._prepareOpts.apply(this, arguments),
        self = this;

        ///ojselect set initial selected value
        var tagName = opts.element.get(0).tagName.toLowerCase();
        if ((tagName === "input" && opts.element.attr("list")) ||
          (tagName === "select" && opts.element.children().length > 0))
        {
          // install the selection initializer
          opts.initSelection = function (element, callback)
          {
            var selected;
            var value = self.getVal();
            if (Array.isArray(value))
              value = value[0];

            if (value !== undefined && value !== null)
            {
              selected = self._optionToData(element.find("option").filter(function ()
                  {
                    return this.value === value;
                  }
                  ));
            }
            else
            {
              selected = self._optionToData(element.find("option").filter(function ()
                  {
                    return this.selected;
                  }
                  ));
            }
            callback(selected);
          };
        }
        else if ("options" in opts || (this.getVal() && this.getVal().length > 0))
        {
          // install default initSelection when applied to hidden input and data is local
          opts.initSelection = opts.initSelection || function (element, callback)
          {
            var id = "";
            if (self.getVal() && self.getVal().length)
              id = self.getVal()[0];

            //search in data by id, storing the actual matching item
            var first = null;
            var match = null;
            opts.query(
            {
              matcher : function (term, text, el)
              {
                var is_match = (id === opts.id(el));
                if (is_match)
                {
                  match = el;
                }
                ///ojselect save the 1st option
                if (!first)
                {
                  first = el;
                }
                return is_match;
              },
              callback : !$.isFunction(callback) ? $.noop : function ()
              {
                ///ojselect if no match, pick the 1st option
                if (!match && tagName === "select")
                {
                  match = first;
                }
                callback(match);
              }
            }
            );
          };
        }
        return opts;
      },

      //_AbstractSingleChoice
      _postprocessResults : function (data, initial, noHighlightUpdate)
      {
        var selected = -1,
        self = this,
        highlightableChoices;

        highlightableChoices = this._findHighlightableChoices();
        _ComboUtils.each2(highlightableChoices, function (i, elm)
        {
          if (self.getVal() && self.getVal()[0] === self.id(elm.data(self._elemNm)))
          {
            selected = i;
            return false;
          }
        }
        );

        // and highlight it
        if (noHighlightUpdate !== false)
        {
          if (initial === true && selected >= 0)
          {
            this._highlight(selected);
          }
        }
      },

      //_AbstractSingleChoice
      ///pass original event
      _onSelect : function (data, options, event)
      {
        if (!this._triggerSelect(data))
        {
          return;
        }

        var old = this.getVal()? this.getVal()[0] : null;

        this._updateSelection(data);
        this.close(event);
        // When there is validation error, the value option may retain the previous value
        // although the display value is different. In that case, user should be able to still
        // select the previous valid value to get rid off the invalid style and message.
        /*if (!(old === this.id(data)))*/
        this.setVal(this.id(data).length === 0 ? [] : this.id(data), event);
      },

      //_AbstractSingleChoice
      ///beforeExpand
      _shouldOpen : function (e)
      {
        if (this._opened())
          return false;
        if (this._enabled === false || this._readonly === true)
          return false;

        var eventData = {
          'component' : this.opts.element
        };

        return this.ojContext._trigger("beforeExpand", e, eventData);
      },

      //_AbstractSingleChoice
      _clearSearch : function ()
      {
        this.search.val("");
      }

    }
    );


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 * 
 * You may obtain a copy of the Apache License and the GPL License at:
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */
/**
 * @private
 */
  var _OjSingleCombobox = _ComboUtils.clazz(_AbstractSingleChoice,
    {
      _elemNm : "ojcombobox",
      _classNm : "oj-combobox",

      _createContainer : function ()
      {
        //@HTMLUpdateOK
        var container = $(document.createElement("div")).attr(
          {
            "class" : "oj-combobox oj-component"
          }
          ).html([
              "<div class='oj-combobox-choice' tabindex='-1' role='presentation'>",
              "   <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'",
              "       spellcheck='false' class='oj-combobox-input' role='combobox' aria-expanded='false' aria-autocomplete='list' />",
              "   <abbr class='oj-combobox-clear-entry' role='presentation'></abbr>",
              "   <a class='oj-combobox-arrow' role='presentation'><b class='oj-combobox-icon oj-component-icon oj-clickable-icon oj-combobox-open-icon' role='presentation'></b></a>",
              "</div>",
              "<div class='oj-listbox-drop' style='display:none' role='presentation'>",
              "   <ul class='oj-listbox-results' role='listbox'>",
              "   </ul>",
              "</div>"].join(""));
        return container;
      },
      
      _enable : function (enabled)
      {
        _OjSingleCombobox.superclass._enable.apply(this, arguments);

        if (this._enabled) 
          this.container.find(".oj-combobox-arrow").removeClass("oj-disabled");
        else 
          this.container.find(".oj-combobox-arrow").addClass("oj-disabled");
      },
      
      close : function (event)
      {
        if (!this._opened())
          return;
        _OjSingleCombobox.superclass.close.apply(this, arguments);
      },

      _opening : function (event)
      {
        var el,
        range,
        len;
        
        //if beforeExpand is not cancelled
        _OjSingleCombobox.superclass._opening.apply(this, arguments);

          el = this.search.get(0);
          if (el.createTextRange)
          {
            range = el.createTextRange();
            range.collapse(false);
            range.select();
          }
          else if (el.setSelectionRange)
          {
            len = this.search.val().length;
            el.setSelectionRange(len, len);
          }

          this._updateResults(true);
      },

      _updateSelection : function (data)
      {
        var formatted;
        
        this.selection.data(this._elemNm, data);
        if (data !== null)
        {
          formatted = this.opts.formatSelection(data, this.search, this.opts.escapeMarkup);
          if (formatted !== undefined) 
          {
              this.search.val(formatted);
          }
          this.search.removeClass(this._classNm + "-default");
        }else{
          //data will be null only when user set it programmatically.
          this._setPlaceholder();
        }
        
        if (this.opts.allowClear)
        {
          this.container.addClass(this._classNm + "-allowclear");
        }
      },
      
      _updateSelectedOption : function(selected)
      {
        if (selected !== undefined && selected !== null) {
          this._updateSelection(selected);
        }else{
          // if we found no match, update the selection with the value
          var value = this.getVal();
          var data = !value ? null : !Array.isArray(value) ? {'label':value}: (Array.isArray(value) && value.length ) ? { 'label': value[0] } : null ;
          this._updateSelection(data);
        } 
      }
    }
    );


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 * 
 * You may obtain a copy of the Apache License and the GPL License at:
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */
  /**
 * @private
 */
var _OjSingleSelect = _ComboUtils.clazz(_AbstractSingleChoice,
    {
      _elemNm : "ojselect",
      _classNm : "oj-select",
      _userTyping : false,


      //_OjSingleSelect
      _createContainer : function ()
      {
        var container = $(document.createElement("div")).attr(
          {
            "class" : "oj-select oj-component"
          }
          ).html([
              "<div class='oj-select-choice' tabindex='0' role='combobox' ",
              "     aria-autocomplete='none' aria-expanded='false' aria-ready='true'>",
              "  <span class='oj-select-chosen'></span>",
              "  <abbr class='oj-select-search-choice-close' role='presentation'></abbr>",
              "  <a class='oj-select-arrow' role='presentation'>",
              "    <b class='oj-component-icon oj-clickable-icon oj-select-open-icon' role='presentation'></b>",
              "</a></div>",

              "<div class='oj-listbox-drop' style='display:none' role='presentation'>",

              "  <div class='oj-listbox-search-wrapper'>",

              "  <div class='oj-listbox-search'>",
              "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'",
              "           spellcheck='false' class='oj-listbox-input' title='Search field' ",
              "           role='combobox' aria-expanded='false' aria-autocomplete='list' />",

              "    <span class='oj-listbox-spyglass-box'>",
              "      <span class='oj-component-icon oj-clickable-icon oj-listbox-search-icon' role='presentation'>",
              "       <b role='presentation'></b></span>",
              "    </span>",
              "  </div>",

              "  </div>",

              "   <ul class='oj-listbox-results' role='listbox'>",
              "   </ul>",
              "</div>"

            ].join(""));

        return container;
      },

      //_OjSingleSelect
      _enable : function (enabled)
      {
        _OjSingleSelect.superclass._enable.apply(this, arguments);

        //Bug 18714295 - dropdown icon is in disabled state after enabling ojselect
        if (this._enabled) {
          this.container.find(".oj-select-choice").attr("tabindex", "0");
          this.container.find(".oj-select-arrow").removeClass("oj-disabled");
        }
        else {
          //Don't allow focus on a disabled "select"
          this.container.find(".oj-select-choice").attr("tabindex", "-1");
          //Bug 18697446 - disabled select icon hover still shows changes
          this.container.find(".oj-select-arrow").addClass("oj-disabled");
        }
      },

      //_OjSingleSelect
      close : function (event)
      {
        if (!this._opened())
          return;
        _OjSingleSelect.superclass.close.apply(this, arguments);

        //Bug 18763700 - required validation err is not displayed when user tabs out
        //always clear search text when dropdown close
        if (! this._testClear(event))
          this._clearSearch();

        //set focus to select box
        _ComboUtils._focus(this.selection);

        ///remove "mouse click" listeners on spyglass
        this.container.find(".oj-listbox-spyglass-box").off("mouseup click");
      },

      //_OjSingleSelect
      _opening : function (event)
      {
        var el,
            range,
            len;

        _OjSingleSelect.superclass._opening.apply(this, arguments);

        //select: focus still stay on the selectBox if open dropdown by mouse click
        this._showSearchBox();

        //James: tab out of an expanded poplist, focus is going all the way to the top of the page.
        if (this._hasSearchBox())
        {
          el = this.search.get(0);
          if (el.createTextRange)
          {
            range = el.createTextRange();
            range.collapse(false);
            range.select();
          }
          else if (el.setSelectionRange)
          {
            len = this.search.val().length;
            el.setSelectionRange(len, len);
          }
        }

        this._updateResults(true);
      },

      //_OjSingleSelect
      _initContainer : function ()
      {
        ///ojselect placeholder
        var selectedId = this.containerId + "_selected";
        this.text = this.container.find(".oj-select-chosen").attr("id", selectedId);

        _OjSingleSelect.superclass._initContainer.apply(this, arguments);

        ///select: accessibility
        this.container.find(".oj-select-choice")
          .attr({
            "aria-owns": this.search.attr("aria-owns"),
            "aria-labelledby": this.search.attr("aria-labelledby"),
            "aria-describedby": selectedId
          });

        this.search.on("keydown", this._bind(this._containerKeydownHandler));
        this.search.on("keyup-change input", this._bind(this._containerKeyupHandler));

        //Bug 18763700 - required validation err is not displayed when user tabs out
        var self = this;
        this.selection.on("blur", function(e) {
          self._testClear(e);
        });

      },

      //_OjSingleSelect
      _initSelection : function ()
      {
        if (this._isPlaceholderOptionSelected())
        {
          this._updateSelection(null);
          this.close();
          this._setPlaceholder();
        }
        else
        {
          _OjSingleSelect.superclass._initSelection.apply(this, arguments);
        }

      },
      
      //_OjSingleSelect
      _updateSelectedOption : function(selected)
      {
        if (selected !== undefined && selected !== null)
        {
          //ojSelect by default use first option if user set a value which is not listed in original option items.
          //So need to update options to reflect the correct value in component state.
          var selectedVal,
          value = this.getVal();
          value = Array.isArray(value)? value[0]: value;
          selectedVal = this.opts.id(selected);

          if(value !== selectedVal)
          {
            //no previous value
            if (value === undefined || value === null) {
              this.ojContext.options['value'] = Array.isArray(selectedVal)? selectedVal : [selectedVal];
            }
            //fire optionChange event
            else {
              this.setVal(Array.isArray(selectedVal)? selectedVal : [selectedVal]);
            }
          }
          this._updateSelection(selected);
          this.close();
        }
      },

      //_OjSingleSelect
      _updateSelection : function (data)
      {
        var formatted;

        this.selection.data(this._elemNm, data);
        //Bug 18326121 - ojet select displaying values incorrectly 
        if (data !== null)
        {  
          this.text.text(data['label']);
        }
        ///ojselect placeholder
        ///reduce number of call to setVal
        ///this.setVal(data? this.opts.id(data) : data);

        //make sure placeholder text has "oj-select-default" class
        if (data && data.id != "")
          this.text.removeClass(this._classNm + "-default");

        if (this.opts.allowClear)
        {
          this.container.addClass(this._classNm + "-allowclear");
        }
      },

      //_OjSingleSelect
      _getActiveContainer : function ()
      {
        var expanded = this.search.attr("aria-expanded");
        return (expanded && this._hasSearchBox()) ? this.search : this.selection;
      },

      //_OjSingleSelect
      _isPlaceholderOptionSelected : function ()
      {
        var placeholderOption;
        ///ojselect allow placeholder to be an empty string
        if (this._getPlaceholder() === null)
          return false; // no placeholder specified so no option should be considered

        var cval = this.getVal();
        cval = Array.isArray(cval)? cval[0]: cval;
        //This method is used to check whether placeholder text need to be displayed in ui or not and hence checking current value should be fine.
        return (cval === "")
         || (cval === undefined)
         || (cval === null);
      },

      //_OjSingleSelect
      ///ojselect placeholder this method should be in AbstractOjChoice
      _getPlaceholder : function ()
      {
        return this.opts.placeholder;
      },

      //_OjSingleSelect
      ///ojselect placeholder
      _showPlaceholder : function ()
      {
        return true;
      },

      //_OjSingleSelect
      _setPlaceholder : function ()
      {
        var placeholder = this._getPlaceholder();

        if (this._isPlaceholderOptionSelected() && placeholder !== undefined)
        {
          if (placeholder === undefined)
            placeholder = "";
          this.text.text(placeholder).addClass(this._classNm + "-default");
          this.container.removeClass(this._classNm + "-allowclear");
        }
      },

      //_OjSingleSelect
      setVal: function (val, event)
      {
        ///pass original event
        _OjSingleSelect.superclass.setVal.call(this, val, event);
        this.selection.data("selectVal", val);
      },

      //_OjSingleSelect
      _containerKeydownHandler : function (e)
      {
        ///ignore shift key 
        if (_ComboUtils.KEY.isControl(e) || _ComboUtils.KEY.isFunctionKey(e))
        {
          return;
        }

        switch (e.which)
        {
        case _ComboUtils.KEY.TAB:
          /*
          this._selectHighlighted(
            {
              noFocus : true
            }, e   ///pass original event
          );
          */
          this.close(e);
          //James: tab out of an expanded poplist, focus is going all the way to the top of the page.
          this.selection.focus();

          //Bug 18763700 - required validation err is not displayed when user tabs out
          this._testClear(e);
          return;

        // open dropdown on Enter 
        case _ComboUtils.KEY.ENTER:
          if (e.target === this.selection[0] && ! this._opened())
          {
            this.open(e);
            _ComboUtils.killEvent(e);
            return;
          }
          break;
        }

       _OjSingleSelect.superclass._containerKeydownHandler.apply(this, arguments);
      },

      //_OjSingleSelect
      //Bug 18763700 - required validation err is not displayed when user tabs out
      _testClear : function (event)
      {
        if (this.text.text() == "")
        {
          this._clear(event);
          return true;
        }
        return false;
      },

      //_OjSingleSelect
      _showSearchBox : function ()
      {
        var focusOnSearchBox = false;
        var searchBox = this.dropdown.find(".oj-listbox-search");
        if (searchBox)
        {
          //hide and show the search box
          if (this._hasSearchBox())
          {
            this.dropdown.find(".oj-listbox-search-wrapper")
              .removeClass("oj-helper-hidden-accessible");

            $(searchBox).removeAttr("aria-hidden");

            focusOnSearchBox = true;
          }
          else
          {
            this.dropdown.find(".oj-listbox-search-wrapper")
              .addClass("oj-helper-hidden-accessible");

            $(searchBox)
            .attr(
            {
              "aria-hidden" : "true"
            }
            );
          }
        }

        //if search box is being displayed, focus on the search box otherwise focus on the select box
        _ComboUtils._focus(focusOnSearchBox ? this.search : this.selection);

        ///disable "click" on spyglass
        if (focusOnSearchBox)
        {
          var self = this;
          searchBox.find(".oj-listbox-spyglass-box").on("mouseup click", function (e)
          {
            self.search.focus();
            e.stopPropagation();
          });
        }

      },

      //_OjSingleSelect
      _hasSearchBox : function ()
      {
        var threshold = this.opts.minimumResultsForSearch;
        var len = this.datalist ? this.datalist[0].length : (this.opts.options ? this.opts.options.length: 0);
        return (len > threshold || this._userTyping);
      }

    }
    );


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

  /**
   * @class
   * @name oj.ojCombobox
   * @augments oj.editableValue
   * @since 0.6
   *
   * @classdesc
   * <h3 id="comboboxOverview-section">
   *   JET Combobox Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#comboboxOverview-section"></a>
   * </h3>
   *
   * <p>Description: JET Combobox enhances a html input and datalist element into a Combobox that supports
   * single-select, multi-select, free text input, and search filtering.</p>
   *
   * <p>A JET Combobox can be created with the following markup. By default, it creates a single-select
   * Combobox. The 'multiple' option can be specified to change it to a multi-select Combobox.</p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;input list="items" data-bind="ojComponent: {component: 'ojCombobox', multiple: true}"/>
   * &lt;datalist id="items">
   *   &lt;option value="option 1">option 1&lt;/option>
   *   &lt;option value="option 2">option 2&lt;/option>
   *   &lt;option value="option 3">option 3&lt;/option>
   *   &lt;option value="option 4">option 4&lt;/option>
   * &lt;/datalist>
   * </code></pre>
   *
   * <p>Please note that datalist is not supported in IE 9. To create a JET Combobox that works across browsers
   * including IE 9, please use the <code class="prettyprint">options</code> array to provide the option items.</p>
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;input data-bind="ojComponent: {component: 'ojCombobox', options: 
   *                                     [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2'}]}"/>
   * </code></pre>
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Use</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td> Select the highlighted choice.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow or DownArrow</kbd></td>
   *       <td> Highlight the option item on the drop down list in the direction of the arrow.
   *         If the drop down is not open, expand the drop down list.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow or RightArrow</kbd></td>
   *       <td> Move focus to the previous or next selected item in Multi-select Combobox.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
   *     </tr>
   *
   *   </tbody>
   *  </table>
   *
   * <p>Disabled option items receive no highlight and are not selectable.</p>
   *
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the Combobox must be <code class="prettyprint">refresh()</code>ed.</p>
   *
   *
   * <h3 id="pseudos-section">
   *   Pseudo-selectors
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
   * </h3>
   *
   * <p>The <code class="prettyprint">:oj-combobox</code> pseudo-selector can be used in jQuery expressions to select JET Combobox.  For example:</p>
   *
   * <pre class="prettyprint">
   * <code>$( ":oj-combobox" ) // selects all JET Combobox on the page
   * $myEventTarget.closest( ":oj-combobox" ) // selects the closest ancestor that is a JET Combobox
   * </code></pre>
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p>
   * It is up to the application developer to associate the label to the input component.
   * For combobox, you should put an <code>id</code> on the input, and then set 
   * the <code>for</code> attribute on the label to be the input's id.
   * </p>
   * <h3 id="label-section">
   *   Label and Combobox
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
   * </h3>
   * <p>
   * For accessibility, you should associate a label element with the input
   * by putting an <code>id</code> on the input, and then setting the 
   * <code>for</code> attribute on the label to be the input's id.
   * </p>
   * <p>
   * The component will decorate its associated label with required and help 
   * information, if the <code>required</code> and <code>help</code> options are set. 
   * </p>
   * <h3 id="jqui2jet-section">
   *   JET for jQuery UI developers
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
   * </h3>
   *
   * <p>Event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "Combobox".</p>
   *
   * @desc Creates a JET Combobox.
   * @example <caption>Initialize the Combobox with no options specified:</caption>
   * $( ".selector" ).ojCombobox();
   *
   * @example <caption>Initialize the Combobox with some options:</caption>
   * $( ".selector" ).ojCombobox( { "multiple": true, "placeholder": "Select multiple values." } );
   *
   * @example <caption>Initialize the Combobox via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
   * &lt;div id="combobox" data-bind="ojComponent: { component: 'ojCombobox',
   *                                                    multiple: true}">
   */
  oj.__registerWidget("oj.ojCombobox", $['oj']['editableValue'],
  {
    defaultElement : "<input>",
    widgetEventPrefix : "oj",
    options :
    {
      /** 
       * A converter instance that duck types {@link oj.Converter}. Or an object literal containing 
       * the following properties. 
       * <p>
       * When <code class="prettyprint">converter</code> option changes due to programmatic 
       * intervention, the component performs various tasks based on the current state it is in. </br>
       * 
       * <h4>Steps Performed Always</h4>
       * <ul>
       * <li>Any cached converter instance is cleared and new converter created. The converter hint is 
       * pushed to messaging. E.g., notewindow displays the new hint(s).
       * </li>
       * </ul>
       * 
       * <h4>Running Validation</h4>
       * <ul>
       * <li>if component is valid when <code class="prettyprint">converter</code> option changes, the 
       * display value is refreshed.</li>
       * <li>if component is invalid and is showing messages -
       * <code class="prettyprint">messagesShown</code> option is non-empty, when 
       * <code class="prettyprint">converter</code> option changes, then all messages generated by the 
       * component are cleared and full validation run using its current display value. 
       * <ul>
       *   <li>if there are validation errors, then <code class="prettyprint">value</code> 
       *   option is not updated, and the errors pushed to <code class="prettyprint">messagesShown</code>
       *   option. The display value is not refreshed in this case. </li>
       *   <li>if no errors result from the validation, <code class="prettyprint">value</code> 
       *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code> 
       *   event on the <code class="prettyprint">value</code> option to clear custom errors. The 
       *   display value is refreshed with the formatted value provided by converter.</li>
       * </ul>
       * </li>
       * <li>if component is invalid and has deferred messages -  
       * <code class="prettyprint">messagesHidden</code> option is non-empty, when 
       * <code class="prettyprint">converter</code> option changes, then the display value is 
       * refreshed with the formatted value provided by converter.</li>
       * </ul>
       * </p>
       * 
       * <h4>Clearing Messages</h4>
       * <ul>
       * <li>When component messages are cleared in the cases described above, messages created by 
       * the component that are present in both <code class="prettyprint">messagesHidden</code> and 
       * <code class="prettyprint">messagesShown</code> options are cleared.</li>
       * <li><code class="prettyprint">messagesCustom</code> option is not cleared. Page authors can 
       * choose to clear it explicitly when setting the converter option.</li>
       * </ul>
       * </p>
       * 
       * @property {string} type - the conveter type registered with the oj.ConverterFactory. 
       * Supported types are 'number' and 'datetime'. See {@link oj.ConverterFactory} for details. <br/>
       * E.g., <code class="prettyprint">{converter: {type: 'number'}</code>
       * @property {Object=} options - optional Object literal of options that the converter expects. 
       * See {@link oj.IntlNumberConverter} for options supported by the number converter. See 
       * {@link oj.IntlDateTimeConverter} for options supported by the date time converter. <br/>
       * E.g., <code class="prettyprint">{converter: {type: 'number', options: {style: 'decimal'}}</code>
       * 
       * @expose 
       * @access public
       * @instance
       * @memberof! oj.ojCombobox
       * @type {Object|undefined}
       */    
      converter: undefined,

    
      /**
       * The placeholder text to set on the element. Though it is possible to set placeholder 
       * attribute on the element itself, the component will only read the value when the component
       * is created. Subsequent changes to the element's placeholder attribute will not be picked up 
       * and page authors should update the option directly.
       * 
       *
       * @example <caption>Initialize the combobox with the <code class="prettyprint">placeholder</code> option specified:</caption>
       * $( ".selector" ).ojCombobox( { "placeholder": "Please select ..." } );
       * 
       * @default when the option is not set, the element's placeholder attribute is used if it exists. 
       * 
       * @expose 
       * @access public
       * @instance
       * @memberof! oj.ojCombobox
       * @type {string|null|undefined}
       */    
      placeholder: undefined,
      
      
      /**
       * If multi-select is enabled for the combobox.
       *
       * @expose
       * @memberof! oj.ojCombobox
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Initialize the Combobox with the <code class="prettyprint">multiple</code> option specified:</caption>
       * $( ".selector" ).ojCombobox( { "multiple": true } );
       */
      multiple : false,
      
      /**
       * The option items for the Combobox. Instead of providing the option items in a datalist, they can be specified as an array of objects containing value and label.
       * The value is used as the value of the option item and label as the label. Both should be of string type. Group data can be provided with label and a children 
       * array containing the option items. Option item can be set as disabled.
       *
       * @expose
       * @memberof! oj.ojCombobox
       * @instance
       * @type {Array}
       *
       * @example <caption>Initialize the Combobox with the <code class="prettyprint">options</code> specified:</caption>
       * $( ".selector" ).ojCombobox( { "options": [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2', disabled: true}, {value: 'option3', label: 'option3'}] } );
       * @example <caption>Initialize the Combobox with group data:</caption>
       * $( ".selector" ).ojCombobox( { "options": [{label : 'group1', children: [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2'}]}, {label: 'group2', children: [{value: 'option3', label: 'option3'}]} ] } );
       */
      options : null,
      
      /**
       * Specify the key names to use in the options array.
       *
       * @expose
       * @memberof! oj.ojCombobox
       * @instance
       * @type {Object}
       *
       * @example <caption>Initialize the Combobox with <code class="prettyprint">optionsKeys</code> specified. This allows the key names to be redefined in the options array.</caption>
       * $( ".selector" ).ojCombobox( { "optionsKeys": {value : "state_abbr", label : "state_name"} } );
       * @example <caption>Redefine keys for data with subgroups.</caption>
       * $( ".selector" ).ojCombobox( { "optionsKeys": {label : "regions", children : "states", childKeys : {value : "state_abbr", label : "state_name"}} } );
       */
      optionsKeys : null,
      
      /**
       * Triggered immediately before the combobox drop down is expanded. 
       *
       * @expose
       * @event
       * @memberof! oj.ojCombobox
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       *
       * @example <caption>Initialize the Combobox with the <code class="prettyprint">beforeExpand</code> callback specified:</caption>
       * $( ".selector" ).ojCombobox({
       *     "beforeExpand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeexpand</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeexpand", function( event, ui ) {} );
       */
      beforeExpand : null

      /** 
       * The value of the combobox. The type of value should be either string or array. 
       * If array is used for single-select, then always first element of the array will be used to select option item.
       * 
       * Note:  <code class="prettyprint">value</code> option can only be bind to a knockout observableArray. 
       * 
       * @example <caption>Initialize the combobox with the <code class="prettyprint">value</code> option specified:</caption>
       * $(".selector").ojCombobox({'value': "option1,option2"});<br/>
       * 
       * @example <caption>Initialize the combobox with the <code class="prettyprint">value</code> option specified as Array for selecting multiple items:</caption>
       * $(".selector").ojCombobox({'value': ["option1", "option2"]});<br/>
       * @example <caption>Get or set the <code class="prettyprint">value</code> option, after initialization:</caption>
       * // Getter: returns value
       * $(".selector").ojCombobox("option", "value");
       * // Setter: sets value with array containing "option1" and "option2"
       * $(".selector").ojCombobox("option", "value", ["option1", "option2"]);
       * // Setter: sets value with string "option1"
       * $(".selector").ojCombobox("option", "value", "option1"); 
       * // Setter: sets comma string of seperated values
       * $(".selector").ojCombobox("option", "value", "option1,option2"]);
       * 
       * @member 
       * @name  value
       * @access public
       * @instance
       * @default When the option is not set, the element's value property is used as its initial value 
       * if it exists. 
       * @memberof! oj.ojCombobox
       * @type {string|Array}
       */

    },

    /**
     * Returns a jQuery object containing the element visually representing the combobox.
     *
     * <p>This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojCombobox
     * @instance
     * @return {jQuery} the combobox
     */
    widget : function ()
    {
      return this.combobox.container;
    },

    /**
     * @override
     * @private
     */
    _ComponentCreate : function ()
    {
      this._super();
      this._setup();
    },

    _InitOptions : function (originalDefaults, constructorOptions)
    {
      var props = [{"attribute": "disabled", "defaultOptionValue": null, "validateOption": true},
                   {"attribute": "placeholder", "defaultOptionValue": ""},
                   {"attribute": "required", "defaultOptionValue": false, 
                    "coerceDomValue": true, "validateOption": true},
                   {"attribute": "title", "defaultOptionValue": ""}
                   // {"attribute": "value", "defaultOptionValue": null}
                 ]; 
    
      this._super(originalDefaults, constructorOptions);
      oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);  

      // TODO: PAVI - Let's discuss
      if (this.options['value'] === undefined) {
          this.options['value'] = (this.element.attr('value') !== undefined) ? _ComboUtils.splitVal(this.element.val(), ",") : null;
      } else {
          //clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
          //TODO: Need to revisit this once 18724975 is fixed.
          var value = this.options['value'];
          if (Array.isArray(value)) {
              value = value.slice(0);
          } else if(typeof value === "string") {
              value = _ComboUtils.splitVal(value, ","); 
          }
          this.options['value'] = value;
      }
    },

    _setup : function ()
    {
      var opts,
      multiple = this.options.multiple;
      opts = {};
      opts.element = this.element;
      opts.ojContext = this;
      opts = $.extend(this.options, opts);

      this.combobox = multiple ? new _OjMultiCombobox() : new _OjSingleCombobox();

      this.combobox._init(opts);
    },

    /**
     * @override
     * @private
     */
    _destroy : function ()
    {
      this.combobox._destroy();
    },
    
    /**
     * Refreshes the combobox.
     *
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojCombobox
     * @instance
     */
    refresh : function ()
    {
      this._super();

      this.combobox._destroy();
      this._setup();
    },

    /**
     * Handles options specific to combobox.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
    _setOption : function (key, value, flags)
    {
      if (key === "value") {
          //clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
          //TODO: Need to revisit this once 18724975 is fixed.
          if (Array.isArray(value)) {
              value = value.slice(0);
          } 
          else if(typeof value === "string") {
              value = _ComboUtils.splitVal(value, ",") ;
          }
      }
      this._super(key, value, flags);  
      
      if (key === "options")
        this.refresh();
        
      if (key === "disabled")
      {
        if (value)
          this.combobox._disable();
        else
          this.combobox._enable();
      }
    },
    
    /**
     * Updates display value of combobox.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
    _SetDisplayValue: function(displayValue)
    {
      this.combobox._initSelection();
    },
    
    /**
     * Set the placeholder.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
    _SetPlaceholder : function(value)
    {
      if (this.combobox) 
      {
        this.combobox.opts.placeholder = value;
        // TODO: pavitra - noticed that some combobox tests fail because the _setPlaceholder is 
        // undefined, when this method is called from _AfterCreate().
        if (this.combobox._setPlaceholder) 
        {
          this.combobox._setPlaceholder();
        }
      }
    },
    
    /**
     * Validates the component's value using the converter and all validators registered on 
     * the component. 
     * @expose 
     * @override
     * @memberof! oj.ojCombobox
     */
    validate : function ()
    {
      if (this.combobox)
        return this._SetValue(this.combobox.getVal(), null, this._VALIDATE_METHOD_OPTIONS);
    },
    
    /**
     * Returns the messaging launcher element  i.e., where user sets focus that triggers the popup. 
     * Usually this is the element input or select that will receive focus and on which the popup 
     * for messaging is initialized. 
     *
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     * @return {Object} jquery element which represents the messaging launcher component
     */
    _GetMessagingLauncherElement : function ()
    {
      return this.combobox.search;
    }, 
    
    /**
     * Returns the jquery element that represents the content part of the component.
     * This is usually the component that user sets focus on (tabindex is set 0) and 
     * where aria attributes like aria-required, aria-labeledby etc. are set. This is
     * also the element where the new value is updated. Usually this is the same as
     * the _GetMessagingLauncherElement.
     *
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     * @return {Object} jquery element which represents the content.
     */
    _GetContentElement : function ()
    {
      return this.combobox.search;
    },      
    
    /**
     * Returns the default styleclass for the component.
     * 
     * @return {string}
     * @expose
     * @memberof! oj.ojCombobox
     * @override
     * @protected
     */
    _GetDefaultStyleClass : function ()
    {
    return "oj-combobox";
    },
    
    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     * Test authors should target sub elements using the following names:
     * <ul>
     * <li><b>oj-combobox-input</b>: the input field </li>
     * <li><b>oj-combobox-arrow</b>: the drop down arrow for single-select combobox </li>
     * <li><b>oj-combobox-drop</b>: the drop down box </li>
     * <li><b>oj-combobox-results</b>: the filtered result list in the rop down</li>
     * <li><b>oj-combobox-selection</b>: the selected choices for multi-select combobox</li>
     * </ul>
     * @expose
     * @memberof! oj.ojCombobox
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      var node = null, subId;
	    if (locator == null)
	    {
        return this.combobox.container ? this.combobox.container[0] : null;
	    }
      else
      {
        node = this._super(locator);
      }
	    
      if (!node)
      {
        subId = locator['subId'];
        if (subId === "oj-combobox-drop")
          subId = "oj-listbox-drop";

        if (subId === "oj-combobox-results")
          subId = "oj-listbox-results";
          
        if (subId === "oj-combobox-selection")
          subId = "oj-combobox-selected-choice";

        switch (subId)
        {
          case "oj-combobox-input":
          case "oj-combobox-arrow":
          case "oj-listbox-drop":
          case "oj-listbox-results":
            node = this.widget().find("." + subId)[0];
            break;
          case "oj-combobox-selected-choice":
            node = this.widget().find("." + subId);
            break;
        }    
	    }

	    // Non-null locators have to be handled by the component subclasses
	    return node || null;
    }

  });
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

  /**
   * @class
   * @name oj.ojSelect
   * @augments oj.editableValue
   * @since 0.6
   *
   * @classdesc
   * <h3 id="selectOverview-section">
   *   JET Select Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectOverview-section"></a>
   * </h3>
   *
   * <p>Description: JET Select enhances a html select and option elements into a Select that supports
   * single-select and search filtering. Note: Muliple selection is not supported in V1.
   *
   * <p>A JET Select can be created with the following markup. By default, it creates a single-select
   * Select. 
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;select data-bind="ojComponent: {component: 'ojSelect'}">
   *     &lt;option value="option 1">option 1&lt;/option>
   *     &lt;option value="option 2">option 2&lt;/option>
   *     &lt;option value="option 3">option 3&lt;/option>
   *     &lt;option value="option 4">option 4&lt;/option>
   * &lt;/select>
   * </code></pre>
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * <p>
   * <h5>When the focus is in the select element</h5>
   * </p>
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Use</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td> Select the highlighted choice.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow or DownArrow</kbd></td>
   *       <td> Highlight the option item on the drop down list in the direction of the arrow.
   *         If the drop down is not open, expand the drop down list.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
   *     </tr>
   *
   *   </tbody>
   *  </table>
   *
   * <p>Disabled option items receive no highlight and are not selectable.
   *
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the Select must be <code class="prettyprint">refresh()</code>ed.
   *
   *
   * <h3 id="pseudos-section">
   *   Pseudo-selectors
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
   * </h3>
   *
   * <p>The <code class="prettyprint">:oj-select</code> pseudo-selector can be used in jQuery expressions to select JET Select.  For example:
   *
   * <pre class="prettyprint">
   * <code>$( ":oj-select" ) // selects all JET Select on the page
   * $myEventTarget.closest( ":oj-select" ) // selects the closest ancestor that is a JET Select
   * </code></pre>
   *
  * <h3 id="a11y-section">
  *   Accessibility
  *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
  * </h3>
  * <p>
  * It is up to the application developer to associate the label to the select component.
  * For select, you should put an <code>id</code> on the select, and then set 
  * the <code>for</code> attribute on the label to be the select's id.
  * </p>
  * <h3 id="label-section">
  *   Label and Select
  *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
  * </h3>
  * <p>
  * For accessibility, you should associate a label element with the select
  * by putting an <code>id</code> on the select, and then setting the 
  * <code>for</code> attribute on the label to be the select's id.
  * </p>
  * <p>
  * The component will decorate its associated label with required and help 
  * information, if the <code>required</code> and <code>help</code> options are set. 
  * </p>
   * <h3 id="jqui2jet-section">
   *   JET for jQuery UI developers
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
   * </h3>
   *
   * <p>Event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "Select".
   *
   * @desc Creates a JET Select.
   * @example <caption>Initialize the Select with no options specified:</caption>
   * $( ".selector" ).ojSelect();
   *
   * @example <caption>Initialize the Select with some options:</caption>
   * $( ".selector" ).ojSelect( { "placeholder": "Select a value." } );
   *
   * @example <caption>Initialize the Select via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
   * &lt;div id="select" data-bind="ojComponent: { component: 'ojSelect' }">
   */
  oj.__registerWidget("oj.ojSelect", $['oj']['editableValue'],
  {
    defaultElement : "<select>",
    widgetEventPrefix : "oj",
    options :
    {
      /**
       * The threshold for showing the search box in the dropdown when it's expanded.
       * The search box is always displayed when the results size is greater than
       * the threshold, otherwise the search box is initially turned off.
       * However, the search box is displayed as soon as the user starts typing.
       * This property only applies to single-select.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {number}
       * @default <code class="prettyprint">10</code>
       */
      minimumResultsForSearch : 10,
      
    
      /**
       * The placeholder text to set on the element.<p>
       * If the <code class="prettyprint">placeholder</code> option is specified to a string, ojselect will adds a placeholder item at the beginning of the dropdown list with
       *<ul>
       *<li>displayValue: placeholder text</li>
       *<li>value: an empty string</li>
       *</ul>
       * The placeholder item in the dropdown is selectable. However, it's not a valid choice, i.e. validation will fail if the select component is a required field.<p>
       * The placeholder item doesn't participate in the filtering, so it will not appear in the result list with a filter specified.<p>
       * Placeholder text can be an empty string, please see the select placeholder cookbook demo.
       * 
       * @example <caption>Initialize the select with the <code class="prettyprint">placeholder</code> option specified:</caption>
       * $( ".selector" ).ojSelect( { "placeholder": "Please select ..." } );
       * 
       * @default <code class="prettyprint">undefined</code>
       * 
       * @expose 
       * @access public
       * @instance
       * @memberof! oj.ojSelect
       * @type {string|null|undefined}
       */    
      placeholder: undefined,
      
      /**
       * If multi-select is enabled for the select.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">multiple</code> option specified:</caption>
       * $( ".selector" ).ojSelect( { "multiple": true } );

      multiple: false,
       */

      /**
       * The option items for the Select. Instead of providing a list of option items, they can be specified as an array of objects containing value and label.
       * The value is used as the value of the option item and label as the label.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {Array}
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">options</code> option specified:</caption>
       * $( ".selector" ).ojSelect( { "options": [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2'}, {value: 'option3', label: 'option3'},] } );
        * @example <caption>Initialize the Select with group data:</caption>
       * $( ".selector" ).ojSelect( { "options": [{label : 'group1', children: [{value: 'option1', label: 'option1'}, {value: 'option2', label: 'option2'}]}, {label: 'group2', children: [{value: 'option3', label: 'option3'}]} ] } );
       */
      options : null,
      
      /**
       * Specify the key names to use in the options array.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {Object}
       *
       * @example <caption>Initialize the Select with <code class="prettyprint">optionsKeys</code> specified. This allows the key names to be redefined in the options array.</caption>
       * $( ".selector" ).ojSelect( { "optionsKeys": {value : "state_abbr", label : "state_name"} } );
       * @example <caption>Redefine keys for data with subgroups.</caption>
       * $( ".selector" ).ojSelect( { "optionsKeys": {label : "regions", children : "states", childKeys : {value : "state_abbr", label : "state_name"}} } );
       */
      optionsKeys : null,

      /**
       * Triggered immediately before the Select drop down is expanded. 
       *
       * @expose
       * @event
       * @memberof! oj.ojSelect
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">beforeExpand</code> callback specified:</caption>
       * $( ".selector" ).ojSelect({
       *     "beforeExpand": function( event ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeexpand</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeexpand", function( event, ui ) {} );
       */
      beforeExpand : null

      /** 
       * The value of the select component. The data type of value is array. Only the first element of the array is used.
       * 
       * Note:  <code class="prettyprint">value</code> option can only be bind to a knockout observableArray. 
       * 
       * @example <caption>Initialize the select with the <code class="prettyprint">value</code> option specified:</caption>
       * $(".selector").ojSelect({"value": ["option1"]});<br/>
       * 
       * @example <caption>Get or set the <code class="prettyprint">value</code> option, after initialization:</caption>
       * // Getter: returns value
       * $(".selector").ojSelect("option", "value");
       * // Setter: sets value with array containing "option1"
       * $(".selector").ojSelect("option", "value", ["option1"]);
       * 
       * @member 
       * @name  value
       * @access public
       * @instance
       * @default When the value option is not set, the first option is used as its initial value if it exists. 
       * @memberof! oj.ojSelect
       * @type {Array}
       */
    },

    /**
     * Returns a jQuery object containing the element visually representing the select.
     *
     * <p>This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     * @return {jQuery} the select
     */
    widget : function ()
    {
      return this.select.container;
    },

    /**
     * @override
     * @private
     * @memberof! oj.ojSelect
     */
    _ComponentCreate : function ()
    {
      this._super();
      this._setup();
    },

    //ojselect
    _setup : function ()
    {
      var opts = {};
      opts.element = this.element;
      opts.ojContext = this;
      opts = $.extend(this.options, opts);

      this.select = new _OjSingleSelect();
      this.select._init(opts);
    },

    /**
     * Refreshes the visual state of the select. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is programmatically changed underneath the component.
     *
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojSelect
     * @instance
     */
    refresh : function ()
    {
      this._super();

      this.select._destroy();
      this._setup();
      //TODO: apply value in options for the selected value
    },

    /**
     * @override
     * @private
     * @memberof! oj.ojSelect
     */
    _destroy : function ()
    {
      this.select._destroy();
    },

    /**
     * Expands the drop down list.
     *
     * This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojSelect
     * @instance

    expand : function ()
    {
      this.select.open();
    },
     */
    /**
     * Collapses the drop down list.
     *
     * This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojSelect
     * @instance

    collapse : function ()
    {
      this.select.close();
    },
     */

    /**
     * Sets the placeholder text on the content element by default. It sets the placeholder attribute
     * on the element. Component subclasses can override this method to control where placeholder text
     * gets set.
     * @param {string} value
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     * @override
     */
    _SetPlaceholder : function(value)
    {
      /*
       * Commented out the content to fix the side effect from 
       * the change made in EditableValue._initComponentMessaging (Revision: 9016).
       * EditableValue called SetPlaceholder with an empty string which made
       * every ojselect to have an empty placeholder in the dropdown.
       * Note: don't remove the method because there is more calls from EditableValue
       * to ojselect before this.select is initialized.
       * ex: _GetContentElement

      if (this.select) 
      {
        this.select.opts.placeholder = value;
        this.select._setPlaceholder();
      }
      */
    },

    /**
     * whether the placeholder option is set
     * 
     * @memberof! oj.ojSelect
     * @instance
     * @protected
     */
    _HasPlaceholderSet : function()
    {
      //Bug 18926010 - an empty placeholder shows up if data changed after first binding 
      return typeof this.options['placeholder'] === 'string';
    },

    /**
     * Clear the placeholder option
     * 
     * @memberof! oj.ojSelect
     * @instance
     * @protected
     */
    _ClearPlaceholder : function()
    {
      //Bug 18926010 - an empty placeholder shows up if data changed after first binding 
      this._SetPlaceholderOption(null);
      this._SetPlaceholder(null);
    },

    //ojselect
    _InitOptions : function (originalDefaults, constructorOptions)
    {
      var props = [{"attribute": "disabled", "defaultOptionValue": null, "validateOption": true},
                   {"attribute": "placeholder", "defaultOptionValue": null},
                   {"attribute": "required", "defaultOptionValue": false, 
                    "coerceDomValue": true, "validateOption": true},
                   {"attribute": "title", "defaultOptionValue": ""}
                   // {"attribute": "value", "defaultOptionValue": null}
                 ]; 
    
      this._super(originalDefaults, constructorOptions);
      oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);  

      // TODO: PAVI - Let's discuss
      if (this.options['value'] === undefined) {
        this.options['value'] = (this.element.attr('value') !== undefined) ? _ComboUtils.splitVal(this.element.val(), ",") : null;
      }
      else {
        //clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
        //TODO: Need to revisit this once 18724975 is fixed.
        var value = this.options['value'];
        if (Array.isArray(value)) {
          value = value.slice(0);
        }
/*
        else if(typeof value ==='string') {
          value = [value];
        }
*/
        this.options['value'] = value;
      }
    },
    
    /**
     * @override
     * @memberof! oj.ojSelect
     */
    validate : function ()
    {
      //Bug 19231311 - select needs implementation fixes...
      return this._SetValue(this.select.getVal(), null, this._VALIDATE_METHOD_OPTIONS);
    },
  
     /**
     * Updates display value.
     * @override
     * @protected
     * @memberof! oj.ojSelect
     */
    _SetDisplayValue: function(displayValue)
    {
      this.select._initSelection();
    },

    /**
     * Handles options specific to select.
     * @override
     * @protected
     * @memberof! oj.ojSelect
     */
    _setOption : function (key, value, flags)
    {
      if (key === "value") {
        //clone the value, otherwise _setDisplayValue will not be invoked on binding value to ko observableArray.
        //TODO: Need to revisit this once 18724975 is fixed.
        //TODO: Need to validate value (bug 19074312)
        if (Array.isArray(value)) {
          value = value.slice(0);
        }
/*
        else if (typeof value === 'string') {
          value = [value];
        }
*/
      }
      else if (key === "placeholder")
      {
        this.select.opts.placeholder = value;
        this.select._setPlaceholder();
      }

      else if (key === "minimumResultsForSearch")
      {
        this.select.opts.minimumResultsForSearch = value;
      }

      this._super(key, value, flags);

      if (key === "disabled")
      {
        if (value)
          this.select._disable();
        else
          this.select._enable();
      }
      else if (key === "options")
      {
        //Bug 18926010 - an empty placeholder shows up if data changed after first binding
        //TODO: when options change, should we clear the value in case it becomes invalid??
        this._setup();
      }
    },

    _getDropdown : function ()
    {
      if (this.select && this.select._opened())
      {
        var dropdown = $(".oj-listbox-drop");
        if (dropdown.attr("id") == "oj-listbox-drop" &&
            dropdown.attr(oj.DomUtils.SURROGATE_ID) == this.select.containerId)
          return dropdown;
      }
      return null;
    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     * Test authors should target sub elements using the following names:
     * <ul>
     * <li><b>oj-select-chosen</b>: the selected text in the select box</li>
     * <li><b>oj-select-search</b>: the search box. Note the searchbox is not always visible</li>
     * <li><b>oj-listbox-input</b>: the search input. Note the search input is not always visible</li>
     * <li><b>oj-select-drop</b>: the drop down box </li>
     * <li><b>oj-select-results</b>: the filtered result list </li>
     * <li><b>oj-listbox-result-label</b>: the filtered result item</li>
     * </ul>
     *
     * Note: To lookup a filtered result item, the dropdown must be open and
     *       the locator object should have the following:<p>
     *          subId: 'oj-listbox-result-label' and 
     *          index: number
     *
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      var node = null, subId;
      if (locator == null)
      {
        return this.select.container ? this.select.container[0] : null;
      }
      else
      {
        node = this._super(locator);
      }
	    
      if (!node)
      {
        subId = locator['subId'];
        if (subId === "oj-select-drop")
          subId = "oj-listbox-drop";

        if (subId === "oj-select-results")
          subId = "oj-listbox-results";

        if (subId === "oj-select-search")
          subId = "oj-listbox-search";

        switch (subId) {
          case "oj-select-choice":
          case "oj-select-chosen":
            node =  this.widget().find("." + subId)[0];
            break;

          case "oj-listbox-drop":
            var dropdown = this._getDropdown();
            if (dropdown) {
              node = dropdown[0];
            }
            break;

          case "oj-listbox-input":
          case "oj-listbox-search":
          case "oj-listbox-results":
            var dropdown = this._getDropdown();
            if (dropdown) {
              node = dropdown.find("." + subId)[0];
            }
            break;

          //Bug 18872085 - ojselect - not able to attach id for generated jet component
          case "oj-listbox-result-label":
            if (this._getDropdown())
            {
              //list of 'li'
              var ddlist =  $("#" + this.select.results.attr("id")).children();
              var index = locator['index'];

              if (ddlist.length && index < ddlist.length) {
                node = ddlist.eq(index).find("." + subId)[0];
              }
            }
            break;
        }
      }
      // Non-null locators have to be handled by the component subclasses
      return node || null;
    },

    /**
     * Returns the default styleclass for the component. Currently this is 
     * used to pass to the _ojLabel component, which will append -label and 
     * add the style class onto the label. This way we can style the label
     * specific to the input component. For example, for inline labels, the
     * radioset/checkboxset components need to have margin-top:0, whereas all the
     * other inputs need it to be .5em. So we'll have a special margin-top style 
     * for .oj-label-inline.oj-radioset-label
     * All input components must override
     * 
     * @return {string}
     * @expose
     * @memberof! oj.ojSelect
     * @override
     * @protected
     */
    _GetDefaultStyleClass : function ()
    {
      return "oj-select";
    },

    /**
     * Returns the messaging launcher element i.e., where user sets focus that triggers the popup. 
     * Usually this is the element input or select that will receive focus and on which the popup 
     * for messaging is initialized. 
     *
     * @override
     * @protected
     * @memberof! oj.ojSelect
     * @return {Object} jquery element which represents the messaging launcher component
     */
    _GetMessagingLauncherElement : function ()
    {
      return this.select.selection;
    },
    
    /**
     * Returns the jquery element that represents the content part of the component.
     * This is usually the component that user sets focus on (tabindex is set 0) and 
     * where aria attributes like aria-required, aria-labeledby etc. are set. This is
     * also the element where the new value is updated. Usually this is the same as
     * the _GetMessagingLauncherElement.
     *
     * @override
     * @protected
     * @memberof! oj.ojSelect
     * @return {Object} jquery element which represents the content.
     */
    _GetContentElement : function ()
    {
      return this.select.selection;
    }

  }
  );


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2012 Igor Vaynberg
 *
 * This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 * General Public License version 2 (the "GPL License"). You may choose either license to govern your
 * use of this software only upon the condition that you accept all of the terms of either the Apache
 * License or the GPL License.
 * 
 * You may obtain a copy of the Apache License and the GPL License at:
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * http://www.gnu.org/licenses/gpl-2.0.html
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 * the specific language governing permissions and limitations under the Apache License and the GPL License.
 */
/**
 * @private
 */
  var _OjMultiCombobox = _ComboUtils.clazz(_AbstractOjChoice,
    {
      _elemNm : "ojcombobox",
      _classNm : "oj-combobox",

      _createContainer : function ()
      {
        //@HTMLUpdateOK
        var container = $(document.createElement("div")).attr(
          {
            "class" : "oj-combobox oj-combobox-multi oj-component"
          }
          ).html([
              "<ul class='oj-combobox-choices'>",
              "  <li class='oj-combobox-search-field'>",
              "    <input type='text' role='combobox' aria-expanded='false' aria-autocomplete='list' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='oj-combobox-input'>",
              "  </li>",
              "</ul>",
              "<div class='oj-combobox-description oj-helper-hidden-accessible'/>",
              "<div class='oj-listbox-drop oj-listbox-drop-multi' style='display:none'>",
              "   <ul class='oj-listbox-results' role='listbox'>",
              "   </ul>",
              "</div>"].join(""));
        return container;
      },
      
      _prepareOpts : function ()
      {
        var opts = _OjMultiCombobox.superclass._prepareOpts.apply(this, arguments),
        self = this;

        if (opts.element.get(0).tagName.toLowerCase() === "input" && opts.element.attr("list"))
        {
          // install the selection initializer
          opts.initSelection = function (element, callback)
          {
            var data = [];
            if (self.getVal() && self.getVal().length)
            {
              var selected;
              var ids = self.getVal();
              for (var i = 0; i < ids.length; i++)
              {
                var id = ids[i];
                selected = element.find("option").filter(function ()
                  {
                    return this.value === id;
                  }
                  );
                if(selected && selected.length)
                {
                    data.push(self._optionToData(selected));  
                }else{
                   // If user entered value which is not listed in predefiend options
                  data.push({'value':id,'label':id});  
                }
                
              }
            }
            else
            {
              var selected;
              selected = element.find("option").filter(function ()
                {
                  return this.selected
                }
                );
              _ComboUtils.each2(selected, function (i, elm)
              {
                data.push(self._optionToData(elm));
              }
              );
            }
            callback(data);
          };
        }
        else if ("options" in opts)
        {
          // install default initSelection when applied to hidden input and data is local
          opts.initSelection = opts.initSelection || function (element, callback)
          {
            var ids = self.getVal();
            //search in data by array of ids, storing matching items in a list
            var matches = [];
            opts.query(
            {
              matcher : function (term, text, el)
              {
                var is_match = $.grep(ids, function (id)
                  {
                    return id === opts.id(el);
                  }
                  ).length;
                if (is_match)
                {
                  matches.push(el);
                }
                return is_match;
              },
              callback : !$.isFunction(callback) ? $.noop : function ()
              {
                // reorder matches based on the order they appear in the ids array because right now
                // they are in the order in which they appear in data array
                var ordered = [];
                for (var i = 0; i < ids.length; i++)
                {
                  var id = ids[i];
                  var found = false;
                  for (var j = 0; j < matches.length; j++)
                  {
                    var match = matches[j];
                    if (id === opts.id(match))
                    {
                      ordered.push(match);
                      matches.splice(j, 1);
                      found = true;
                      break;
                    }
                  }
                  if(!found){
                    //If user entered value which is not listed in predefiend options
                    ordered.push({'value':id,'label':id});
                  }
                }
                callback(ordered);
              }
            }
            );
          };
        }
        return opts;
      },
      
      _selectChoice : function (choice)
      {
        var selected = this.container.find("." + this._classNm + "-selected-choice.oj-focus");
        if (selected.length && choice && choice[0] == selected[0])
        {}

        else
        {
          if (selected.length)
          {
            this.opts.element.trigger("choice-deselected", selected);
          }
          selected.removeClass("oj-focus");
          if (choice && choice.length)
          {
            this.close();
            choice.addClass("oj-focus");
            this.container.find(".oj-combobox-description").text(choice.attr("valueText") + ". Press back space to delete.")
            .attr("aria-live", "assertive");
            this.opts.element.trigger("choice-selected", choice);
          }
        }
      },
      
      _destroy : function ()
      {
        $("label[for='" + this.search.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
        _OjMultiCombobox.superclass._destroy.apply(this, arguments);
      },

      _initContainer : function ()
      {
        var selector = "." + this._classNm + "-choices",
        selection,
        idSuffix = _ComboUtils.nextUid(),
        elementLabel;

        this.searchContainer = this.container.find("." + this._classNm + "-search-field");
        this.selection = selection = this.container.find(selector);

        var _this = this;
        this.selection.on("click", "." + this._classNm + "-selected-choice:not(." + this._classNm + "-locked)", function (e)
        {
          _this.search[0].focus(); //Fixed??
          _this._selectChoice($(this));
        }
        );

        elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
        if (!elementLabel.attr("id"))
          elementLabel.attr('id', this._classNm + "-label-" + idSuffix);

        // add aria associations
        selection.find("." + this._classNm + "-input").attr("id", this._classNm + "-input-" + idSuffix);
        this.results.attr("id", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-owns", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-labelledby", elementLabel.attr("id"));

        this.search.on("input paste", this._bind(function ()
          {
            if (!this._isInterfaceEnabled())
              return;
            if (!this._opened())
            {
              this.open();
            }
          }
          ));

        this.search.attr("tabindex", this.elementTabIndex);
        this.keydowns = 0;
        this.search.on("keydown", this._bind(function (e)
          {
            if (!this._isInterfaceEnabled())
              return;

            ++this.keydowns;
            var selected = selection.find("." + this._classNm + "-selected-choice.oj-focus");
            var prev = selected.prev("." + this._classNm + "-selected-choice:not(." + this._classNm + "-locked)");
            var next = selected.next("." + this._classNm + "-selected-choice:not(." + this._classNm + "-locked)");
            var pos = _ComboUtils.getCursorInfo(this.search);

            if (selected.length &&
              (e.which == _ComboUtils.KEY.LEFT || e.which == _ComboUtils.KEY.RIGHT || e.which == _ComboUtils.KEY.BACKSPACE || e.which == _ComboUtils.KEY.DELETE || e.which == _ComboUtils.KEY.ENTER))
            {
              var selectedChoice = selected;
              if (e.which == _ComboUtils.KEY.LEFT && prev.length)
              {
                selectedChoice = prev;
              }
              else if (e.which == _ComboUtils.KEY.RIGHT)
              {
                selectedChoice = next.length ? next : null;
              }
              else if (e.which === _ComboUtils.KEY.BACKSPACE)
              {
                this._unselect(selected.first(), e);
                this.search.width(10);
                selectedChoice = prev.length ? prev : next;
              }
              else if (e.which == _ComboUtils.KEY.DELETE)
              {
                this._unselect(selected.first(), e);
                this.search.width(10);
                selectedChoice = next.length ? next : null;
              }
              else if (e.which == _ComboUtils.KEY.ENTER)
              {
                selectedChoice = null;
              }

              this._selectChoice(selectedChoice);
              _ComboUtils.killEvent(e);
              if (!selectedChoice || !selectedChoice.length)
              {
                this.open();
              }
              return;
            }
            else if (((e.which === _ComboUtils.KEY.BACKSPACE && this.keydowns == 1)
                 || e.which == _ComboUtils.KEY.LEFT) && (pos.offset == 0 && !pos.length))
            {
              this._selectChoice(selection.find("." + this._classNm + "-selected-choice:not(." + this._classNm + "-locked)").last());
              _ComboUtils.killEvent(e);
              return;
            }
            else
            {
              this._selectChoice(null);
            }

            if (this._opened())
            {
              switch (e.which)
              {
              case _ComboUtils.KEY.UP:
              case _ComboUtils.KEY.DOWN:
                this._moveHighlight((e.which === _ComboUtils.KEY.UP) ? -1 : 1);
                _ComboUtils.killEvent(e);
                return;
              case _ComboUtils.KEY.ENTER:
                this._selectHighlighted(null, e);
                _ComboUtils.killEvent(e);
                return;
              case _ComboUtils.KEY.TAB:
                this.close(e);
                return;
              case _ComboUtils.KEY.ESC:
                this._cancel(e);
                _ComboUtils.killEvent(e);
                return;
              }
            }

            if (e.which === _ComboUtils.KEY.TAB || _ComboUtils.KEY.isControl(e) || _ComboUtils.KEY.isFunctionKey(e)
               || e.which === _ComboUtils.KEY.BACKSPACE || e.which === _ComboUtils.KEY.ESC)
            {
              return;
            }

            if (e.which === _ComboUtils.KEY.ENTER)
            {
              if (this.opts.openOnEnter === false)
              {
                return;
              }
              else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey)
              {
                return;
              }
            }

            this.open();

            if (e.which === _ComboUtils.KEY.PAGE_UP || e.which === _ComboUtils.KEY.PAGE_DOWN)
            {
              // prevent the page from scrolling
              _ComboUtils.killEvent(e);
            }

            if (e.which === _ComboUtils.KEY.ENTER)
            {
              // prevent form from being submitted
              _ComboUtils.killEvent(e);
            }

          }
          ));

        this.search.on("keyup", this._bind(function (e)
          {
            this.keydowns = 0;
          }
          ));

        this.search.on("blur", this._bind(function (e)
          {
            if (this.opts["manageNewEntry"] && this.search.val() && (this.results.children().length <= 0)) {
              var data = this.opts["manageNewEntry"](this.search.val());
              this._onSelect(data, null, e);
            }
            this.search.removeClass(this._classNm + "-focused");
            this._selectChoice(null);
            if (!this._opened())
              this._clearSearch();
            e.stopImmediatePropagation();
          }
          ));

        this.container.on("click", selector, this._bind(function (e)
          {
            if (!this._isInterfaceEnabled())
              return;
            if ($(e.target).closest("." + this._classNm + "-selected-choice").length > 0)
            {
              // clicked inside a oj-combobox selected choice, do not open
              return;
            }
            this._selectChoice(null);
            this.open();
            this._focusSearch();
            e.preventDefault();
          }
          ));

        this.container.on("focus", selector, this._bind(function ()
          {
            if (!this._isInterfaceEnabled())
              return;
          }
          ));

        this._initContainerWidth();
        this.opts.element.hide()
                  .attr("aria-hidden", true);

        // set the placeholder if necessary
        this._clearSearch();
      },
      
      _enableInterface : function ()
      {
        if (_OjMultiCombobox.superclass._enableInterface.apply(this, arguments))
        {
          this.search.prop("disabled", !this._isInterfaceEnabled());
        }
      },
      
      _initSelection : function ()
      {
        var data;
        if ((this.getVal() === null || this.getVal().length === 0) && this.opts.element.text() === "")
        {
          this._updateSelection([]);
          this.close();
          // set the placeholder if necessary
          this._clearSearch();
        }
        if (this.datalist || (this.getVal() !== null && this.getVal().length))
        {
          var self = this,
          element;
          if (this.datalist)
            element = this.datalist;
          else
            element = this.opts.element;
          this.opts.initSelection.call(null, element, function (data)
          {
            if (data !== undefined && data !== null)
            {
              self._updateSelection(data);
              self.close();
              // set the placeholder if necessary
              self._clearSearch();
            }
          }
          );
        }
      },
      
      _clearSearch : function ()
      {
        var placeholder = this._getPlaceholder(),
        maxWidth = this._getMaxSearchWidth();

        if (placeholder !== undefined && (!this.getVal() || this.getVal().length === 0))
        {
          this.search.attr("placeholder", placeholder);
          // stretch the search box to full width of the container so as much of the placeholder is visible as possible
          // we could call this._resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
          this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
        }
        else
        {
          this.search.attr("placeholder", "");
          this.search.val("").width(10);
        }
      },
      
      _opening : function (event)
      {
        //if beforeExpand is not cancelled
        if (this.ojContext._trigger("beforeExpand", event)) 
        {
          this._resizeSearch();
          _OjMultiCombobox.superclass._opening.apply(this, arguments);
          this._focusSearch();
          this._updateResults(true);
          this.search.focus();
        }
      },
      
      close : function (event)
      {
        if (!this._opened())
          return;
        _OjMultiCombobox.superclass.close.apply(this, arguments);
      },
      
      _focus : function ()
      {
        this.close();
        this.search.focus();
      },
      
      _updateSelection : function (data)
      {
        var ids = [],
        filtered = [],
        self = this;

        // filter out duplicates
        $(data).each(function ()
        {
          if (ids.indexOf(self.id(this)) < 0)
          {
            ids.push(self.id(this));
            filtered.push(this);
          }
        }
        );
        data = filtered;
        this.selection.find("." + this._classNm + "-selected-choice").remove();
        $(data).each(function ()
        {
          self._addSelectedChoice(this);
        }
        );
        self._postprocessResults();
      },
      
      _onSelect : function (data, options, event)
      {
        if (!this._triggerSelect(data))
        {
          return;
        }
        this._addSelectedChoice(data);
        var id = this.id(data);
        //Clone the value before invoking setVal(), otherwise it will not trigger change event.
        var val = this.getVal() ? this.getVal().slice(0) : [];
        
        // If the component is invalid, we will not get all the values matching the displayed value
        if (!this.ojContext.isValid())
          val = _ComboUtils.splitVal(this.opts.element.val(), this.opts.separator);
          
        $(data).each(function() {
            if (val.indexOf(id) < 0) {
                val.push(id);
            }
        });
        this.setVal(val, event);
        if (this.select || !this.opts.closeOnSelect)
          this._postprocessResults(data, false, this.opts.closeOnSelect === true);
        if (this.opts.closeOnSelect)
        {
          this.close(event);
          this.search.width(10);
        }
        
        if (!options || !options.noFocus)
          this._focusSearch();
      },
      
      _cancel : function (event)
      {
        this.close(event);
        this._focusSearch();
      },
      
      _addSelectedChoice : function (data)
      {
        var enableChoice = !data.locked,
        enabledItem = $(
            "<li class='" + this._classNm + "-selected-choice'>" +
            "    <div></div>" +
            "    <a href='#' onclick='return false;' class='" + this._classNm + "-clear-entry' tabindex='-1'>" +
            "    <span class='oj-component-icon oj-clickable-icon oj-combobox-clear-entry-icon' role='presentation'></a>" +
            "</li>"),
        disabledItem = $(
            //"<li class='oj-combobox-selected-choice oj-combobox-locked'>" +
            "<li class='" + this._classNm + "-selected-choice " + this._classNm + "-locked'>" +
            "<div></div>" +
            "</li>");
        var choice = enableChoice ? enabledItem : disabledItem,
        id = this.id(data),
        formatted;

        formatted = this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
        if (formatted !== undefined)
        {
          choice.find("div").replaceWith("<div class='" + this._classNm + "-selected-choice-label'>" + formatted + "</div>");
          choice.attr("valueText", formatted);
        }
        if (enableChoice)
        {
          choice.find("." + this._classNm + "-clear-entry")
          .on("mousedown", _ComboUtils.killEvent)
          .on("click dblclick", this._bind(function (e)
            {
              if (!this._isInterfaceEnabled())
                return;

              $(e.target).closest("." + this._classNm + "-selected-choice").fadeOut('fast', this._bind(function ()
                {
                  this._unselect($(e.target), e);
                  this.selection.find("." + this._classNm + "-selected-choice.oj-focus").removeClass("oj-focus");
                  this.close(e);
                  this._focusSearch();
                }
                )).dequeue();
              _ComboUtils.killEvent(e);
            }
            ));
        }
        choice.data(this._elemNm, data);
        choice.insertBefore(this.searchContainer);
        
      },
      
      _unselect : function (selected, event)
      {
        var val = this.getVal() ? this.getVal().slice(0) : [],
        data,
        index;
        selected = selected.closest("." + this._classNm + "-selected-choice");
          
        if (selected.length === 0)
        {
          //TODO: translation string
          throw "Invalid argument: " + selected + ". Must be ." + this._classNm + "-selected-choice";
        }
        data = selected.data(this._elemNm);
        if (!data)
        {
          // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
          // and invoked on an element already removed
          return;
        }
        
        // If the component is invalid, we will not get all the values matching the displayed value
        if (!this.ojContext.isValid())
          val = _ComboUtils.splitVal(this.opts.element.val(), this.opts.separator);
          
        while ((index = val.indexOf(this.id(data))) >= 0)
        {
          val.splice(index, 1);
          this.setVal(val, event);
          if (this.select)
            this._postprocessResults();
        }
        selected.remove();
      },
      
      _postprocessResults : function (data, initial, noHighlightUpdate)
      {
        var val = (this.getVal() &&  (this.opts.element.val() || this.ojContext.isValid())) ? this.getVal() : [],
        choices = this.results.find(".oj-listbox-result"),
        compound = this.results.find(".oj-listbox-result-with-children"),
        self = this;
          
        _ComboUtils.each2(choices, function (i, choice)
        {
          var id = self.id(choice.data(self._elemNm));
          if (val && val.indexOf(id) >= 0)
          {
            choice.addClass("oj-selected");
            // mark all children of the selected parent as selected
            choice.find(".oj-listbox-result-selectable").addClass("oj-selected");
          }
        }
        );
        _ComboUtils.each2(compound, function (i, choice)
        {
          // hide an optgroup if it doesnt have any selectable children
          if (!choice.is(".oj-listbox-result-selectable")
             && choice.find(".oj-listbox-result-selectable:not(.oj-selected)").length === 0)
          {
            choice.addClass("oj-selected");
          }
        }
        );
        
        if (!choices.filter('.oj-listbox-result:not(.oj-selected)').length > 0)
          this.close();
      },
      
      _getMaxSearchWidth : function ()
      {
        return this.selection.width() - _ComboUtils.getSideBorderPadding(this.search);
      },
      
      _textWidth : function (text) {
        var textSpan = '<span style="display:none">' + text + '</span>';
        $('body').append(textSpan);
        var width = $('body').find('span:last').width();
        $('body').find('span:last').remove();
        return width;
      },
      
      _resizeSearch : function ()
      {
        var minimumWidth,
        left,
        maxWidth,
        containerLeft,
        searchWidth,
        sideBorderPadding = _ComboUtils.getSideBorderPadding(this.search);

        minimumWidth = this._textWidth(this.search.val()) + 10;
        left = this.search.offset().left;
        maxWidth = this.selection.width();
        containerLeft = this.selection.offset().left;
        searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;
        if (searchWidth < minimumWidth)
        {
          searchWidth = maxWidth - sideBorderPadding;
        }
        if (searchWidth < 40)
        {
          searchWidth = maxWidth - sideBorderPadding;
        }
        if (searchWidth <= 0)
        {
          searchWidth = minimumWidth;
        }
        this.search.width(Math.floor(searchWidth));
      },

      setVal : function (val, event)
      {
        var unique;
        unique = [];
        
        if (typeof val === "string")
          val = _ComboUtils.splitVal(val, this.opts.separator);
        // filter out duplicates
        for(var i =0; i < val.length; i++)
        {
          if (unique.indexOf(val[i]) < 0)
            unique.push(val[i]);
        }
        
        this.ojContext._SetValue(unique, event, {doValueChangeCheck: false});
        this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
        
        this.search.attr("aria-activedescendant", this.opts.element.attr("id"));
      }
    }
    );


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */
 
/**
 * Shared for ojInputDate + ojInputTime
 * @ignore
 */
function disableEnableSpan(children, val) 
{
  var filteredChildren = children.filter("span");
  if (val)
  {
    filteredChildren.addClass("oj-disabled").removeClass("oj-enabled oj-default");
  }
  else 
  {
    filteredChildren.removeClass("oj-disabled").addClass("oj-enabled oj-default");
  }
}

/**
 * Copies time over from the from date to the to date. Used for ojtimepicker + ojdatetimepicker as well.
 */
function copyTimeOver(from, to)
{
  to.setHours(from.getHours());
  to.setMinutes(from.getMinutes());
  to.setSeconds(from.getSeconds());
  to.setMilliseconds(from.getMilliseconds());
  return to;
}

/**
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 * @ignore
 */
function bindHover(dpDiv)
{
  var selector = ".oj-datepicker-prev-icon, .oj-datepicker-prev-icon .oj-clickable-icon.oj-component-icon, .oj-datepicker-next-icon, .oj-datepicker-next-icon .oj-clickable-icon.oj-component-icon, .oj-datepicker-calendar td a";
  return dpDiv.delegate(selector, "mouseout", function ()
  {
    $(this).removeClass("oj-hover");
  }).delegate(selector, "mouseover", function ()
  {
    $(this).addClass("oj-hover");
  }).delegate(selector, "focus", function ()
  {
    $(this).addClass("oj-focus");
  }).delegate(selector, "blur", function ()
  {
    $(this).removeClass("oj-focus");
  });
}

//to display the suffix for the year
var yearDisplay = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
{
  "year" : "numeric"
});


/*!
 * JET Input Date @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojInputDate
 * @augments oj.inputBase
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="inputDateOverview-section">
 *   JET ojInputDate Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputDateOverview-section"></a>
 * </h3>
 * 
 * <p>Description: ojInputDate provides basic support for datepicker selection.
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>When focus is on the input element.
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>DownArrow or UpArrow</kbd></td>
 *       <td>Shows the grid and moves the focus into the expanded date grid</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Close the grid.</tr>
 *     <tr>
 * </tbody></table>
 * 
 * <br/>
 * <p>When focus is on the picker.
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Select the currently focused day</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move up in the grid.</tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move down in the grid.</tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move right in the grid.</tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move left in the grid.</tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Close the grid.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first day of the month.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last day of the month.</tr>
 *     <tr>
 *       <td><kbd>PageUp</kbd></td>
 *       <td>Switch to previous month.</tr>
 *     <tr>
 *       <td><kbd>PageDown</kbd></td>
 *       <td>Switch to next month.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageUp</kbd></td>
 *       <td>Switch to previous year.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageDown</kbd></td>
 *       <td>Switch to next year.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageUp</kbd></td>
 *       <td>Switch to previous by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageDown</kbd></td>
 *       <td>Switch to next by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + T</kbd></td>
 *       <td>Places focus on Today button if it exists.</tr>
 *    </tbody>
 * </table>
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputDate" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * It is up to the application developer to associate the label to the input component.
 * For inputDate, you should put an <code>id</code> on the input, and then set 
 * the <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <h3 id="label-section">
 *   Label and InputDate
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a label element with the input
 * by putting an <code>id</code> on the input, and then setting the 
 * <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code>required</code> and <code>help</code> options are set. 
 * </p>
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="dateId" data-bind="ojComponent: {component: 'ojInputDate'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputDate
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputDate();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputDate( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="dateId" data-bind="ojComponent: {component: 'ojInputDate'}" /&gt;
 */
oj.__registerWidget("oj.ojInputDate", $['oj']['inputBase'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  
  //-------------------------------------From base---------------------------------------------------//
  _CLASS_NAMES : "oj-inputdatetime-input",
  _WIDGET_CLASS_NAMES : "oj-inputdatetime-date-only oj-component oj-inputdatetime",
  _INPUT_HELPER_KEY: "inputHelp",
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "text"}],
  //-------------------------------------End from base-----------------------------------------------//
  
  _TRIGGER_CLASS : "oj-inputdatetime-input-trigger", 
  _TRIGGER_CALENDAR_CLASS : "oj-inputdatetime-calendar-icon", 
  
  _CURRENT_CLASS : "oj-datepicker-current-day", 
  _DAYOVER_CLASS : "oj-datepicker-days-cell-over",
  _UNSELECTABLE_CLASS : "oj-datepicker-unselectable",
  
  _DATEPICKER_DESCRIPTION_ID : "oj-datepicker-desc",
  _CALENDAR_DESCRIPTION_ID : "oj-datepicker-calendar", 
  _MAIN_DIV_ID : "oj-datepicker-div", 
  
  _INLINE_CLASS : "oj-datepicker-inline",
  _INPUT_CONTAINER_CLASS : " oj-inputdatetime-input-container",
  
  options : 
  {
    /**
     * <p>
     * Note that Jet framework prohibits setting subset of options which are object types.<br/><br/>
     * For example $(".selector").ojInputDate("option", "datePicker", {footerLayout: "today"}); is prohibited as it will 
     * wipe out all other sub-options for "datePicker" object.<br/><br/> If one wishes to do this [by above syntax or knockout] one 
     * will have to get the "datePicker" object, modify the necessary sub-option and pass it to above syntax.<br/><br/>
     * 
     * The properties supported on the datePicker option are:
     * 
     * @property {string=} footerLayout Will dictate what content is shown within the footer of the calendar. <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {footerLayout: ""}}</code> with possible values being 
     * <ul>
     *   <li>"" - Do not show anything</li>
     *   <li>"today" - the today button</li>
     * </ul>
     * <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.footerLayout", "today");</code>
     * 
     * @property {string=} changeMonth Whether the month should be rendered as a dropdown instead of text. <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {changeMonth: "select"}}</code> with possible values being 
     * <ul>
     *  <li>"select" - As a dropdown</li>
     *  <li>"none" - As a text</li>
     * </ul>
     * <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.changeMonth", "none");</code>
     * 
     * @property {string=} changeYear Whether the year should be rendered as a dropdown instead of text. <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {changeYear: "select"}}</code> with possible values being 
     * <ul>
     *  <li>"select" - As a dropdown</li>
     *  <li>"none" - As a text</li>
     * </ul>
     * <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.changeYear", "none");</code>
     * 
     * @property {number=} currentMonthPos The position in multipe months at which to show the current month (starting at 0). <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {currentMonthPos: 0}}</code> <br/><br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.currentMonthPos", 1);</code>
     * 
     * @property {string=} daysOutsideMonth Dictates the behavior of days outside the current viewing month. <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {daysOutsideMonth: "hidden"}}</code> with possible values being 
     * <ul>
     *  <li>"hidden" - Days outside the current viewing month will be hidden</li>
     *  <li>"visible" - Days outside the current viewing month will be visible</li>
     *  <li>"selectable" - Days outside the current viewing month will be visible + selectable</li>
     * </ul>
     * <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.daysOutsideMonth", "visible");</code>
     * 
     * @property {number=} numberOfMonths The number of months to show at once. Note that if one is using a numberOfMonths > 4 then one should define a CSS rule 
     * for the width of each of the months. For example if numberOfMonths is set to 6 then one should define a CSS rule .oj-datepicker-multi-6 .oj-datepicker-group 
     * providing the width each month should take in percentage.  <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {numberOfMonths: 1}}</code> <br/><br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.numberOfMonths", 2);</code>
     * 
     * @property {string=} showOn When the datepicker should be shown. <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {showOn: "image"}}</code> with possible values being 
     * <ul>
     *  <li>"focus" - when the element receives focus or when the trigger calendar image is clicked</li>
     *  <li>"image" - when the trigger calendar image is clicked</li>
     * </ul>
     * <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.showOn", "focus");</code>
     * 
     * @property {string|number=} stepMonths How the prev + next will step back/forward the months. <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {stepMonths: "numberOfMonths"}}</code>
     * <ul>
     *  <li>"numberOfMonths" - Will use numberOfMonths option value as value</li>
     *  <li>number - Number of months to step back/forward</li>
     * </ul>
     * <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.stepMonths", 2);</code>
     * 
     * @property {number=} stepBigMonths Number of months to step back/forward for the (Alt + Page up) + (Alt + Page down) key strokes.  <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {stepBigMonths: 12}}</code><br/><br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.stepBigMonths", 3);</code>
     * 
     * @property {string=} weekDisplay Whether week of the year will be shown.<br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {weekDisplay: "none"}}</code>
     * <ul>
     *  <li>"number" - Will show the week of the year as a number</li>
     *  <li>"none" - Nothing will be shown</li>
     * </ul>
     * <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.weekDisplay", "number");</code>
     * 
     * @property {string=} yearRange The range of years displayed in the year drop-down: either relative to today's year ("-nn:+nn"), 
     * relative to the currently selected year ("c-nn:c+nn"), absolute ("nnnn:nnnn"), or combinations of these formats ("nnnn:-nn"). <br/><br/>
     * The default value is <code class="prettyprint">{datePicker: {yearRange: "c-10:c+10"}}</code><br/><br/>
     * Example <code class="prettyprint">$(".selector").ojInputDate("option", "datePicker.yearRange", "c-5:c+10");</code>
     * </p>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {Object}
     */
    datePicker: 
    {
      /**
       * @expose
       */
      footerLayout : "", 
      
      /**
       * @expose
       */
      changeMonth : "select", 
  
      /**
       * @expose
       */
      changeYear : "select", 
      
      /**
       * @expose
       */
      currentMonthPos : 0,
      
      /**
       * @expose
       */
      daysOutsideMonth : "hidden", 
      
      /**
       * @expose
       */
      numberOfMonths : 1, 
  
      /**
       * @expose
       */
      showOn : "image", 
  
      /**
       * @expose
       */
      stepMonths : "numberOfMonths", 
  
      /**
       * @expose
       */
      stepBigMonths : 12, 
  
      /**
       * @expose
       */
      weekDisplay : "none", // "number" to show week of the year, "none" to not show it
  
      /** 
       * @expose 
       */
      yearRange : "c-10:c+10" // Range of years to display in drop-down,
      // either relative to today's year (-nn:+nn), relative to currently displayed year
      // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
      
    },
    
    /**
     * A datetime converter instance that duck types {@link oj.DateTimeConverter}. Or an object literal 
     * containing the properties listed below. 
     * 
     * The converter used for ojInputDate. Page authors can set a custom converter by creating one using the datetime converter factory 
     * and providing custom options - 
     * oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(customOptions).
     * 
     * <p>
     * When <code class="prettyprint">converter</code> option changes due to programmatic 
     * intervention, the component performs various tasks based on the current state it is in. </br>
     * 
     * <h4>Steps Performed Always</h4>
     * <ul>
     * <li>Any cached converter instance is cleared and new converter created. The converter hint is 
     * pushed to messaging. E.g., notewindow displays the new hint(s).
     * </li>
     * </ul>
     * 
     * <h4>Running Validation</h4>
     * <ul>
     * <li>if component is valid when <code class="prettyprint">converter</code> option changes, the 
     * display value is refreshed.</li>
     * <li>if component is invalid and is showing messages -
     * <code class="prettyprint">messagesShown</code> option is non-empty, when 
     * <code class="prettyprint">converter</code> option changes then all component messages are 
     * cleared and full validation run using the current display value on the component. 
     * <ul>
     *   <li>if there are validation errors, then <code class="prettyprint">value</code> 
     *   option is not updated, and the error pushed to <code class="prettyprint">messagesShown</code>
     *   option. The display value is not refreshed in this case. </li>
     *   <li>if no errors result from the validation, the <code class="prettyprint">value</code> 
     *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code> 
     *   event on the <code class="prettyprint">value</code> option to clear custom errors. The 
     *   display value is refreshed with the formatted value provided by converter.</li>
     * </ul>
     * </li>
     * <li>if component is invalid and has deferred messages when converter option changes, the 
     *   display value is again refreshed with the formatted value provided by converter.</li>
     * </ul>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>Only messages created by the component are cleared. This includes both 
     * <code class="prettyprint">messagesHidden</code> and <code class="prettyprint">messagesShown</code>
     *  options.</li>
     * <li><code class="prettyprint">messagesCustom</code> option is not cleared.</li>
     * </ul>
     * </p> 
     * 
     * @property {string} type - the converter type registered with the oj.ConverterFactory. 
     * Usually 'datetime'. See {@link oj.DateTimeConverterFactory} for details. <br/>
     * E.g., <code class="prettyprint">{converter: {type: 'datetime'}</code>
     * @property {Object=} options - optional Object literal of options that the converter expects. 
     * See {@link oj.IntlDateTimeConverter} for options supported by the jet datetime converter. 
     * E.g., <code class="prettyprint">{converter: {type: 'datetime', options: {formatType: 'date'}}</code>
     * 
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter()</code>
     */
    converter : oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
    {
      "day" : "2-digit", "month" : "2-digit", "year" : "2-digit"
    }),
    
    /**
     * The maximum selectable date. When set to null, there is no maximum.
     *
     * <ul>
     *  <li> type string - ISOString
     *  <li> null - no limit
     * </ul>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">null</code>
     */
    max : undefined, 
    
    /**
     * The minimum selectable date. When set to null, there is no minimum.
     *
     * <ul>
     *  <li> type string - ISOString
     *  <li> null - no limit
     * </ul>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">null</code>
     */
    min : undefined,
    
    /**
     * Additional info to be used when rendering the day
     *
     * This should be a JavaScript Function reference which accepts as its argument the following JSON format 
     * {fullYear: Date.getFullYear(), month: Date.getMonth()+1, date: Date.getDate()}
     * 
     * and returns null or all or partial JSON data of 
     * {disabled: true|false, className: "additionalCSS", tooltip: 'Stuff to display'}
     * 
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {Function}
     * @default <code class="prettyprint">null</code>
     */
    dayFormatter : null
    
    /**
     * Additional info to be used when rendering the day
     *
     * This should be in the following JSON format with the year, month, day based on Date.getFullYear(), Date.getMonth(), and Date.getDate():
     * {year: {month: {day: {disabled: true|false, className: "additionalCSS", tooltip: 'Stuff to display'}}}
     * 
     * There also exists a special '*' character which represents ALL within that field [i.e. * within year, represents for ALL year].
     *
     * @expose
     * @name dayMetaData
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">null</code>
     * @example <code class="prettyprint">{2013: {11: {25: {disabled: true, className: 'holiday', tooltip: 'Stuff to display'}, 5: {disabled: true}}}}}</code>
     */
    
    // DOCLETS 
    /** 
     * The placeholder text to set on the element. Though it is possible to set placeholder 
     * attribute on the element itself, the component will only read the value when the component
     * is created. Subsequent changes to the element's placeholder attribute will not be picked up 
     * and page authors should update the option directly.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> option:</caption>
     * &lt;!-- Foo is InputDate, InputDateTime -->
     * &lt;input id="date" data-bind="ojComponent: {component: 'ojFoo', placeholder: 'Birth Date'}" /&gt;
     * 
     * @example <caption>Initialize <code class="prettyprint">placeholder</code> option from html attribute:</caption>
     * &lt;!-- Foo is InputDate, InputDateTime -->
     * &lt;input id="date" data-bind="ojComponent: {component: 'ojFoo'}" placeholder="User Name" /&gt;
     * 
     * @default when the option is not set, the element's placeholder attribute is used if it exists. 
     * If the attribute is not set then the default can be the converter hint provided by the 
     * datetime converter. See displayOptions for details.
     * 
     * @access public
     * @instance
     * @expose 
     * @name placeholder
     * @instance
     * @memberof! oj.ojInputDate
     */
    
    /** 
     * The value of the ojInputDate component which should be an ISOString.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojInputDate({'value': new Date().toISOString()});<br/>
     * @example <caption>Get or set the <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns Today's date in ISOString
     * $(".selector").ojInputDate("option", "value");
     * // Setter: sets it to a different date
     * $(".selector").ojInputDate("option", "value", new Date(2013, 0, 1).ISOString);
     * 
     * @expose 
     * @name value
     * @instance
     * @memberof! oj.ojInputDate
     * @default When the option is not set, the element's value property is used as its initial value 
     * if it exists. This value must be an ISOString.
     */
    
    /** 
     * @name prevText
     * @see #translations
     */
    
    /** 
     * @name nextText
     * @see #translations
     */
    
    /** 
     * @name currentText
     * @see #translations
     */
    
    /** 
     * @name weekHeader
     * @see #translations
     */
  },
  
  _InitOptions : function (originalDefaults, constructorOptions)
  {
    var props = [{"attribute": "disabled", "defaultOptionValue": false, "validateOption": true},
                 {"attribute": "title", "defaultOptionValue": ""},
                 {"attribute": "placeholder", "defaultOptionValue": ""},
                 {"attribute": "value", "defaultOptionValue": null},
                 {"attribute": "required", "defaultOptionValue": false, 
                  "coerceDomValue": true, "validateOption": true},
                 {"attribute": "min", "defaultOptionValue": null},
                 {"attribute": "max", "defaultOptionValue": null}]; 
    
    this._super(originalDefaults, constructorOptions);
    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);
  },
  
  /**
   * @ignore
   * @protected
   */
  _InitBase : function __InitBase() 
  {
    this._triggerNode = null;
    this._ignoreShow = false; //only case is when of showOn of focus and one hides the element [need to avoid showing]
    this._maxRows = 4;

    this._currentDay = 0;
    this._drawMonth = this._currentMonth = 0;
    this._drawYear = this._currentYear = 0;
    
    this._datePickerDefaultValidators = {};
    
    var nodeName = this.element[0].nodeName.toLowerCase();
    this._isInLine = (nodeName === "div" || nodeName === "span");
    
    this._dpDiv = bindHover($("<div id='" + this._GetSubId(this._MAIN_DIV_ID) + "' role='region' aria-describedby='" + this._GetSubId(this._DATEPICKER_DESCRIPTION_ID) + "' class='oj-datepicker-content'></div>"));
    $("body").append(this._dpDiv);
    
    if(this._isInLine) 
    {
      //if inline then there is no input element, so reset _CLASS_NAMES
      this._CLASS_NAMES = "";
    }
    else
    {
      //append input container class to be applied to the root node as well, since not inline
      //[note the special case where input container class will NOT be on the widget node is when 
      //ojInputDateTime is of inline and ojInputTime places container around the input element]
      this._WIDGET_CLASS_NAMES += this._INPUT_CONTAINER_CLASS;
      var self = this;
      this._popUpDpDiv = this._dpDiv.ojPopup({"initialFocus": "none", 
                                              "rootAttributes": {"class": "datetimepicker-dropdown"},
                                              "open": function () {
                              self._dpDiv.find(".oj-datepicker-calendar").focus();
                          }});
    }
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _ComponentCreate : function __ComponentCreate()
  {
    
    this._InitBase();
    
    var retVal = this._super();
    
    //Need to set the currentDay, currentMonth, currentYear to either the value or the default of today's Date
    //Note that these are days indicator for the datepicker, so it is correct in using today's date even if value 
    //hasn't been set
    this._setCurrentDate(this._getDate());
    
    if (this._isInLine)
    {
      this.element.append(this._dpDiv);
      this.element.addClass(this._INLINE_CLASS); //by applying the inline class it places margin bottom, to separate in case ojInputTime exists
      
      // Set display:block in place of inst._dpDiv.show() which won't work on disconnected elements
      // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
      this._dpDiv.css("display", "block");
    }
    else 
    {
      this._attachTrigger();
    }
    
    return retVal;
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */        
  _AfterCreate : function () 
  {
    var ret = this._superApply(arguments);
    
    this._disableEnable(this.options["disabled"]);
    
    return ret;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _setOption : function __setOption(key, value, flags)
  {
    
    var retVal = null, 
        dateTimeRangeOptions = {}, 
        dateRestrictionOptions = {};
    
    //When a null, undefined, or "" value is passed in set to null for consistency
    //note that if they pass in 0 it will also set it null
    if (key === "value")
    {
      if(!value) 
      {
        value = null;
      }
      
      retVal = this._super(key, value, flags);
      this._setCurrentDate(value);
      if(this._datepickerShowing()) 
      {
        this._updateDatepicker();
      }
      return retVal;
    }
    
    retVal = this._super(key, value, flags);
    
    if (key === "disabled")
    {
      this._disableEnable(value);
    }
    else if (key === "max" || key === "min") 
    {
      //since validators are immutable, they will contain min + max as local values. B/c of this will need to recreate
      dateTimeRangeOptions = {'min': this.options['min'], 
          'max': this.options['max'],
          'converter': this._GetConverter()};

      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE] = 
        oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE).createValidator(dateTimeRangeOptions);
      
      this._AfterSetOptionValidators();
    }
    else if(key === "readOnly" && value) 
    {
      this.hide();
    }
    else if (key === "dayFormatter") 
    {
      //since validators are immutable, they will contain dayFormatter as local values. B/c of this will need to recreate
      dateRestrictionOptions = {'dayFormatter': this.options["dayFormatter"], 
          'converter': this._GetConverter()};

      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION] = 
        oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION).createValidator(dateRestrictionOptions);
      
      this._AfterSetOptionValidators();
    }
    
    if (key === "datePicker" && flags["subkey"] === "currentMonthPos")
    {
      //need to reset up the drawMonth + drawYear
      this._setCurrentDate(this.options["value"]);
    }
    
    var updateDatePicker = {"max": true, "min": true, "dayFormatter": true, "datePicker": true, "translations": true, "dayMetaData": true};
    
    if(this._datepickerShowing() && key in updateDatePicker) 
    {
      this._updateDatepicker();
    }
    
    return retVal;
  },
  
  /**
   * Need to override due to usage of display: inline-table [as otherwise for webkit the hidden content takes up 
   * descent amount of space]
   *  
   * @protected
   * @instance
   * @memberOf !oj.ojInputDate
   */
  _AppendInputHelperParent : function __AppendInputHelperParent() 
  {
    return this._triggerNode;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var retVal = this._super();
    
    this.element.off("focus");
    
    if (this._triggerNode)
    {
      this._triggerNode.remove();
    }
    
    if(this._isInLine) 
    {
      //need to remove disabled + readOnly b/c they are set by super classes and datepicker is special in that this.element 
      //can be a div element for inline mode
      this.element.removeProp("disabled");
      this.element.removeProp("readonly");
    }
    
    this._dpDiv.remove();
    return retVal;
  },
  
  _datepickerShowing: function() 
  {
    return this._isInLine || this._popUpDpDiv.ojPopup("isOpen");
  },
  
  /**
   * This function will create the necessary calendar trigger container [i.e. image to launch the calendar] 
   * and perform any attachment to events
   * 
   * @private
   */
  _attachTrigger : function __attachTrigger()
  {
    var showOn = this.options["datePicker"]["showOn"], 
        triggerContainer = $("<span>").addClass(this._TRIGGER_CLASS);

    if (showOn === "focus")
    {
      // pop-up date picker when in the marked field
      this.element.on("focus", $.proxy(this.show, this));
    }

    // pop-up date picker when button clicked
    var triggerCalendar = $("<span/>").addClass(this._TRIGGER_CALENDAR_CLASS + " oj-clickable-icon oj-component-icon");
    triggerContainer.append(triggerCalendar);

    var self = this;
    triggerCalendar.on("click", function ()
    {
      if (self._datepickerShowing())
      {
        self.hide();
      }
      else 
      {
        self.show();
      }
      return false;
    }).on("mouseenter", function ()
    {
      $(this).addClass("oj-hover");
    }).on("mousedown", function ()
    {
      $(this).addClass("oj-active");
    }).on("mouseleave", function ()
    {
      $(this).removeClass("oj-hover oj-active");
    });
    
    this._triggerNode = triggerContainer;
    this.element.after(triggerContainer);
  },
  
  //This handler is when an user keys down with the calendar having focus
  _doCalendarKeyDown : function __doCalendarKeyDown(event)
  {
    var sel, handled = false, 
        kc = $.ui.keyCode, 
        isRTL = this._IsRTL();

    if (this._datepickerShowing())
    {
      switch (event.keyCode)
      {
        case 84: //t character
          if (event.altKey && event.ctrlKey) 
          {
            this._dpDiv.find(".oj-datepicker-current").focus();
            handled = true;
          }
          break;
        case kc.TAB:
          this.hide();
          // hide on tab out
          break;
        case kc.ENTER:
          sel = $("td." + this._DAYOVER_CLASS + ":not(." + this._CURRENT_CLASS + ")", this._dpDiv);
          if (sel[0])
          {
            this._selectDay(this._currentMonth, this._currentYear, sel[0], event);
          }
          //need to return false so preventing default + stop propagation here
          event.preventDefault();
          event.stopPropagation();
          return false;
        case kc.ESCAPE:
          this.hide();
          this.element.focus();
          handled = true;
          break;// hide on escape
        case kc.PAGE_UP:
          if(event.ctrlKey && event.altKey)
          {
            this._adjustDate(- this.options["datePicker"]["stepBigMonths"], "M", true);
          }
          else if (event.altKey)
          {
            this._adjustDate( - 1, "Y", true);
          }
          else 
          {
            this._adjustDate(- this._getStepMonths(), "M", true);
          }
          handled = true;
          break;// previous month/year on page up/+ ctrl
        case kc.PAGE_DOWN:
          if(event.ctrlKey && event.altKey)
          {
            this._adjustDate(+ this.options["datePicker"]["stepBigMonths"], "M", true);
          }
          else if (event.altKey)
          {
            this._adjustDate(1, "Y", true);
          }
          else 
          {
            this._adjustDate(+ this._getStepMonths(), "M", true);
          }
          handled = true;
          break;// next month/year on page down/+ ctrl
        case kc.END:
          this._currentDay = this._getDaysInMonth(this._currentYear, this._currentMonth);
          this._updateDatepicker(true);
          handled = true;
          break;
        case kc.HOME:
          this._currentDay = 1;
          this._updateDatepicker(true);
          handled = true;
          break;
        case kc.LEFT:
          this._adjustDate((isRTL ?  + 1 :  - 1), "D", true);
          // -1 day on ctrl or command +left
          if (event.originalEvent.altKey)
          {
            this._adjustDate((event.ctrlKey ?  - this.options["datePicker"]["stepBigMonths"] :  - this._getStepMonths()), "M", true);
          }
          // next month/year on alt +left on Mac
          handled = true;
          break;
        case kc.UP:
          this._adjustDate( - 7, "D", true);
          handled = true;
          break;// -1 week on ctrl or command +up
        case kc.RIGHT:
          this._adjustDate((isRTL ?  - 1 :  + 1), "D", true);
          // +1 day on ctrl or command +right
          if (event.originalEvent.altKey)
          {
            this._adjustDate((event.ctrlKey ?  + this.options["datePicker"]["stepBigMonths"] :  + this._getStepMonths()), "M", true);
          }
          // next month/year on alt +right
          handled = true;
          break;
        case kc.DOWN:
          this._adjustDate( + 7, "D", true);
          handled = true;
          break;// +1 week on ctrl or command +down
        default : ;
      }
    }
    else if (event.keyCode === kc.HOME && event.ctrlKey)
    {
      // display the date picker on ctrl+home
      this.show();
      handled = true;
    }

    if (handled)
    {
      event.preventDefault();
      event.stopPropagation();
    }

  },

  /**
   * Thie function will update the calendar display
   * 
   * @private
   * @param {boolean=} focusOnCalendar
   */
  _updateDatepicker : function __updateDatepicker(focusOnCalendar)
  {
    this._maxRows = 4;//Reset the max number of rows being displayed (see #7043)
    var generatedHtmlContent = this._generateHTML();
    this._dpDiv.empty().append(generatedHtmlContent.html);
    
    var buttons = $("button", this._dpDiv);
    
    if(buttons.length > 0) 
    {
      if(buttons.length === 1) 
      {
        $(buttons[0]).addClass("oj-datepicker-single-button");
      }
      
      $.each(buttons, function (index, ele)
      {
        $(ele).ojButton();
      });
      
    }
    
    this._attachHandlers();
    
    if (generatedHtmlContent.dayOverId)
    {
      this._dpDiv.find(".oj-datepicker-calendar").attr("aria-activedescendant", generatedHtmlContent.dayOverId);
    }

    var numMonths = this._getNumberOfMonths(), 
        cols = numMonths[1], 
        width = 17;

    this._dpDiv.removeClass("oj-datepicker-multi-2 oj-datepicker-multi-3 oj-datepicker-multi-4").width("");
    if (cols > 1)
    {
      this._dpDiv.addClass("oj-datepicker-multi-" + cols).css("width", (width * cols) + "em");
    }
    this._dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("oj-datepicker-multi");

    // #6694 - don't focus the input if it's already focused
    // this breaks the change event in IE
    if (this._datepickerShowing() && this.element.is(":visible") && !this.element.is(":disabled"))
    {
      if (!focusOnCalendar && !this._isInLine)
      {
        if (this.element[0] !== document.activeElement)
        {
          this.element.focus();
        }
      }
      else 
      {
        var calendar = this._dpDiv.find(".oj-datepicker-calendar");
        if (calendar[0] !== document.activeElement)
        {
          calendar.focus();
        }
      }
    }
    
  },

  /**
   * Adjust one of the date sub-fields.
   * 
   * @private
   * @param {number} offset
   * @param {string} period
   * @param {boolean=} focusOnCalendar
   */
  _adjustDate : function __adjustDate(offset, period, focusOnCalendar)
  {
    if (this.options["disabled"])
    {
      return;
    }
    this._adjustInstDate(offset + (period === "M" ? this.options["datePicker"]["currentMonthPos"] : 0), // undo positioning
    period);
    this._updateDatepicker(focusOnCalendar);
  },

  /**
   * Action for current link.
   * 
   * @private
   */
  _gotoToday : function __gotoToday()
  {
    var date = new Date();

    this._currentDay = date.getDate();
    this._drawMonth = this._currentMonth = date.getMonth();
    this._drawYear = this._currentYear = date.getFullYear();

    this._adjustDate();
  },

  /**
   * Action for selecting a new month/year.
   * 
   * @private
   * @param {Object} select
   * @param {string} period
   */
  _selectMonthYear : function __selectMonthYear(select, period)
  {
    var selected = parseInt(select.options[select.selectedIndex].value, 10);

    if (period === "M")
    {
      this._currentMonth = this._drawMonth = selected;
    }
    else 
    {
      this._currentYear = this._drawYear = selected;
    }
    
    //Take care of accessibility
    $("#" + this._GetSubId(this._CALENDAR_DESCRIPTION_ID)).html(this.options["monthWide"][this._drawMonth] + " " + yearDisplay.format(new Date(this._drawYear, this._drawMonth, 1).toISOString()));

    this._adjustDate();
  },
  
  //Action for selecting a day.
  _selectDay : function __selectDay(month, year, td, event)
  {
    if ($(td).hasClass(this._UNSELECTABLE_CLASS) || this.options["disabled"])
    {
      return;
    }

    this._currentDay = $("a", td).html();
    this._currentMonth = month;
    this._currentYear = year;

    var value = this.options['value'] ? oj.IntlConverterUtils.isoToLocalDate(this.options['value']) : null;
    if (value)
    {
      var temp = new Date(this._currentYear, this._currentMonth, this._currentDay);
      
      copyTimeOver(value, temp);

      value = temp;
    }
    else 
    {
      value = new Date(this._currentYear, this._currentMonth, this._currentDay);
    }
    
    var isoString = value.toISOString();
    var formatted = this._GetConverter()["format"](isoString);
    this._SetDisplayValue( formatted ); //need to set the display value, since _SetValue doesn't trigger it per discussion
    this._SetValue(isoString, event);
    this.hide();
  },
  
  //A date may be specified as an exact value or a relative one.
  _determineDate : function __determineDate(date, defaultDate)
  {
    return !date ? defaultDate : (typeof date === "string" ? oj.IntlConverterUtils.isoToLocalDate(date) : new Date(date.getTime()));
  },

  /**
   * Set the date(s) directly.
   * 
   * @private
   * @param {Object} date
   */
  _setCurrentDate : function __setCurrentDate(date)
  {
    var newDate = this._determineDate(date, this._getTodayDate());

    this._currentDay = newDate.getDate();
    this._drawMonth = this._currentMonth = newDate.getMonth();
    this._drawYear = this._currentYear = newDate.getFullYear();

    this._adjustInstDate();
  },

  _getStepMonths : function __getStepMonths()
  {
    var stepMonths = this.options["datePicker"]["stepMonths"];
    return $.isNumeric(stepMonths) ? stepMonths : this.options["datePicker"]["numberOfMonths"];
  },

  /**
   * Attach the onxxx handlers.  These are declared statically so 
   * they work with static code transformers like Caja.
   * 
   * @private
   */
  _attachHandlers : function __attachHandlers()
  {
    var stepMonths = this._getStepMonths(), self = this;
    this._dpDiv.find("[data-handler]").map(function ()
    {
      var handler = 
      {
        /** @expose */
        prev : function (evt)
        {
          self._adjustDate( - stepMonths, "M", true);
          evt.preventDefault();
        },
        /** @expose */
        next : function (evt)
        {
          self._adjustDate( + stepMonths, "M", true);
          evt.preventDefault();
        },
        /** @expose */
        today : function (evt)
        {
          if((evt.type === "keyup" && evt.keyCode === 13) || evt.type === "click")
          {
            self._gotoToday();
            evt.preventDefault();
            evt.stopPropagation();
          }
        },
        /** @expose */
        selectDay : function (evt)
        {
          self._selectDay( + this.getAttribute("data-month"),  + this.getAttribute("data-year"), this, evt);
          return false;
        },
        /** @expose */
        selectMonth : function ()
        {
          self._selectMonthYear(this, "M");
          return false;
        },
        /** @expose */
        selectYear : function ()
        {
          self._selectMonthYear(this, "Y");
          return false;
        },
        /** @expose */
        calendarKey : function (evt)
        {
          self._doCalendarKeyDown(evt);
        }
      };
      $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
    });
  },

  /**
   * Generate the HTML for the current state of the date picker.
   * 
   * @private
   */
  _generateHTML : function __generateHTML()
  {
    var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, todayControl,
        footerLayout, weekDisplay, dayNames = this.options["dayWide"], dayNamesMin = this.options["dayNarrow"], 
        monthNames = this.options["monthWide"], monthNamesShort = this.options["monthAbbreviated"], 
        firstDay = this.options["firstDayOfWeek"], daysOutsideMonth, html, dow, row, group, col, selected, rowCellId, 
        dayOverClass, dayOverId = "", calender, thead, day, daysInMonth, leadDays, curRows, numRows, 
        printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), 
        today = new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate()), // clear time
        isRTL = this._IsRTL(), footerLayoutDisplay = this.options["datePicker"]["footerLayout"], numMonths = this._getNumberOfMonths(), 
        currentMonthPos = this.options["datePicker"]["currentMonthPos"], dayFormatter = this.options["dayFormatter"], 
        currMetaData = null, isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1), minDate = this._getMinMaxDate("min"), 
        maxDate = this._getMinMaxDate("max"), drawMonth = this._drawMonth - currentMonthPos, drawYear = this._drawYear, 
        compareDate = new Date(this._currentYear, this._currentMonth, this._currentDay), valueDate = new Date(this._getDate()), 
        selectedDay = valueDate.getDate(), selectedMonth = valueDate.getMonth(), selectedYear = valueDate.getFullYear(), 
        wDisabled = this.options["disabled"], calculatedWeek, weekText = this.getTranslatedString("weekText");

    valueDate.setHours(0);
    valueDate.setMinutes(0);
    valueDate.setSeconds(0);
    valueDate.setMilliseconds(0);

    if (drawMonth < 0)
    {
      drawMonth += 12;
      drawYear--;
    }
    if (maxDate)
    {
      maxDraw = new Date(maxDate.getFullYear(), maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate());
      maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
      while (new Date(drawYear, drawMonth, 1) > maxDraw)
      {
        drawMonth--;
        if (drawMonth < 0)
        {
          drawMonth = 11;
          drawYear--;
        }
      }
    }
    this._drawMonth = drawMonth;
    this._drawYear = drawYear;

    prevText = this.getTranslatedString("prevText");

    prev = (this._canAdjustMonth( - 1, drawYear, drawMonth) && !wDisabled ? "<a href='#' class='oj-datepicker-prev-icon oj-enabled oj-default oj-component-icon oj-clickable-icon' data-handler='prev' data-event='click'" + " title='" + prevText + "'></a>" : "<a class='oj-datepicker-prev-icon oj-disabled oj-component-icon oj-clickable-icon' title='" + prevText + "'></a>");

    nextText = this.getTranslatedString("nextText");

    next = (this._canAdjustMonth( + 1, drawYear, drawMonth) && !wDisabled ? "<a href='#' class='oj-datepicker-next-icon oj-enabled oj-default oj-component-icon oj-clickable-icon' data-handler='next' data-event='click'" + " title='" + nextText + "'></a>" : "<a class='oj-datepicker-next-icon oj-disabled oj-component-icon oj-clickable-icon' title='" + nextText + "'></a>");

    currentText = this.getTranslatedString("currentText");
    gotoDate = today;

    footerLayout = "";
    todayControl = "<button type='button' class='oj-datepicker-current oj-priority-secondary' data-handler='today' data-event='click keyup'" + ">" + currentText + "</button>";
    
    if(footerLayoutDisplay.length > 1) //keep the code for future multiple buttons
    {
      var todayIndex = footerLayoutDisplay.indexOf("today"),
          loop = 0,
          footerLayoutButtons = [{index: todayIndex, content: (this._isInRange(gotoDate) ? todayControl : "")}];
      
      //rather than using several if + else statements, sort the content to add by index of the strings
      footerLayoutButtons.sort(function(a, b) 
      {
        return a.index - b.index;
      });
      
      //continue to loop until the index > -1 [contains the string]
      while(loop < footerLayoutButtons.length && footerLayoutButtons[loop].index < 0) { loop++; }
      
      while(loop < footerLayoutButtons.length) 
      {
        footerLayout += footerLayoutButtons[loop++].content;
      }
      
      if(footerLayout.length > 0) 
      {
        footerLayout = "<div class='oj-datepicker-buttonpane'>" + footerLayout + "</div>";
      }
    }

    weekDisplay = this.options["datePicker"]["weekDisplay"];

    daysOutsideMonth = this.options["datePicker"]["daysOutsideMonth"];
    html = "";
    
    var monthControl = "all";
    for (row = 0;row < numMonths[0];row++)
    {
      group = "";
      this._maxRows = 4;
      for (col = 0;col < numMonths[1];col++)
      {
        monthControl = "all";
        calender = "";
        if (isMultiMonth)
        {
          calender += "<div class='oj-datepicker-group";
          if (numMonths[1] > 1)
          {
            switch (col)
            {
              case 0:
                calender += " oj-datepicker-group-first";
                monthControl = (isRTL ? "right" : "left");
                break;
              case numMonths[1] - 1:
                calender += " oj-datepicker-group-last";
                monthControl = (isRTL ? "left" : "right");
                break;
              default :
                calender += " oj-datepicker-group-middle";
                monthControl = "";
                break;
            }
          }
          calender += "'>";
        }
        calender += "<div class='oj-datepicker-header" + (wDisabled ? " oj-disabled " : " oj-enabled oj-default ") + "'>" + (/all|left/.test(monthControl) && row === 0 ? (isRTL ? next : prev) : "") + (/all|right/.test(monthControl) && row === 0 ? (isRTL ? prev : next) : "") + this._generateMonthYearHeader(drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
"</div><table class='oj-datepicker-calendar" + (wDisabled ? " oj-disabled " : " oj-enabled oj-default ") + "' tabindex=-1 data-handler='calendarKey' data-event='keydown' aria-readonly='true' role='grid' " + "aria-labelledby='" + this._GetSubId(this._CALENDAR_DESCRIPTION_ID) + "'><thead role='presentation'>" + "<tr role='row'>";
        thead = (weekDisplay === "number" ? "<th class='oj-datepicker-week-col'>" + this.getTranslatedString("weekHeader") + "</th>" : "");
        for (dow = 0;dow < 7;dow++)
        {
          // days of the week
          day = (dow + parseInt(firstDay, 10)) % 7;
          thead += "<th role='columnheader' aria-label='" + dayNames[day] + "'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='oj-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
        }
        calender += thead + "</tr></thead><tbody role='presentation'>";
        daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
        if (drawYear === selectedYear && drawMonth === selectedMonth)
        {
          selectedDay = Math.min(selectedDay, daysInMonth);
        }
        leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
        curRows = Math.ceil((leadDays + daysInMonth) / 7);// calculate the number of rows to generate
        numRows = (isMultiMonth ? this._maxRows > curRows ? this._maxRows : curRows : curRows);//If multiple months, use the higher number of rows (see #7043)
        this._maxRows = numRows;
        printDate = new Date(drawYear, drawMonth, 1 - leadDays);
        for (dRow = 0;dRow < numRows;dRow++)
        {
          // create date picker rows
          calender += "<tr role='row'>";
          
          calculatedWeek = this._GetConverter().calculateWeek(printDate.toISOString());
          tbody = (weekDisplay === "none" ? "" : "<td class='oj-datepicker-week-col' role='rowheader' aria-label='" + weekText + " " + calculatedWeek + "'>" + calculatedWeek + "</td>");
          for (dow = 0;dow < 7;dow++)
          {
            // create date picker days
            otherMonth = (printDate.getMonth() !== drawMonth);
            selected = printDate.getTime() === valueDate.getTime();
            rowCellId = "oj-dp-" + dRow + "-" + dow;
            dayOverClass = (printDate.getTime() === compareDate.getTime() && drawMonth === this._currentMonth);
            if (dayOverClass)
            {
              dayOverId = rowCellId;
            }

            daySettings = [true, ""];
            var pYear = printDate.getFullYear(), 
                pMonth = printDate.getMonth(), 
                pDate = printDate.getDate();

            if (dayFormatter)
            {
              currMetaData = dayFormatter({"fullYear": pYear, "month": pMonth+1, "date": pDate}); //request to start from 1 rather than 0
              if (currMetaData)
              {
                //has content
                daySettings = [!currMetaData["disabled"], currMetaData["className"] || ""];
                if (currMetaData["tooltip"])
                {
                  daySettings.push(currMetaData["tooltip"]);
                }
              }
            }
            var selectedDate = printDate.getTime() === valueDate.getTime();

            unselectable = (otherMonth && daysOutsideMonth !== "selectable") || !daySettings[0] || (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
            tbody += "<td role='gridcell' aria-disabled='" + !!unselectable + "' aria-selected='" + selected + "' id='" + rowCellId + "' " + "class='" + ((dow + firstDay + 6) % 7 >= 5 ? " oj-datepicker-week-end" : "") + // highlight weekends
(otherMonth ? " oj-datepicker-other-month" : "") + // highlight days from other months
(dayOverClass ? " " + this._DAYOVER_CLASS : "") + // highlight selected day
(unselectable || wDisabled ? " " + this._UNSELECTABLE_CLASS + " oj-disabled" : " oj-enabled ") + // highlight unselectable days
(otherMonth && daysOutsideMonth === "hidden" ? "" : " " + daySettings[1] + // highlight custom dates
(selected ? " " + this._CURRENT_CLASS : "") + // highlight selected day
(printDate.getTime() === today.getTime() ? " oj-datepicker-today" : "")) + "'" + // highlight today (if different)
((!otherMonth || daysOutsideMonth !== "hidden") && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
(otherMonth && daysOutsideMonth === "hidden" ? "&#xa0;" : // display for other months
(unselectable || wDisabled ? "<span class='oj-disabled'>" + printDate.getDate() + "</span>" : "<a class='oj-enabled" + (selectedDate ? " oj-selected" : "") + // highlight selected day
(otherMonth ? " oj-priority-secondary" : "") + // distinguish dates from other months
"' " + (selectedDate || dayOverClass ? "" : "tabindex='-1' ") + " href='#'>" + printDate.getDate() + "</a>")) + "</td>";// display selectable date
            printDate.setDate(printDate.getDate() + 1);
          }
          calender += tbody + "</tr>";
        }
        drawMonth++;
        if (drawMonth > 11)
        {
          drawMonth = 0;
          drawYear++;
        }
        calender += "</tbody></table>" + (isMultiMonth ? "</div>" + ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='oj-datepicker-row-break'></div>" : "") : "");
        group += calender;
      }
      html += group;
    }
    html += footerLayout;
    return {html : html, dayOverId : dayOverId};
  },

  /**
   * Generate the month and year header.
   * 
   * @private
   */
  _generateMonthYearHeader : function __generateMonthYearHeader(drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort)
  {

    var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, 
        changeMonth = this.options["datePicker"]["changeMonth"], changeYear = this.options["datePicker"]["changeYear"], 
        positionOfMonthToYear = oj.LocaleData.isMonthPriorToYear() ? "before" : "after", 
        html = "<div class='oj-datepicker-title' role='header'>", monthHtml = "", 
        wDisabled = this.options["disabled"];

    // month selection
    if (secondary || changeMonth === "none")
    {
      monthHtml += "<span class='oj-datepicker-month'>" + monthNames[drawMonth] + "</span>";
    }
    else 
    {
      inMinYear = (minDate && minDate.getFullYear() === drawYear);
      inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
      monthHtml += "<select tabindex='-1' class='oj-datepicker-month " + (wDisabled ? "oj-disabled' disabled" : "oj-enabled'") + " data-handler='selectMonth' data-event='change' role='listbox'>";
      for (month = 0;month < 12;month++)
      {
        if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth()))
        {
          monthHtml += "<option role='option' value='" + month + "' aria-selected='" + (month === drawMonth ? "true' selected='selected'" : "false'") + ">" + monthNamesShort[month] + "</option>";
        }
      }
      monthHtml += "</select>";
    }

    if (positionOfMonthToYear === "before")
    {
      html += monthHtml + (secondary || !((changeMonth === "select") && (changeYear === "select")) ? "&#xa0;" : "");
    }

    // year selection
    if (!this.yearshtml)
    {
      this.yearshtml = "";
      if (secondary || changeYear === "none")
      {
        html += "<span class='oj-datepicker-year'>" + yearDisplay.format(new Date(drawYear, drawMonth, 1).toISOString()) + "</span>";
      }
      else 
      {
        // determine range of years to display
        years = this.options["datePicker"]["yearRange"].split(":");
        thisYear = new Date().getFullYear();
        determineYear = function (value)
        {
          var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10)));
          return (isNaN(year) ? thisYear : year);
        };
        year = determineYear(years[0]);
        endYear = Math.max(year, determineYear(years[1] || ""));
        year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
        endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
        this.yearshtml += "<select tabindex='-1' class='oj-datepicker-year " + (wDisabled ? "oj-disabled' disabled" : "oj-enabled'") + " data-handler='selectYear' data-event='change' role='listbox'>";
        for (;year <= endYear;year++)
        {
          this.yearshtml += "<option role='option' value='" + year + "' aria-selected='" + (year === drawYear ? "true' selected='selected'" : "false'") + ">" + yearDisplay.format(new Date(year, drawMonth, 1).toISOString()) + "</option>";
        }
        this.yearshtml += "</select>";

        html += this.yearshtml;
        this.yearshtml = null;
      }
    }

    if (positionOfMonthToYear === "after")
    {
      html += (secondary || !((changeMonth === "select") && (changeYear === "select")) ? "&#xa0;" : "") + monthHtml;
    }
    html += "<span class='oj-helper-hidden-accessible' id='" + this._GetSubId(this._CALENDAR_DESCRIPTION_ID) + "'>" + monthNames[drawMonth] + " " + yearDisplay.format(new Date(drawYear, drawMonth, 1).toISOString()) + "</span>";
    html += "<span class='oj-helper-hidden-accessible' id='" + this._GetSubId(this._DATEPICKER_DESCRIPTION_ID) + "'>" + this.getTranslatedString("datePicker") + "</span>";
    html += "</div>";// Close datepicker_header
    return html;
  },

  /**
   * Adjust one of the date sub-fields.
   * 
   * @private
   */
  _adjustInstDate : function __adjustInstDate(offset, period)
  {
    var year = this._drawYear + (period === "Y" ? offset : 0), 
        month = this._drawMonth + (period === "M" ? offset : 0), 
        day = Math.min(this._currentDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), 
        date = new Date(year, month, day);

    this._currentDay = date.getDate();
    this._drawMonth = this._currentMonth = date.getMonth();
    this._drawYear = this._currentYear = date.getFullYear();
  },

  /**
   * Determine the number of months to show.
   * 
   * @private
   */
  _getNumberOfMonths : function __getNumberOfMonths()
  {
    var numMonths = this.options["datePicker"]["numberOfMonths"];
    numMonths = typeof numMonths === "string" ? parseInt(numMonths, 10) : numMonths;
    return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
  },

  /**
   * Determine the current maximum date - ensure no time components are set.
   * 
   * @private
   */
  _getMinMaxDate : function __getMinMaxDate(minMax)
  {
    return this._determineDate(this.options[minMax], null);
  },

  /**
   * Find the number of days in a given month.
   * 
   * @private
   */
  _getDaysInMonth : function __getDaysInMonth(year, month)
  {
    return 32 - new Date(year, month, 32).getDate();
  },

  /**
   * Find the day of the week of the first of a month.
   * 
   * @private
   */
  _getFirstDayOfMonth : function __getFirstDayOfMonth(year, month)
  {
    return new Date(year, month, 1).getDay();
  },

  /**
   * Determines if we should allow a "next/prev" month display change.
   * 
   * @private
   */
  _canAdjustMonth : function __canAdjustMonth(offset, curYear, curMonth)
  {
    var numMonths = this._getNumberOfMonths(), date = new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1);

    if (offset < 0)
    {
      date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
    }
    return this._isInRange(date);
  },

  /**
   * Is the given date in the accepted range? 
   * 
   * @private
   */
  _isInRange : function __isInRange(date)
  {
    var yearSplit, currentYear, minDate = this._getMinMaxDate("min"), maxDate = this._getMinMaxDate("max"), minYear = null, maxYear = null, years = this.options["datePicker"]["yearRange"];
    if (years)
    {
      yearSplit = years.split(":");
      currentYear = new Date().getFullYear();
      minYear = parseInt(yearSplit[0], 10);
      maxYear = parseInt(yearSplit[1], 10);
      if (yearSplit[0].match(/[+\-].*/))
      {
        minYear += currentYear;
      }
      if (yearSplit[1].match(/[+\-].*/))
      {
        maxYear += currentYear;
      }
    }

    return ((!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear));
  },
  
  /**
   * To disable or enable the widget
   * 
   * @private
   * @instance
   */
  _disableEnable : function __disableEnable(val)
  {
    if (this._triggerNode)
    {
      disableEnableSpan(this._triggerNode.children(), val);
    }
    
    if(val) 
    {
      this.hide();
    }
    
    //need to update the look, note that if it is displaying the datepicker dropdown it would be hidden in _setOption function
    if(this._isInLine) 
    {
      this._updateDatepicker();
    }
  },
  
  /**
   * Invoke super only if it is not inline
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _AppendInputHelper : function __AppendInputHelper()
  {
    if (!this._isInLine)
    {
      this._superApply(arguments);
    }
  },
  
  /**
   * This handler will set the value from the input text element. 
   * 
   * @ignore
   * @protected
   * @override
   * @param {Event} event
   * @instance
   * @memberof! oj.ojInputDate
   */
  _onBlurHandler : function __onBlurHandler(event)
  {
    if(this._isInLine) 
    {
      return;
    }
    
    this._superApply(arguments);
  },
  
  /**
   * This handler will be invoked when keydown is triggered for this.element. When is of inline ignore the keydowns
   * 
   * @ignore
   * @protected
   * @override
   * @param {Event} event
   * @instance
   * @memberof! oj.ojInputDate
   */
  _onKeyDownHandler : function __onKeyDownHandler(event) 
  {
    if(this._isInLine) 
    {
      return;
    }
    
    this._superApply(arguments);
    
    var kc = $.ui.keyCode, 
        handled = false;

    if (this._datepickerShowing())
    {

      switch (event.keyCode)
      {
        case kc.TAB: 
          this.hide();
          break;
        case kc.ESCAPE:
          this.hide();
          handled = true;
          break;
        case kc.UP: ;
        case kc.DOWN:
          this._dpDiv.find(".oj-datepicker-calendar").focus();
          handled = true;
          break;
        default: ;
      }

    }
    else 
    {

      switch (event.keyCode)
      {
        case kc.UP: ;
        case kc.DOWN:
          this.show();
          handled = true;
          break;
        default: ;
      }

    }

    if (handled)
    {
      event.preventDefault();
      event.stopPropagation();
      return false;
    }
  },
  
  /**
   * Ignore for when of inline, since then this.element would be of div and has a funky nature
   * 
   * @param {String} displayValue of the new string to be displayed
   * 
   * @memberof! oj.ojInputDate
   * @instance
   * @protected
   * @override
  */  
  _SetDisplayValue : function (displayValue) 
  {
    if(!this._isInLine) 
    {
      this._superApply(arguments);
    }
    
    this._setCurrentDate(this._getDate());
    
    //so this is a change in behavior from original design. Previously it was decided that app developer 
    //would have to invoke refresh to render the calendar after setting the new value programatically; however now it is 
    //required to hook it in when _SetDisplayValue is invoked [can't use _SetValue b/c that function is not invoked 
    //when developer invokes ("option", "value", new Date().toISOString())
    if(this._datepickerShowing())
    {
      this._updateDatepicker();
    }
  },
  
  /**
   * Need to override since apparently we allow users to set the converter to null, undefined, and etc and when 
   * they do we use the default converter
   * 
   * @return {Object} a converter instance or null
   * 
   * @memberof! oj.ojInputDate
   * @instance
   * @protected
   * @override
   */
  _GetConverter : function () 
  {
    return this.options['converter'] ? 
        this._superApply(arguments) : 
        $["oj"]["ojInputDate"]["prototype"]["options"]["converter"];
  },

  /**
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _GetElementValue : function ()
  {
    return this.options['value'] || "";
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputdate";
  },
  
  /**
   * Sets up the default dateTimeRange and dateRestriction validators.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _GetImplicitValidators : function ()
  {
    var ret = this._superApply(arguments),
        minDate = this.options['min'],
        maxDate = this.options['max'],
        dateTimeRangeOptions = {}, dateRestrictionOptions = {};
    
    if(minDate != null || maxDate != null) 
    {
      //need to alter how the default validators work as validators are now immutable
      dateTimeRangeOptions = {'min': this.options['min'], 
                              'max': this.options['max'],
                              'converter': this._GetConverter()};
      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE] = 
              oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE).createValidator(dateTimeRangeOptions);
    }
    
    if(this.options["dayFormatter"] != null) 
    {
      dateRestrictionOptions = {'dayFormatter': this.options["dayFormatter"], 
                                'converter': this._GetConverter()};
      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION] = 
            oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION).createValidator(dateRestrictionOptions);
    }
    
    return $.extend(this._datePickerDefaultValidators, ret);
  },
  
  /**
   * Gets today's date w/o time
   * 
   * @private
   * @return {Object} date
   */
  _getTodayDate : function __getTodayDate()
  {
    var date = new Date();
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    return date;
  },

  /**
   * Retrieve the default date shown on opening.
   * 
   * @private
   */
  _getDate : function __getDate()
  {
    return this._determineDate(this.options['value'], this._getTodayDate());
  },

  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * 
   * @expose
   * @override
   * @memberof! oj.ojInputDate
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    var node = null,
        subId = locator && locator['subId'],
        dpDiv = this._dpDiv;
    
    if(subId) 
    {
      switch(subId) 
      {
      case "oj-datepicker-content": node = dpDiv[0]; break;
      case "oj-inputdatetime-calendar-icon": node = $(".oj-inputdatetime-calendar-icon", this._triggerNode)[0]; break;
      case "oj-datepicker-prev-icon": node = $(".oj-datepicker-prev-icon", dpDiv)[0]; break;
      case "oj-datepicker-next-icon": node = $(".oj-datepicker-next-icon", dpDiv)[0]; break;
      case "oj-datepicker-month": node = $(".oj-datepicker-month", dpDiv)[0]; break;
      case "oj-datepicker-year": node = $(".oj-datepicker-year", dpDiv)[0]; break;
      case "oj-datepicker-current": node = $(".oj-datepicker-current", dpDiv)[0]; break;
      default: node = null;
      }
    }
    
    // Non-null locators have to be handled by the component subclasses
    return node || this._superApply(arguments);
  },
  
  /**
   * Returns the subId string for the given child DOM node.  For more details, see 
   * <a href="#getNodeBySubId">getNodeBySubId</a>.
   * 
   * @expose
   * @override
   * @memberof oj.ojInputDate
   * @instance
   * 
   * @param {!Element} node - child DOM node
   * @return {string|null} The subId for the DOM node, or <code class="prettyprint">null</code> when none is found.
   * 
   * @example <caption>Get the subId for a certain DOM node:</caption>
   * // Foo is ojInputNumber, ojInputDate, etc.
   * var subId = $( ".selector" ).ojFoo( "getSubIdByNode", nodeInsideComponent );
   */
  getSubIdByNode: function(node)
  {
    var dpDiv = this._dpDiv,
        subId = null,
        checks = [{"selector": ".oj-inputdatetime-calendar-icon", "ele": this._triggerNode},
                  {"selector": ".oj-datepicker-prev-icon", "ele": dpDiv},
                  {"selector": ".oj-datepicker-next-icon", "ele": dpDiv},
                  {"selector": ".oj-datepicker-month", "ele": dpDiv},
                  {"selector": ".oj-datepicker-year", "ele": dpDiv},
                  {"selector": ".oj-datepicker-current", "ele": dpDiv}];
    
    if(node === dpDiv[0]) 
    {
      return "oj-datepicker-content";
    }
    
    for(var i=0, j=checks.length; i < j; i++) 
    {
      var map = checks[i],
          entry = $(map["selector"], map["ele"]);
      
      if(entry.length === 1 && entry[0] === node) 
      {
        subId = map["selector"].substr(1);
        break;
      }
    }
    
    return subId || this._superApply(arguments);
  },
  
  /** 
   * Hides the datepicker
   * 
   * @expose 
   * @memberof! oj.ojInputDate
   * @instance
   */
  hide : function __hide()
  {

    if (this._datepickerShowing() && !this._isInLine)
    {
      this._popUpDpDiv.ojPopup("close");
      
      if(this.options["datePicker"]["showOn"] === "focus") 
      {
        this._ignoreShow = true;
      }
      this.element.focus();
    }

    return this;
  },
  
  /** 
   * @expose
   * @memberof! oj.ojInputDate
   * @instance
   */
  refresh : function __refresh()
  {
    return this._superApply(arguments) || this;
  },

  /**
   * Shows the datepicker
   * 
   * @expose
   * @memberof! oj.ojInputDate
   * @instance
   */
  show : function __show()
  {
    if (this._datepickerShowing() || this.options["disabled"] || this.options["readOnly"])
    {
      return;
    }
    
    if (this._ignoreShow) 
    {
      //set within hide or elsewhere and focus is placed back on this.element
      this._ignoreShow = false;
      return;
    }

    var rtl = this._IsRTL();

    //to avoid flashes on Firefox
    this._dpDiv.empty();
    this._updateDatepicker();
    
    // Since the popup is reparented to the body, it looses associate in the dom.
    // Establish linkage between the popup and the datepicker.
    var widget = this.widget();
    var surrogateId = !widget.is("[id]") ? widget.uniqueId().attr("id") : widget.attr("id");
    this._popUpDpDiv.ojPopup("widget").attr(oj.DomUtils.SURROGATE_ID, surrogateId);

    this._popUpDpDiv.ojPopup("open", this.element, {"my" : rtl ? "right top" : "left top", 
                              "at" : rtl ? "right bottom" : "left bottom", "collision" : "fit"});
    
    return this;
  }
  
});

// Add custom getters for properties from the LocaleElements bundle
oj.Components.setDefaultOptions(
  {
    'ojInputDate': 
    {
      'firstDayOfWeek': oj.Components.createDynamicPropertyGetter(
        function() 
        {
           return oj.LocaleData.getFirstDayOfWeek();
        }),
        
      'dayWide': oj.Components.createDynamicPropertyGetter(
        function() 
        {
           return oj.LocaleData.getDayNames("wide");
        }),
        
      'dayNarrow': oj.Components.createDynamicPropertyGetter(
        function() 
        {
            return oj.LocaleData.getDayNames("narrow");
        }),
        
      'monthWide': oj.Components.createDynamicPropertyGetter(
        function() 
        {
           return oj.LocaleData.getMonthNames("wide");
        }),
        
      'monthAbbreviated': oj.Components.createDynamicPropertyGetter(
        function() 
        {
           return oj.LocaleData.getMonthNames("abbreviated");
        })
    }
  }
);

//////////////////     SUB-IDS     //////////////////

/**
 * <p>Sub-ID for the calendar drop down node.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-datepicker-content
 * @memberof oj.ojInputDate
 * @instance
 * 
 * @example <caption>Get the calendar drop down node:</caption>
 * // Foo is ojInputDate or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-datepicker-content'} );
 */

/**
 * <p>Sub-ID for the calendar icon that triggers the calendar drop down.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-inputdatetime-calendar-icon
 * @memberof oj.ojInputDate
 * @instance
 * 
 * @example <caption>Get the calendar icon that triggers the calendar drop down:</caption>
 * // Foo is ojInputDate or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-inputdatetime-calendar-icon'} );
 */
 
/**
 * <p>Sub-ID for the previous month icon.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-datepicker-prev-icon
 * @memberof oj.ojInputDate
 * @instance
 * 
 * @example <caption>Get the previous month icon:</caption>
 * // Foo is ojInputDate or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-datepicker-prev-icon'} );
 */

/**
 * <p>Sub-ID for the next month icon.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-datepicker-next-icon
 * @memberof oj.ojInputDate
 * @instance
 * 
 * @example <caption>Get the next month icon:</caption>
 * // Foo is ojInputDate or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-datepicker-next-icon'} );
 */

/**
 * <p>Sub-ID for the month span or select element.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-datepicker-month
 * @memberof oj.ojInputDate
 * @instance
 * 
 * @example <caption>Get the month span or select element:</caption>
 * // Foo is ojInputDate or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-datepicker-month'} );
 */
 
/**
 * <p>Sub-ID for the year span or select element.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-datepicker-year
 * @memberof oj.ojInputDate
 * @instance
 * 
 * @example <caption>Get the year span or select element:</caption>
 * // Foo is ojInputDate or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-datepicker-year'} );
 */
 
/**
 * <p>Sub-ID for the current/today button for button bar.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-datepicker-current
 * @memberof oj.ojInputDate
 * @instance
 * 
 * @example <caption>Get the current/today button for button bar:</caption>
 * // Foo is ojInputDate or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-datepicker-current'} );
 */
 
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class
 * @name oj.ojInputTime
 * @augments oj.inputBase
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="inputTimeOverview-section">
 *   JET ojInputTime Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputTimeOverview-section"></a>
 * </h3>
 * 
 * <p>Description: ojInputTime provides a simple time selection drop down.
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputTime" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="timeId" data-bind="ojComponent: {component: 'ojInputTime'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputTime
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputTime();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputTime( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="timeId" data-bind="ojComponent: {component: 'ojInputTime'}" /&gt;
 */
oj.__registerWidget("oj.ojInputTime", $['oj']['inputBase'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  
  //-------------------------------------From base---------------------------------------------------//
  _CLASS_NAMES : "oj-inputdatetime-input",
  _WIDGET_CLASS_NAMES : "oj-inputdatetime-time-only oj-component oj-inputdatetime oj-inputdatetime-input-container",
  _INPUT_HELPER_KEY: "inputHelp",
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "text"}],
  //-------------------------------------End from base-----------------------------------------------//
  
  _TIME_PICKER_ID : "ojInputTime", 
  _TRIGGER_CLASS : "oj-inputdatetime-input-trigger",
  _TRIGGER_TIME_CLASS : "oj-inputdatetime-time-icon",
  
  options : 
  {
    /**
     * Default converter for ojInputTime
     *
     * If one wishes to provide a custom converter for the ojInputTime override the factory returned for
     * oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME)
     *
     * @expose
     * @memberof! oj.ojInputTime
     * @instance
     * @default <code class="prettyprint">oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter({"hour": "2-digit", "hour12": true, "minute": "2-digit"})</code>
     */
    converter : oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
    {
      "hour" : "2-digit", "hour12" : true, "minute" : "2-digit"
    }),
    
    /**
     * The maximum selectable date. When set to null, there is no maximum.
     *
     * <ul>
     *  <li> type string - ISOString
     *  <li> null - no limit
     * </ul>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputTime
     * @default <code class="prettyprint">null</code>
     */
    max : undefined, 
    
    /**
     * The minimum selectable date. When set to null, there is no minimum.
     *
     * <ul>
     *  <li> type string - ISOString
     *  <li> null - no limit
     * </ul>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputTime
     * @default <code class="prettyprint">null</code>
     */
    min : undefined, 
    
    /**
     * JSON data passed when the widget is of ojInputDateTime
     * 
     * {
     *  widget : dateTimePickerInstance,
     *  inline: true|false
     * }
     * 
     * @expose
     * @memberof! oj.ojInputTime
     * @instance
     * @private
     */
    datePickerComp : null,
    
    /**
     * <p>
     * The properties supported on the timePicker option are:
     * @property {string=} timeIncrement Time increment to be used for ojInputTime, the format is hh:mm:ss:SS. <br/><br/>
     * 
     * The default value is <code class="prettyprint">{timePicker: {timeIncrement': "00:30:00:00"}}</code>. <br/><br/>
     * Example <code class="prettyprint">$(".selector").ojInputTime("option", "timePicker.timeIncrement", "00:10:00:00");</code>
     * </p>
     * 
     * @expose
     * @instance
     * @memberof! oj.ojInputTime
     */
    timePicker: 
    {
      /**
       * @expose
       */
      timeIncrement : "00:30:00:00"
    }
    
    // DOCLETS 

    /** 
     * The placeholder text to set on the element. Though it is possible to set placeholder 
     * attribute on the element itself, the component will only read the value when the component
     * is created. Subsequent changes to the element's placeholder attribute will not be picked up 
     * and page authors should update the option directly.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> option:</caption>
     * &lt;input id="date" data-bind="ojComponent: {component: 'ojInputTime', placeholder: 'Birth Date'}" /&gt;
     * 
     * @example <caption>Initialize <code class="prettyprint">placeholder</code> option from html attribute:</caption>
     * &lt;input id="date" data-bind="ojComponent: {component: 'ojInputTime'}" placeholder="User Name" /&gt;
     * 
     * @default when the option is not set, the element's placeholder attribute is used if it exists. 
     * If the attribute is not set then the default can be the converter hint provided by the 
     * datetime converter. See displayOptions for details.
     * 
     * @access public
     * @instance
     * @expose 
     * @name placeholder
     * @instance
     * @memberof! oj.ojInputTime
     */    
    
    /** 
     * The value of the ojInputTime component which should be an ISOString.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojInputTime({'value': new Date().toISOString()});<br/>
     * @example <caption>Get or set the <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns Today's date in ISOString
     * $(".selector").ojInputTime("option", "value");
     * // Setter: sets it to a different date
     * $(".selector").ojInputTime("option", "value", new Date(2013, 0, 1, 0, 0, 0, 0).toISOString());
     * 
     * @expose 
     * @name value
     * @instance
     * @memberof! oj.ojInputTime
     * @default When the option is not set, the element's value property is used as its initial value 
     * if it exists. This value must be an ISOString.
     */
    
  },
  
  _InitOptions : function (originalDefaults, constructorOptions)
  {
    var props = [{"attribute": "disabled", "defaultOptionValue": false, "validateOption": true},
                 {"attribute": "title", "defaultOptionValue": ""},
                 {"attribute": "placeholder", "defaultOptionValue": ""},
                 {"attribute": "value", "defaultOptionValue": null},
                 {"attribute": "required", "defaultOptionValue": false, 
                  "coerceDomValue": true, "validateOption": true},
                 {"attribute": "min", "defaultOptionValue": null},
                 {"attribute": "max", "defaultOptionValue": null}]; 
    
    this._super(originalDefaults, constructorOptions);
    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);
  },
  
  /**
   * @ignore
   */
  _InitBase : function __InitBase() 
  {
    this._timePickerDefaultValidators = {};
    
    this._datePickerComp = this.options["datePickerComp"];
    
    this._timePickerDisplay = $("<div id='" + this._GetSubId(this._TIME_PICKER_ID) + "' class='oj-listbox-drop' style='display:none'></div>");
    $("body").append(this._timePickerDisplay);
    
    var self = this;
    this._popUpTimePickerDisplay = this._timePickerDisplay.ojPopup({
                                              "initialFocus": "none", 
                                              "rootAttributes": {"class": "datetimepicker-dropdown"},
                                              "open": function () {
                              
                              var selected = $("[aria-selected]", self._timePickerDisplay);
                              if (selected.length === 1)
                              {
                                self._checkScrollTop($(selected));
                              }
                          
                              $("ul", self._timePickerDisplay).focus();
                          }});
  },
  
  _timepickerShowing: function () 
  {
    return this._popUpTimePickerDisplay.ojPopup("isOpen");
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   */
  _ComponentCreate : function __ComponentCreate()
  {
    this._InitBase();
    
    var ret = this._superApply(arguments);
    
    if (this._isContainedInDateTimePicker() && !this._isDatePickerInline())
    {
      //set to nothing since then of not inline and don't want to place two component classes to 
      //the same input element
      this._CLASS_NAMES = "";
    }
    
    this._attachTrigger();
    
    return ret;
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   */        
  _AfterCreate : function () 
  {
    var ret = this._superApply(arguments);
    
    disableEnableSpan(this._triggerNode.children(), this.options["disabled"]);
    
    return ret;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _setOption : function __setOption(key, value, flags)
  {
    var retVal = null,
        timeRangeOptions = {};
    
    //When a null, undefined, or "" value is passed in set to null for consistency
    //note that if they pass in 0 it will also set it null
    if (key === "value")
    {
      if(!value) 
      {
        value = null;
      }
      
      retVal = this._super(key, value, flags);
      this._generateTime();
      return retVal;
    }
    
    retVal = this._superApply(arguments);

    if(key === "disabled") 
    {
      if(value) 
      {
        this.hide();
      }
      disableEnableSpan(this._triggerNode.children(), value);
    }
    else if ((key === "max" || key === "min") && this._isIndependentInput())
    {
      //since validators are immutable, they will contain min + max as local values. B/c of this will need to recreate
      timeRangeOptions = {'min': this.options['min'], 
          'max': this.options['max'],
          'converter': this._GetConverter()};

      this._timePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE] = 
        oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE).createValidator(timeRangeOptions);
      
      this._AfterSetOptionValidators();
    }
    else if(key === "readOnly" && value) 
    {
      this.hide();
    }
    
    var redrawTimePicker = {"max": true, "min": true, "converter": true, "timePicker": true};
    if(key in redrawTimePicker) 
    {
      //changing back to original code of invoking _generateTime per discussion
      this._generateTime();
    }
 
    return retVal;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var retVal = this._super();
    
    if (this._triggerNode)
    {
      this._triggerNode.remove();
    }

    this._timePickerDisplay.remove();
    
    return retVal;
  },
  
  /**
   * Invoke super only if it is standlone or if it is part of ojInputDateTime and ojInputDateTime is inline
   * 
   * @ignore
   * @protected
   * @override
   */
  _AppendInputHelper : function __AppendInputHelper()
  {
    if (this._isIndependentInput())
    {
      this._superApply(arguments);
    }
  },
  
  /**
   * Need to override due to usage of display: inline-table [as otherwise for webkit the hidden content takes up 
   * descent amount of space]
   *  
   * @protected
   * @instance
   * @memberOf !oj.ojInputTime
   */
  _AppendInputHelperParent : function __AppendInputHelperParent() 
  {
    return this._triggerNode;
  },
  
  /**
   * Only time to have ojInputTime handle the display of timepicker by keyDown is when datePickerComp reference is null or 
   * when it is not null and is inline
   * 
   * @ignore
   * @protected
   * @override
   * @param {Event} event
   */
  _onKeyDownHandler : function __onKeyDownHandler(event) 
  {
    if(this._isIndependentInput()) 
    {
      this._superApply(arguments);
      
      var kc = $.ui.keyCode, 
        handled = false;
      
      if (this._timepickerShowing())
      {
        switch (event.keyCode)
        {
          case kc.TAB: ;
            this.hide();
            break;
          case kc.ESCAPE:
            this.hide();
            handled = true;
            break;
          case kc.UP: ;
          case kc.DOWN:
            $("ul", this._timePickerDisplay).focus();
            handled = true;
            break;
        }
      }
      else 
      {
        switch (event.keyCode)
        {
          case kc.UP: ;
          case kc.DOWN:
            this.show();
            handled = true;
            break;
        }
      }
  
      if (handled || event.keyCode === kc.ENTER)
      {
        event.preventDefault();
        event.stopPropagation();
        return false;
      }
    }
  },
  
  /**
   * This function will create the necessary time trigger container [i.e. image to launch the time drop down] 
   * and perform any attachment to events
   * 
   * @private
   */
  _attachTrigger : function __attachTrigger()
  {

    //only time to create one's own span element is when datePickerComp reference is null or when it is not null and is inline
    var createNewSpan = this._isIndependentInput(), 
        triggerContainer = createNewSpan ? $($("<span>").addClass(this._TRIGGER_CLASS)) : $("+ span", this.element),
        triggerTime = $("<span/>").addClass(this._TRIGGER_TIME_CLASS + " oj-clickable-icon oj-component-icon");

    triggerContainer.append(triggerTime);
    
    var self = this;
    triggerTime.on("click", function ()
    {
      if (self._timepickerShowing())
      {
        self.hide();
      }
      else 
      {
        self.show();
      }
    }).on("mouseenter", function() 
    {
      $(this).addClass("oj-hover");
    }).on("mousedown", function() 
    {
      $(this).addClass("oj-active");
    }).on("mouseleave", function() 
    {
      $(this).removeClass("oj-hover oj-active");
    });
    
    this._triggerNode = triggerContainer;
    if (createNewSpan)
    {
      this.element.after(triggerContainer);
    }
  },
  
  /**
   * Returns a boolean of whether the date is in the min + max range
   * 
   * @private
   */
  _inMinMaxRange : function __inMinMaxRange(date) 
  {
    var minDate = this.options["min"] ? oj.IntlConverterUtils.isoToLocalDate(this.options["min"]) : null,
        maxDate = this.options["max"] ? oj.IntlConverterUtils.isoToLocalDate(this.options["max"]) : null;
    
    return (minDate !== null && date < minDate) || (maxDate !== null && date > maxDate);
  },
  
  /**
   * This function will generate the time drop down 
   * 
   * @private
   */
  _generateTime : function __generateTime()
  {

    var processDate = this.options["value"] ? oj.IntlConverterUtils.isoToLocalDate(this.options["value"]) : new Date(), //don't care about year, month, and date since will generate by time
        timeNode = $("<ul class='oj-listbox-results' tabindex='-1' role='listbox'></ul>"), 
        selectedDateFormat = this._getFormattedValue(), source = [], i, j;

    processDate.setHours(0);
    processDate.setMinutes(0);
    processDate.setSeconds(0);
    processDate.setMilliseconds(0);

    source = this._getTimeSource(processDate);
    selectedDateFormat = selectedDateFormat || source[0].value; //either choose the selected date or if it doesn't exist the first value

    this._timePickerDisplay.empty();

    for (i = 0, j = source.length;i < j;i++)
    {
      var value = source[i].value,
          minMaxRange = source[i]["minMaxRange"],
          liNode = $("<li class='oj-listbox-result " + (minMaxRange ? "oj-disabled" : "") + "' role='presentation'>"),
          nodeId = this["uuid"] + "_sel" + i,
          node = $("<div class='oj-listbox-result-label' " + (minMaxRange ? "aria-disabled " : "") + "data-value='" + value + "' role='option' id='" + 
                    nodeId + "'>" + source[i].label + "</li>");

      if (selectedDateFormat === value)
      {
        node.attr("aria-selected", "true");
        liNode.addClass("oj-hover"); //TODO When combo box changes it's CSS to Jet specific [i.e. oj-selected or something else] make the same change
        timeNode.attr("aria-activedescendant", nodeId);
      }
      
      liNode.append(node);
      timeNode.append(liNode);
    }

    this._timePickerDisplay.append(timeNode);
    
    $(".oj-listbox-result", timeNode).on("mousemove", function ()
    {
      var ref = $(this);
      
      if(ref.hasClass("oj-disabled")) 
      {
        //ignore disabled entries
        return;
      }
      
      $(".oj-hover", timeNode).removeClass("oj-hover"); //remove previously selected entry TODO modify when combo box changes
      
      ref.addClass("oj-hover"); //TODO modify when combo box changes its CSS selection identifier
      
      timeNode.attr("aria-activedescendant", ref.children()[0].id);
    });

    var self = this;
    timeNode.on("click", function (event)
    {
      var target = $(event.target);
      
      if(target.hasClass("oj-disabled") || target.attr("aria-disabled") !== undefined) 
      {
        //disabled
        return;
      }
      
      self.hide();
      self._processTimeSelection(event);
    }).on("keydown", function (event)
    {
      self._timeNodeKeyDown(event);
    });

  },
  
  /**
   * This function will return an array of JSON objects of label + value for the 
   * time drop down
   * 
   * @private
   * @param {Object} date to get timeSource of
   * @return {Array} source
   */
  _getTimeSource : function __getTimeSource(date)
  {
    var source = [], 
        converter = this._GetConverter();

    if (date)
    {
      var timeIncrement = this.options["timePicker"]["timeIncrement"],
          splitted = timeIncrement.split(":");
      
      if (splitted.length === 4)
      {
        var increments = {
                            hourIncr : parseInt(splitted[0].substring(0), 10), 
                            minuteIncr : parseInt(splitted[1], 10), 
                            secondIncr : parseInt(splitted[2], 10), 
                            millisecondIncr : parseInt(splitted[3], 10)
                          };

        var processDate = new Date(date), formatted = "";
        //continue until day differs
        do 
        {
          formatted = converter.format(processDate.toISOString());
          source.push(
          {
            label : formatted, value : formatted, "minMaxRange" : this._inMinMaxRange(processDate)
          });
          processDate.setHours(processDate.getHours() + increments.hourIncr);
          processDate.setMinutes(processDate.getMinutes() + increments.minuteIncr);
          processDate.setSeconds(processDate.getSeconds() + increments.secondIncr);
          processDate.setMilliseconds(processDate.getMilliseconds() + increments.millisecondIncr);
        }
        while (processDate.getDate() === date.getDate());
      }
      else 
      {
        throw new Error("timeIncrement value should be in the format of hh:mm:ss:SS");
      }
      
    }

    return source;
  },
  
  //This handler is when an user keys down with the drop down has focus
  _timeNodeKeyDown : function __timeNodeKeyDown(event)
  {

    if (this._timepickerShowing())
    {

      var kc = $.ui.keyCode, 
          handled = false;

      switch (event.keyCode)
      {
        case kc.TAB: ;
          this.hide();
          break;
        case kc.ESCAPE:
          this.hide();
          this.element.focus();
          handled = true;
          break;
        case kc.UP:
          this._processNextPrevSibling(event, "prev");
          handled = true;
          break;
        case kc.DOWN:
          this._processNextPrevSibling(event, "next");
          handled = true;
          break;
        case kc.ENTER:
          this._processTimeSelection(event);
          handled = true;
          break;
      }

      if (handled)
      {
        event.preventDefault();
        event.stopPropagation();
        return false;
      }
    }
  },
  
  /**
   * This function will set the oj-hover to the next or previous sibling due to key down or key up stroke
   * 
   * @private
   * @param {Event} event
   * @param {string} prevOrNext
   */
  _processNextPrevSibling : function __processNextPrevSibling(event, prevOrNext)
  {
    var prevActive = $(".oj-hover", this._timePickerDisplay), //TODO update when combobox updates their selector CSS
        ulElement = $("ul", this._timePickerDisplay);
    
    if (prevActive.length === 1)
    {
      var node = prevActive[prevOrNext]();
      if (node.length === 1)
      {
        prevActive.removeClass("oj-hover"); //TODO update when combobox updates their selector CSS
        node.addClass("oj-hover");  //TODO update when combobox updates their selector CSS
        ulElement.attr("aria-activedescendant", node.children()[0].id);
        this._checkScrollTop(node);
      }
    }
  },
  
  /**
   * This handler is when an user selects a time entry
   * 
   * @private
   * @param {Event} event
   */
  _processTimeSelection : function __processTimeSelection(event)
  {

    var timePickerDisplay = this._timePickerDisplay, 
        prevSelected = $("[aria-selected]", timePickerDisplay), 
        ulElement = $("ul", timePickerDisplay), 
        selected = $(".oj-hover div", timePickerDisplay); //TODO update when combobox updates their selector CSS

    if (selected.length !== 1)
    {
      return;
    }
    
    if(prevSelected.length === 1)
    {
      //previous selection can be 0 so remove only when of size 1
      prevSelected.removeAttr("aria-selected");
      prevSelected.parent().removeClass("oj-hover");  //TODO update when combobox updates their selector CSS
    }
    
    selected.attr("aria-selected", "true");
    selected.parent().addClass("oj-hover"); //TODO update when combobox updates their selector CSS
    
    this._SetDisplayValue(selected.attr("data-value")); //requirement to invoke _SetDisplayValue since _SetValue doesn't invoke it
    this._SetValue(selected.attr("data-value"), event);
    
    ulElement.attr("aria-activedescendant", selected[0].id);
    
    this.hide();
    
    this.element.focus();
    
    if (this._isContainedInDateTimePicker())
    {
      //when focus is placed on the input, since datePickerComp w/ showOn of focus can display it
      this._datePickerComp["widget"].hide();
    }
  },
  
  /**
   * Invoked when blur is triggered of the this.element
   * 
   * @ignore
   * @protected
   * @param {Event} event
   */
  _onBlurHandler : function __onBlurHandler(event) 
  {
    if(this._isIndependentInput())
    {
      this._superApply(arguments);
    }
  },
  
  /** 
   * Shows the timepicker
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  show : function __show()
  {
    if (this.options["disabled"] || this.options["readOnly"])
    {
      return;
    }

    if (this._isContainedInDateTimePicker())
    {
      //need to hide the datePickerComp prior to showing timepicker
      this._datePickerComp["widget"].hide();
    }
    
    //lazily generate
    if (this._timePickerDisplay.children().length === 0)
    {
      this._generateTime();
    }
    
    //Need to set the width to align with what combobox does
    this._timePickerDisplay.width(this.element.parent().width());
    
    //TODO REMOVE LATER WHEN THE CSS HAS BEEN MODIFIED for oj-listbox-drop, causes the popup to think it's not visible 
    //due to offsetwidth + offsetheight being 0
    this._timePickerDisplay.css({"position": "relative"});
    
    var rtl = this._IsRTL();

    // Since the popup is reparented to the body, it looses associate in the dom.
    // Establish linkage between the popup and the timepicker.
    var widget = this.widget();
    var surrogateId = !widget.is("[id]") ? widget.uniqueId().attr("id") : widget.attr("id");
    this._popUpTimePickerDisplay.ojPopup("widget").attr(oj.DomUtils.SURROGATE_ID, surrogateId);

    this._popUpTimePickerDisplay.ojPopup("open", this.element, {"my" : rtl ? "right top" : "left top", 
                                          "at" : rtl ? "right bottom" : "left bottom", "collision" : "fit"});
    
  },
  
  /** 
   * Hides the timepicker
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  hide : function __hide()
  {
    if (this._timepickerShowing())
    {
      this._popUpTimePickerDisplay.ojPopup("close");
      this.element.focus();
    }
  },
  
  /** 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  refresh : function __refresh()
  {
    return this._superApply(arguments) || this;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   */
  _SetDisplayValue : function __setDisplayValue(displayValue)
  {
    //When not part of datePickerComp or of inline should update input element
    if (this._isIndependentInput())
    {
      this._superApply(arguments);
    }
    
    //so this is a change in behavior from original design. Previously it was decided that app developer 
    //would have to invoke refresh to render the calendar after setting the new value programatically; however now it is 
    //required to hook it in when _SetDisplayValue is invoked [can't use _SetValue b/c that function is not invoked 
    //when developer invokes ("option", "value", new Date())
    if(this._timepickerShowing()) 
    {
      this._generateTime();
    }
  },
  
  /**
   * Whether the this.element should be wrapped. Function so that additional conditions can be placed
   * 
   * @ignore
   * @protected
   * @override
   * @return {boolean}
   */
  _DoWrapElement : function ()
  {
    return this._isIndependentInput();
  },
  
  /**
   * Whether the input element of ojInputTime is shared or not [i.e. not part of ojInputDateTime or if it has 
   * been created by ojInputDateTime that is inline
   * 
   * @ignore
   * @return {boolean}
   */
  _isIndependentInput : function __isIndependentInput()
  {
    return !this._isContainedInDateTimePicker() || this._isDatePickerInline();
  },
  
  /**
   * @protected
   * @override
   * @return {string}
   * @instance
   * @memberof! oj.ojInputTime
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputtime";
  },
  
  /**
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   */
  _GetElementValue : function ()
  {
    return this.options['value'] || "";
  },
  
  /**
   * Sets up the default dateTimeRange and dateRestriction validators.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _GetImplicitValidators : function ()
  {
    var ret = this._superApply(arguments),
        minDate = this.options['min'],
        maxDate = this.options['max'],
        timeRangeOptions = {};
    
    if((minDate != null || maxDate != null) && this._isIndependentInput()) 
    {
      //need to alter how the default validators work as validators are now immutable
      timeRangeOptions = {'min': minDate, 
                          'max': maxDate,
                          'converter': this._GetConverter()};
      this._timePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE] = 
              oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE).createValidator(timeRangeOptions);
    }
    
    return $.extend(this._timePickerDefaultValidators, ret);
  },
  
  /**
   * Need to override since apparently we allow users to set the converter to null, undefined, and etc and when 
   * they do we use the default converter
   * 
   * @return {Object} a converter instance or null
   * 
   * @memberof! oj.ojInputTime
   * @instance
   * @protected
   * @override
   */
  _GetConverter : function () 
  {
    return this.options['converter'] ? 
            this._superApply(arguments) : 
            $["oj"]["ojInputTime"]["prototype"]["options"]["converter"];
  },
  
  /**
   * This helper function will check if the currently selected time entry is within the view and if not will scroll to it
   * 
   * @private
   * @param {Object} node
   */
  _checkScrollTop : function (node)
  {
    /* After CSS change of listbox this feature is broken, need to investigate why and am disabling for now
    var top = node.position().top, 
        height = this._timePickerDisplay.height(), 
        results = $(".oj-listbox-results", this._timePickerDisplay),
        scrollTop = results.scrollTop();

    if ((height + scrollTop) < top || top < scrollTop)
    {
      results.scrollTop(top);
    }*/
  },
  
  /**
   * This function will return a formattedValue of the date object
   * 
   * @private
   * @return {string} increments
   */
  _getFormattedValue : function __getFormattedValue()
  {
    var converter = this._GetConverter(), 
        date = this.options['value'];

    return date ? converter.format(date) : "";
  },
  
  /**
   * Whether ojInputTime has been created by ojInputDateTime
   * 
   * @private
   */
  _isContainedInDateTimePicker : function __isContainedInDateTimePicker()
  {
    return this._datePickerComp !== null;
  },
  
  /**
   * Helper function to determine whether the provided datePickerComp is inline or not
   * 
   * @private
   */
  _isDatePickerInline : function __isDatePickerInline()
  {
    return this._datePickerComp["inline"];
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values. For Time
   * 
   * @expose
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    var node = null,
        subId = locator && locator['subId'];
    
    if(subId) {
      if (subId === "oj-listbox-drop")
      {
        node = this._timePickerDisplay[0];
      }
      else if (subId === "oj-inputdatetime-time-icon")
      {
        node = $(".oj-inputdatetime-time-icon", this._triggerNode)[0];
      }
    }
    
    return node || this._superApply(arguments);
  },
  
  /**
   * Returns the subId string for the given child DOM node.  For more details, see 
   * <a href="#getNodeBySubId">getNodeBySubId</a>.
   * 
   * @expose
   * @override
   * @memberof oj.ojInputTime
   * @instance
   * 
   * @param {!Element} node - child DOM node
   * @return {string|null} The subId for the DOM node, or <code class="prettyprint">null</code> when none is found.
   * 
   * @example <caption>Get the subId for a certain DOM node:</caption>
   * // Foo is ojInputNumber, ojInputTime, etc.
   * var subId = $( ".selector" ).ojFoo( "getSubIdByNode", nodeInsideComponent );
   */
  getSubIdByNode: function(node)
  {
     var timeIcon = $(".oj-inputdatetime-time-icon", this._triggerNode),
        subId = null;
    
    if(node === this._timePickerDisplay[0]) 
    {
      subId = "oj-listbox-drop";
    }
    else if(node === timeIcon[0])
    {
      subId = "oj-inputdatetime-time-icon";
    }
    
    return subId || this._superApply(arguments);
  },
  
  /** 
   * Returns the root node
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  widget : function __widget()
  {
    return this._isIndependentInput() ? this._super() : this._datePickerComp["widget"].widget();
  }
  
});

//////////////////     SUB-IDS     //////////////////

/**
 * <p>Sub-ID for the time drop down div container.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-listbox-drop
 * @memberof oj.ojInputTime
 * @instance
 * 
 * @example <caption>Get the time drop down div container:</caption>
 * // Foo is ojInputTime, ojInputDateTime, etc.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-listbox-drop'} );
 */
 
 /**
 * <p>Sub-ID for the time icon that triggers the time drop down display.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-inputdatetime-time-icon
 * @memberof oj.ojInputTime
 * @instance
 * 
 * @example <caption>Get the time icon that triggers the time drop down display:</caption>
 * // Foo is ojInputTime or ojInputDateTime.
 * var node = $( ".selector" ).ojFoo( "getNodeBySubId", {'subId': 'oj-inputdatetime-time-icon'} );
 */
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class
 * @name oj.ojInputDateTime
 * @augments oj.ojInputDate
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="inputDateTimeOverview-section">
 *   JET ojInputDateTime Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputDateTimeOverview-section"></a>
 * </h3>
 * 
 * <p>Description: ojInputDateTime extends from ojInputDate providing additionally time selection drop down.</p>
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Select the currently focused day</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move up in the grid.</tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move down in the grid.</tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move right in the grid.</tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move left in the grid.</tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Close the grid.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first day of the month.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last day of the month.</tr>
 *     <tr>
 *       <td><kbd>PageUp</kbd></td>
 *       <td>Switch to previous month.</tr>
 *     <tr>
 *       <td><kbd>PageDown</kbd></td>
 *       <td>Switch to next month.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageUp</kbd></td>
 *       <td>Switch to previous year.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageDown</kbd></td>
 *       <td>Switch to next year.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageUp</kbd></td>
 *       <td>Switch to previous by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageDown</kbd></td>
 *       <td>Switch to next by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + T</kbd></td>
 *       <td>Places focus on Today button if it exists.</tr>
 *     <tr>
 *       <td><kbd>Shift + DownArrow or UpArrow</kbd></td>
 *       <td>Shows the timepicker and moves the focus into the expanded timepicker list</td>
 *     </tr>
 * </tbody></table>
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputDateTime" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
  * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * It is up to the application developer to associate the label to the input component.
 * For inputDateTime, you should put an <code>id</code> on the input, and then set 
 * the <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <h3 id="label-section">
 *   Label and InputDateTime
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a label element with the input
 * by putting an <code>id</code> on the input, and then setting the 
 * <code>for</code> attribute on the label to be the input's id.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code>required</code> and <code>help</code> options are set. 
 * </p> 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="dateTimeId" data-bind="ojComponent: {component: 'ojInputDateTime'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputDateTime
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputDateTime();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputDateTime( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="dateTimeId" data-bind="ojComponent: {component: 'ojInputDateTime'}" /&gt;
 */
oj.__registerWidget("oj.ojInputDateTime", $['oj']['ojInputDate'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj",
  
  //-------------------------------------From base---------------------------------------------------//
  _WIDGET_CLASS_NAMES : "oj-inputdatetime-date-time oj-component oj-inputdatetime",
  _INPUT_HELPER_KEY: "inputHelpBoth",
  //-------------------------------------End from base-----------------------------------------------//
  
  options : 
  {
    /**
     * Default converter for ojInputDateTime
     *
     * If one wishes to provide a custom converter for the ojInputDateTime override the factory returned for
     * oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME)
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDateTime
     * @default <code class="prettyprint">oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter({"day": "2-digit", "month": "2-digit", "year": "2-digit", "hour": "2-digit", "hour12": true, "minute": "2-digit"})</code>
     */
    converter : oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
    {
      "day" : "2-digit", "month" : "2-digit", "year" : "2-digit", "hour" : "2-digit", "hour12" : true, "minute" : "2-digit"
    }),
    
    /**
     * Time Picker option is a JSON object containing sub-options for the ojInputDateTime component
     * 
     * <p>
     * The properties supported on the timePicker option are:
     * @property {string=} timeIncrement Time increment to be used for ojInputDateTime, the format is hh:mm:ss:SS. <br/> 
     * The default value is <code class="prettyprint">{timePicker: {timeIncrement': "00:30:00:00"}}</code>. <br/>
     * Example <code class="prettyprint">$(".selector").ojInputDateTime("option", "timePicker.timeIncrement", "00:10:00:00");</code>
     * </p>
     * 
     * @expose
     * @instance
     * @memberof! oj.ojInputDateTime
     * @type {Object.<string>}
     */
    timePicker: 
    {
      /**
       * @expose
       */
      timeIncrement : "00:30:00:00"
    }
    
    /** 
     * The value of the ojInputDateTime component which should be an ISOString
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojInputDateTime({'value': new Date().toISOString()});<br/>
     * @example <caption>Get or set the <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns Today's date in ISOString
     * $(".selector").ojInputDateTime("option", "value");
     * // Setter: sets it to a different date
     * $(".selector").ojInputDateTime("option", "value", new Date(2013, 0, 1, 0, 0, 0, 0).toISOString());
     * 
     * @expose 
     * @name value
     * @instance
     * @memberof! oj.ojInputDateTime
     * @default When the option is not set, the element's value property is used as its initial value 
     * if it exists. This value must be an ISOString.
     */
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _InitBase : function __InitBase() 
  {
    this._super();
    
    this._timePickerElement = this.element; //if the ojInputDateTime is inline, then this ref will change to a NEW input element
    this._timePicker = null;
    this._timeConverter = null;
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _ComponentCreate : function __ComponentCreate()
  {
    var ret = this._super(), 
        timeConverter = this._getTimePickerConverter(this._GetConverter());
    
    if (timeConverter === null)
    {
      throw new Error("Plase use ojInputDate if you do not have time portion");
    }
    
    if (this._isInLine)
    {
      //Since DatePicker never intended to have timepicker associated to it
      //need to have an input element that is tied to the time selector
      
      var input = $("<input type='text'>");
      input.insertAfter(this.element);
      
      //Now need to reset this._timePickerElement to the newly created input element
      this._timePickerElement = input;
    }
    
    //create time instance for the time portion
    this._timePicker = this._timePickerElement.ojInputTime(
    {
      "converter" : timeConverter,
      "min": this.options["min"],
      "max": this.options["max"],
      "value": this._getDate().toISOString(),
      "optionChange" : $.proxy(this._timeSelected, this), 
      "timePicker" : this.options["timePicker"], 
      "datePickerComp" : {"widget": this, "inline": this._isInLine} 
    });
    
    this._timePicker.ojInputTime("option", "disabled", this.options["disabled"]);
    
    return ret;
  },
  
  _setOption : function __setOption(key, value, flags)
  {
    var retVal = this._superApply(arguments);
    
    if(this._timePicker) 
    {
      var timeInvoker = {"disabled": true, "min": true, "max": true};
      
      if (key in timeInvoker)
      {
        this._timePicker.ojInputTime("option", key, value);
      }
      else if(key === "timePicker" && flags["subkey"] === "timeIncrement")
      {
        this._timePicker.ojInputTime("option", "timePicker.timeIncrement", value["timeIncrement"]);
      }
      else if (key === "converter")
      {
        this._timeConverter = null;
        this._timePicker.ojInputTime("option", key, this._getTimePickerConverter(this._GetConverter())); //need to invoke _GetConverter for the case when null and etc sent in
      }
    }
    
    return retVal;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var ret = this._super();

    this._timePicker.ojInputTime("destroy");

    if (this._isInLine)
    {
      //note that this.element below would be of the TimePicker's input element
      this._timePickerElement.remove();
    }
    
    return ret;
  },
  
  /*
   * Will provide the timePicker converter based on the actual converter
   */
  _getTimePickerConverter : function __getTimePickerConverter(converter) 
  {
    if(this._timeConverter !== null) 
    {
      return this._timeConverter;
    }
    
    var resolvedOptions = converter.resolvedOptions(), options = { },
        params = ["hour", "hour12", "minute", "second", "millisecond", "timeFormat"], i, j;

    for (i = 0, j = params.length;i < j;i++)
    {
      if (params[i] in resolvedOptions)
      {
        if(params[i] === "timeFormat") {
          //special case for timeFormat, formatType of time must be added
          options["formatType"] = "time";
        }
        options[params[i]] = resolvedOptions[params[i]];
      }
    }
    
    if ($.isEmptyObject(options))
    {
      return null;
    }
    
    var timeConverter = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(options);
    this._timeConverter = timeConverter;
    return timeConverter;
  },
  
  /**
   * Handler for when the time is selected
   * 
   * @private
   * @param {Event} event
   * @param {Object} params
   */
  _timeSelected : function __timeSelected(event, params)
  {
    
    if(params["option"] === "value" && params["value"])
    {
      this._SetValue(copyTimeOver(params["value"] ? oj.IntlConverterUtils.isoToLocalDate(params["value"]) : new Date(), this._getDate()).toISOString(), event);
    }
    
  },
  
  /**
   * Just for the case of launching timepicker with Shift + Up or Shift + Down
   * 
   * @ignore
   * @protected
   * @override
   * @param {Event} event
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _onKeyDownHandler : function __onKeyDownHandler(event) 
  {
    var kc = $.ui.keyCode, 
        handled = false;
    
    switch (event.keyCode)
    {
      case kc.UP: ;
      case kc.DOWN:
        if(event.shiftKey)
        {
          this._timePicker.ojInputTime("show");
          handled = true;
        }
        break;
      default: ;
    }

    if (handled)
    {
      event.preventDefault();
      event.stopPropagation();
      return false;
    }
    
    return this._superApply(arguments);
  },
  
  /**
   * @ignore
   * @expose
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  show : function __show()
  {
    this._timePicker.ojInputTime("hide");
    return this._super();
  },
  
  /**
   * Method to show the internally created ojInputTime
   * 
   * @expose
   * @memberof! oj.ojInputDateTime
   * @instance
   */
  showTimePicker : function __showTimePicker()
  {
    this.hide();
    return this._timePicker.ojInputTime("show");
  },
  
  /**
   * Method to hide the internally created ojInputTime
   * 
   * @expose
   * @memberof! oj.ojInputDateTime
   * @instance
   */
  hideTimePicker : function __hideTimePicker()
  {
    return this._timePicker.ojInputTime("hide");
  },
  
  /** 
   * @ignore
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  refresh : function __refresh()
  {
    return this._superApply(arguments) || this;
  },
  
  /**
   * So _SetDisplayValue gets invoked when the value gets updated and is the reason that _SetDisplayValue is overridden 
   * rather than _SetValue to update the the internal ojInputTime's value as well as updating the look of the calendar 
   * + time drop down.
   * 
   * @param {String} displayValue of the new string to be displayed
   * @memberof! oj.ojInputDateTime
   * @instance
   * @protected
  */  
  _SetDisplayValue : function (displayValue) 
  {
    this._superApply(arguments);
    
    if(this._timePicker)
    {
      this._timePicker.ojInputTime("option", "value", this.options["value"]);
    }
    
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * 
   * @expose
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    var subId = locator && locator['subId'];
    
    if(subId && (subId === "oj-listbox-drop" || subId === "oj-inputdatetime-time-icon")) 
    {
      return this._timePicker.ojInputTime("getNodeBySubId", locator);
    }
    else 
    {
      return this._superApply(arguments);
    }
    
  },
  
  /**
   * Returns the subId string for the given child DOM node.  For more details, see 
   * <a href="#getNodeBySubId">getNodeBySubId</a>.
   * 
   * @expose
   * @override
   * @memberof oj.ojInputDateTime
   * @instance
   * 
   * @param {!Element} node - child DOM node
   * @return {string|null} The subId for the DOM node, or <code class="prettyprint">null</code> when none is found.
   * 
   * @example <caption>Get the subId for a certain DOM node:</caption>
   * // Foo is ojInputNumber, ojInputDate, etc.
   * var subId = $( ".selector" ).ojFoo( "getSubIdByNode", nodeInsideComponent );
   */
  getSubIdByNode: function(node)
  {
    return this._timePicker.ojInputTime("getSubIdByNode", node) || this._superApply(arguments);
  },
  
  /**
   * Need to override since apparently we allow users to set the converter to null, undefined, and etc and when 
   * they do we use the default converter
   * 
   * @return {Object} a converter instance or null
   * 
   * @memberof! oj.ojInputDateTime
   * @instance
   * @protected
   * @override
   */
  _GetConverter : function () 
  {
    return this.options['converter'] ? 
            this._superApply(arguments) :
            $["oj"]["ojInputDateTime"]["prototype"]["options"]["converter"];
  },
  
  /**
   * 
   * @return {Object} jquery object 
   * 
   * 
   * @expose
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _GetMessagingLauncherElement : function ()
  {
    // pavitra: changing this to be the timepicker element as the messaging launcher is the element 
    // that user inputs
    return !this._isInLine ? this._super() : this._timePickerElement;
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputdatetime";
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _GetTranslationsSectionName: function()
  {
    return "oj-ojInputDate"; 
  }
  
});
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * @export
 * @class oj.FlattenedTreeRowSet
 * @classdesc RowSet wrapper for FlattenedTreeDataSource
 * 
 * @param {oj.FlattenedTreeDataSource} data oj.FlattenedTreeDataSource
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 */
oj.FlattenedTreeRowSet = function(data, options) 
{
  // Initialize
  oj.FlattenedTreeRowSet._init(this, data, options);
};

// Subclass from oj.FlattenedTreeDataSource
oj.Object.createSubclass(oj.FlattenedTreeRowSet, oj.RowSet, "oj.FlattenedTreeRowSet");

/**
 * Initializes the data source.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.Init = function()
{
    oj.FlattenedTreeRowSet.superclass.Init.call(this);
};

oj.FlattenedTreeRowSet._init = function(rowSet, data, options) 
{
  rowSet._eventHandlers = [];
  rowSet._startIndex = 0;
  
  rowSet.Init();
  rowSet._data = data;
  
  // override the fetchSize with -1 if not already specified.
  if (rowSet._data.getOption('fetchSize') == null)
  {
    rowSet._data.getFetchSize = function()
    {
      return -1;
    };
  }
  // override the insert/removeRows function
  rowSet._data.insertRows = function(insertAtIndex, insertAtKey, nodeSet)
  {
    var i, row, rowIdx;
    for (i = 0; i < nodeSet.getCount(); i++)
    {
      rowIdx = insertAtIndex + i;
      row = new oj.ArrayRow(nodeSet.getData(i), {'context': nodeSet.getMetadata(i)});
      row.index = rowIdx;
      row._updateContext = (function(index){
        return function() {
          this['context'] = nodeSet.getMetadata(index);
        };
      })(i);
      rowSet._rows.splice(rowIdx, 0, row);
      oj.FlattenedTreeRowSet.superclass._handleEvent.call(rowSet, oj.RowSet.EventType['ADD'], row);
    }
    oj.FlattenedTreeRowSet._realignRowIndices(0, rowSet._rows);
    if (rowSet._pageSize)
    {
      setTimeout(function(){
        rowSet.fetch({'pageSize': rowSet._pageSize});
      }, 0);
    }
  };
  rowSet._data.removeRows = function(rowKeys)
  {
    var i, row, rowIdx;
    for (i = 0; i < rowKeys.length; i++)
    {
      // indices shift down as we remove
      rowIdx = rowKeys[i].index - i;
      // just create a dummy row for deletion
      row = new oj.ArrayRow({}, null);
      row.index = rowIdx;
      rowSet._rows.splice(rowIdx, 1);
      oj.FlattenedTreeRowSet.superclass._handleEvent.call(rowSet, oj.RowSet.EventType['REMOVE'], row);
    }
    oj.FlattenedTreeRowSet._realignRowIndices(0, rowSet._rows);
    if (rowSet._pageSize)
    {
      setTimeout(function(){
        rowSet.fetch({'pageSize': rowSet._pageSize});
      }, 0);
    }
  };
};

/**
 * Add an instance of this RowSet's Row(s) to the end of the RowSet.
 * @param {oj.Row} row Row object
 * @param {Object=} options at: splice the new Row into the RowSet at the value given (at:index) <p>
 *                          deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * 
 * @returns {Object} if deferred or virtual, return a promise when the set has completed
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.add = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return the Row object found at the given index of the RowSet, or a promise object that will return the Row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the RowSet is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual RowSet or
 *                  if deferred is specified and true, at will return a jQuery promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.at = function(index, options)
{
  return this._rows[index];
};

/**
 * Return a copy of the RowSet
 * @return {Object} copy of the RowSet
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.clone = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Collapse the specified row.
 * @param {Object} rowKey the key of the row to collapse
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.collapse = function(rowKey)
{
  this._data.collapse(rowKey);
};

/**
 * Expand the specified row.
 * @param {Object} rowKey the key of the row to expand
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.expand = function(rowKey)
{
  this._data.expand(rowKey);
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.fetch = function(options)
{
  options = options || {};
  if (options['startIndex'] != null)
  {
    this._startIndex = options['startIndex'];
  }
  // if pageSize is not specified then fetch everything
  var rangeCount = Number.MAX_VALUE;
  
  if (options['pageSize'] != null)
  {
    rangeCount = options['pageSize'];
    this._pageSize = rangeCount;
  }
  
  var startIndex = this._startIndex;
  if (this._rows != null && options['pageSize'] != null)
  {
    var endIndex = this._rows.length - 1;
    
    if (this._startIndex + options['pageSize'] - 1 <= endIndex)
    {
      // we already have the nodes, don't need to do a fetch
      // just update the metadata in case it changed
      var i;
      for (i = 0; i < this._rows.length; i++)
      {
        if (this._rows[i]._updateContext)
        {
          this._rows[i]._updateContext();
        }
      }
      options['refresh'] = true;
      this._endFetch(options, null);
      return;
    }
    else if (this._startIndex <= endIndex)
    {
      startIndex = endIndex + 1;
    }
  }
  
  var rangeOption = {'start': startIndex, 'count':  rangeCount};
  var self = this;
  this._data.fetchRows(rangeOption,
    {
      "success": function(nodeSet)
      {
        self._handleFetchRowsSuccess(nodeSet);
        options['refresh'] = true;
        self._endFetch(options, null);
      }.bind(this),
      "error": function(status)
      {
       self._endFetch(options, status);
      }.bind(this)
    }
  ); 
};

/**
 * Return the first Row object from the RowSet whose Row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the Row when done
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.get = function(id, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 
 * @return {number} The index of the given Row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.indexOf = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Determine if the RowSet has any Rows
 * 
 * @returns {boolean} true if RowSet is empty
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.isEmpty = function()
{
  oj.Assert.failedInAbstractFunction();
  return true;
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.on = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._data.on(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeRowSet.superclass.on.call(this, eventType, eventHandler);
  }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.off = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._data.off(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeRowSet.superclass.off.call(this, eventType, eventHandler);
  }
};

/**
 * Remove a Row from the RowSet, if found.
 * @param {oj.Row} row Row object
 * @param {Object=} options silent: if set, do not fire a remove event
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.remove = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Remove and replace the RowSet's entire list of Rows with a new set of Rows, if provided. Otherwise, empty the RowSet.
 * @param {Object=} data Array of Row objects with which to replace the RowSet's data. 
 * @param {Object=} options user options, passed to event
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.reset = function(data, options)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Return the length of the RowSet
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.size = function()
{ 
  if (!this._rows)
    return 0;
  
  if (this._pageSize && this._rows.length > this._startIndex + this._pageSize)
  {
    return this._startIndex + this._pageSize;
  }
  else
  {
    return this._rows.length;
  }
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.sort = function(criteria)
{
  // delegates to the underlying TreeDataSource but intercept the success callback so that we can clear the cache
  var self = this;
  return this._data.getWrappedDataSource().sort(criteria,
    {"success": function(nodeSet)
      {
        self._data.refresh();
        self.fetch({'startIndex': self._startIndex, 'pageSize': self._pageSize});
      }.bind(this),
      "error": function(status)
      {
        //this._handleFetchRowsError(status, {'start': rowStart, 'count': rowCount}, callbacks, callbackObjects);
      }.bind(this)});
};

/**
 * Return current start index.
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.startIndex = function() {
  return 0;
};

/**
 * Return the total length of the RowSet
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.totalSize = function()
{
  return -1;
};

oj.FlattenedTreeRowSet.prototype._handleFetchRowsSuccess = function(nodeSet)
{
  this._currentNodeSet = nodeSet;
  if (!this._rows)
  {
    this._rows = [];
  }
  oj.FlattenedTreeRowSet._getRowArray(this._currentNodeSet, this, this._rows);
};

/**
 * Indicate ending fetch
 * @private
 */
oj.FlattenedTreeRowSet.prototype._endFetch = function(options, e)
{
  options = options || {}; 
  var success = options['success'];
  var error = options['error'];
  
  if (e != null)
  {
    oj.FlattenedTreeRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['ERROR'], e);
    
    if (error)
    { 
      error.call(this, options, e);
    }
  }
  else
  {
    oj.FlattenedTreeRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['SYNC'], options);
    
    if (success)
    {
      success.call(this, options);
    }
  }
};

oj.FlattenedTreeRowSet._getRowArray = function(nodeSet, rowSet, rows)
{
  var endIndex = nodeSet.getCount() - 1;
  var startIndex = nodeSet.getStart();

  var i;
  for (i = startIndex; i <= endIndex; i++)
  {
    var row = new oj.ArrayRow(nodeSet.getData(i), {'context': nodeSet.getMetadata(i)});
    row._updateContext = (function(index){
        return function() {
          this['context'] = nodeSet.getMetadata(index);
        };
      })(i);
    row['index'] = i;
    rows[i] = row;
    row['rowSet'] = rowSet;
  }
};

// Realign all the indices of the rows (after sort for example)
oj.FlattenedTreeRowSet._realignRowIndices = function(start, rows)
{
  var row;
  for (var i = start; i < rows.length; i++)
  {
    row = rows[i];
    if (row)
    {
      row['index'] = i;
    }
  }
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.TableDataSource
 * @classdesc Abstract object representing data used by table component
 * @param {Object} data data supported by the components
 * @param {Object|null} options Array of options for the TableDataSource
 * @constructor
 */
oj.TableDataSource = function(data, options)
{
  if (this.constructor == oj.TableDataSource)
  {
    // This should only be called by the constructors of the subclasses. If you need
    // to initialize a new TableDataSource then call the constructors of the subclasses such
    // as oj.ArrayTableDataSource or oj.CollectionTableDataSource.
    var errSummary = oj.TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY;
    var errDetail = oj.TableDataSource._LOGGER_MSG._ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL;
    throw new Error(errSummary + '\n' + errDetail);
  }
  // Initialize
  this.data = data;
  this.options = options;
  this.isFetching = false;
  this._startIndex = 0;
  this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.TableDataSource, oj.DataSource, "oj.TableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.Init = function()
{
  oj.TableDataSource.superclass.Init.call(this);
};

/**
 * Return the oj.Row object found at the given index of the RowSet.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @return {Object} oj.Row object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.at = function(index)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 *                  success: a user callback called when the fetch has completed successfully. The callback is called passing the TableDataSource object and the fetch options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the TableDataSource object and the fetch options argument.<p>
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.fetch = function(options)
{
  oj.Assert.failedInAbstractFunction();
  return oj.Object.__getPromise(function(resolve, reject) {
          reject();
        });
};

/**
 * Return the first oj.Row object from the RowSet whose Row id value is the given id
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.get = function(id)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.getCapability = function(feature)
{
    return null;
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row oj.Row object to locate 
 * @return {number} The index of the given Row object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.indexOf = function(row)
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Get the length of the RowSet.
 * limit it.
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.size = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Performs a sort on the data source. Null criteria clears the existing sort.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise} promise object triggering done when complete.
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.sort = function(criteria)
{
  oj.Assert.failedInAbstractFunction();
  return oj.Object.__getPromise(function(resolve, reject) {
        reject();
      });
};

/**
 * Get or set the current start index.
 * @param {number} startIndex start index
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.startIndex = function(startIndex) 
{
  if (startIndex != null)
  {
    this._startIndex = startIndex;
  }
  return this._startIndex;
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.totalSize = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Event types
 * @enum {string}
 */
oj.TableDataSource.EventType =
  {
    /** Triggered when a Row is added to a TableDataSource */
    'ADD': "add",
    /** Triggered when a Row is removed from a TableDataSource */
    'REMOVE': "remove",
    /** Triggered when a TableDataSource is reset */
    'RESET': "reset",
    /** Triggered when a TableDataSource is refreshed */
    'REFRESH': "refresh",
    /** Triggered when a TableDataSource is sorted */
    'SORT': "sort",
    /** Triggered when a Row's attributes are changed */
    'CHANGE': "change",
    /** Triggered when a TableDataSource has sent a fetch request */
    'REQUEST': "request",
    /** Triggered when a TableDataSource has been updated by a fetch */
    'SYNC': "sync",
    /** Triggered when an error occurred on the TableDataSource */
    'ERROR': "error"
  };

/**
 * @const
 * @export
 */
oj.TableDataSource._LOGGER_MSG =
  {
    '_ERR_TABLE_DATASOURCE_INSTANTIATED_SUMMARY': 'oj.TableDataSource constructor called.',
    '_ERR_TABLE_DATASOURCE_INSTANTIATED_DETAIL':  'Please do not instantiate oj.TableDataSource. Please use one of the subclasses instead such as oj.ArrayTableDataSource or oj.CollectionTableDataSource.',
    '_ERR_DATA_INVALID_TYPE_SUMMARY':             'Invalid data type.',
    '_ERR_DATA_INVALID_TYPE_DETAIL':              'Please specify the appropriate data type.'
  };
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.PagingTableDataSource
 * @classdesc Object representing data used by the paging component
 * @param {Object} dataSource
 * @param {Object|null} options Array of options for the PagingControlDataSource
 * @constructor
 */
oj.PagingTableDataSource = function(dataSource, options)
{
  // Initialize
  options = options || {};
  
  if (!(dataSource instanceof oj.TableDataSource))
  {
    // we only support Array, oj.Collection, or ko.observableArray. To
    // check for observableArray, we can't do instanceof check because it's
    // a function. So we just check if it contains a subscribe function.
    var errSummary = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_SUMMARY'];
    var errDetail = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_DETAIL'];
    throw new Error(errSummary + '\n' + errDetail);
  }
  this.dataSource = dataSource;
  this._startIndex = 0;
  this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.PagingTableDataSource, oj.PagingDataSource, "oj.PagingTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.Init = function()
{
  oj.PagingTableDataSource.superclass.Init.call(this);
};

/**
 * Retrieves the underlying DataSource.
 * @return {Object} the underlying oj.DataSource.
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.getWrappedDataSource = function()
{
    return this.dataSource;
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 *                  success: a user callback called when the fetch has completed successfully. The callback is called passing the PagingTableDataSource object and the fetch options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the PagingTableDataSource object and the fetch options argument.<p>
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.fetch = function(options)
{
  if (options != null)
  {
    this._startIndex = options['startIndex'];
    if (options['reset']) {
        this._currentStartIndex = undefined;
    }
  }
  var pageSize = options['pageSize'] != null ? options['pageSize'] : this._pageSize;
  options['pageSize'] = pageSize;
  options['startIndex'] = this._startIndex;
  var self = this;
  return oj.Object.__getPromise(function(resolve, reject) {
    options['success'] = function()
    {
      resolve();
      self._fetchType = options['fetchType'];
    };
    options['error'] = function()
    {
      reject();
    }
    self.dataSource.fetch(options);
  });
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.next = function()
{
  if (this.dataSource.totalSize() == -1 || this.dataSource.totalSize() > this._startIndex)
  {
    if (!this._currentStartIndex)
    {
      this._currentStartIndex = this._startIndex + this._pageSize;
    }
    else
    {
      this._currentStartIndex = this._currentStartIndex + this._pageSize;
    }
    this._currentPageSize = this._currentPageSize + this._pageSize;
    var self = this;
    return this.dataSource.fetch({'startIndex': this._currentStartIndex, 'pageSize': this._pageSize, 'fetchType': 'next', 'success' : function()
    {
      self._fetchType = 'next';
    }});
  }
  return oj.Object.__getPromise(function(resolve, reject) {
        reject();
      });
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.previous = function()
{
  if (this._startIndex != 0 || this._startIndex != -1)
  {
    this._startIndex = this._startIndex - this._pageSize;
    this._startIndex = this._startIndex < 0 ? 0 : this._startIndex;
    this._currentPageSize = this._currentPageSize - this._pageSize;
    var self = this;
    return this.dataSource.fetch({'startIndex': this._currentStartIndex, 'pageSize': this._pageSize, 'fetchType': 'previous', 'success' : function()
    {
      self._fetchType = 'previous';
    }});
  }
  return oj.Object.__getPromise(function(resolve, reject) {
      reject();
    });
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.setPageSize = function(n) {
  this._pageSize = n;
  this._currentPageSize = this._startIndex + n;
};

/**
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.startIndex = function() {
  return this._startIndex;
};


/**** start delegated functions ****/

/**
 * Return the model object found at the given index of the collection.
 * 
 * @param {number} index Index for which to return the model object. 
 * @return {Object} Model object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.at = function(index)
{
  return this.dataSource.at(index);
};

/**
 * Return the first model object from the collection whose model id value is the given id or cid, or the id or cid from a passed in model
 * @param {Object|string} id ID, cid, or Model (see Model id or cid) for which to return the model object, if found. 
 * @return {Object} First model object in the collection where model.id = id or model.cid = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.get = function(id)
{
  return this.dataSource.get(id);
};

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.getCapability = function(feature)
{
  return this.dataSource.getCapability(feature);
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.hasMore = function()
{
  return this.dataSource.hasMore();
};

/**
 * Return the array index location of the given model object.
 * @param {Object} model Model object to locate 
 * @return {number} The index of the given model object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.indexOf = function(model)
{
  return this.dataSource.indexOf(model);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @return {function(Object)} the event handler function attached to the event 
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.on = function(eventType, eventHandler)
{
  var self = this;
  var dataSource = (/** @type {{on: Function}} */ (this.dataSource));
  
  if (eventType == oj.TableDataSource.EventType['SYNC'])
  {
    var ev = function(event){self._handleSyncEvent(event, eventHandler);}
    dataSource.on(eventType, ev);
    return ev;
  }
  else
  {
    dataSource.on(eventType, eventHandler);
    return eventHandler;
  }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.off = function(eventType, eventHandler)
{
  var dataSource = (/** @type {{off: Function}} */ (this.dataSource));
  return dataSource.off(eventType, eventHandler);
};

/**
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.size = function()
{
  if (this._currentPageSize != null && this._currentPageSize > 0)
  {
    if (this.dataSource.size() > this._currentPageSize)
    {
      return this._currentPageSize;
    }
  }
  return this.dataSource.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise} promise object triggering done when complete.
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.sort = function(criteria)
{
  return this.dataSource.sort(criteria);
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.totalSize = function()
{
  return this.dataSource.totalSize();
};

/**** end delegated functions ****/

oj.PagingTableDataSource.prototype._handleSyncEvent = function(event, eventHandler)
{
  var self = this;
  setTimeout(function()
    {
      if (self._fetchType == 'next' || event['fetchType'] == 'next')
      {
        var dataSource = (/** @type {{handleEvent: Function}} */ (self.dataSource));
        var startIndex = event['startIndex'];
        var pageSize = event['pageSize'];
        self._startIndex = 0;
        self._fetchType = null;
        var i;

        var end = startIndex + pageSize;
        if (end > dataSource.size()) {
            // Don't ask beyond the known end
            end = dataSource.size();
        }
        for (i = startIndex; i < startIndex + pageSize; i++)
        {
          dataSource.handleEvent(oj.RowSet.EventType['ADD'], self.dataSource.at(i));
        }
        eventHandler(event);
      }
      else
      {
        eventHandler(event);
      }
    }, 0);
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.ArrayTableDataSource
 * @classdesc Object representing data used by table component
 * @param {Array|Object|function():Array} data data supported by the components
 * @param {Object|null} options Array of options for the TableDataSource
 * @constructor
 */
oj.ArrayTableDataSource = function(data, options)
{
  // Initialize
  this.data = {};   // This was put in to keep closure happy...
  if (!(data instanceof Array) &&
      (typeof (data) != 'function' &&
       typeof (data.subscribe) != 'function'))
  {
    // we only support Array or ko.observableArray. To
    // check for observableArray, we can't do instanceof check because it's
    // a function. So we just check if it contains a subscribe function.
    var errSummary = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_SUMMARY'];
    var errDetail = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_DETAIL'];
    throw new Error(errSummary + '\n' + errDetail);
  }

  oj.ArrayTableDataSource.superclass.constructor.call(this, data, options);

  this._rowSet = new oj.ArrayRowSet(/** @type Array */ (data), this.options);
  this._addRowSetEventListeners();

  if ((options != null && (options['startFetch'] == 'enabled' || options['startFetch'] == null))
    || options == null)
  {
    this._startFetchEnabled = true;
  }
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.ArrayTableDataSource, oj.TableDataSource, "oj.ArrayTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.Init = function()
{
  oj.ArrayTableDataSource.superclass.Init.call(this);
};

/**
 * Add an instance of oj.Row to the end of the RowSet.
 * @param {Object} m Row object (or array of rows) to add. These can be already-created instance of the oj.Row object, or sets of attribute/values, which will be wrapped by add().
 * @param {Object=} options silent: if set, do not fire an add event<p>
 *                          at: splice the new Row into the RowSet at the value given (at:index) <p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.add = function(m, options)
{
  this._rowSet.add(m, options);
};

/**
 * Return the oj.Row object found at the given index of the RowSet.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @return {Object} oj.Row object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.at = function(index)
{
  return this._rowSet.at(index);
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 *                  success: a user callback called when the fetch has completed successfully. The callback is called passing the ArrayTableDataSource object and the fetch options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the ArrayTableDataSource object and the fetch options argument.<p>
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.fetch = function(options)
{
  options = options || {};
  var self = this;
  var success = options['success'];
  var error = options['error'];
  var context = options['context'] == null? this : options['context'];
  var fetchType = options['fetchType'];
  
  if (fetchType == 'init' && !this._startFetchEnabled)
  {
    return oj.Object.__getPromise(function(resolve, reject) {
        resolve();
      });
  }
  
  if (options['startIndex'] != null)
  {
    oj.ArrayTableDataSource.superclass.startIndex.call(this, options['startIndex']);
  }
  var data = this.data;
  
  return oj.Object.__getPromise(function(resolve, reject) {
    options['success'] = function()
    {
      if (success != null)
      {
        success.call(context, self, options);
      }
      resolve();
    };
    options['error'] = function(options, e)
    {
      if (error != null)
      {
        error.call(context, self, options, e);
      }
      reject();
    }
    if (options['startFetch'] == 'enabled')
    {
      // only do an initial fetch if rowSet is empty
      if (self._rowSet.isEmpty() ||
        (typeof self._rowSet.size() === 'undefined'))
      {
        self._rowSet.fetch(options);
      }
    }
    else
    {
      self._rowSet.fetch(options);
    }
  });
};

/**
 * Return the first oj.Row object from the RowSet whose Row id value is the given id
 * @param {string} id ID for which to return the Row object, if found. 
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.get = function(id)
{
  return this._rowSet.get(id);
};

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 */
oj.ArrayTableDataSource.prototype.getCapability = function(feature)
{
    return 'full';
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.hasMore = function()
{
  if (this._rowSet != null)
  {
    return this._rowSet.hasMore();
  }
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row oj.Row object to locate 
 * @return {number} The index of the given Row object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.indexOf = function(row)
{
  return this._rowSet.indexOf(row);
};

/**
 * Remove a Row from the RowSet, if found.
 * @param {Object} m oj.Row object or array of Rows to remove. 
 * @param {Object=} options silent: if set, do not fire a remove event 
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.remove = function(m, options)
{
  this._rowSet.remove(m, options);
};

/**
 * Remove and replace the RowSet's entire list of Rows with a new set of Rows, if provided. Otherwise, empty the RowSet.
 * @param {Object=} data Array of Row objects or attribute/value pair objects with which to replace the RowSet's data. 
 * @param {Object=} options user options, passed to event
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.reset = function(data, options)
{
  this._rowSet.reset(data, options);
};

/**
 * Get the length of the RowSet.
 * limit it.
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.size = function()
{
  return this._rowSet.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise} promise object triggering done when complete.
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.sort = function(criteria)
{
  if (criteria == null)
  {
    this._rowSet['comparator'] = null;
    return oj.Object.__getPromise(function(resolve, reject) {
      resolve();
    }); 
  }
  
  var key = criteria['key']; 
  var direction = criteria['direction'];
  var comparator = null;
  
  if (direction == 'ascending')
  {
    comparator = function(row) {
      if ($.isFunction(row.get))
      {
        return row.get(key);
      }
      else
      {
        return row[key]();
      }
    };
  }
  else if (direction == 'descending')
  {
    comparator = function(rowA, rowB) {
      var a, b;
      if ($.isFunction(rowA.get))
      {
        a = rowA.get(key);
        b = rowB.get(key);
      }
      else
      {
        a = rowA[key]();
        b = rowB[key]();
      }
      if (a === b)
      {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  this._rowSet['comparator'] = comparator;
  var self = this;
  
  return oj.Object.__getPromise(function(resolve, reject) {
     self._rowSet.sort();
     resolve();
  });
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.totalSize = function()
{
  return this._rowSet.totalSize();
};

/**
 * Add event listeners to the RowSet
 * @private
 */
oj.ArrayTableDataSource.prototype._addRowSetEventListeners = function()
{
  var self = this;
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ADD'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['ADD'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REMOVE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['REMOVE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REQUEST'], function(event) {
    self.isFetching = true;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['REQUEST'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['RESET'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['RESET'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SORT'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['SORT'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['CHANGE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['CHANGE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SYNC'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['SYNC'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ERROR'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['ERROR'], event);
  });
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * The ojTable component enhances a HTML table element into one that supports all
 * the features in JET Table.
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * When existing focus is on a column header.
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Navigate to next focusable element on page (outside table).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Navigate to previous focusable element on page (outside table).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move focus to the first row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Do nothing.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move focus to previous column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+LeftArrow</kbd></td>
 *       <td>Select and move focus to previous column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move focus to next column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+RightArrow</kbd></td>
 *       <td>Select and move focus to next column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Space</kbd></td>
 *       <td>Select column.</td>
 *     </tr>
 * </tbody></table>
 * When existing focus is on a row element.
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next focusable element in row.
 *           <br>If focus is on the last focusable element in the row, move focus to first focusable element in next row.
 *           <br>If focus is on the last focusable element in the last row, move focus to next focusable element on the page (outside table).
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous focusable element in row.
 *           <br>If focus is on the first focusable element in the row, move focus to last focusable element in previous row.
 *           <br>If focus is on the first focusable element in the first row, move focus to previous focusable element on the page (outside table).
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move focus to the next row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+DownArrow</kbd></td>
 *       <td>Select and move focus to the next row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move focus to the previous row. If at the first row then move to the column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+UpArrow</kbd></td>
 *       <td>Select and move focus to the previous row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Do nothing.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Do nothing.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Space</kbd></td>
 *       <td>Select row.</td>
 *     </tr>
 * </tbody></table>
 * 
 * <h3>Support for knockout templates:</h3>
 * When knockout bindings are used, the following additional options are available to use
 * knockout templates to customize JET Table.
 * <ul>
 *   <li>template<p>
 *   The name of the knockout template for the cells in a column.
 *   <li>headerTemplate<p>
 *   The name of the knockout template for the header in a column.
 *   </li>
 *   <li>footerTemplate<p>
 *   The name of the knockout template for the footer in a column.
 *   </li>
 *   <li>rowTemplate<p>
 *   The name of the knockout template for each row to use.
 *   </li>
 * </ul>
 * 
 * @example  <caption>Initialize the table via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
 *      [{headerText: 'Department Id', field: 'DepartmentId'},
 *      {headerText: 'Department Name', field: 'DepartmentName'},
 *      {headerText: 'Location Id', field: 'LocationId'},
 *      {headerText: 'Manager Id', field: 'ManagerId'}]}"&gt;
 *      
 * @example  <caption>Initialize the table with column templates via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
 *      [{headerText: 'Department Id', field: 'DepartmentId'},
 *      {headerText: 'Department Name', field: 'DepartmentName'},
 *      {headerText: 'Location Id', field: 'LocationId'},
 *      {headerText: 'Manager Id', field: 'ManagerId'}]},
 *      {headerTemplate: 'oracle_link_hdr', template: 'oracle_link'}]}"&gt;
 * &lt;script type="text/html" id="oracle_link_hdr"&gt;
 *    &lt;th style="padding-left: 5px; padding-right: 5px;"&gt;
 *       Oracle Link
 *    &lt;/th&gt;
 * &lt;/script&gt;
 * &lt;script type="text/html" id="oracle_link"&gt;
 *     &lt;td&gt;
 *         &lt;a href="http://www.oracle.com"&gt;Oracle&lt;/a&gt;
 *     &lt;/td&gt;
 * &lt;/script&gt;
 *
 * @example  <caption>Initialize the table with rowTemplate via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
 *      [{headerText: 'Department Id', field: 'DepartmentId'},
 *      {headerText: 'Department Name', field: 'DepartmentName'},
 *      {headerText: 'Location Id', field: 'LocationId'},
 *      {headerText: 'Manager Id', field: 'ManagerId'}],
 *      rowTemplate: 'row_tmpl'}"&gt;
 * &lt;script type="text/html" id="row_tmpl"&gt;
 *   &lt;tr&gt;
 *       &lt;td data-bind="text: DepartmentId"&gt;
 *       &lt;/td&gt;
 *       &lt;td data-bind="text: DepartmentName"&gt;
 *       &lt;/td&gt;
 *       &lt;td data-bind="text: LocationId"&gt;
 *       &lt;/td&gt;
 *       &lt;td data-bind="text: ManagerId"&gt;
 *       &lt;/td&gt;
 *   &lt;/tr&gt;
 * &lt;/script&gt;
 * 
 * @class
 * @constructor
 * @name oj.ojTable
 * @augments oj.baseComponent
 */
(function() {
  oj.__registerWidget("oj.ojTable", $['oj']['baseComponent'],
    {
      version: '1.0.0',
      defaultElement: '<table>',
      widgetEventPrefix: 'oj',
      options:
        {
          /** 
           * Accessibility options. 
           * <p>
           * The following options are supported:
           * <ul>
           *   <li>rowHeader: columnId</li>
           * </ul>
           * The td cells in the column specified by the rowHeader
           * attribute will be assigned an id and then referenced by the
           * headers attribute in the rest of the cells in the row.
           * This is required by screenReaders. By default the first column
           * will be taken as the rowHeader.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {Object.<string, string>|null}
           * @property {string} rowHeader the column id to be used as the row header by screen readers
           * @default <code class="prettyprint">null</code>
           */
          accessibility: null,
          /** 
           * The current row the user has navigated to. Can be an index and/or key value.
           * When both are specified, the index is used as a hint.
           * Returns the current row or null if there is none.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {Object}
           * @default <code class="prettyprint">null</code>
           * 
           * @example <caption>Get the current row:</caption>
           * $( ".selector" ).ojTable("option", "currentRow");
           * 
           * @example <caption>Set the current row on the table during initialization:</caption>
           * $(".selector").ojTable({"currentRow", {rowKey: '123'}});
           * 
           * @example <caption>Set the current row on the table during initialization:</caption>
           * $(".selector").ojTable({"currentRow", {rowIndex: 1}});
           *
           * @example <caption>Set the current row on the table after initialization:</caption>
           * $(".selector").ojTable({"option", "currentRow", {rowKey: '123'}});
           * 
           * @example <caption>Set the current row on the table after initialization:</caption>
           * $(".selector").ojTable({"option", "currentRow", {rowIndex: 1}});
           */
          currentRow: null,
          /** 
           * The data to bind to the component. 
           * <p>
           * Must be of type oj.TableDataSource {@link oj.TableDataSource}
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {oj.TableDataSource|null}
           * @default <code class="prettyprint">null</code>
           */
          data: null,
          /**
           * The text to display when there are no data in the Table. If it is not defined, 
           * then a default empty text is extracted from the resource bundle.
           * 
           * @expose 
           * @memberof! oj.ojTable
           * @instance
           * @type {string|null}
           * @default <code class="prettyprint">"No data to display."</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">emptyText</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, emptyText: 'No data', columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          emptyText: null,
          /** 
           * Whether the horizontal gridlines are to be drawn.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {string}
           * @default <code class="prettyprint">"enabled"</code>
           */
          horizontalGridVisible: 'enabled',
          /** 
           * The row renderer function to use.
           * <p>
           * The renderer function will be passed in an Object which contains the fields:
           * <ul>
           *   <li>component: Instance of the component</li>
           *   <li>row: Key/value pairs of the row</li>
           *   <li>status: Contains the rowIndex, rowKey, and currentRow</li>
           *   <li>parentElement: Empty rendered TR element</li>
           * </ul>
           * The function returns  either a String or 
           * a DOM element of the content inside the row. If the developer chooses 
           * to manipulate the row element directly, the function should return 
           * nothing.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {Function|null}
           * @default <code class="prettyprint">null</code>
           */
          rowRenderer: null,
          /**
           * Specifies the current selections in the table. Can be either an index or key value.
           * When both are specified, the index is used as a hint.
           * Returns an array of range objects, or an empty array if there's no selection.
           * 
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable
           * @type {Array.<Object>}
           * @default <code class="prettyprint">[]</code>
           * 
           * @example <caption>Get the current selection:</caption>
           * $( ".selector" ).ojTable("option", "selection");
           * 
           * @example <caption>Set a row selection on the table during initialization:</caption>
           * $(".selector").ojTable({"selection", [{startIndex: {"row":1}, endIndex:{"row":3}}]});
           * 
           * @example <caption>Set a column selection on the table during initialization:</caption>
           * $(".selector").ojTable({"selection", [{startIndex: {"column":2}, endIndex: {"column":4}}]});
           *
           * @example <caption>Set a row selection on the table after initialization:</caption>
           * $(".selector").ojTable("option", "selection", [{startIndex: {"row":1}, endIndex:{"row":3}}]);
           * 
           * @example <caption>Set a column selection on the table after initialization:</caption>
           * $(".selector").ojTable("option", "selection", [{startIndex: {"column":1}, endIndex: {"column":3}}]);
           * 
           * @example <caption>Set a row selection on the table after initialization:</caption>
           * $(".selector").ojTable("option", "selection", [{startKey: {"row":10}, endKey:{"row":30}}]);
           * 
           * @example <caption>Set a column selection on the table after initialization:</caption>
           * $(".selector").ojTable("option", "selection", [{startKey: {"column": column1}, endKey: {"column": column2}}]);
           */
          selection: [],  
          /** 
           * The row and column selection modes. Both can be either single or multiple.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {Object.<string, string>|null}
           * @property {string} row single or multiple selection for rows
           * @property {string} column single or multiple selection for columns
           * @default <code class="prettyprint">null</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">selectionMode</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, selectionMode: {row: 'multiple', column: 'multiple'}, columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          selectionMode: null,
          /** 
           * Whether the vertical gridlines are to be drawn.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {string}
           * @default <code class="prettyprint">"enabled"</code>
           */
          verticalGridVisible: 'enabled',
          /** 
           * An array of column definitions.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {Array.<Object>|null}
           * @default <code class="prettyprint">null</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">columns</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          columns: [{
              /** 
               * The renderer function that renders the content of the cell. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>data: The cell data</li>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>row: Key/value pairs of the row</li>
               *   <li>status: Contains the rowIndex, rowKey, and currentRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the cell data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable
               * @alias columns.renderer
               * @type {Function|null}
               * @default <code class="prettyprint">null</code>
               */
              renderer: null,
              /** 
               * The CSS class to apply to the column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable
               * @alias columns.className
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              className: null,
              /** 
               * The data field this column refers to. 
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.field
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              field: null,
              /** 
               * The CSS class to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.footerClassName
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              footerClassName: null,
              /** 
               * The renderer function that renders the content of the footer. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>status: Contains the rowIndex, rowKey, and currentRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the footer. If the developer chooses 
               * to manipulate the footer element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the footer data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.footerRenderer
               * @type {Function|null}
               * @default <code class="prettyprint">null</code>
               */
              footerRenderer: null,       
              /** 
               * The CSS styling to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.footerStyle
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              footerStyle: null,
              /** 
               * The CSS class to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.headerClassName
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              headerClassName: null,
              /** 
               * The renderer function that renders the content of the header. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>parentElement: Empty rendered TH element</li>
               * </ul>
               * The function returns either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the header data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.headerRenderer
               * @type {Function|null}
               * @default <code class="prettyprint">null</code>
               */
              headerRenderer: null, 
              /** 
               * The CSS styling to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.headerStyle
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              headerStyle: null,
              /** 
               * Text to display in the header of the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.headerText
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              headerText: null,
              /** 
               * The identifier for the column
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.id
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              id: null,
              /** 
               * Whether or not the column is sortable. 
               * <p>
               * A sortable column has a clickable header that (when clicked) 
               * sorts the table by that column's property. Note that 
               * in order for a column to be sortable, this attribute 
               * must be set to "enabled" and the underlying model must 
               * support sorting by this column's property. If this attribute
               * is set to "auto" then the column will be sortable if the
               * underlying model supports sorting. A value of "none" will
               * disable sorting on the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.sortable
               * @type {string|null}
               * @default <code class="prettyprint">"auto"</code>
               */
              sortable: 'auto',
              /** 
               * This is the property that the framework uses to 
               * sort the Table's data.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.sortProperty
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              sortProperty: null,
              /** 
               * The CSS styling to apply to the column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columns.style
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              style: null
            }],
          /** 
           * Default values to apply to all columns objects.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @type {Object.<string, string|null>}
           * @default <code class="prettyprint">null</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">columnsDefault</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columnsDefault: {headerStyle: 'text-align: left; white-space:nowrap;'}, columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          columnsDefault: {
              /** 
               * The renderer function that renders the content of the cell. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>data: The cell data</li>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>row: Key/value pairs of the row</li>
               *   <li>status: Contains the rowIndex, rowKey, and currentRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the cell data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable
               * @alias columnsDefault.renderer
               * @type {Function|null}
               * @default <code class="prettyprint">null</code>
               */
              renderer: null,
              /** 
               * The default CSS class for column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.className
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              className: null,
              /** 
               * The default data field for column. 
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.field
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              field: null,
              /** 
               * The CSS class to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.footerClassName
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              footerClassName: null,
              /** 
               * The renderer function that renders the content of the footer. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>status: Contains the rowIndex, rowKey, and currentRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the footer. If the developer chooses 
               * to manipulate the footer element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the footer data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.footerRenderer
               * @type {Function|null}
               * @default <code class="prettyprint">null</code>
               */
              footerRenderer: null, 
              /** 
               * The CSS styling to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.footerStyle
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              footerStyle: null,
              /** 
               * The default CSS class to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.headerClassName
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              headerClassName: null,
              /** 
               * The renderer function that renders the content of the header. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>parentElement: Empty rendered TH element</li>
               * </ul>
               * The function returns either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the header data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.headerRenderer
               * @type {Function|null}
               * @default <code class="prettyprint">null</code>
               */
              headerRenderer: null, 
              /** 
               * The default CSS styling to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.headerStyle
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              headerStyle: null,
              /** 
               * Default text to display in the header of the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.headerText
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              headerText: null,
              /** 
               * Whether or not the column is sortable. 
               * <p>
               * A sortable column has a clickable header that (when clicked) 
               * sorts the table by that column's property. Note that 
               * in order for a column to be sortable, this attribute 
               * must be set to "enabled" and the underlying model must 
               * support sorting by this column's property. If this attribute
               * is set to "auto" then the column will be sortable if the
               * underlying model supports sorting. A value of "none" will
               * disable sorting on the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.sortable
               * @type {string|null}
               * @default <code class="prettyprint">"auto"</code>
               */
              sortable: 'auto',
              /** 
               * Default property that the framework uses to 
               * sort the Table's data.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.sortProperty
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              sortProperty: null,
              /** 
               * Default CSS styling to apply to the column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @alias columnsDefault.style
               * @type {string|null}
               * @default <code class="prettyprint">null</code>
               */
              style: null
            },
            /**
              * Triggered before the current row is changed via the <code class="prettyprint">currentRow</code> option or via the UI.
              *
              * @expose 
              * @event 
              * @memberof! oj.ojTable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Parameters
              * @property {Object} ui.currentRow the new current row
              * @property {number} ui.previousCurrentRow the old current row
              * 
              * @example <caption>Initialize the table with the <code class="prettyprint">beforeCurrentRow</code> callback specified:</caption>
              * $( ".selector" ).ojTable({
              *     "beforeCurrentRow": function( event, data ) {}
              * });
              *
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforecurrentrow</code> event:</caption>
              * $( ".selector" ).on( "ojbeforecurrentrow", function( event, data ) {} );
              */
            beforeCurrentRow: null,
            /**
              * Triggered when selection is changed via the <code class="prettyprint">selection()</code> method or via the UI.
              *
              * @expose 
              * @event 
              * @memberof! oj.ojTable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Parameters
              * @property {Array} ui.selection the table selection object
              * 
              * @example <caption>Initialize the table with the <code class="prettyprint">select</code> callback specified:</caption>
              * $( ".selector" ).ojTable({
              *     "select": function( event, data ) {}
              * });
              *
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
              * $( ".selector" ).on( "ojselect", function( event, data ) {} );
              */
            select: null,
            /** 
              * Translations for the component
              * @expose 
              * @public 
              * @instance
              * @memberof! oj.ojTable
              * @type {Object.<string, string>}
              * @property {string} labelSelectRow Select row label
              * @property {string} labelSelectColumn Select column label
              * @property {string} labelSort Context menu label for sort
              * @property {string} labelSortAsc Context menu label for sort ascending
              * @property {string} labelSortDsc Context menu label for sort descending
              * @property {string} msgFetchingData Fetching data message
              * @property {string} msgNoData No data to display message
              */
            translations: {}
        },
      /**
       * @const
       * @private
       */
      _BUNDLE_KEY:
        {
          _MSG_FETCHING_DATA:                             'msgFetchingData',
          _MSG_NO_DATA:                                   'msgNoData',
          _LABEL_SELECT_COLUMN:                           'labelSelectColumn',
          _LABEL_SELECT_ROW:                              'labelSelectRow'
        },
      /**
       * @const
       * @private
       */
      _LOGGER_MSG:
        {
          _ERR_PRECURRENTROW_ERROR_SUMMARY:                'Did not change current row due to error.',
          _ERR_PRECURRENTROW_ERROR_DETAIL:                 'Error detail: {error}.',
          _ERR_CURRENTROW_UNAVAILABLE_INDEX_SUMMARY:       'Did not change current row due to unavailable row index.',
          _ERR_CURRENTROW_UNAVAILABLE_INDEX_DETAIL:        'Unavailable row index: {rowIdx}.',
          _ERR_REFRESHROW_INVALID_INDEX_SUMMARY:          'Invalid row index value.',
          _ERR_REFRESHROW_INVALID_INDEX_DETAIL:           'Row index: {rowIdx}.',
          _ERR_DATA_INVALID_TYPE_SUMMARY:                 'Invalid data type.',
          _ERR_DATA_INVALID_TYPE_DETAIL:                  'Please specify the appropriate data type.'
        },
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_ID:                                  '_headerColumn',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_TEXT_ID:                             '_headerColumnText',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_ASC_ID:                              '_headerColumnAsc',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_DSC_ID:                              '_headerColumnDsc',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_ID_PREFIX:                           '_hdrCol',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_AUTO:                                       'auto',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_ENABLED:                                    'enabled',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_DISABLED:                                   'disabled',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_NONE:                                       'none',
      /**
       * @private
       * @const
       */
      _OPTION_SELECTION_MODES:
        {
          _SINGLE:                                        'single',
          _MULTIPLE:                                      'multiple'
        },
      /**
       * @private
       * @const
       */
      _COLUMN_SORT_ORDER:
        {
          _ASCENDING:                                     'ascending',
          _DESCENDING:                                    'descending'
        },
      /**
       * @private
       * @const
       */
      _KEYBOARD_CODES:
        {
          _KEYBOARD_CODE_SHIFT:                           16,
          _KEYBOARD_CODE_SPACEBAR:                        32,
          _KEYBOARD_CODE_ENTER:                           13,
          _KEYBOARD_CODE_UP:                              38,
          _KEYBOARD_CODE_DOWN:                            40,
          _KEYBOARD_CODE_LEFT:                            37,
          _KEYBOARD_CODE_RIGHT:                           39,
          _KEYBOARD_CODE_HOME:                            36,
          _KEYBOARD_CODE_END:                             35,
          _KEYBOARD_CODE_TAB:                             9,
          _KEYBOARD_CODE_ESC:                             27,
          _KEYBOARD_MODIFIER_SHIFT:                       'shiftKey'
        },
      /**** start Public APIs ****/
      /**
       * Get the column metadata
       * @param {number} columnIdx  Column index of the column. Null returns all columns
       * @return {Object|null} Column metadata or null if not found
       * @export
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @example <caption>Invoke the <code class="prettyprint">columnMetaData</code> method:</caption>
       * $( ".selector" ).ojTable( "columnMetaData", "columnId1" );
       */
      'columnMetaData': function(columnIdx)
      {
        var columns = this._getColumnDefs();

        if (columnIdx === null || arguments.length == 0)
        {
          return columns;
        }
        else
        {
          return columns[columnIdx];
        }
      },
      /**
       * Return the subcomponent node represented by the documented locator attribute values.
       * 
       * To lookup a cell the locator object should have the following:
       *          subId: 'oj-table-cell'
       *          rowIndex: number
       *          columnIndex: number
       *          
       * To lookup a header the locator object should have the following:
       *          subId: 'oj-table-header'
       *          index: number   
       *          
       * To lookup a footer the locator object should have the following:
       *          subId: 'oj-table-footer'
       *          index: number   
       *          
       * To lookup a sort icon the locator object should have the following:
       *          subId: 'oj-table-sort-ascending'/'oj-table-sort-descending'
       *          index: number                
       * 
       * @override
       * @param {Object} locator An Object containing at minimum a subId property whose value is a string 
       * @return {Element|null} the subcomponent located by the subId string passed in locator, if found.
       * @export
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * 
       */
      'getNodeBySubId': function(locator)
      {
        if (locator == null)
        {
          return this.element ? this.element[0] : null;
        }

        var subId = locator['subId'];

        if (subId === 'oj-table-cell')
        {
          var rowIdx = locator['rowIndex'];
          var columnIdx = locator['columnIndex'];
          return this._getTableDomUtils().getTableBodyCell(rowIdx, columnIdx)[0];
        }
        else if (subId === 'oj-table-header' ||
                 subId === 'oj-table-sort-ascending' ||
                 subId === 'oj-table-sort-descending')
        {
          var columnIdx = locator['index'];
          var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);
          if (tableHeaderColumn != null)
          {
            if (subId === 'oj-table-header')
            {
              return tableHeaderColumn[0];
            }
            else if (subId === 'oj-table-sort-ascending')
            {
              var tableHeaderColumnSortAsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
              if (tableHeaderColumnSortAsc.length > 0)
              {
                return tableHeaderColumnSortAsc[0];
              }
            }
            else
            {
              var tableHeaderColumnSortDsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
              if (tableHeaderColumnSortDsc.length > 0)
              {
                return tableHeaderColumnSortDsc[0];
              }
            }
          }
        }
        else if (subId === 'oj-table-footer')
        {
          var columnIdx = locator['index'];
          var tableFooterCell = this._getTableDomUtils().getTableFooterCell(columnIdx);
          
          if (tableFooterCell != null)
          {
            return tableFooterCell[0];
          }
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },              
      /**
       * Refresh the table.
       * @export
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * $( ".selector" ).ojTable( "refresh" );
       */
      'refresh': function()
      {
        this._super();
        this._refresh(true);
      },
      /**
       * Refresh a row in the table.
       * @param {number} rowIdx  Index of the row to refresh.
       * @return {boolean} true if refreshed, false if not
       * @throws {Error}
       * @export
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @example <caption>Invoke the <code class="prettyprint">refreshRow</code> method:</caption>
       * $( ".selector" ).ojTable( "refreshRow", 1 );
       */
      'refreshRow': function(rowIdx)
      {
        var data = this._getData();
        // if no data then bail
        if (!data)
        {
          return false;
        }

        if (isNaN(rowIdx) || rowIdx < 0 || rowIdx > data.size() - 1)
        {
          // validate rowIdx value
          var errSummary = this._LOGGER_MSG._ERR_REFRESHROW_INVALID_INDEX_SUMMARY;
          var errDetail = oj.Translations.applyParameters(this._LOGGER_MSG._ERR_REFRESHROW_INVALID_INDEX_DETAIL, {'rowIdx': rowIdx.toString()});
          throw new RangeError(errSummary + '\n' + errDetail);
        }

        // get row at rowIdx
        var row = data.at(rowIdx);
        if (row == null)
        {
          return false;
        }
        // refresh table row DOM with row
        try
        {
            if (row instanceof oj.Row)
            {
              this._refreshTableBodyRow(rowIdx, row);
            }
            else
            {
              this._asyncRefreshTableBodyRow(row);
            }
        }
        catch (e)
        {
          oj.Logger.error(e);
        }
        return true;
      },
      /**** end Public APIs ****/

      /**** start internal widget functions ****/

      /**
       * @override
       * @protected
       * @instance
       * @memberof! oj.ojTable
       */
      _ComponentCreate : function ()
      {
        this._super();
        this._draw();
        this._registerCustomEvents();
        this._on(this._events);
        // register event listeners for table on the datasource so that the table
        // component is notified when rows are added, deleted, etc from the datasource.
        this._registerDomEventListeners();
        this._registerDataSourceEventListeners();
        
        var self = this;
        setInterval(
          function()
          {
            if (self._selectionTimer != null)
            {
              self._setSelection();
              self._selectionTimer = null;
            }
        }, 100);
      },
      /**
       * @override
       * @private
       */
      _destroy: function()
      {
        var data = this._getData();
        // unregister the listeners on the datasource
        this._unregisterDataSourceEventListeners();
        
        this._getTableDomUtils().getTableBody().removeAttr(oj.Components._OJ_CONTAINER_ATTR);

        this.element.children().remove('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_CLASS);
        this.element.children().remove('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_BODY_CLASS);
        this.element.children().remove('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_STATUS_MESSAGE_CLASS);

        var tableContainer = this._getTableDomUtils().getTableContainer();
        if (tableContainer != null)
        {
          // add the table back tgo the parent element and remove the 
          // tableContainer div
          tableContainer[0].parentNode.appendChild(this.element);
          tableContainer[0].parentNode.removeChild(tableContainer[0]);
        }
        this.element.removeClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CLASS);
      },
      /**
       * @override
       * @private
       */
      _draw: function()
      {
        var options = this.options;
        
         // add css class to element
        this.element.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_ELEMENT_CLASS);

        // create the initial table structure
        this._getTableDomUtils().createInitialTable(this._isTableHeaderless(), 
                                                    this._isTableFooterless(), 
                                                    this._handleContextMenuBeforeShow.bind(this), 
                                                    this._handleContextMenuSelect.bind(this));
        // style the initial table structure
        this._getTableDomUtils().styleInitialTable();

        // populate the table header DOM with header content
        this._refreshTableHeader();

        // populate the table footer DOM with footer content
        this._refreshTableFooter();

        // resize the table dimensions to accomodate the completed tableheader
        this._getTableDomUtils().refreshTableDimensions(true);

        if (this.options.disabled)
        {
          this.disable();
        }
        
        this._registerResizeListener(this._getTableDomUtils().getTableContainer());
      },
      /**
       * @override
       * @private
       */
      _events:
        {
          /**
           * Reset the keyboard state on blur and set the inactive
           * selected rows
           */
          'blur': function(event)
          {
            // make sure the blur isn't for a focus to an element within
            // the table
            var table = this._getTableDomUtils().getTable();
            if (table.has(event.relatedTarget).length > 0)
            {
              return;
            }
            // In FF we check explicitOriginalTarget
            else if (event.originalEvent != null && event.originalEvent.explicitOriginalTarget == table[0])
            {
              return;
            }

            this._clearKeyboardKeys();
            this._clearFocusedHeaderColumn();
            this._clearFocusedRow();
            this._setTableNavigationMode(false);
          },
          /**
           * Check the keyboard state on focus
           */
          'focus': function(event)
          {
            var focusedRowIdx = this._getFocusedRowIdx();
            var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
            
            if (focusedRowIdx == null && focusedHeaderColumnIdx == null)
            {
              // if no row or column is focused then set the focus on the first column
              this._setHeaderColumnFocus(0, true, false, null);
            }
          },
          /**
           * Capture acc selected column event
           */
          'click .oj-table-checkbox-acc-select-column': function(event)
          {
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            var selected = $(event.currentTarget).is(':checked');
            // if selected then focus on the column
            if (selected)
            {
              this._setHeaderColumnFocus(columnIdx, true, true, null);
            }
            this._setHeaderColumnSelection(columnIdx, selected, event.currentTarget, event);
            event.stopPropagation();
          },
          /**
           * Capture acc selected row event
           */
          'click .oj-table-checkbox-acc-select-row': function(event)
          {
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            var selected = $(event.currentTarget).is(':checked');
            // if selected then focus on the row
            if (selected)
            {
              this._setRowFocus(rowIdx, true, null, event);
            }
            this._setRowSelection(rowIdx, selected, event.currentTarget, event);
            event.stopPropagation();
          },
          /**
           * Capture keyboard down events
           */
          'keydown': function(event)
          {
            // ignore key event on the footer
            if (this._getTableDomUtils().getTableFooter() != null && 
                this._getTableDomUtils().getTableFooter().has(event.target).length > 0)
            {
              return;
            }
            this._addKeyboardKey(event.keyCode);
            // process single or two key events
            if (this._getKeyboardKeys().length == 1 ||
              this._getKeyboardKeys().length == 2)
            {
              if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_SPACEBAR) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_HOME) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_END))
              {
                event.preventDefault();
                event.stopPropagation();
              }

              if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN))
              {
                this._handleKeydownUpDown(event);
              }
              else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_LEFT) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_RIGHT))
              {
                this._handleKeydownLeftRight(event);
              }
              else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_TAB))
              {
                this._handleKeydownTab(event);
              }
            }
          },
          /**
           * Capture keyboard up events
           */
          'keyup': function(event)
          {
            // ignore key event on the footer
            if (this._getTableDomUtils().getTableFooter() != null && 
                this._getTableDomUtils().getTableFooter().has(event.target).length > 0)
            {
              return;
            }
            // process single or 2 key events
            if (this._getKeyboardKeys().length == 1)
            {
              var keyboardCode1 = this._getKeyboardKeys()[0];

              if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_SPACEBAR)
              {
                this._handleKeyupSpacebar(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_ENTER)
              {
                this._handleKeyupEnter(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_HOME)
              {
                this._handleKeyupHome(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_END)
              {
                this._handleKeyupEnd(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_ESC)
              {
                this._handleKeyupEsc(event);
              }
              this._removeKeyboardKey(keyboardCode1);
            }
            // remove the keycode from our internal list of pressed keys.
            this._removeKeyboardKey(event.keyCode);
          },
          /**
           * show the ascending/descending links when the mouse 
           * enters a column header
           */
          'mouseenter .oj-table-column-header-cell': function(event)
          {
            // get the column index of the header element
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            // show the asc/dsc links for the header
            this._showTableHeaderColumnSortLink(columnIdx);
          },
          /**
           * hide the ascending/descending links when the mouse 
           * leaves a column header
           */
          'mouseleave .oj-table-column-header-cell': function(event)
          {
            // get the column index of the header element
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            // hide the asc/dsc links for the header
            this._hideTableHeaderColumnSortLink(columnIdx, true);
            this._hideTableHeaderColumnSortLink(columnIdx, false);
          },
          /**
           * show the row hover when the mouse enters a table cell
           */
          'mouseenter .oj-table-data-cell': function(event)
          {
            // get the row index of the cell element
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            // set row hover
            this._updateRowCellsClass(rowIdx, {hover: true});
          },
          /**
           * hide the row hover when the mouse leaves a table cell
           */
          'mouseleave .oj-table-data-cell': function(event)
          {
            // get the row index of the cell element
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            // unset row hover
            this._updateRowCellsClass(rowIdx, {hover: false});
          },
          /**
           * invoke a sort on the column data when the mouse clicks the ascending link
           */
          'click .oj-table-column-header-asc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

            if (!tableHeaderColumn)
            {
              return;
            }

            // check if the column is currently sorted
            var sorted = tableHeaderColumn.data('sorted');
            if (sorted == this._COLUMN_SORT_ORDER._ASCENDING)
            {
              this._handleSortTableHeaderColumn(columnIdx, false);
            }
            else
            {
              this._handleSortTableHeaderColumn(columnIdx, true);
            }
            event.preventDefault();
            event.stopPropagation();
          },
          'click .oj-table-column-header-acc-asc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            this._handleSortTableHeaderColumn(columnIdx, true);
            event.preventDefault();
            event.stopPropagation();
          },
          /**
           * invoke a sort on the column data when the mouse clicks the descending link
           */
          'click .oj-table-column-header-dsc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

            if (!tableHeaderColumn)
            {
              return;
            }

            // check if the column is currently sorted
            var sorted = tableHeaderColumn.data('sorted');
            if (sorted == this._COLUMN_SORT_ORDER._DESCENDING)
            {
              this._handleSortTableHeaderColumn(columnIdx, true);
            }
            else
            {
              this._handleSortTableHeaderColumn(columnIdx, false);
            }
            event.preventDefault();
            event.stopPropagation();
          },
          'click .oj-table-column-header-acc-dsc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            this._handleSortTableHeaderColumn(columnIdx, false);
            event.preventDefault();
            event.stopPropagation();
          },
          /**
           * set the row focus or selection when the mouse clicks on a cell.
           * Ctrl + click results in selection and focus. Plain click results in focus.
           * Plain click on a selected row removes the selection.
           */
          'click .oj-table-data-cell': function(event)
          {
            this._checkFocus();
            // get the row index of the cell element
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            // set the row focus
            this._setRowFocus(rowIdx, true, event.currentTarget, event);
            // check if we are selecting
            if (this._getKeyboardKeys().length == 1)
            {
              if (this._getKeyboardKeys()[0] == this._KEYBOARD_CODES._KEYBOARD_CODE_SHIFT)
              {
                var lastSelectedRowIdx = this._getLastRowSelection();
                if (lastSelectedRowIdx != null)
                {
                  // shift selection is always from the last selected row
                  if (rowIdx < lastSelectedRowIdx)
                  {
                    var i;
                    for (i = rowIdx; i <= lastSelectedRowIdx; i++)
                    {
                      this._setRowSelection(i, true, event.currentTarget, event);
                    }
                  }
                  else
                  {
                    var i;
                    for (i = lastSelectedRowIdx; i <= rowIdx; i++)
                      this._setRowSelection(i, true, event.currentTarget, event);
                  }
                }
              }
            }
            else if (oj.DomUtils.isMetaKeyPressed(event))
            {
              this._setRowSelection(rowIdx, !this._getRowSelection(rowIdx), event.currentTarget, event);
            }
            else if (this._getKeyboardKeys().length == 0)
            {
              this._clearSelectedRows();
              this._setRowSelection(rowIdx, !this._getRowSelection(rowIdx), event.currentTarget, event);
            }
          },
          /**
           * set the column header selection and focus. Plain click results in
           * focus and selection. If Ctrl is not pressed then we have single column selection.
           */
          'click .oj-table-column-header-cell': function(event)
          {
            this._checkFocus();
            // get the column index
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            // set the column focus
            this._setHeaderColumnFocus(columnIdx, true, true, event.currentTarget);
            // check if we are selecting
            if (this._getKeyboardKeys().length == 1)
            {
              if (this._getKeyboardKeys()[0] == this._KEYBOARD_CODES._KEYBOARD_CODE_SHIFT)
              {
                var lastSelectedColumnIdx = this._getLastHeaderColumnSelection();
                if (lastSelectedColumnIdx != null)
                {
                  // shift selection is always from the last selected column
                  if (columnIdx < lastSelectedColumnIdx)
                  {
                    var i;
                    for (i = columnIdx; i <= lastSelectedColumnIdx; i++)
                    {
                      this._setHeaderColumnSelection(i, true, event.currentTarget, event);
                    }
                  }
                  else
                  {
                    var i;
                    for (i = lastSelectedColumnIdx; i <= columnIdx; i++)
                      this._setHeaderColumnSelection(i, true, event.currentTarget, event);
                  }
                }
              }
            }
            else if (oj.DomUtils.isMetaKeyPressed(event))
            {
              this._setHeaderColumnSelection(columnIdx, !this._getHeaderColumnSelection(columnIdx), event.currentTarget, event);
            }
            else if (this._getKeyboardKeys().length == 0)
            {
              this._clearSelectedHeaderColumns();
              this._setHeaderColumnSelection(columnIdx, !this._getHeaderColumnSelection(columnIdx), event.currentTarget, event);
            }
            event.preventDefault();
          }
        },
      /**
       * @param {boolean} immediate  refresh immediately
       * @private
       */
      _refresh: function(immediate)
      {
        this._clearCachedMetadata();
        if (this._data != this.options['data'])
        {
          this._clearCachedDataMetadata();
        }
        if (this._contextMenuId != this._getTableDomUtils().getContextMenuId())
        {
          this._getTableDomUtils().createContextMenu(this._handleContextMenuBeforeShow.bind(this), 
                                                     this._handleContextMenuSelect.bind(this));
        }
        this._getTableDomUtils().clearCachedDom();
        var self = this;
        setTimeout(function()
        {
          self._refreshAll(immediate)
        }, 0);
      },
      /**
       * @override
       * @private
       */
      _setOption: function(key, value)
      {
        var shouldRefresh = this._isTableRefreshNeeded(key, value);
        this._superApply(arguments);
        
        if (shouldRefresh)
        {
          this._refresh(true);
        }
        if (key == 'selection')
        {
          this._setSelection();
        }
      },
      /**** end internal widget functions ****/

      /**** start internal functions ****/

      /**
       * Add a keyCode to internally track pressed keys. keyCodes should be added on 
       * mouse down and then later removed on mouse up.
       * @param {number} keyCode  KeyCode of the keyboard key.
       * @private
       */
      _addKeyboardKey: function(keyCode)
      {
        var foundCode = false;
        for (var prop in this._KEYBOARD_CODES)
        {
          if (this._KEYBOARD_CODES.hasOwnProperty(prop))
          {
            if (this._KEYBOARD_CODES[prop] == keyCode)
            {
              foundCode = true;
            }
          }
        }

        if (!foundCode)
        {
          // only add keys we are interested in
          return;
        }

        var keyboardKeys = this._getKeyboardKeys();
        var found = false;
        var i;
        for (i = 0; i < keyboardKeys.length; i++)
        {
          if (keyboardKeys[i] == keyCode)
          {
            found = true;
            break;
          }
        }
        if (!found)
        {
          keyboardKeys.push(keyCode);
        }
      },
      /**
       * Add a new tr and refresh the DOM at the row index and refresh the table 
       * dimensions to accomodate the new row
       * @param {number} rowIdx  row index
       * @param {Object} row  oj.Row
       * @param {Object} docFrag  document fragment
       * 
       * @private
       */
      _addSingleTableBodyRow: function(rowIdx, row, docFrag)
      {
        var tableBodyRow = this._getTableDomUtils().createTableBodyRow(rowIdx);
        this._getTableDomUtils().styleTableBodyRow(tableBodyRow);
        // insert the <tr> element in to the table body DOM
        this._getTableDomUtils().insertTableBodyRow(rowIdx, tableBodyRow, row, docFrag);
        if (row instanceof oj.Row)
        {
          this._refreshTableBodyRow(rowIdx, row, tableBodyRow, docFrag);
        }
        else
        {
          this._asyncRefreshTableBodyRow(row);
        }
      },
      /**
       * Refresh the row asynchronously
       * @param {Object} row deferred object or oj.Row
       * 
       * @private
       */
      _asyncRefreshTableBodyRow: function(row)
      {
        var self = this;
        
        row.then(function(resolvedModel)
                 {
                   setTimeout(function()
                   {
                     var rowIdx = resolvedModel.index - self._getData().startIndex();
                     self._refreshTableBodyRow(rowIdx, resolvedModel);
                     self._getTableDomUtils().refreshTableDimensions();
                   }, 0);
                 }); 
      },
      /**
       * Check the focus is on the table or descendent focusable element
       * @private
       */
      _checkFocus: function()
      {
        // set focus on the table
        if (!this._isFocused())
        {
          // only focus if focus is not on some child element of table
          this._getTableDomUtils().getTable().focus();
        }
      },
      /**
       * Clear any cached metadata
       * @private
       */
      _clearCachedMetadata: function()
      {
        this._columnDefArray = null;
        this._setTableNavigationMode(false);
      },
      /**
       * Clear any cached data metadata
       * @private
       */
      _clearCachedDataMetadata: function()
      {
        if (this._data != null)
        {
          this._unregisterDataSourceEventListeners();
        }
        this._data = null;
      },
      /**
       * Clear any keyboard keys
       * @private
       */
      _clearKeyboardKeys: function()
      {
        this._keyboardKeys = [];
      },
      /**
       * Clear the focused column header
       * @private
       */
      _clearFocusedHeaderColumn: function()
      {
        var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
        if (focusedHeaderColumnIdx != null)
        {
          this._setHeaderColumnFocus(focusedHeaderColumnIdx, false, false, null);
        }
        this._activeColumnIndex = -1;
      },
      /**
       * Clear the focused row
       * @private
       */
      _clearFocusedRow: function()
      {
        var focusedRowIdx = this._getFocusedRowIdx();
        if (focusedRowIdx != null)
        {
          this._setRowFocus(focusedRowIdx, false, null, null);
        }
      },
      /**
       * Clear the selected column headers
       * @private
       */
      _clearSelectedHeaderColumns: function()
      {
        var selectedHeaderColumnIdxs = this._getSelectedHeaderColumnIdxs();

        var i;
        for (i = 0; i < selectedHeaderColumnIdxs.length; i++)
        {
          this._setHeaderColumnSelection(selectedHeaderColumnIdxs[i], false, null);
        }
      },
      /**
       * Clear the selected rows
       * @private
       */
      _clearSelectedRows: function()
      {
        var selectedRowIdxs = this._getSelectedRowIdxs();

        var i;
        for (i = 0; i < selectedRowIdxs.length; i++)
          this._setRowSelection(selectedRowIdxs[i], false, null);
      },
      /**
       * Clear the sorted column header indicator. Note this does not affect the order
       * of the data. This is just to clear the UI indication.
       * @param {number} columnIdx  column index
       * @private
       */
      _clearSortedHeaderColumn: function(columnIdx)
      {
        var sortedTableHeaderColumnIdx = this._getSortedTableHeaderColumnIdx();
        if (sortedTableHeaderColumnIdx != null)
        {
          var sortedTableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(sortedTableHeaderColumnIdx);
          var sorted = sortedTableHeaderColumn.data('sorted');
          sortedTableHeaderColumn.data('sorted', null);
          
          if (sortedTableHeaderColumnIdx != columnIdx)
          {
            if (sorted == this._COLUMN_SORT_ORDER._ASCENDING)
            {
              this._hideTableHeaderColumnSortLink(sortedTableHeaderColumnIdx, true);
            }
            else
            {
              this._hideTableHeaderColumnSortLink(sortedTableHeaderColumnIdx, false);
            }
          }
          else
          {
            var sortedTableHeaderColumnAscLink = sortedTableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
            sortedTableHeaderColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            var sortedTableHeaderColumnDscLink = sortedTableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
            sortedTableHeaderColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
        }
      },
      /**
       * Execute queued row operations
       * @private
       */
      _executeQueuedTableBodyRowOperations: function()
      {
        if (this._rowOperationQueue != null)
        {
          var lastOperation = this._rowOperationQueue[this._rowOperationQueue.length - 1];

          if (lastOperation != null)
          {
            var lastOperationEventType = lastOperation.eventType;

            if (lastOperationEventType == oj.TableDataSource.EventType['ADD'])
            {
              this._executeTableBodyRowsAdd(this._rowOperationQueue);
            }
            else if (lastOperationEventType == oj.TableDataSource.EventType['REMOVE'])
            {
              this._executeTableBodyRowsRemove(this._rowOperationQueue);
            }
            else if (lastOperationEventType == oj.TableDataSource.EventType['CHANGE'])
            {
              this._executeTableBodyRowsChange(this._rowOperationQueue);
            }
            this._rowOperationQueue = [];
          }
        }
      },
      /**
       * Add all the rows contained in the input array.
       * @param {Array} rows Array of row contexts to add
       * @private
       */
      _executeTableBodyRowsAdd: function(rows)
      {
        // see if we should batch add
        // only batch if we are adding a block of contiguous rows
        var batchAdd = false;
        if (rows.length > 1)
        {
          var i;
          var isContiguous = true;
          for (i = 0; i < rows.length; i++)
          {
            if (i != 0)
            {
              if (rows[i - 1].rowIdx != rows[i].rowIdx - 1)
              {
                isContiguous = false;
                break;
              }
            }
          }
          
          if (isContiguous)
          {
            var tableBody = this._getTableDomUtils().getTableBody();
            var tableBodyDocFrag = $(document.createDocumentFragment());
            for (i = 0; i < rows.length; i++)
            {
              this._addSingleTableBodyRow(rows[i].rowIdx, rows[i].row, tableBodyDocFrag);
            }
            if (rows[0].rowIdx == 0)
            {
              tableBody.prepend(tableBodyDocFrag);
            }
            else
            {
              var tableBodyRowBefore = this._getTableDomUtils().getTableBodyRow(rows[0].rowIdx);
              if (tableBodyRowBefore != null)
              {
                tableBody[0].insertBefore(tableBodyDocFrag[0], tableBodyRowBefore[0]);
              }
              else
              {
                tableBody[0].insertBefore(tableBodyDocFrag[0], null);
              }
            }
            var j, columns;
            for (i = 0; i < rows.length; i++)
            {
              this._getTableDomUtils().renderDelayedTableBodyRow(rows[i].rowIdx);
              columns = this._getColumnDefs();
              for (j = 0; j < columns.length; j++)
              {
                this._getTableDomUtils().renderDelayedTableBodyCell(rows[i].rowIdx, j);
              }
            }
            this._getTableDomUtils().clearDelayedRenderRows();
            this._getTableDomUtils().clearDelayedRenderCells();
            batchAdd = true;
          }
        }
        
        if (!batchAdd)
        {
          for (i = 0; i < rows.length; i++)
          {
            this._addSingleTableBodyRow(rows[i].rowIdx, rows[i].row);
          }        
        }
        
        this._getTableDomUtils().clearCachedDomRowData();
        this._getTableDomUtils().refreshTableDimensions();
      },
      /**
       * Change all the rows contained in the input array.
       * @param {Array} rows Array of row contexts to change
       * @private
       */
      _executeTableBodyRowsChange: function(rows)
      {
        var i;
        for (i = 0; i < rows.length; i++)
        {
            if (rows[i].row instanceof oj.Row)
            {
              this._refreshTableBodyRow(rows[i].rowIdx, rows[i].row);
            }
            else
            {
              this._asyncRefreshTableBodyRow(rows[i].row);
            }
        }
        this._getTableDomUtils().refreshTableDimensions();
      },
      /**
       * Change all the rows contained in the input array.
       * @param {Array} rows Array of row contexts to change
       * @private
       */
      _executeTableBodyRowsRemove: function(rows)
      {
        var i;
        for (i = 0; i < rows.length; i++)
        {
          this._removeTableBodyRow(rows[i].rowIdx);
        }
        this._getTableDomUtils().refreshTableDimensions();
      },
      /**
       * Fire optionChange event 
       * @param {String} key - 'selected'
       * @param {Object} previousValue 
       * @param {Object} value
       * @param {Object} event
       *
       * @private
       */
      _fireOptionChange: function(key, previousValue, value, event) 
      {
        var ui = {
          "option": key,
          "previousValue": previousValue,
          "value": value,
          "optionMetadata": {'writeback': event ? "shouldWrite" : "shouldNotWrite"}
        };
        this._trigger('optionChange', event, ui);
      },
      /**
       * Return the column definitions
       * @return {Array} array of column metadata Objects.
       * @private
       */
      _getColumnDefs: function()
      {
        // cache the columns array in this._columnDefArray
        if (!this._columnDefArray)
        {
          this._columnDefArray = this._getColumnMetadata();
        }
        return this._columnDefArray;
      },
      /**
       * Return the column metadata in sorted oder.
       * @return {Array} array of column metadata Objects.
       * @private
       */
      _getColumnMetadata: function()
      {
        // get the columns metadata
        var columns = this.options['columns'];
        var columnsDefault = this.options['columnsDefault'];

        if ((columns.length == 0 ||
            (columns.length == 1 &&
            columns[0].id == null &&
            columns[0].headerText == null &&
            columns[0].field == null)) &&
            (columnsDefault.headerText == null &&
            columnsDefault.field == null))
        {
          return [];
        }
        
        var defaultedColumns = [];
        var i;
        for (i = 0; i < columns.length; i++)
        {
          defaultedColumns[i] = $.extend({}, columnsDefault, columns[i]);
        }

        var columnsSortedArray = [];
        // add the rest of the columns in the array
        for (i = 0; i < defaultedColumns.length; i++)
        {
          columnsSortedArray.push(defaultedColumns[i]);
        }
        
        var data = this._getData();
        var sortSupportedData = false;
        if (data != null && data.getCapability('sort') == 'full')
        {
          sortSupportedData = true;
        }

        for (i = 0; i < defaultedColumns.length; i++)
        {
          // generate ids for columns which don't have it specified
          if (columnsSortedArray[i]['id'] == null)
          {
            columnsSortedArray[i]['id'] = this._COLUMN_HEADER_ID_PREFIX + i;
          }
          // for the columns which have sortable = 'auto' check the datasource
          // and enable or disable
          if ((columnsSortedArray[i]['sortable'] == null || 
               columnsSortedArray[i]['sortable'] == this._OPTION_AUTO)
               && sortSupportedData)
          {
            columnsSortedArray[i]['sortable'] = this._OPTION_ENABLED;
          }
        }
        return columnsSortedArray;
      },
      /**
       * Return the column index for column key.
       * @param {Object} columnKey column key
       * @return {number|null} column index
       * @private
       */
      _getColumnIdxForColumnKey: function(columnKey)
      {
        var columns = this._getColumnDefs();
      
        if (columns != null)
        {
          var i, column;
          for (i = 0; i < columns.length; i++)
          {
            column = columns[i];
            if (oj.Object.compareValues(column.id, columnKey))
            {
              return i;
            }
          }
        }
        return null;
      },
      /**
       * Return all the column indexes for elements with a particular style class
       * @param {string} styleClass  style class
       * @return {Array} Array of column indexes
       * @private
       */
      _getColumnIdxsForElementsWithStyleClass: function(styleClass)
      {
        var elements = this._getTableDomUtils().getTable().find(styleClass);
        var columnIdxs = [];
        if (elements && elements.length > 0)
        {
          var i, j, alreadyAdded, columnIdx;
          for (i = 0; i < elements.length; i++)
          {
            columnIdx = this._getTableDomUtils().getElementColumnIdx($(elements.get(i)));

            alreadyAdded = false;
            for (j = 0; j < columnIdxs.length; j++)
            {
              if (columnIdxs[j] == columnIdx)
              {
                alreadyAdded = true;
              }
            }
            if (!alreadyAdded)
            {
              columnIdxs.push(columnIdx);
            }
          }
        }

        return columnIdxs;
      },
      /**
       * Return the column key for column index.
       * @param {number} columnIdx column index
       * @return {Object} column key
       * @private
       */
      _getColumnKeyForColumnIdx: function(columnIdx)
      {
        var columns = this._getColumnDefs();
      
        if (columns != null && columnIdx < columns.length)
        {
          return columns[columnIdx]['id'];
        }
        return null;
      },
      /**
       * Return the column renderer
       * @param {number} columnIdx  column index
       * @param {String} type  renderer type
       * @return {Object} renderer
       * @private
       */
      _getColumnRenderer: function(columnIdx, type)
      {
        var columns = this._getColumnDefs();
        var column = columns[columnIdx];
        
        if (type == 'cell')
        {
          return column['renderer'];
        }
        else if (type == 'footer')
        {
          return column['footerRenderer'];
        }
        else if (type == 'header')
        {
          return column['headerRenderer'];
        }

        return null;
      },
      /**
       * Get the current row.
       * @return {Object|null} current row object or null if none.
       * @throws {Error}
       * @private
       */
      _getCurrentRow: function()
      {
        var data = this._getData();
        // if no data then bail
        if (!data)
        {
          return null;
        }
        return this._currentRow;
      },
      /**
       * Return the datasource object defined for this table
       * @return {Object} Datasource object.
       * @throws {Error}
       * @private
       */
      _getData: function()
      {
        if (!this._data && this.options.data != null)
        {
          var data = this.options.data;
          if (data instanceof oj.TableDataSource ||
              data instanceof oj.PagingTableDataSource)
          {
            this._data = data;
          }
          else
          {
            // we only support TableDataSource
            var errSummary = this._LOGGER_MSG._ERR_DATA_INVALID_TYPE_SUMMARY;
            var errDetail = this._LOGGER_MSG._ERR_DATA_INVALID_TYPE_DETAIL;
            throw new Error(errSummary + '\n' + errDetail);
          }
          this._dataMetadata = this.options.data;
          this._registerDataSourceEventListeners();
          
          // do an initial fetch if not a PagingTableDataSource
          // paging control should do the fetches for PagingTableDataSource
          if (data instanceof oj.TableDataSource)
          {
            var self = this;
            setTimeout(function(){
              if (self._data.size() == 0)
              {
                self._getData().fetch({'fetchType': 'init'});
              }
            }, 0);
          }
        }
        return this._data;
      },
      /**
       * Get the focused column header index
       * @return {number|null} the column index
       * @private
       */
      _getFocusedHeaderColumnIdx: function()
      {
        // focused column headers have the focused style class. There should only be one focused header
        return this._getColumnIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CELL_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS)[0];
      },
      /**
       * Get the focused row index
       * @return {number|null} the row index
       * @private
       */
      _getFocusedRowIdx: function()
      {
        // focused rows have cells with focused style class. There should only be one focused row
        return this._getRowIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS)[0];
      },
      /**
       * Return whether the column header at the index is focused
       * @param {number} columnIdx  column index
       * @return {boolean} whether it's focused
       * @private
       */
      _getHeaderColumnFocus: function(columnIdx)
      {
        return this._getHeaderColumnState(columnIdx).focused;
      },
      /**
       * Return whether the column header at the index is selected
       * @param {number} columnIdx  column index
       * @return {boolean} whether it's selected
       * @private
       */
      _getHeaderColumnSelection: function(columnIdx)
      {
        return this._getHeaderColumnState(columnIdx).selected;
      },
      /**
       * Return the column selection mode
       * @return {string|null} single, multiple, or null
       * @private
       */
      _getColumnSelectionMode: function()
      {
        var columnSelectionMode = this.options.selectionMode == null ? null : this.options.selectionMode['column'];
        return columnSelectionMode;
      },
      /**
       * Return the state of the column header at a partiocular index
       * @param {number} columnIdx  column index
       * @return {Object} Object which contains booleans focused and selected
       * @private
       */
      _getHeaderColumnState: function(columnIdx)
      {
        var headerColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

        return {focused: headerColumn.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS),
          selected: headerColumn.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED)};
      },
      /**
       * Return the currently pressed keyboard keys
       * @return {Array} Array of keyCodes
       * @private
       */
      _getKeyboardKeys: function()
      {
        if (!this._keyboardKeys)
        {
          this._keyboardKeys = [];
        }

        // reverse the array since we want the keybaord keys to be a LIFO stack
        return this._keyboardKeys.reverse();
      },
      /**
       * Return the last column which was selected (chronologically)
       * @return {number|null} last selected column
       * @private
       */
      _getLastHeaderColumnSelection: function()
      {
        if (this._lastSelectedColumnIdxArray != null &&
          this._lastSelectedColumnIdxArray.length > 0)
        {
          return this._lastSelectedColumnIdxArray[0];
        }
        return null;
      },
      /**
       * Return the last row which was selected (chronologically)
       * @return {number|null} last selected row
       * @private
       */
      _getLastRowSelection: function()
      {
        if (this._lastSelectedRowIdxArray != null &&
          this._lastSelectedRowIdxArray.length > 0)
        {
          return this._lastSelectedRowIdxArray[0];
        }
        return null;
      },
      /**
       * Get the element from an array of elements according to type
       * @param {Object} elements  Array of jquery elements
       * @param {string} type  DOM type
       * @return {Object|null} element
       * @private
       */
      _getJQueryElement: function(elements, type)
      {
        var i;
        for (i = 0; i < $(elements).length; i++)
        {
          if ($($(elements)[i]).is(type))
          {
            return $(elements)[i];
          }
        }
        return null;
      },
      /**
       * Return whether the row is focused
       * @param {number} rowIdx  row index
       * @return {boolean} whether the row is focused
       * @private
       */
      _getRowFocus: function(rowIdx)
      {
        return this._getTableDomUtils().getTableBodyRow(rowIdx).hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
      },
      /**
       * Return whether the row is hovered
       * @param {number} rowIdx  row index
       * @return {boolean} whether the row is hovered
       * @private
       */
      _getRowHover: function(rowIdx)
      {
        return this._getTableDomUtils().getTableBodyRow(rowIdx).hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._HOVER);
      },
      /**
       * Return the row index for row key. Only loop through displayed rows.
       * @param {Object} rowKey row key
       * @return {number|null} row index
       * @private
       */
      _getRowIdxForRowKey: function(rowKey)
      {
        var data = this._getData();
      
        if (data != null)
        {
          var startIndex = data.startIndex();
          var endIndex = startIndex + data.size();
          var i, row, rowIdx;
          for (i = startIndex; i < endIndex; i++)
          {
            rowIdx = i - startIndex;
            row = data.at(i);
            if (row != null && 
                (row instanceof oj.Row) && 
                oj.Object.compareValues(row['id'], rowKey))
            {
              return rowIdx;
            }
          }
        }
        return null;
      },
      /**
       * Return all the row indexes for elements with a particular style class
       * @param {string} styleClass  style class
       * @return {Array} Array of row indexes
       * @private
       */
      _getRowIdxsForElementsWithStyleClass: function(styleClass)
      {
        var elements = this._getTableDomUtils().getTable().find(styleClass);
        var rowIdxs = [];
        if (elements && elements.length > 0)
        {
          var i, j, rowIdx, alreadyAdded;
          for (i = 0; i < elements.length; i++)
          {
            rowIdx = this._getTableDomUtils().getElementRowIdx($(elements.get(i)));

            alreadyAdded = false;
            for (j = 0; j < rowIdxs.length; j++)
            {
              if (rowIdxs[j] == rowIdx)
              {
                alreadyAdded = true;
              }
            }
            if (!alreadyAdded)
            {
              rowIdxs.push(rowIdx);
            }
          }
        }

        return rowIdxs;
      },
      /**
       * Return the row key for row index.
       * @param {number} rowIdx row index
       * @return {Object} row key
       * @private
       */
      _getRowKeyForRowIdx: function(rowIdx)
      {
        var data = this._getData();
      
        if (data != null)
        {
          var row = data.at(rowIdx);
          if (row != null && (row instanceof oj.Row))
          {
            return row['id'];
          }
        }
        return null;
      },
      /**
       * Return the row renderer
       * @return {Object} renderer
       * @private
       */
      _getRowRenderer: function()
      {
        return this.options['rowRenderer'];
      },
      /**
       * Return whether the row is selected
       * @param {number} rowIdx  row index
       * @return {boolean} whether the row is selected
       * @private
       */
      _getRowSelection: function(rowIdx)
      {
        return this._getTableDomUtils().getTableBodyRow(rowIdx).hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
      },
      /**
       * Return the row selection mode
       * @return {string|null} single, multiple, or null
       * @private
       */
      _getRowSelectionMode: function()
      {
        var rowSelectionMode = this.options['selectionMode'] == null ? null : this.options['selectionMode']['row'];
        return rowSelectionMode;
      },
      /**
       * Return the selected column header indexes
       * @return {Array} array of column header indexes
       * @private
       */
      _getSelectedHeaderColumnIdxs: function()
      {
        // selected column headers have the selected css class
        return this._getColumnIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CELL_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
      },
      /**
       * Return the selected row indexes
       * @return {Array} array of row indexes
       * @private
       */
      _getSelectedRowIdxs: function()
      {
        // selected rows have the selected css class
        return this._getRowIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
      },
      /**
       * Gets the selection
       * @private	 
       */
      _getSelection: function()
      {
        var data = this._getData();
        var startIndex = data != null ? data.startIndex() : 0;
        var selectedRowIdxs = this._getSelectedRowIdxs();
        var selectedColumnIdxs = this._getSelectedHeaderColumnIdxs();
        var selectionIdxs = null;
        var rowSelection = true;
        if (selectedRowIdxs != null && selectedRowIdxs.length > 0)
        {
          selectionIdxs = selectedRowIdxs;
        }
        else if (selectedColumnIdxs != null && selectedColumnIdxs.length > 0)
        {
          selectionIdxs = selectedColumnIdxs;
          rowSelection = false;
        }
        else
        {
          return null;
        }

        var rangeArray = [];

        // first count the number of ranges we have by seeing how many
        // non-continguous selections we have
        var rangeCount = 0;
        var previousIdx = null;
        var rangeObj, selectionIdx, selectionKey;
        var i;
        for (i = 0; i < selectionIdxs.length; i++)
        {
          selectionIdx = selectionIdxs[i] + startIndex;
          if (i == 0)
          {
            rangeObj = [];
            rangeObj['startIndex'] = [];
            rangeObj['endIndex'] = [];
            rangeObj['startKey'] = [];
            rangeObj['endKey'] = [];
            if (rowSelection)
            {
              rangeObj['startIndex']['row'] = selectionIdx;
              rangeObj['endIndex']['row'] = selectionIdx;
              selectionKey = this._getRowKeyForRowIdx(selectionIdx);
              rangeObj['startKey']['row'] = selectionKey;
              rangeObj['endKey']['row'] = selectionKey;
            }
            else
            {
              rangeObj['startIndex']['column'] = selectionIdx;
              rangeObj['endIndex']['column'] = selectionIdx;
              selectionKey = this._getColumnKeyForColumnIdx(selectionIdx);
              rangeObj['startKey']['column'] = selectionKey;
              rangeObj['endKey']['column'] = selectionKey;
            }
            rangeArray[0] = rangeObj;
          }
          else
          {
            rangeObj = rangeArray[rangeCount];
            if (rowSelection)
            {
              rangeObj['endIndex']['row'] = selectionIdx;
              selectionKey = this._getRowKeyForRowIdx(selectionIdx);
              rangeObj['endKey']['row'] = selectionKey;
            }
            else
            {
              rangeObj['endIndex']['column'] = selectionIdx;
              selectionKey = this._getColumnKeyForColumnIdx(selectionIdx);
              rangeObj['endKey']['column'] = selectionKey;
            }
            if (selectionIdx != previousIdx + 1)
            {
              if (rowSelection)
              {
                rangeObj['endIndex']['row'] = previousIdx;
                selectionKey = this._getRowKeyForRowIdx(previousIdx);
                rangeObj['endKey']['row'] = selectionKey;
                rangeObj = [];
                rangeObj['startIndex'] = [];
                rangeObj['endIndex'] = [];
                rangeObj['startKey'] = [];
                rangeObj['endKey'] = [];
                rangeObj['startIndex']['row'] = selectionIdx;
                rangeObj['endIndex']['row'] = selectionIdx;
                selectionKey = this._getRowKeyForRowIdx(selectionIdx);
                rangeObj['startKey']['row'] = selectionKey;
                rangeObj['endKey']['row'] = selectionKey;
              }
              else
              {
                rangeObj['endIndex']['column'] = previousIdx;
                selectionKey = this._getColumnKeyForColumnIdx(previousIdx);
                rangeObj['endKey']['column'] = selectionKey;
                rangeObj = [];
                rangeObj['startIndex'] = [];
                rangeObj['endIndex'] = [];
                rangeObj['startKey'] = [];
                rangeObj['endKey'] = [];
                rangeObj['startIndex']['column'] = selectionIdx;
                rangeObj['endIndex']['column'] = selectionIdx;
                selectionKey = this._getColumnKeyForColumnIdx(selectionIdx);
                rangeObj['startKey']['column'] = selectionKey;
                rangeObj['endKey']['column'] = selectionKey;
              }
              rangeCount++;
              rangeArray[rangeCount] = rangeObj;
            }
          }
          previousIdx = selectionIdx;
        }
        return rangeArray;
      },
      /**
       * Return the currnetly sorted column index
       * @return {number|null} column index
       * @private
       */
      _getSortedTableHeaderColumnIdx: function()
      {
        var tableHeaderColumns = this._getTableDomUtils().getTableHeaderColumns();

        var i, sorted;
        for (i = 0; i < tableHeaderColumns.length; i++)
        {
          // sorted column will have the sorted data attr
          sorted = $(tableHeaderColumns[i]).data('sorted');

          if (sorted != null)
          {
            return i;
          }
        }
        return null;
      },
      /**
       * Get tabbable elements within the element
       * @param {jQuery} element  DOM element
       * @return {jQuery|null} jQuery array of DOM elements
       * @private
       */
      _getTabbableElements: function(element)
      {
        var tabbableElements = element.find(':tabbable');

        if (tabbableElements != null && tabbableElements.length > 0)
        {
          return tabbableElements;
        }
        return null;
      },
      /**
       * Return table DOM utils instance
       * @return {Object} instance of table DOM utils
       * @private
       */
      _getTableDomUtils: function()
      {
        if (!this._tableDomUtils)
        {
          this._tableDomUtils = new oj.TableDomUtils(this);
        }
        return this._tableDomUtils;
      },
      /**
       * Return the number of DOM rows in the table
       * @return {number} row count.
       * @private
       */
      _getTableRowCount: function()
      {
        var rows = this._getTableDomUtils().getTableBodyRows();

        if (rows != null)
        {
          return rows.length;
        }
        return 0;
      },
      /**
       * Handle an ojbeforeopen event on the context menu. Set the position correctly for keyboard events and store the Keyboard/Mouse event that called the context menu
       * @private	 
       */
      _handleContextMenuBeforeShow: function(event, ui)
      {
        var contextMenu = this._getTableDomUtils().getContextMenu();

        this._contextMenuEvent = event['originalEvent']['originalEvent'];
        
        // first check if we are invoking on an editable or clickable element If so bail
        if (this._isNodeEditableOrClickable($(this._contextMenuEvent['target'])))
        {
          return false;
        }
        
        // TODO: Rather than setting "position" in this beforeOpen listener, probably better to 
        // override _OpenContextMenu() and pass "position" in its call to menu.open().  That way, 
        // if the app wants to tweak the position in its beforeOpen listener, its success 
        // doesn't depend on who gets their listeners registered first.
        if (this._contextMenuEvent['type'] === 'keydown')
        {
          ui.openOptions.position = {"my": "start top", "at": "start bottom", "of": this._contextMenuEvent['target']};
        }
        else
        {
          ui.openOptions.position = {"my": "start top", "at": "start bottom"};
        }
        
        var headerColumn = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-column-header-cell');
        headerColumn = headerColumn == null ? this._getTableDomUtils().getTableHeaderColumn(this._activeColumnIndex) : headerColumn;
        var tableBodyCell = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-data-cell');
        
        if (tableBodyCell != null)
        {
          var columnIdx = this._getTableDomUtils().getElementColumnIdx(tableBodyCell);
          headerColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);
        }

        if (headerColumn.attr('data-oj-sortable') == this._OPTION_ENABLED)
        {
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortAsc]').removeClass('oj-disabled');
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortDsc]').removeClass('oj-disabled');
        }
        else
        {
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortAsc]').addClass('oj-disabled');
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortDsc]').addClass('oj-disabled');
          
          return false;
        }
      },
      /**
       * Handle an ojselect event on a menu item, if sort call the handler on the core.
       * If resize prompt the user with a dialog box
       * @private	 
       */
      _handleContextMenuSelect: function(event, ui)
      {
        var menuItemCommand = ui.item.attr('data-oj-command');
        var headerColumn = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-column-header-cell');
        var tableBodyCell = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-data-cell');
        var columnIdx = null;
        
        if (headerColumn != null)
        {
          columnIdx = this._getTableDomUtils().getElementColumnIdx(headerColumn);
        }
        if (tableBodyCell != null)
        {
          columnIdx = this._getTableDomUtils().getElementColumnIdx(tableBodyCell);
        }
        if (menuItemCommand == 'oj-table-sortAsc')
        {
          this._handleSortTableHeaderColumn(columnIdx, true);
        }
        else if (menuItemCommand == 'oj-table-sortDsc')
        {
          this._handleSortTableHeaderColumn(columnIdx, false);
        }
      },
      /**
       * Callback handler for data error.
       * @param {Object} error 
       * @private
       */
      _handleDataError: function(error)
      {
        this._hideStatusMessage();
        oj.Logger.error(error);
      },
      /**
       * Callback handler for fetch start in the datasource.
       * @param {Object} event 
       * @private
       */
      _handleDataFetchStart: function(event)
      {
        this._showStatusMessage();
        this._dataFetching = true;
      },
      /**
       * Callback handler for fetch completed in the datasource. Refresh entire
       * table body DOM and refresh the table dimensions if refresh == true. Hide the Fetching Data... 
       * status message.
       * @param {Object} event
       * @private
       */
      _handleDataFetchEnd: function(event)
      {
        try {
            if (this._dataFetching && this._dataSorting) {
                this._dataFetching = false;
                this._dataSorting = false;
                this._handleDataSort();
            }
            else {
                var refresh = event['refresh'];

                if (refresh)
                {
                  this._refreshAll(true);
                }
            }
            this._hideStatusMessage();
        }
        catch (e) {
            throw e;
        }
        finally {
            this._dataFetching = false;
            this._dataSorting = false;
        }
      },
      /**
       * Callback handler for reset in the datasource. Refresh entire
       * table body DOM and refresh the table dimensions.
       * @param {Object} event 
       * @private
       */
      _handleDataReset: function(event)
      {
        this._hideStatusMessage();
        this._refreshAll();
        this._setCurrentRow(null, null);
      },
      /**
       * Callback handler for rows added into the datasource. Add a new tr and refresh the DOM
       * at the row index and refresh the table dimensions to accomodate the new
       * row
       * @param {Object} event
       * @private
       */
      _handleDataRowAdd: function(event)
      {
        if (event && event.index !== undefined) {
            var rowIdx = event.index;
            var row = event;
            var data = this._getData();
            this._hideStatusMessage();

            var startIndex = data.startIndex();
            var endIndex = startIndex + data.size() - 1;

            if (rowIdx != null && (rowIdx < startIndex || rowIdx > endIndex))
            {
              // we're getting an add event for a row which is not in the current
              // display range
              return;
            }
            // insert the <tr> element in to the table body DOM
            if (rowIdx >= 0)
            {
              rowIdx = rowIdx - startIndex;
            }
            this._queueTableBodyRowOperation(oj.TableDataSource.EventType['ADD'], rowIdx, row);
        }
      },
      /**
       * Callback handler for row change in the datasource. Refresh the changed
       * row.
       * @param {Object} event
       * @private
       */
      _handleDataRowChange: function(event)
      {
        var rowIdx = event.index;
        var row = event;
        var data = this._getData();
        this._hideStatusMessage();
        
        var startIndex = data.startIndex();
        var endIndex = startIndex + data.size() - 1;
        
        if (rowIdx != null && (rowIdx < startIndex || rowIdx > endIndex))
        {
          // we're getting a change event for a row which is not in the current
          // display range
          return;
        }
        if (rowIdx >= 0)
        {
          rowIdx = rowIdx - startIndex;
        }
        this._queueTableBodyRowOperation(oj.TableDataSource.EventType['CHANGE'], rowIdx, row);
      },
      /**
       * Callback handler for row removed in the datasource. Remove the row DOM from the
       * table body by searching for the matching rowKey. New rows will have null rowKey.
       * After removing the row, refresh all the remaining row indexes since
       * they will have shifted. Lastly, refresh the table dimensions
       * @param {Object} event
       * @private
       */
      _handleDataRowRemove: function(event)
      {
        var rowIdx = event.index;
        var row = event;
        var data = this._getData();
        this._hideStatusMessage();
        var startIndex = data.startIndex();
        rowIdx = rowIdx - startIndex;
        this._queueTableBodyRowOperation(oj.TableDataSource.EventType['REMOVE'], rowIdx, row);
      },
      /**
       * Callback handler for sort completed in the datasource. Refresh entire
       * table body DOM and refresh the table dimensions. Set row focus to the
       * current row.
       * @param {Object} event 
       * @private
       */
      _handleDataSort: function(event)
      {
        if (!this._dataFetching) {
            this._hideStatusMessage();
            this._refreshTableBody();
            this._getTableDomUtils().refreshTableDimensions(true);
            // clear row selection
            this._clearSelectedRows();
            this['options']['selection'] = null;
            // set the current row
            this._setCurrentRow(this._currentRow, null);
        }
      },
      /**
       * Handler for Left/Right keydown.
       * @param {Object} event
       * @private
       */
      _handleKeydownLeftRight: function(event)
      {
        // pressing left/right navigates the column headers
        var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
        var columns = this._getColumnDefs();

        if (focusedHeaderColumnIdx != null)
        {
          var newFocusedHeaderColumnIdx = focusedHeaderColumnIdx;

          if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_LEFT))
          {
            newFocusedHeaderColumnIdx = focusedHeaderColumnIdx > 0 ? focusedHeaderColumnIdx - 1 : focusedHeaderColumnIdx;
          }
          else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_RIGHT))
          {
            newFocusedHeaderColumnIdx = focusedHeaderColumnIdx < columns.length - 1 ? focusedHeaderColumnIdx + 1 : focusedHeaderColumnIdx;
          }

          if (newFocusedHeaderColumnIdx != focusedHeaderColumnIdx)
          {
            this._setHeaderColumnFocus(newFocusedHeaderColumnIdx, true, false, null);

            if (event[this._KEYBOARD_CODES._KEYBOARD_MODIFIER_SHIFT])
            {
              // if shift is also pressed then we need to select too
              var newFocusedHeaderColumnSelection = this._getHeaderColumnSelection(newFocusedHeaderColumnIdx);
              // we may be clearing or setting the selection
              this._setHeaderColumnSelection(newFocusedHeaderColumnIdx, !newFocusedHeaderColumnSelection, null, event);
              // if we are clearing the selection, then clear the previous column too.
              if (newFocusedHeaderColumnSelection)
              {
                if (this._getHeaderColumnSelection(focusedHeaderColumnIdx))
                {
                  this._setHeaderColumnSelection(focusedHeaderColumnIdx, false, null, event);
                }
              }
            }
          }
        }
      },
      /**
       * Handler for Tab keydown.
       * @param {Object} event
       * @private
       */
      _handleKeydownTab: function(event)
      {
        // if Tab is pressed while a row has focus then we 
        // want to Tab within that row and then go to the 
        // next row until Esc is pressed
        var tabHandled = false;
        var focusedRowIdx = this._getFocusedRowIdx();

        if (focusedRowIdx != null && this._isTableNavigationMode())
        {

          var tableBody = this._getTableDomUtils().getTableBody();
          var tabbableElementsInBody = this._getTabbableElements(tableBody);
          // only bother if there are any tabbable elements
          if (tabbableElementsInBody != null)
          {
            tabHandled = true;
            var currentFocusElement = document.activeElement;

            var isCurrentlyFocused = false;
            var i, tableBodyRow, tabbableElementsInRow;
            for (i = 0; i < tabbableElementsInBody.length; i++)
            {
              if (currentFocusElement == tabbableElementsInBody[i])
              {
                isCurrentlyFocused = true;
                break;
              }
            }
            // if already focused on an element in the body, then
            // don't do anything
            if (isCurrentlyFocused)
            {
              return;
            }
            else if (!event[this._KEYBOARD_CODES._KEYBOARD_MODIFIER_SHIFT])
            {
              tableBodyRow = this._getTableDomUtils().getTableBodyRow(focusedRowIdx);
              tabbableElementsInRow = this._getTabbableElements(tableBodyRow);

              if (tabbableElementsInRow != null)
              {
                $(tabbableElementsInRow[0]).focus();
              }
              else
              {
                // if there are no tabbable elements
                // in the row then focus on the first 
                // tabbable element in the body
                $(tabbableElementsInBody[0]).focus();
              }
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
        
        if (!tabHandled)
        {
          // tab out of the component to the next tabbable
          // element on the page
          var table = this._getTableDomUtils().getTable();
          var tabbableElementsInDocument = this._getTabbableElements($(document));
          var tabbableElementsInTable = this._getTabbableElements(table);
          var tabbableElementsInTableCount = tabbableElementsInTable != null ? tabbableElementsInTable.length : 0;
          var tableTabIndex = tabbableElementsInDocument.index(this._getTableDomUtils().getTable());
          if (!event[this._KEYBOARD_CODES._KEYBOARD_MODIFIER_SHIFT])
          {
            $(tabbableElementsInDocument[tableTabIndex + tabbableElementsInTableCount + 1]).focus();
          }
          else
          {
            $(tabbableElementsInDocument[tableTabIndex - 1]).focus();
          }
          event.preventDefault();
          event.stopPropagation();
        }
        // we need to remove Tab on keydown because we may not
        // get a keyup for it if focus moves
        // outside of table
        this._removeKeyboardKey(event.keyCode);
      },
      /**
       * Handler for Up/Down keydown.
       * @param {Object} event
       * @private
       */
      _handleKeydownUpDown: function(event)
      {
        var focusedRowIdx = this._getFocusedRowIdx();
        var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedRowIdx != null)
        {
          // if row is focused then up/down navigates the rows
          var data = this._getData();
          var newFocusedRowIdx = focusedRowIdx;

          if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP))
          {
            if (focusedRowIdx > 0)
            {
              newFocusedRowIdx = focusedRowIdx - 1;
            }
            else
            {
              newFocusedRowIdx = focusedRowIdx;
            }
          }
          else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN))
          {
            newFocusedRowIdx = focusedRowIdx < data.size() - 1 ? focusedRowIdx + 1 : focusedRowIdx;
          }

          if (newFocusedRowIdx != focusedRowIdx)
          {
            this._setRowFocus(newFocusedRowIdx, true, null, event);

            if (event[this._KEYBOARD_CODES._KEYBOARD_MODIFIER_SHIFT])
            {
              // if shift is also pressed then we need to select too
              var newFocusedRowSelection = this._getRowSelection(newFocusedRowIdx);
              // we may be clearing or setting the selection
              this._setRowSelection(newFocusedRowIdx, !newFocusedRowSelection, null, event);
              // if we are clearing the selection, then clear the previous row too.
              if (newFocusedRowSelection)
              {
                if (this._getRowSelection(focusedRowIdx))
                {
                  this._setRowSelection(focusedRowIdx, false, null, event);
                }
              }
            }
          }
          // if user is on the first row and presses up the focus on the first column header
          else if (newFocusedRowIdx == focusedRowIdx &&
            focusedRowIdx == 0 &&
            this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP))
          {
            this._setHeaderColumnFocus(0, true, false, null);
          }
        }
        // if user is on a column header and pressed down then focus on the first row
        else if (focusedHeaderColumnIdx != null &&
          this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN))
        {
          this._setRowFocus(0, true, null, event);
        }
      },
      /**
       * Handler for End keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupEnd: function(event)
      {
        // pressing End focuses on last column
        var focusedColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedColumnIdx != null &&
          focusedColumnIdx != this._getColumnDefs().length - 1)
        {
          this._setHeaderColumnFocus(this._getColumnDefs().length - 1, true, false, null);
        }
      },
      /**
       * Handler for Enter keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupEnter: function(event)
      {
        // pressing enter does sort on the focused column header
        var focusedColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedColumnIdx != null && this._getColumnDefs()[focusedColumnIdx]['sortable'] == this._OPTION_ENABLED)
        {
          var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(focusedColumnIdx);
          var sorted = tableHeaderColumn.data('sorted');
          // if not already sorted then sort ascending. If already sorted
          // ascending then do descending sort and vice versa.
          if (sorted == null || sorted == this._COLUMN_SORT_ORDER._DESCENDING)
          {
            this._handleSortTableHeaderColumn(focusedColumnIdx, true);
          }
          else
          {
            this._handleSortTableHeaderColumn(focusedColumnIdx, false);
          }
        }
      },
      /**
       * Handler for Esc keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupEsc: function(event)
      {
        // pressing Esc always returns focus back to the table.
        // This is for when users are tabbing through focuable
        // elements and need to get back to general table nav
        event.preventDefault();
        event.stopPropagation();
        this._getTableDomUtils().getTable().focus();
        this._setTableNavigationMode(false);
      },
      /**
       * Handler for Home keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupHome: function(event)
      {
        // pressing Home focuses on first column
        var focusedColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedColumnIdx != null && focusedColumnIdx != 0)
        {
          this._setHeaderColumnFocus(0, true, false, null);
        }
      },
      /**
       * Handler for Spacebar keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupSpacebar: function(event)
      {
        // pressing spacebar selects the focused row/column
        var focusedRowIdx = this._getFocusedRowIdx();

        if (focusedRowIdx != null)
        {
          this._setRowSelection(focusedRowIdx, !this._getRowSelection(focusedRowIdx), null, event);
        }
        else
        {
          var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
          if (focusedHeaderColumnIdx != null)
          {
            this._clearSelectedRows();
            this._setHeaderColumnSelection(focusedHeaderColumnIdx, !this._getHeaderColumnSelection(focusedHeaderColumnIdx), null, event);
          }
        }
      },
      /**
       * Handler for column sort
       * @param {number} columnIdx  column index
       * @param {boolean} ascending  sort order ascending
       * @private
       */
      _handleSortTableHeaderColumn: function(columnIdx, ascending)
      {
        // clear the sorted indicator on any other column
        this._clearSortedHeaderColumn(columnIdx);
        // get the column metadata
        var column = this._getColumnDefs()[columnIdx];
        // get which field to sort on
        var sortField = column['sortProperty'] == null ? column['field'] : column['sortProperty'];
        // get the column header DOM element
        var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);
        // invoke sort on the data
        this._invokeDataSort(sortField, ascending, null);
        this._sortColumn = column;

        if (ascending)
        {
          // store sort order on the DOM element
          tableHeaderColumn.data('sorted', this._COLUMN_SORT_ORDER._ASCENDING);
          var headerColumnAscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
          headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
          headerColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
          var headerColumnAsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_CLASS);
          headerColumnAsc.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
          var headerColumnDsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_CLASS);
          headerColumnDsc.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
        }
        else
        {
          // store sort order on the DOM element
          tableHeaderColumn.data('sorted', this._COLUMN_SORT_ORDER._DESCENDING);
          var headerColumnDscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
          headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
          headerColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
          var headerColumnDsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_CLASS);
          headerColumnDsc.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
          var headerColumnAsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_CLASS);
          headerColumnAsc.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
        }
        this._hideTableHeaderColumnSortLink(columnIdx, !ascending);
      },
      /**
       * Hide the 'No data to display.' message.
       * @private
       */
      _hideNoDataMessage: function()
      {
        var noDataMessage = this._getTableDomUtils().getTableNoDataMessage();
        noDataMessage.css('display', 'none');
      },
      /**
       * Hide the Fetching Data... status message.
       * @private
       */
      _hideStatusMessage: function()
      {
        var statusMessage = this._getTableDomUtils().getTableStatusMessage();
        statusMessage.css('display', 'none');
      },
      /**
       * Hide the column header sort link
       * @param {number} columnIdx  column index
       * @param {boolean} ascending  sort order ascending
       * @private
       */
      _hideTableHeaderColumnSortLink: function(columnIdx, ascending)
      {
        // check if the column is sortable. If not, then there won't be any sort links
        if (this._getColumnDefs()[columnIdx]['sortable'] == this._OPTION_ENABLED)
        {
          var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);
          // check if the column is currently sorted
          var sorted = tableHeaderColumn.data('sorted');

          // we should only hide the ascending sort link if the column is not sorted or
          // is sorted by descending order
          if (ascending && (sorted == null || sorted == this._COLUMN_SORT_ORDER._DESCENDING))
          {
            var headerColumnAscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
            headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
            headerColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
            headerColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
          // we should only hide the descending sort link if the column is not sorted or
          // is sorted by ascending order
          else if (!ascending && (sorted == null || sorted == this._COLUMN_SORT_ORDER._ASCENDING))
          {
            var headerColumnDscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
            headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
            headerColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
            headerColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
        }
      },
      /**
       * Invoke sort on a field. This function is called when a user clicks the 
       * column header sort links
       * @param {string} sortField  field name
       * @param {boolean} ascending  sort order ascending
       * @param {jQuery} element  DOM element which triggered the sort
       * @private
       */
      _invokeDataSort: function(sortField, ascending, element)
      {
        var data = this._getData();
        // if no data then bail
        if (!data)
        {
          return null;
        }

        // show the Fetching Data... message
        this._showStatusMessage();
        
        var sortCriteria = {};
        sortCriteria['key'] = sortField;

        // the sort function on the datasource takes comparators
        if (ascending)
        {
          sortCriteria['direction'] = this._COLUMN_SORT_ORDER._ASCENDING;
          data.sort(sortCriteria);
        }
        else
        {
          sortCriteria['direction'] = this._COLUMN_SORT_ORDER._DESCENDING;
          data.sort(sortCriteria);
        }
      },
      /**
       * Whether the columns have been updated
       * @return {boolean} true or false
       * @private
       */
      _isColumnMetadataUpdated: function()
      {
        if (this._columnDefArray != null)
        {
          var columnsMetadata = this._getColumnMetadata();
          if (this._columnDefArray.length != columnsMetadata.length)
          {
            return true;
          }
          else
          {
            var i, prop;
            for (i = 0; i < columnsMetadata.length; i++)
            {
              for (prop in columnsMetadata[i]) {
                if (columnsMetadata[i].hasOwnProperty(prop)) {
                  if (columnsMetadata[i][prop] != this._columnDefArray[i][prop])
                  {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        }
        return true;
      },
      /**
       * Whether the focus is on the table or descendent focusable element
       * @return {boolean} true or false
       * @private
       */
      _isFocused: function()
      {
        // set focus on the table
        var currentFocusElement = $(document.activeElement);
        var table = this._getTableDomUtils().getTable();
        if (table[0] != currentFocusElement[0] &&
          table.has(currentFocusElement).length == 0)
        {
          return false;
        }
        return true;
      },
      /**
       * Is keybaord key pressed
       * @param {number} keyCode  KeyCode of the keyboard key.
       * @return {boolean} true or false
       * @private
       */
      _isKeyboardKeyPressed: function(keyCode)
      {
        var keyboardKeys = this._getKeyboardKeys();
        var i;
        for (i = 0; i < keyboardKeys.length; i++)
        {
          if (keyboardKeys[i] == keyCode)
          {
            return true;
          }
        }
        return false;
      },
      /**
       * Return whether the node is editable or clickable
       * @param {jQuery} node  Node
       * @return {boolean} true or false
       * @private	 
       */
      _isNodeEditableOrClickable: function(node)
      {
        var nodeName;
        var table = this._getTableDomUtils().getTable();

        while (null != node && node[0] != table[0] &&
          (nodeName = node.prop("nodeName")) != "TD" && nodeName != "TH")
        {
          // If the node is a text node, move up the hierarchy to only operate on elements
          // (on at least the mobile platforms, the node may be a text node)
          if (node[0].nodeType == 3) // 3 is Node.TEXT_NODE
          {
            node = node[0].parentNode;
            continue;
          }

          var tabIndex = node.attr('tabIndex');

          if (tabIndex != null && tabIndex >= 0)
          {
            return true;
          }
          else if (nodeName.match(/^INPUT|SELECT|OPTION|BUTTON|^A\b|TEXTAREA/))
          {
            // ignore elements with tabIndex == -1
            if (tabIndex != -1)
            {
              return true;
            }
          }
          node = node.parentNode;
        }
        return false;
      },
      /**
       * Returns whether the table is footerless
       * @return {boolean} true or false
       * @private
       */
      _isTableFooterless: function()
      {
        var columns = this._getColumnDefs();
        var i, footerRenderer;
        
        for (i = 0; i < columns.length; i++)
        {
          footerRenderer = this._getColumnRenderer(i, 'footer');
          if (footerRenderer != null)
          {
            return false
          }
        }
        return true;
      },
      /**
       * Returns whether the table is headerless
       * @return {boolean} true or false
       * @private
       */
      _isTableHeaderless: function()
      {
        var columns = this._getColumnDefs();

        var i, j;
        for (i = 0; i < columns.length; i++)
        {
          if (columns[i]['headerText'] != null ||
            columns[i]['headerStyle'] != null ||
            (columns[i]['sortable'] != null &&
              columns[i]['sortable'] != this._OPTION_NONE) ||
            columns[i]['sortProperty'] != null ||
            columns[i]['headerRenderer'] != null)
          {
            return false;
          }
        }
        
        return true;
      },
      /**
       * Returns whether the table header columns were rendered
       * @return {boolean} true or false
       * @private
       */
      _isTableHeaderColumnsRendered: function()
      {
        return this._renderedTableHeaderColumns == true;
      },
      /**
       * Return whether the component is in table navigation mode
       * @return {boolean} true or false
       * @private
       */
      _isTableNavigationMode: function()
      {
        return this._tableNavMode;
      },
      /**
       * Returns whether the table refresh is needed based on option change
       * @param {string} key option key
       * @param {Object} value option value
       * @return {boolean} true or false
       * @private
       */
      _isTableRefreshNeeded: function(key, value)
      {
        var currentOptions = this.options;
        if (key != 'selection' && !oj.Object.compareValues(value, currentOptions[key]))
        {
          return true;
        }
        
        return false;
      },
      /**
       * Queue row operation
       * @param {string} eventType  event type
       * @param {number} rowIdx  row index
       * @param {Object} row  oj.Row
       * @private
       */
      _queueTableBodyRowOperation: function(eventType, rowIdx, row)
      {
        var self = this;
        if (!this._rowOperationQueue)
        {
          this._rowOperationQueue = [];
        }
        var executeImmediate = false;
        
        var lastOperation = this._rowOperationQueue[this._rowOperationQueue.length - 1];

        if (lastOperation != null)
        {
          var lastOperationEventType = lastOperation.eventType;

          if (lastOperationEventType != eventType)
          {
            this._executeQueuedTableBodyRowOperations();
            executeImmediate = true;
          }
        }
        
        if (this._queueExecutionTimer == null && !executeImmediate)
        {
          setTimeout(function() {
            self._executeQueuedTableBodyRowOperations();
            self._queueExecutionTimer = null;
          }, 0);
          this._queueExecutionTimer = true;
        }
        var i;
        var foundExisting = false;
        
        for (i = 0; i < this._rowOperationQueue.length; i++)
        {
          // Collapse duplicate operations
          if (this._rowOperationQueue[i].eventType == eventType &&
              this._rowOperationQueue[i].rowIdx == rowIdx && 
              this._rowOperationQueue[i].row == row)
            {
              this._rowOperationQueue[i] = {eventType: eventType, rowIdx: rowIdx, row: row};
              foundExisting = true;
            }
        }

        if (!foundExisting)
        {
          this._rowOperationQueue.push({eventType: eventType, rowIdx: rowIdx, row: row});
        }
      },
      /**
       * @param {boolean} immediate  refresh immediately
       * @private
       */
      _refreshAll: function(immediate)
      {
        this._refreshTableNoDataMessage();
        if (immediate)
        {
          // if we are doing an immediate refresh then execute any queued up
          // operations
          this._executeQueuedTableBodyRowOperations();
        }
        if (this._isColumnMetadataUpdated() ||
            (!this._isTableHeaderColumnsRendered() &&
            !this._isTableHeaderless()))
        {
          this._clearCachedMetadata();
          this._refreshTableHeader();
          
          // see if we need to clear the sort. If the column we sorted on is no
          // longer there then clear it.
          if (this._sortColumn != null)
          {
            var i, column;
            var foundColumn = false;
            var columns = this._getColumnDefs();
            if (columns != null)
            {
              for (i = 0; i < columns.length; i++)
              {
                column = columns[i];
                if (oj.Object.compareValues(column, this._sortColumn))
                {
                  foundColumn = true;
                  break;
                }
              }
              if (!foundColumn)
              {
                this._getData().sort(null);
              }
            }
          }
        }
        this._refreshTableFooter();
        this._refreshTableBody();
        // if the datasource is already doing a fetch then show the message
        if (this._getData() != null && this._getData().isFetching)
        {
          this._showStatusMessage();
        }
        this._getTableDomUtils().refreshTableDimensions(immediate);        
      },
      
      /**
       * Refresh the entire table body with data from the datasource
       * @private
       */
      _refreshTableBody: function()
      {
        var self = this;
        var tableBody = this._getTableDomUtils().getTableBody();
        var data = this._getData();
        var tableBodyRows = tableBody.children();
        var i;
        for (i = 0; i < tableBodyRows.length; i++)
        {
          this._removeTableBodyRow(0);
        }
        
        // if no data then bail
        if (!data || data.size() == 0 || this._getColumnDefs().length == 0)
        {
          this._showNoDataMessage();
        }
        else
        {
          this._hideNoDataMessage();
          this._getTableDomUtils().clearDelayedRenderRows();
          this._getTableDomUtils().clearDelayedRenderCells();
          var tableBodyDocFrag = $(document.createDocumentFragment());
          var startIndex = data.startIndex();
          var endIndex = startIndex + data.size();
          var j, row, rowIdx, columns, tableBodyRow;
          for (i = startIndex; i < endIndex; i++)
          {
            rowIdx = i - startIndex;
            row = data.at(i);
            if (row != null)
            {
              tableBodyRow = this._getTableDomUtils().createTableBodyRow(rowIdx);
              this._getTableDomUtils().styleTableBodyRow(tableBodyRow);
              this._getTableDomUtils().insertTableBodyRow(rowIdx, tableBodyRow, row, tableBodyDocFrag);
              if (row instanceof oj.Row)
              {
                this._refreshTableBodyRow(rowIdx, row, tableBodyRow, tableBodyDocFrag);
              }
              else
              {
                this._asyncRefreshTableBodyRow(row);
              }
            }
          }
          tableBody.append(tableBodyDocFrag);
          
          for (i = startIndex; i < endIndex; i++)
          {
            rowIdx = i - startIndex;
            this._getTableDomUtils().renderDelayedTableBodyRow(rowIdx);
            columns = this._getColumnDefs();
            for (j = 0; j < columns.length; j++)
            {
              this._getTableDomUtils().renderDelayedTableBodyCell(rowIdx, j);
            }
          }
          this._getTableDomUtils().clearDelayedRenderRows();
          this._getTableDomUtils().clearDelayedRenderCells();
        }
      },
      /**
       * Refresh the row at a particular index with the row data
       * @param {number} rowIdx  row index
       * @param {Object} row  oj.Row
       * @param {Object} tableBodyRow tr element
       * @param {Object} docFrag  document fragment
       * @private
       */
      _refreshTableBodyRow: function(rowIdx, row, tableBodyRow, docFrag)
      {
        var options = this.options;
        var rowRenderer = this._getRowRenderer();
        var columns = this._getColumnDefs();

        if (isNaN(rowIdx) || rowIdx < 0)
        {
          // validate rowIdx value
          oj.Logger.error('Error: Invalid rowIdx value: ' + rowIdx);
        }

        this._hideNoDataMessage();
        
        if (tableBodyRow == null)
        {
          // check if we already have a <tr> element at that index
          tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
          if (!tableBodyRow)
          {
            // if not return
            return;
          }
          else
          {
            tableBodyRow.empty();
            this._getTableDomUtils().createTableBodyCellAccSelect(rowIdx, tableBodyRow);
          }
        }

        // check if a row renderer was defined
        if (rowRenderer)
        {
          var rowContext = this._getTableDomUtils().getRendererContextObject(row, tableBodyRow[0]);
          var delayedRowObj = {};
          delayedRowObj.rowContext = rowContext;
          delayedRowObj.rowRenderer = rowRenderer;
          delayedRowObj.tableBodyRow = tableBodyRow;
          delayedRowObj.row = row;
          this._getTableDomUtils().addDelayedRenderRow(rowIdx, delayedRowObj);
          
          if (docFrag == null)
          {
            // if docFrag is null then render it immediately
            this._getTableDomUtils().renderDelayedTableBodyRow(rowIdx);
            this._getTableDomUtils().clearDelayedRenderRows();
          }
        }
        else
        {
          var j, column, cellContext, cellRenderer;
          for (j = 0; j < columns.length; j++)
          {
            column = columns[j];
            cellRenderer = this._getColumnRenderer(j, 'cell');
            // set the cells in the inserted row with values from the row
            this._getTableDomUtils().setTableBodyCell(rowIdx, j, tableBodyRow, row, cellRenderer);
            if (docFrag == null)
            {
              this._getTableDomUtils().renderDelayedTableBodyCell(rowIdx, j);
              this._getTableDomUtils().clearDelayedRenderCells();
            }
          }
        }
        this._selectionTimer = true;
      },
      /**
       * Refresh the table footer
       * @private
       */
      _refreshTableFooter: function()
      {
        var columns = this._getColumnDefs();
        var tableFooter = this._getTableDomUtils().getTableFooter();

        if (!tableFooter)
        {
          if (this._isTableFooterless())
          {
            return;
          }
          else
          {
            // metadata could have been updated to add column headers
            tableFooter = this._getTableDomUtils().createTableFooter();
            this._getTableDomUtils().styleTableFooter(tableFooter);
          }
        }

        var tableFooterRow = this._getTableDomUtils().getTableFooterRow();
        // remove all the existing footer cells
        tableFooterRow.empty();

        if (columns && columns.length > 0)
        {
          this._getTableDomUtils().createTableFooterAccSelect(tableFooterRow);
          
          var i, column, footerRenderer, footerCell, footerCellContent;
          for (i = 0; i < columns.length; i++)
          {
            column = columns[i];
            footerRenderer = this._getColumnRenderer(i, 'footer');
            footerCell = this._getTableDomUtils().createTableFooterCell(i, this._getColumnSelectionMode());
            this._getTableDomUtils().styleTableFooterCell(i, footerCell);
            this._getTableDomUtils().insertTableFooterCell(i, footerCell);

            if (footerRenderer)
            {
              // if footerRenderer is defined then call that
              footerCellContent = footerRenderer({'footerContext': this._getTableDomUtils().getRendererContextObject(null, footerCell[0]),
                                                  'column': column});
              
              if (footerCellContent != null)
              {
                // if the renderer returned a value then we set it as the content
                // for the footer cell
                footerCell.empty();
                footerCell.append(footerCellContent);
              }
              else
              {
                // if the renderer didn't return a value then the existing
                // footer cell was manipulated. So get it and set the required
                // attributes just in case it was replaced or the attributes
                // got removed
                footerCell = $(tableFooterRow.children(':not(.' + oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS + ')')[i]);
                this._getTableDomUtils().styleTableFooterCell(i, footerCell, this._getColumnSelectionMode());
              }
            }
          }
        }
      },
      /**
       * Refresh the table header
       * @private
       */
      _refreshTableHeader: function()
      {
        var columns = this._getColumnDefs();
        var tableHeader = this._getTableDomUtils().getTableHeader();

        if (!tableHeader)
        {
          if (this._isTableHeaderless())
          {
            return;
          }
          else
          {
            // metadata could have been updated to add column headers
            tableHeader = this._getTableDomUtils().createTableHeader();
            this._getTableDomUtils().styleTableHeader(tableHeader);
          }
        }

        var tableHeaderRow = this._getTableDomUtils().getTableHeaderRow();
        // remove all the existing column headers
        tableHeaderRow.empty();

        if (columns && columns.length > 0)
        {
          var tableHeaderAccSelectRowColumn = this._getTableDomUtils().createTableHeaderAccSelectRowColumn();
          tableHeaderRow.append(tableHeaderAccSelectRowColumn);

          var i, j, column, headerRenderer, headerColumn, headerColumnContent;
          for (i = 0; i < columns.length; i++)
          {
            column = columns[i];
            headerRenderer = this._getColumnRenderer(i, 'header');
            headerColumn = this._getTableDomUtils().createTableHeaderColumn(i, this._getColumnSelectionMode());
            this._getTableDomUtils().insertTableHeaderColumn(i, headerColumn);
            
            var headerColumnAsc = $(headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_CLASS)[0]);
            var headerColumnAscWidth = headerColumnAsc.width();
            var headerColumnAscHeight = headerColumnAsc.height();
            var headerColumnSortPlaceholder = $(headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_SORT_PACEHOLDER_CLASS)[0]);
            headerColumnSortPlaceholder.css('width', headerColumnAscWidth + 'px');
            headerColumnSortPlaceholder.css('height', headerColumnAscHeight + 'px');

            if (headerRenderer)
            {
              // if headerRenderer is defined then call that
              headerColumnContent = headerRenderer({'headerContext': this._getTableDomUtils().getRendererContextObject(null, headerColumn[0]),
                                                    'column': column});
              
              if (headerColumnContent != null)
              {
                // if the renderer returned a value then we set it as the content
                // for the headerColumn
                headerColumn.empty();
                headerColumn.append(headerColumnContent);
              }
              else
              {
                // if the renderer didn't return a value then the existing
                // headerColumn was manipulated. So get it and set the required
                // attributes just in case it was replaced or the attributes
                // got removed
                headerColumn = $(tableHeaderRow.children(':not(' + '.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_ROW_CLASS + ')')[i]);
                this._getTableDomUtils().setTableHeaderColumnAttributes(i, headerColumn);
                this._getTableDomUtils().styleTableHeaderColumn(i, headerColumn, this._getColumnSelectionMode());
              }
            }
            // set the acc column selection checkbox
            this._getTableDomUtils().createTableHeaderColumnAccSelect(i, this._getColumnSelectionMode());
          }
          this._renderedTableHeaderColumns = true;
        }
      },
      /**
       * Refresh the no data message
       * @private
       */
      _refreshTableNoDataMessage: function()
      {
        var tableNoDataMessage = this._getTableDomUtils().getTableNoDataMessage();
        tableNoDataMessage[0].parentNode.removeChild(tableNoDataMessage[0]);
        this._getTableDomUtils().createTableNoDataMessage();
      },
      /**
       * Register the events which will be published by the table component.
       * @private
       */
      _registerCustomEvents: function()
      {
        // ojtablecurrentrow handlers will be passed an object which contains the
        // old and new current row
        var jqEvent = (/** @type {{special: Object}} */($.event));
        var jqEventSpecial = jqEvent['special'];
        jqEventSpecial['ojtablecurrentrow'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
        // ojtablebeforecurrentrow handlers will be passed an object which contains the
        // old and new current row
        jqEventSpecial['ojtablebeforecurrentrow'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
        // ojtablescroll handlers will be passed an object which contains
        // the scrollTop and scrollLeft
        jqEventSpecial['ojtablescroll'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
        // ojtableselect handlers will be passed an object which contains
        // either the row or column index and the selectionAdded boolean which indicates whether
        // the selection was added or removed.
        jqEventSpecial['ojtableselect'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
      },
      /**
       * Register event listeners which need to be registered datasource. 
       * @private
       */
      _registerDataSourceEventListeners: function()
      {
        // register the listeners on the datasource
        var data = this._getData();
        if (data != null)
        {
          this._unregisterDataSourceEventListeners();
          
          this._dataSourceEventHandlers = [];
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['REQUEST'], 'eventHandler': this._handleDataFetchStart.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['SYNC'], 'eventHandler': this._handleDataFetchEnd.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['SORT'], 'eventHandler': this._handleDataSort.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['ADD'], 'eventHandler': this._handleDataRowAdd.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['REMOVE'], 'eventHandler': this._handleDataRowRemove.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['CHANGE'], 'eventHandler': this._handleDataRowChange.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['RESET'], 'eventHandler': this._handleDataReset.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.TableDataSource.EventType['ERROR'], 'eventHandler': this._handleDataError.bind(this)});

          var i;
          var ev;
          for (i = 0; i < this._dataSourceEventHandlers.length; i++) {
            ev = data.on(this._dataSourceEventHandlers[i]['eventType'], this._dataSourceEventHandlers[i]['eventHandler']);
            if (ev) {
                this._dataSourceEventHandlers[i]['eventHandler'] = ev;
            }
          }
        }
      },
      /**
       * Register event listeners which need to be registered directly on
       * the DOM element.
       * @private
       */
      _registerDomEventListeners: function()
      {
        if (this._getTableDomUtils().getScroller() != null)
        {
          // if width or height is defined then we can have scrollbars so register scroll event listeners
          this._getTableDomUtils().getScroller().scroll((function(event) {
            var scrollLeft = $(event.target).scrollLeft();
            var maxScrollLeft = $(event.target)[0].scrollWidth - $(event.target)[0].clientWidth;

            if (this._GetReadingDirection() === "rtl")
            {
              scrollLeft = Math.abs(scrollLeft);
              if (/webkit/.test(navigator.userAgent.toLowerCase()))
              {
                scrollLeft = maxScrollLeft - scrollLeft;
              }
            }

            var scrollTop = $(event.target).scrollTop();
            var tableHeader = this._getTableDomUtils().getTableHeader();

            if (!tableHeader)
            {
              return;
            }

            if (!this._getTableDomUtils().isDivScroller())
            {
              var tableHeaderRow = this._getTableDomUtils().getTableHeaderRow();
              if (tableHeaderRow)
              {
                if (this._GetReadingDirection() === "rtl")
                {
                  tableHeaderRow.css('right', '-' + scrollLeft + 'px');
                }
                else
                {
                  tableHeaderRow.css('left', '-' + scrollLeft + 'px');
                }
              }
            }
            else
            {
              if (this._GetReadingDirection() === "rtl")
              {
                tableHeader.css('right', '-' + scrollLeft + 'px');
              }
              else
              {
                tableHeader.css('left', '-' + scrollLeft + 'px');
              }
            }
            // trigger the ojtablescroll event so that listeners on the table
            // // component will be notified that the table was scrolled.
            this._trigger('scroll', event, {'scrollLeft': $(event.target).scrollLeft(), 'scrollTop': scrollTop});
          }).bind(this));
        }
      },
      /**
       * Register event listeners for resize the container DOM element.
       * @param {jQuery} element  DOM element
       * @private
       */
      _registerResizeListener: function(element)
      {         
        if (!this._isResizeListenerAdded)
        {
          var self = this;
          oj.DomUtils.addResizeListener(element[0], function(width, height)
                                                    {
                                                      var tableContainerHeight = self._getTableDomUtils().getTableContainer().outerHeight();
                                                      var tableContainerWidth = self._getTableDomUtils().getTableContainer().outerWidth();
                                                      self._getTableDomUtils().refreshTableDimensions(false, tableContainerWidth, tableContainerHeight);
                                                    });
          this._isResizeListenerAdded = true;
        }
      },
      /**
       * Remove a keyCode from our internal list of pressed keys. This is done on keyup.
       * @private
       */
      _removeKeyboardKey: function(keyCode)
      {
        var keyboardKeys = this._getKeyboardKeys();
        var i;
        for (i = 0; i < keyboardKeys.length; i++)
        {
          if (keyboardKeys[i] == keyCode)
          {
            keyboardKeys.splice(i, 1);
          }
        }
      },
      /**
       * Remove table body row
       * @param {jQuery} rowIdx  row index
       * @private
       */
      _removeTableBodyRow: function(rowIdx)
      {
        var tableBodyRows = this._getTableDomUtils().getTableBodyRows();
        var tableBodyRow = null;
        if (tableBodyRows != null &&
          rowIdx < tableBodyRows.length &&
          rowIdx >= 0)
        {
          tableBodyRow = $(tableBodyRows[rowIdx]);
          if (tableBodyRow != null)
          {
            var index = $.inArray(tableBodyRow[0], this['hoverable']);
            if (index > -1)
            {
              this['hoverable'].splice(index, 1);
            }
            tableBodyRow[0].parentNode.removeChild(tableBodyRow[0]);
            this._getTableDomUtils().clearCachedDomRowData();
          }
        }
      },
      /**
       * Scroll column into viewport
       * @param {number} columnIdx  row index
       * @private
       */
      _scrollColumnIntoViewport: function(columnIdx)
      {
        var tableBody = this._getTableDomUtils().getTableBody();
        var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

        if (!tableHeaderColumn)
        {
          return;
        }

        var scrollbarWidth = this._getTableDomUtils().getScrollbarWidth();
        var headerColumnRect = tableHeaderColumn.get(0).getBoundingClientRect();
        var tableBodyRect = tableBody.get(0).getBoundingClientRect();

        var scrolledLeft = false;
        if (headerColumnRect.left < tableBodyRect.left)
        {
          var scrollLeftDiff = tableBodyRect.left - headerColumnRect.left;
          tableBody.scrollLeft(tableBody.scrollLeft() - scrollLeftDiff);
          scrolledLeft = true;
        }

        if (headerColumnRect.right > tableBodyRect.right - scrollbarWidth && !scrolledLeft)
        {
          var scrollLeftDiff = headerColumnRect.right - tableBodyRect.right + scrollbarWidth;
          tableBody.scrollLeft(tableBody.scrollLeft() + scrollLeftDiff);
        }
      },
      /**
       * Scroll row into viewport
       * @param {number} rowIdx  row index
       * @private
       */
      _scrollRowIntoViewport: function(rowIdx)
      {

        var tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
        var scrollbarHeight = this._getTableDomUtils().getScrollbarHeight();
        var rowRect = tableBodyRow.get(0).getBoundingClientRect();
        var scrollingElement = this._getTableDomUtils().getScroller();
        var scrollingElementRect = scrollingElement.get(0).getBoundingClientRect();

        var scrolledDown = false;
        if (rowRect.bottom > scrollingElementRect.bottom - scrollbarHeight)
        {
          var scrollTopDiff = rowRect.bottom - scrollingElementRect.bottom + scrollbarHeight;
          scrollingElement.scrollTop(scrollingElement.scrollTop() + scrollTopDiff);
          scrolledDown = true;
        }

        if (rowRect.top < scrollingElementRect.top && !scrolledDown)
        {
          var scrollTopDiff = scrollingElementRect.top - rowRect.top;
          scrollingElement.scrollTop(scrollingElement.scrollTop() - scrollTopDiff);
        }

      },
      /**
       * Update the current row. If called with null then resets the currentRow.
       * If index/key argument is specified then sets the current row. A beforecurrentrow 
       * event is fired before the current row is changed. If that event results in
       * an error then the current row will not be changed.
       * @param {Object} currentRow current row
       * @param {Object} event
       * @throws {Error}
       * @private
       */
      _setCurrentRow: function(currentRow, event)
      {
        var existingCurrentRow = this._currentRow;
        if (currentRow == null)
        {
          this._currentRow = null;
          this.options['currentRow'] = null; 
          this._setRowFocus(-1, true, null, event);
          this._fireOptionChange('currentRow', existingCurrentRow, this.options['currentRow'], event); 
          return;
        }
        var data = this._getData();
        var rowIdx = currentRow['rowIndex'];
        var rowKey = currentRow['rowKey'];
        if (rowKey != null)
        {
          rowIdx = this._getRowIdxForRowKey(rowKey);
        }
        else
        {
          rowKey = this._getRowKeyForRowIdx(rowIdx);
        }
        currentRow = {'rowIndex': rowIdx, 'rowKey': rowKey};
          
        if (rowIdx != -1 && 
            (!data || 
            data.size() == 0 ||
            rowIdx < -1))
        {
          var errSummary = this._LOGGER_MSG._ERR_CURRENTROW_UNAVAILABLE_INDEX_SUMMARY;
          var errDetail = oj.Translations.applyParameters(this._LOGGER_MSG._ERR_CURRENTROW_UNAVAILABLE_INDEX_DETAIL, {'rowIdx': rowIdx});
          throw new Error(errSummary + '\n' + errDetail);
        }
        if (!oj.Object.compareValues(this._currentRow, currentRow))
        {
          try
          {
            this._trigger('beforecurrentrow', event, {'currentRow': {'rowIndex': rowIdx, 'rowKey': rowKey}, 'previousCurrentRow': this._currentRow});
          }
          catch (err)
          {
            // caught an error. Do not change current row
            var errSummary = this._LOGGER_MSG._ERR_PRECURRENTROW_ERROR_SUMMARY;
            var errDetail = oj.Translations.applyParameters(this._LOGGER_MSG._ERR_PRECURRENTROW_ERROR_DETAIL, {'error': err.toString()});
            oj.Logger.info(errSummary + '\n' + errDetail);
          }
          this._currentRow = {'rowIndex': rowIdx, 'rowKey': rowKey};
          this.options['currentRow'] = {'rowIndex': rowIdx, 'rowKey': rowKey}; 
          this._setRowFocus(rowIdx, true, null, event);
          this._fireOptionChange('currentRow', existingCurrentRow, this.options['currentRow'], event); 
        }
      },
      /**
       * Set focus on column header
       * @param {number} columnIdx  column index
       * @param {boolean} focused  whether it's focused
       * @param {boolean} clearSelectedRows  whether to clear the selected rows
       * @param {jQuery} element  DOM element which triggered the column header focus
       * @private
       */
      _setHeaderColumnFocus: function(columnIdx, focused, clearSelectedRows, element)
      {
        if (focused)
        {
          var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
          if (focusedHeaderColumnIdx != null && focusedHeaderColumnIdx != columnIdx)
          {
            this._setHeaderColumnFocus(focusedHeaderColumnIdx, false, false, element);
          }
          // clear focused row
          this._clearFocusedRow();
          // clear selected rows
          if (clearSelectedRows)
          {
            this._clearSelectedRows();
          }
          // scroll column into view
          this._scrollColumnIntoViewport(columnIdx);
          this._activeColumnIndex = columnIdx;
          
        }
        this._setHeaderColumnState(columnIdx, {focused: focused}, element);
      },
      /**
       * Set selection on column header
       * @param {number} columnIdx  column index
       * @param {boolean} selected  whether it's focused
       * @param {jQuery} element  DOM element which triggered the column header selection
       * @param {Object} event
       * @private
       */
      _setHeaderColumnSelection: function(columnIdx, selected, element, event)
      {
        if (this._getColumnSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE ||
          this._getColumnSelectionMode() == this._OPTION_SELECTION_MODES._MULTIPLE)
        {
          if (isNaN(columnIdx) || columnIdx < 0)
          {
            // validate value
            oj.Logger.error('Error: Invalid column selection value: ' + columnIdx);
          }

          // if we have single selection then clear any existing selections
          if (this._getColumnSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE && selected)
          {
            this._clearSelectedHeaderColumns();
          }
          this._setHeaderColumnState(columnIdx, {selected: selected}, element, event);
          // save it
          this._setLastHeaderColumnSelection(columnIdx, selected);
          
          // update the acc checkbox
          var accSelectionColumn = this._getTableDomUtils().getTableHeaderColumnAccSelect(columnIdx);
          var accSelectCheckbox = $(accSelectionColumn.children('.' + oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_COLUMN_CLASS)[0]);
          accSelectCheckbox.prop('checked', selected);
          var selection = this._getSelection();
          this['options']['selection'] = selection;
        }
      },
      /**
       * Set the state of the column header. e.g., focused, selected, etc.
       * @param {number} columnIdx  column index
       * @param {Object} state  Object which contains whether it's focused or selected
       * @param {jQuery} element  DOM element which triggered the column header state
       * @param {Object} event
       * @private
       */
      _setHeaderColumnState: function(columnIdx, state, element, event)
      {
        var headerColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

        if (!headerColumn)
        {
          return;
        }

        var focused = state.focused;
        var selected = state.selected;

        if (selected != null)
        {
          var headerColumnSelected = headerColumn.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);

          var selectionChanged = false;
          if (headerColumnSelected != selected)
          {
            if (!selected)
            {
              headerColumn.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            else
            {
              headerColumn.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            selectionChanged = true;
          }

          if (selectionChanged)
          {
            this._trigger('select', event, {'column': columnIdx, 'selectionAdded': selected});
          }
        }
        if (focused != null)
        {
          if (!focused)
          {
            headerColumn.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            this._hideTableHeaderColumnSortLink(columnIdx, true);
            this._hideTableHeaderColumnSortLink(columnIdx, false);
          }
          else
          {
            headerColumn.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            this._showTableHeaderColumnSortLink(columnIdx);
          }
        }
        this._updateHeaderColumnCellsClass(columnIdx);
      },
      /**
       * Set the last column which was selected (chronologically)
       * @param {number} columnIdx  column index
       * @param {boolean} selected  whether it's selected
       * @private
       */
      _setLastHeaderColumnSelection: function(columnIdx, selected)
      {
        if (!this._lastSelectedColumnIdxArray)
        {
          this._lastSelectedColumnIdxArray = [];
        }

        var i;
        for (i = 0; i < this._lastSelectedColumnIdxArray.length; i++)
        {
          if (this._lastSelectedColumnIdxArray[i] == columnIdx)
          {
            this._lastSelectedColumnIdxArray.splice(i, 1);
            break;
          }
        }

        if (selected)
        {
          this._lastSelectedColumnIdxArray.push(columnIdx);
        }
      },
      /**
       * Set the last row which was selected (chronologically)
       * @param {number} rowIdx  row index
       * @param {boolean} selected  whether it's selected
       * @private
       */
      _setLastRowSelection: function(rowIdx, selected)
      {
        if (!this._lastSelectedRowIdxArray)
        {
          this._lastSelectedRowIdxArray = [];
        }

        for (var i = 0; i < this._lastSelectedRowIdxArray.length; i++)
        {
          if (this._lastSelectedRowIdxArray[i] == rowIdx)
          {
            this._lastSelectedRowIdxArray.splice(i, 1);
            break;
          }
        }

        if (selected)
        {
          this._lastSelectedRowIdxArray.push(rowIdx);
        }
      },
      /**
       * Set focus on row
       * @param {number} rowIdx  row index
       * @param {boolean} focused  whether it's focused
       * @param {jQuery} element  DOM element which triggered the row focus
       * @param {Object} event 
       * @private
       */
      _setRowFocus: function(rowIdx, focused, element, event)
      {
        if (rowIdx == -1)
        {
          this._clearFocusedRow();
          return;
        }
        var tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
        
        if (!tableBodyRow)
        {
          return;
        }

        if (focused)
        {
          var focusedRowIdx = this._getFocusedRowIdx();
          if (focusedRowIdx != null && focusedRowIdx != rowIdx)
          {
            this._setRowFocus(focusedRowIdx, false, element, null);
          }
          var rowKey = this._getRowKeyForRowIdx(rowIdx);
          this._setCurrentRow({'rowIndex': rowIdx, 'rowKey': rowKey}, event);
          tableBodyRow.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
          this._scrollRowIntoViewport(rowIdx);
          // clear any hover on the row
          this._updateRowCellsClass(rowIdx, {focused: true, hover: false});
          // clear any focused column header
          this._clearFocusedHeaderColumn();
          // clear any selected column header
          this._clearSelectedHeaderColumns();
          // set to table navigation mode
          this._setTableNavigationMode(true);
        }
        else
        {
          tableBodyRow.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
        }
        // update focus style for the cells
        this._updateRowCellsClass(rowIdx, {focused: focused});
      },
      /**
       * Set selection on row
       * @param {number} rowIdx  column index
       * @param {boolean} selected  whether it's selected
       * @param {jQuery} element  DOM element which triggered the row selection
       * @param {Object} event
       * @private
       */
      _setRowSelection: function(rowIdx, selected, element, event)
      {
        if (this._getRowSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE ||
          this._getRowSelectionMode() == this._OPTION_SELECTION_MODES._MULTIPLE)
        {
          if (isNaN(rowIdx) || rowIdx < 0)
          {
            // validate value
            oj.Logger.error('Error: Invalid row selection value: ' + rowIdx);
          }

          // if we have single selection then clear any existing selections
          if (this._getRowSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE && selected)
          {
            this._clearSelectedRows();
          }
          var tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
          var selectionChanged = false;

          var rowSelected = tableBodyRow.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);

          if (rowSelected != selected)
          {
            if (!selected)
            {
              tableBodyRow.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            else
            {
              tableBodyRow.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            selectionChanged = true;
          }

          if (selectionChanged)
          {
            this._trigger('select', event, {'row': rowIdx, 'selectionAdded': selected});
          }

          if (selectionChanged)
          {
            // if selection was set then we want to override
            // the default style precedence
            if (selected)
            {
              this._updateRowCellsClass(rowIdx, {hover: false, focused: false, selected: true});
            }
            else
            {
              this._updateRowCellsClass(rowIdx, {selected: false});
            }
          }
          // save it
          this._setLastRowSelection(rowIdx, selected);

          // update the acc checkbox
          var accSelectionCell = this._getTableDomUtils().getTableBodyCellAccSelect(tableBodyRow);
          var accSelectCheckbox = $(accSelectionCell.children('.' + oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_ROW_CLASS)[0]);
          accSelectCheckbox.prop('checked', selected);
          var selection = this._getSelection();
          this['options']['selection'] = selection;
        }
      },
      /**
       * Sets selection from options
       * @private	 
       */
      _setSelection: function()
      {
        var selection = this.options['selection'];
        
        if (selection != null && selection.length > 0)
        {
          var currentSelection = this._getSelection();
          var selectionChanged = !oj.Object.compareValues(selection, currentSelection);
          if (!selectionChanged)
          {
            return;
          }
          var data = this._getData();
          var startIndex = data != null ? data.startIndex() : 0;
          // first clear currently selected rows
          this._clearSelectedRows();
          // we need to set the selection
          var i, j, rangeObj, startRowIdx, endRowIdx, startColumnIdx, endColumnIdx;
          for (i = 0; i < selection.length; i++)
          {
            rangeObj = selection[i];

            if ((rangeObj['startKey'] == null && rangeObj['startIndex'] == null) || 
                (rangeObj['endKey'] == null && rangeObj['endIndex'] == null))
            {
              oj.Logger.error('Error: Invalid range object in selection. Both start and end objects must be specified');
              return null;
            }
            
            // if keys are specified, we get the index from the key
            if (rangeObj['startKey'] != null && rangeObj['startKey']['row'] != null)
            {
              startRowIdx = this._getRowIdxForRowKey(rangeObj['startKey']['row']);
            }
            if (rangeObj['endKey'] != null && rangeObj['endKey']['row'] != null)
            {
              endRowIdx = this._getRowIdxForRowKey(rangeObj['endKey']['row']);
            }
            if (rangeObj['startKey'] != null && rangeObj['startKey']['column'] != null)
            {
              startColumnIdx = this._getColumnIdxForColumnKey(rangeObj['startKey']['column']);
            }
            if (rangeObj['endKey'] != null && rangeObj['endKey']['column'] != null)
            {
              endColumnIdx = this._getColumnIdxForColumnKey(rangeObj['endKey']['column']);
            }
            
            if (startRowIdx == null && rangeObj['startIndex'] != null)
            {
              startRowIdx = rangeObj['startIndex']['row'];
            }
            if (endRowIdx == null && rangeObj['endIndex'] != null)
            {
              endRowIdx = rangeObj['endIndex']['row'];
            }
            if (startColumnIdx == null && rangeObj['startIndex'] != null)
            {
              startColumnIdx = rangeObj['startIndex']['column'];
            }
            if (endColumnIdx == null && rangeObj['endIndex'] != null)
            {
              endColumnIdx = rangeObj['endIndex']['column'];
            }

            if (startRowIdx != null && endRowIdx != null && startColumnIdx != null && endColumnIdx != null)
            {
              oj.Logger.error('Error: Invalid range object in selection - Can only support row or column selection. Not both');
              return null;
            }
            if (startRowIdx != null && endRowIdx != null)
            {
              startRowIdx = startRowIdx - startIndex;
              endRowIdx = endRowIdx - startIndex;
              // this is a row based selection
              if (startRowIdx >= 0 && endRowIdx >= 0)
              {
                for (j = startRowIdx; j <= endRowIdx; j++)
                {
                  try
                  {
                    this._setRowSelection(j, true, null);
                  }
                  catch (e)
                  {
                    oj.Logger.error('Error: ' + e);
                  }
                }
              }
            }
            else if (startColumnIdx != null && endColumnIdx != null)
            {
              // this is a column based selection
              for (j = startColumnIdx; j <= endColumnIdx; j++)
              {
                try
                {
                  this._setHeaderColumnSelection(j, true, null);
                }
                catch (e)
                {
                  oj.Logger.error('Error: ' + e);
                }
              }
            }
            else
            {
              oj.Logger.error('Error: Invalid range object in selection - \n start row: ' + startRowIdx + '\n' + 'end row: ' + endRowIdx+ '\n' + 'start column: ' + startColumnIdx + '\n' + 'end column: ' + endColumnIdx);
              return null;
            }
          }
        }
      },
      /**
       * Set whether the component is in table navigation mode
       * @param {boolean} value true or false
       * @private
       */
      _setTableNavigationMode: function(value)
      {
        this._tableNavMode = value;
      },
      /**
       * Show the 'No data to display.'
       * @private
       */
      _showNoDataMessage: function()
      {
        var noDataMessage = this._getTableDomUtils().getTableNoDataMessage();
        noDataMessage.css('display', 'inline');
      },
      /**
       * Show the Fetching Data... status message.
       * @private
       */
      _showStatusMessage: function()
      {
        var statusMessage = this._getTableDomUtils().getTableStatusMessage();
        statusMessage.css('display', 'inline');
      },
      /**
       * Show the column header sort link
       * @param {number} columnIdx  column index
       * @private
       */
      _showTableHeaderColumnSortLink: function(columnIdx)
      {
        if (this._getColumnDefs()[columnIdx]['sortable'] == this._OPTION_ENABLED)
        {
          var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

          if (!tableHeaderColumn)
          {
            return;
          }
          
          // check if the column is currently sorted
          var sorted = tableHeaderColumn.data('sorted');

          // we should only show the ascending sort link if the column is not sorted
          if (sorted == null)
          {
            var headerColumnAscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
            headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
            headerColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
            var headerColumnAsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_CLASS);
            headerColumnAsc.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
            var headerColumnDsc = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_CLASS);
            headerColumnDsc.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
          }
        }
      },
      /**
       * Unregister event listeners which are registered on datasource. 
       * @private
       */
      _unregisterDataSourceEventListeners: function()
      {
        var data = this._getData();
        // unregister the listeners on the datasource
        if (this._dataSourceEventHandlers != null && data != null)
        {
          var i;
          for (i = 0; i < this._dataSourceEventHandlers.length; i++)
            data.off(this._dataSourceEventHandlers[i]['eventType'], this._dataSourceEventHandlers[i]['eventHandler']);
        }
      },
      /**
       * Update the css class from all the cells in a column according to column state
       * @param {number} columnIdx  column index
       * @param {boolean} blur  true or false
       * @private
       */
      _updateHeaderColumnCellsClass: function(columnIdx, blur)
      {
        var state = this._getHeaderColumnState(columnIdx);
        var selected = state.selected;
        var selectedRowIdxs = this._getSelectedRowIdxs();
        var data = this._getData();
        var i, j, tableBodyCell, rowSelected;
        for (i = 0; i < data.size(); i++)
        {
          tableBodyCell = this._getTableDomUtils().getTableBodyCell(i, columnIdx);
          if (!selected)
          {
            rowSelected = false;
            for (j = 0; j < selectedRowIdxs.length; j++)
            {
              if (i == selectedRowIdxs[j])
              {
                rowSelected = true;
                break;
              }
            }
            if (!rowSelected)
            {
              $(tableBodyCell).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
          }
          else
          {
            $(tableBodyCell).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
        }
      },
      /**
       * Update the css class from all the cells in a row according to row state
       * @param {number} rowIdx  row index
       * @param {Object} state  row state
       * @param {boolean} blur  true or false
       * @private
       */
      _updateRowCellsClass: function(rowIdx, state, blur)
      {
        var tableBodyCells = this._getTableDomUtils().getTableBodyCells(rowIdx);
        var focused = state.focused;
        var selected = state.selected;
        var hover = state.hover;

        if (!tableBodyCells)
        {
          return;
        }

        if (hover != null)
        {
          var i;
          for (i = 0; i < tableBodyCells.length; i++)
          {
            if (!hover)
            {
              $(tableBodyCells[i]).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._HOVER);
            }
            else
            {
              $(tableBodyCells[i]).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._HOVER);
            }
          }
        }
        if (focused != null)
        {
          var i;
          for (i = 0; i < tableBodyCells.length; i++)
          {
            if (!focused)
            {
              $(tableBodyCells[i]).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            }
            else
            {
              $(tableBodyCells[i]).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            }
          }
        }
        if (selected != null)
        {
          var i;
          for (i = 0; i < tableBodyCells.length; i++)
          {
            if (!selected)
            {
              $(tableBodyCells[i]).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            else
            {
              $(tableBodyCells[i]).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
          }
        }
      }
      /**** end internal functions ****/
    })
}());
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.FlattenedTreeTableDataSource
 * @classdesc Object representing data used by the rowexpander component
 * @param {Object} data
 * @param {Object|null} options Array of options for the TreeTableDataSource
 * @constructor
 */
oj.FlattenedTreeTableDataSource = function(data, options)
{
  // Initialize
  options = options || {};

  if (!(data instanceof oj.FlattenedTreeDataSource))
  {
    var errSummary = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_SUMMARY'];
    var errDetail = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_DETAIL'];
    throw new Error(errSummary + '\n' + errDetail);
  }

  this.dataSource = data;
  this._rowSet = new oj.FlattenedTreeRowSet(data, options);
  this._addRowSetEventListeners();
  this.Init();
  
  if ((options != null && (options['startFetch'] == 'enabled' || options['startFetch'] == null))
    || options == null)
  {
    this._startFetchEnabled = true;
  }
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.FlattenedTreeTableDataSource, oj.TableDataSource, "oj.FlattenedTreeTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.Init = function()
{
  oj.FlattenedTreeTableDataSource.superclass.Init.call(this);
};

/**
 * Determines whether this FlattenedTreeTableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 */
oj.FlattenedTreeTableDataSource.prototype.getCapability = function(feature)
{
    return 'full';
};

/**
 * Retrieves the underlying DataSource.
 * @return {Object} the underlying oj.DataSource.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.getWrappedDataSource = function()
{
    return this.dataSource;
};

/**
 * Calls fetch on the datasource.
 * @param {Object=} options Options to control fetch<p>
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.fetch = function(options)
{
  options = options || {};
  var self = this;
  var success = options['success'];
  var error = options['error'];
  var context = options['context'] == null? this : options['context'];
  var fetchType = options['fetchType'];
  
  if (fetchType == 'init' && !this._startFetchEnabled)
  {
     return oj.Object.__getPromise(function(resolve, reject) {
        resolve();
      });
  }

  return oj.Object.__getPromise(function(resolve, reject) {
    options['success'] = function()
    {
      if (success != null)
      {
        success.call(context, self, options);
      }
      resolve();
    };
    options['error'] = function(options, e)
    {
      if (error != null)
      {
        error.call(context, self, options, e);
      }
      reject();
    }
    if (options['startFetch'] == 'enabled')
    {
      // only do an initial fetch if rowSet is empty
      if (self._rowSet.isEmpty() ||
        (typeof self._rowSet.size() === 'undefined'))
      {
        self._rowSet.fetch(options);
      }
    }
    else
    {
      self._rowSet.fetch(options);
    }
  });
};




/**** start delegated functions ****/

/**
 * Return the model object found at the given index of the collection.
 * 
 * @param {number} index Index for which to return the model object. 
 * @return {Object} Model object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.at = function(index)
{
  return this._rowSet.at(index);
};

/**
 * Collapse the specified row.
 * @param {Object} rowKey the key of the row to collapse
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.collapse = function(rowKey)
{
  this._rowSet.collapse(rowKey);
};

/**
 * Expand the specified row.
 * @param {Object} rowKey the key of the row to expand
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.expand = function(rowKey)
{
  this._rowSet.expand(rowKey);
};

/**
 * Return the first model object from the collection whose model id value is the given id or cid, or the id or cid from a passed in model
 * @param {Object|string} id ID, cid, or Model (see Model id or cid) for which to return the model object, if found. 
 * @return {Object} First model object in the collection where model.id = id or model.cid = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.get = function(id)
{
  return this._rowSet.get(id);
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.hasMore = function()
{
  return this._rowSet.hasMore();
};

/**
 * Return the array index location of the given model object.
 * @param {Object} model Model object to locate 
 * @return {number} The index of the given model object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.indexOf = function(model)
{
  return this._rowSet.indexOf(model);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.on = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._rowSet.on(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeTableDataSource.superclass.on.call(this, eventType, eventHandler);
  }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.off = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._rowSet.off(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeTableDataSource.superclass.off.call(this, eventType, eventHandler);
  }
};

/**
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.size = function()
{
  return this._rowSet.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise} promise object triggering done when complete.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.sort = function(criteria)
{
  if (criteria == null)
  {
    return oj.Object.__getPromise(function(resolve, reject) {
      resolve();
    }); 
  }
  
  var self = this;
  criteria['axis'] = 'column';
  return oj.Object.__getPromise(function(resolve, reject) {
    self._rowSet.sort(criteria);
    resolve();
  });
};

/**
 * Return current start index.
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.startIndex = function() {
  return this._rowSet.startIndex();
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.totalSize = function()
{
  return this._rowSet.totalSize();
};

/**** end delegated functions ****/

/**
 * Add event listeners to the RowSet
 * @private
 */
oj.FlattenedTreeTableDataSource.prototype._addRowSetEventListeners = function()
{
  var self = this;
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ADD'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['ADD'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REMOVE'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['REMOVE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REQUEST'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['REQUEST'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['RESET'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['RESET'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SORT'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['SORT'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['CHANGE'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['CHANGE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SYNC'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['SYNC'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ERROR'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['ERROR'], event);
  });
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.TableDomUtils
 * @classdesc DOM Utils for ojTable
 * @param {Object} component ojTable instance
 * @constructor
 */
oj.TableDomUtils = function(component)
{
  this.component = component;
  this.options = component['options'];
  this.element = component['element'];
  this.Init();
  var self = this;
  setInterval(
    function()
    {
      if (self._refreshTableDimensionsTimer != null)
      {
        var width = self._refreshTableDimensionsTimer.width;
        var height = self._refreshTableDimensionsTimer.height;
      
        self._refreshTableDimensions(width, height);
        self._refreshTableDimensionsTimer = null;
      }
    }, 50);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.TableDomUtils, oj.Object, "oj.TableDomUtils");

/**
 * Initializes the instance.
 * @export
 */
oj.TableDomUtils.prototype.Init = function()
{
  oj.TableDomUtils.superclass.Init.call(this);
};

/**
  * Add the cell for delayed rendering
  * @private
  * @param {number} rowIdx  row index
  * @param {number} columnIdx  column index
  * @param {Object} delayedCellObj cell information
  */
oj.TableDomUtils.prototype.addDelayedRenderCell = function(rowIdx, columnIdx, delayedCellObj)
{
  if (!this._delayedRenderCells)
  {
    this._delayedRenderCells = new Array();
  }
  var delayedRowCells = this._delayedRenderCells[rowIdx];
  
  if (!delayedRowCells)
  {
    delayedRowCells = new Array();
  }
  delayedRowCells[columnIdx] = delayedCellObj;
  this._delayedRenderCells[rowIdx] = delayedRowCells;
};

/**
  * Add the row for delayed rendering
  * @private
  * @param {number} rowIdx  row index
  * @param {Object} delayedRowObj row information
  */
oj.TableDomUtils.prototype.addDelayedRenderRow = function(rowIdx, delayedRowObj)
{
  if (!this._delayedRenderRows)
  {
    this._delayedRenderRows = new Array();
  }
  this._delayedRenderRows[rowIdx] = delayedRowObj;
};

/**
 * Clear any cached DOM
 * @private
 */
oj.TableDomUtils.prototype.clearCachedDom = function()
{
  this.clearCachedDomRowData();
  this._tableContainerDimensions = null;
}

/**
 * Clear any cached DOM rows
 * @private
 */
oj.TableDomUtils.prototype.clearCachedDomRowData = function()
{
  this._cachedDomTableBodyRows = null;
}

/**
  * Clear the array of delayed cells for rendering
  */
oj.TableDomUtils.prototype.clearDelayedRenderCells = function()
{
  if (this._delayedRenderCells != null)
  {
    while(this._delayedRenderCells.length > 0) 
    {
      this._delayedRenderCells.pop();
    }
  }
};

/**
  * Clear the array of delayed rows for rendering
  */
oj.TableDomUtils.prototype.clearDelayedRenderRows = function()
{
  if (this._delayedRenderRows != null)
  {
    while(this._delayedRenderRows.length > 0) 
    {
      this._delayedRenderRows.pop();
    }
  }
};

/**
 * Create a span element for acc purposes
 * @param {string} text span text
 * @param {string|null} className css class
 * @return {jQuery} jQuery span DOM element
 */
oj.TableDomUtils.prototype.createAccLabelSpan = function(text, className)
{
  var accLabel = $(document.createElement('span'));
  if (className != null)
  {
    accLabel.addClass(className);
  }
  accLabel.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  accLabel.append(text);

  return accLabel;
};

/**
 * Add a default context menu to the table container if there is none. If there is
 * a context menu set on the table options we use that one. Add listeners
 * for context menu before show and select.
 * @param {function(Object)} handleContextMenuBeforeShow function called before menu show
 * @param {function(Object)} handleContextMenuSelect function called for menu select
 * @return {jQuery} jQuery ul DOM element
 */
oj.TableDomUtils.prototype.createContextMenu = function(handleContextMenuBeforeShow, handleContextMenuSelect)
{
  var menuContainer = null;
  var menuContainerId = null;
  var listItems;
  var self = this;

  if (this.options["contextMenu"] != null || this.getTable().attr("contextmenu") != null)
  {
    menuContainerId = this.getContextMenuId();
    menuContainer = $(menuContainerId);
    listItems = menuContainer.find('[data-oj-command]');
    listItems.each(function() {
      var command;
      if ($(this).children('a').length === 0)
      {
        command = $(this).attr('data-oj-command').split("-");
        $(this).replaceWith(self.createContextMenuItem(command[command.length - 1]));
      }
    });
    this._menuContainer = menuContainer;
    this.component._contextMenuId = menuContainerId;
    menuContainer.ojMenu('refresh');
    menuContainer.on("ojbeforeopen", handleContextMenuBeforeShow);
    menuContainer.on("ojselect", handleContextMenuSelect);

    return menuContainer;
  }
  
  return null
};

/**
 * Builds a menu for a command, takes care of submenus where appropriate
 * @return {jQuery} jQuery li DOM element
 */
oj.TableDomUtils.prototype.createContextMenuItem = function(command)
{
  if (command === 'sort')
  {
    return $(this.createContextMenuListItem(command)).append($('<ul></ul>').append($(this.createContextMenuListItem('sortAsc'))).append($(this.createContextMenuListItem('sortDsc'))));
  }
  return null;
};

/**
 * Builds a context menu list item from a command
 * @param {string} command the string to look up command value for as well as translation
 * @return {jQuery} jQuery li DOM element 
 */
oj.TableDomUtils.prototype.createContextMenuListItem = function(command)
{
  var contextMenuListItem = $(document.createElement('li'));
  contextMenuListItem.attr('data-oj-command', 'oj-table-' + command);
  contextMenuListItem.append(this.createContextMenuLabel(command));

  return contextMenuListItem;
};

/**
 * Builds a context menu label by looking up command translation
 * @param {string} command the string to look up translation for
 * @return {jQuery} jQuery a DOM element
 */
oj.TableDomUtils.prototype.createContextMenuLabel = function(command)
{
  var contextMenuLabel = $(document.createElement('a'));
  contextMenuLabel.attr('href', '#');
  var commandString = null;
  if (command == 'sort')
  {
    commandString = this.component.getTranslatedString('labelSort');
  }
  else if (command == 'sortAsc')
  {
    commandString = this.component.getTranslatedString('labelSortAsc');
  }
  else if (command == 'sortDsc')
  {
    commandString = this.component.getTranslatedString('labelSortDsc');
  }
  contextMenuLabel.append(commandString);

  return contextMenuLabel;
};

/**
 * Create the initial empty table
 * @param {boolean} isTableHeaderless is table headerless
 * @param {boolean} isTableFooterless is table footerless
 * @param {function(Object)} handleContextMenuBeforeShow function called before menu open
 * @param {function(Object)} handleContextMenuSelect function called for menu select
 * @return {jQuery} jQuery table DOM element
 */
oj.TableDomUtils.prototype.createInitialTable = function(isTableHeaderless, isTableFooterless, handleContextMenuBeforeShow, handleContextMenuSelect)
{
  var table = this.getTable();
  this.createTableContainer();
  // create the context menu
  this.createContextMenu(handleContextMenuBeforeShow, handleContextMenuSelect);
  // we only need a scroller div if we are using fallback scrolling
  if (this.isDivScroller())
  {
    this.createTableDivScroller();
  }

  if (!isTableHeaderless)
  {
    this.createTableHeader();
  }
  if (!isTableFooterless)
  {
    this.createTableFooter();
  }
  this.createTableBody();
  this.createTableNoDataMessage();
  this.createTableStatusMessage();

  return table;
};

/**
 * Create an empty tbody element with appropriate styling
 * @return {jQuery} jQuery tbody DOM element
 */
oj.TableDomUtils.prototype.createTableBody = function()
{
  var table = this.getTable();
  var tableBody = $(document.createElement('tbody'));
  table.append(tableBody);
  this._cachedDomTableBody = tableBody;

  return tableBody;
};

/**
 * Create an empty td element with appropriate styling
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableBodyCell = function(rowIdx, columnIdx)
{
  var tableBodyCell = $(document.createElement('td'));

  return tableBodyCell;
};

/**
 * Create a checkbox for accessibility row selection
 * @param {number} rowIdx  row index
 * @param {jQuery} tableBodyRow  tr DOM element
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableBodyCellAccSelect = function(rowIdx, tableBodyRow)
{
  var accSelectionCell = this.getTableBodyCellAccSelect(tableBodyRow);
  var isTableHeaderless = this.getTableHeader() == null ? true : false;

  if (accSelectionCell != null)
  {
    return accSelectionCell;
  }

  accSelectionCell = $(document.createElement('td'));
  accSelectionCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS);
  accSelectionCell.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  if (!isTableHeaderless)
  {
    accSelectionCell.attr('headers', oj.TableDomUtils._COLUMN_HEADER_ROW_SELECT_ID);
  }
  var accSelectCheckbox = $(document.createElement('input'));
  accSelectCheckbox.attr('id', 'acc_sel_row' + rowIdx);
  accSelectCheckbox.attr('type', 'checkbox');
  accSelectCheckbox.attr('tabindex', '-1');
  var selectRowTitle = this.component.getTranslatedString(this.component._BUNDLE_KEY._LABEL_SELECT_ROW);
  accSelectCheckbox.attr('title', selectRowTitle);
  accSelectCheckbox.addClass(oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_ROW_CLASS);
  accSelectionCell.append(accSelectCheckbox);
  tableBodyRow.prepend(accSelectionCell);

  return accSelectionCell;
};

/**
 * Create an empty tr element with appropriate styling
 * @param {number} rowIdx  row index
 * @return {jQuery} jQuery tr DOM element
 */
oj.TableDomUtils.prototype.createTableBodyRow = function(rowIdx)
{
  var tableBodyRow = $(document.createElement('tr'));
  this.createTableBodyCellAccSelect(rowIdx, tableBodyRow);
  
  return tableBodyRow;
};

/**
 * Create an empty div element with appropriate styling
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableContainer = function()
{
  var options = this.options;
  // need to enclose the table in a div to provide horizontal scrolling
  var tableContainer = $(document.createElement('div'));
  this.element.parent()[0].replaceChild(tableContainer[0], this.element[0]);
  tableContainer.prepend(this.element);
  this._cachedDomTableContainer = tableContainer;

  return tableContainer;
};

/**
 * Create an empty tfoot with appropriate styling
 * @return {jQuery} jQuery tfoot DOM element
 */
oj.TableDomUtils.prototype.createTableFooter = function()
{
  var table = this.getTable();
  var tableFooter = $(document.createElement('tfoot'));
  var tableFooterRow = $(document.createElement('tr'));
  this.createTableFooterAccSelect(tableFooterRow);

  tableFooter.append(tableFooterRow);
  
  // check if thead is already there. If so add relative to thead.
  var tableHeader = this.getTableHeader();
  if (tableHeader != null)
  {
    tableHeader.after(tableFooter);
  }
  else
  {
    // check if tbody is already there. If so add relative to tbody.
    var tableBody = this.getTableBody();
    if (tableBody != null)
    {
      tableBody.before(tableFooter);
    }
    else
    {
      table.append(tableFooter);
    }
  }

  return tableFooter;
};

/**
 * Create a checkbox for accessibility row selection
 * @param {jQuery} tableFooterRow  tr DOM element
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableFooterAccSelect = function(tableFooterRow)
{
  var accFooterCell = tableFooterRow.find('.' + oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);

  if (accFooterCell != null && accFooterCell.length > 0)
  {
    return $(accFooterCell[0]);
  }
  accFooterCell = $(document.createElement('td'));
  accFooterCell.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  accFooterCell.attr('tabindex', '-1');
  tableFooterRow.prepend(accFooterCell);

  return accFooterCell;
};

/**
 * Create an empty td element with appropriate styling
 * @param {number} columnIdx  column index
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableFooterCell = function(columnIdx)
{
  var tableFooterCell = $(document.createElement('td'));

  return tableFooterCell;
};

/**
 * Create an empty thead & tr element with appropriate styling
 * @return {jQuery} jQuery thead DOM element
 */
oj.TableDomUtils.prototype.createTableHeader = function()
{
  var table = this.getTable();
  var tableHeader = $(document.createElement('thead'));
  var tableHeaderRow = $(document.createElement('tr'));
  this._cachedDomTableHeaderRow = tableHeaderRow;
  tableHeader.append(tableHeaderRow);
  
  // check if tfoot is already there. If so add relative to tfoot.
  var tableFooter = this.getTableFooter();
  if (tableFooter != null)
  {
    tableFooter.before(tableHeader);
  }
  else
  {
    // check if tbody is already there. If so add relative to tbody.
    var tableBody = this.getTableBody();
    if (tableBody != null)
    {
      tableBody.before(tableHeader);
    }
    else
    {
      table.append(tableHeader);
    }
  }
  this._cachedDomTableHeader = tableHeader;
  
  return tableHeader;
};

/**
 * Create a th element for accessibility row selection
 * @return {jQuery} jQuery th DOM element
 */
oj.TableDomUtils.prototype.createTableHeaderAccSelectRowColumn = function()
{
  var headerColumn = $(document.createElement('th'));
  headerColumn.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_ROW_CLASS);
  headerColumn.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  headerColumn.attr('id', oj.TableDomUtils._COLUMN_HEADER_ROW_SELECT_ID);
  var selectRowTitle = this.component.getTranslatedString(this.component._BUNDLE_KEY._LABEL_SELECT_ROW);
  headerColumn.attr('title', selectRowTitle);
  headerColumn.append(selectRowTitle);

  return headerColumn;
};

/**
 * Create a th element with appropriate styling and column content
 * @param {number} columnIdx  column index
 * @param {string} columnSelectionMode  column selection mode
 * @return {jQuery} jQuery th DOM element
 */
oj.TableDomUtils.prototype.createTableHeaderColumn = function(columnIdx, columnSelectionMode)
{
  var column = this.component['columnMetaData'](columnIdx);
  var headerColumnCell = $(document.createElement('th'));
  this.styleTableHeaderColumn(columnIdx, headerColumnCell, columnSelectionMode);
  var headerColumnDiv = $(document.createElement('div'));
  headerColumnDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS);
  
  if (column.sortable == oj.TableDomUtils._OPTION_ENABLED)
  {
    if (this.component._GetReadingDirection() === "rtl")
    {
      headerColumnDiv.css('padding-left', '0px');
    }
    else
    {
      headerColumnDiv.css('padding-right', '0px');
    }
  }
  headerColumnCell.append(headerColumnDiv);
  
  // add abbr for acc
  headerColumnCell.attr('abbr', column.headerText);
  // add title for tooltip
  headerColumnCell.attr('title', column.headerText);
  this.component._hoverable(headerColumnCell);
  
  // the text div contains the column header text
  var headerColumnTextDiv = $(document.createElement('div'));
  headerColumnTextDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_TEXT_CLASS);
  if (column.headerStyle != null)
  {
    headerColumnTextDiv.attr('style', column.headerStyle);
  }
  if (column.headerClassName != null)
  {
    headerColumnTextDiv.addClass(column.headerClassName);
  }
  headerColumnDiv.append(headerColumnTextDiv);
  headerColumnTextDiv.append(column.headerText);
  // sort ascending link
  var headerColumnAscDiv = $(document.createElement('div'));
  headerColumnAscDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_CLASS);
  headerColumnDiv.append(headerColumnAscDiv);
  if (column.sortable == oj.TableDomUtils._OPTION_ENABLED)
  {
    var headerColumnAscLink = $(document.createElement('a'));
    headerColumnAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
    headerColumnAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._WIDGET_ICON_CLASS);
    headerColumnAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_ICON_CLASS);
    headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
    headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._CLICKABLE_ICON);
    this.component._hoverable(headerColumnAscLink);
    headerColumnAscDiv.append(headerColumnAscLink);
    
    // separate link for acc
    var headerColumnAccAscLink = $(document.createElement('a'));
    headerColumnAccAscLink.attr('tabindex', '0');
    headerColumnAccAscLink.attr('href', '#');
    headerColumnAccAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_ASC_LINK_CLASS);
    headerColumnAccAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
    headerColumnAccAscLink.append(this.component.getTranslatedString('labelSortAsc'));
    headerColumnAscDiv.append(headerColumnAccAscLink);
    
    headerColumnCell.attr('data-oj-sortable', oj.TableDomUtils._OPTION_ENABLED);
    
    var headerColumnSortPlaceholderDiv = $(document.createElement('div'));
    headerColumnSortPlaceholderDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_SORT_PACEHOLDER_CLASS);
    headerColumnSortPlaceholderDiv.css('display', 'inline-block');
    headerColumnDiv.append(headerColumnSortPlaceholderDiv);
  }
  //sort descending link
  var headerColumnDscDiv = $(document.createElement('div'));
  headerColumnDscDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_CLASS);
  // descending sort is initially not visible
  headerColumnDscDiv.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
  headerColumnDiv.append(headerColumnDscDiv);
  if (column.sortable == oj.TableDomUtils._OPTION_ENABLED)
  {
    var headerColumnDscLink = $(document.createElement('a'));
    headerColumnDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
    headerColumnDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._WIDGET_ICON_CLASS);
    headerColumnDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_ICON_CLASS);
    headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
    headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._CLICKABLE_ICON);
    this.component._hoverable(headerColumnDscLink);
    headerColumnDscDiv.append(headerColumnDscLink);
    
    // separate link for acc
    var headerColumnAccDscLink = $(document.createElement('a'));
    headerColumnAccDscLink.attr('tabindex', '0');
    headerColumnAccDscLink.attr('href', '#');
    headerColumnAccDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_DSC_LINK_CLASS);
    headerColumnAccDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
    headerColumnAccDscLink.append(this.component.getTranslatedString('labelSortDsc'));
    headerColumnDscDiv.append(headerColumnAccDscLink);
  }

  return headerColumnCell;
};

/**
 * Create a checkbox for accessibility column selection
 * @param {number} columnIdx  column index
 * @param {string} columnSelectionMode  column selection mode
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableHeaderColumnAccSelect = function(columnIdx, columnSelectionMode)
{
  if (columnSelectionMode != oj.TableDomUtils._OPTION_SELECTION_MODES._SINGLE &&
    columnSelectionMode != oj.TableDomUtils._OPTION_SELECTION_MODES._MULTIPLE)
  {
    return null;
  }
  var headerColumn = this.getTableHeaderColumn(columnIdx);
  var accSelectionHeaderColumn = this.getTableHeaderColumnAccSelect(columnIdx);

  if (accSelectionHeaderColumn != null)
  {
    return accSelectionHeaderColumn;
  }

  accSelectionHeaderColumn = $(document.createElement('div'));
  accSelectionHeaderColumn.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_COLUMN_CLASS);
  accSelectionHeaderColumn.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  var accSelectCheckbox = $(document.createElement('input'));
  accSelectCheckbox.attr('id', 'acc_sel_col' + columnIdx);
  accSelectCheckbox.attr('type', 'checkbox');
  accSelectCheckbox.attr('tabindex', '-1');
  var selectColumnTitle = this.component.getTranslatedString(this.component._BUNDLE_KEY._LABEL_SELECT_COLUMN);
  accSelectCheckbox.attr('title', selectColumnTitle);
  accSelectCheckbox.addClass(oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_COLUMN_CLASS);
  accSelectionHeaderColumn.append(accSelectCheckbox);
  headerColumn.prepend(accSelectionHeaderColumn);

  return accSelectionHeaderColumn;
};

/**
 * Create a div element for table scrolling. Used in scrolling fallback mode.
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableDivScroller = function()
{
  var table = this.getTable();
  var tableContainer = this.getTableContainer();
  var tableDivScroller = $(document.createElement('div'));
  tableDivScroller.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_SCROLLER_CLASS);
  tableContainer[0].replaceChild(tableDivScroller[0], table[0]);
  tableDivScroller.append(table);
  this._cachedDomTableDivScroller = tableDivScroller;

  return tableDivScroller;
};

/**
 * Create a div element for the 'No data to display' message
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableNoDataMessage = function()
{
  var tableContainer = this.getTableContainer();
  var noDataMessage = $(document.createElement('div'));
  noDataMessage.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_NO_DATA_MESSAGE_CLASS);
  noDataMessage.css('display', 'none');
  var emptyTextMsg = null;
  if (this.options['emptyText'] != null)
  {
    emptyTextMsg = this.options['emptyText'];
  }
  else
  {
    emptyTextMsg = this.component.getTranslatedString(this.component._BUNDLE_KEY._MSG_NO_DATA);
  }
  noDataMessage.append(emptyTextMsg);
  tableContainer.append(noDataMessage);
  this._cachedDomTableNoDataMessage = noDataMessage;

  return noDataMessage;
};

/**
 * Create a div element for the Fetching Data... status message
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableStatusMessage = function()
{
  var tableContainer = this.getTableContainer();
  var statusMessage = $(document.createElement('div'));
  statusMessage.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_STATUS_MESSAGE_CLASS);
  statusMessage.css('display', 'none');
  statusMessage.append(this.component.getTranslatedString(this.component._BUNDLE_KEY._MSG_FETCHING_DATA));
  tableContainer.append(statusMessage);
  this._cachedDomTableStatusMessage = statusMessage;

  return statusMessage;
};

/**
 * Get the context menu
 * @return  {jQuery} jQuery table DOM element
 */
oj.TableDomUtils.prototype.getContextMenu = function()
{
  return this._menuContainer;
};

/**
 * Get the context menu id
 * @return  {string} context menu id
 */
oj.TableDomUtils.prototype.getContextMenuId = function()
{
  return this.options["contextMenu"] == null ? '#' + this.getTable().attr("contextmenu") : this.options["contextMenu"];
};

/**
 * Get the column index of the DOM element. e.g. pass in the table cell to
 * see which column it's in.
 * @param {jQuery} element  DOM element
 * @return {number|null} the column index
 * @private
 */
oj.TableDomUtils.prototype.getElementColumnIdx = function(element)
{
  var tableBodyCell = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);
  if (tableBodyCell != null)
  {
    return tableBodyCell.parent().children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS).index(tableBodyCell);
  }
  
  var tableHeaderColumn = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CELL_CLASS);
  if (tableHeaderColumn != null)
  {
    return tableHeaderColumn.parent().children('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CELL_CLASS).index(tableHeaderColumn);
  }
  
  var tableFooterCell = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS);
  if (tableFooterCell != null)
  {
    return tableFooterCell.parent().children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS).index(tableFooterCell);
  }
  return null;
};

/**
 * Get the row index of the DOM element. e.g. pass in the table cell to
 * see which row it's in.
 * @param {jQuery} element  DOM element
 * @return {number} the row index
 * @private
 */
oj.TableDomUtils.prototype.getElementRowIdx = function(element)
{
  var tableBodyRow = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  
  return tableBodyRow.index();
};

/**
 * Return table container dimensions
 * @return {Object} the height and width of the table container
 */
oj.TableDomUtils.prototype.getTableContainerDimensions = function()
{
  var tableContainer = this.getTableContainer();
  tableContainer.attr('style', '');
  this.styleTableContainer(tableContainer);
  
  // hide all children so it does affect the style
  var i;
  var tableContainerChildrenDisplayStyle = [];
  
  for (i = 0; i < tableContainer.children().length; i++)
  {
    tableContainerChildrenDisplayStyle[i] = $(tableContainer.children()[i]).css('display').toString();
    $(tableContainer.children()[i]).css('display', 'none');
  }
  var tableContainerDisplayStyle = tableContainer.css('display').toString();
  tableContainer.css('display', 'inline-block');
  var tableBorderWidth = tableContainer.outerWidth() - tableContainer.innerWidth();
  var tableBorderHeight = tableContainer.outerHeight() - tableContainer.innerHeight();
  var tableHeight = tableContainer.outerHeight() > tableBorderHeight ? tableContainer.outerHeight() : 0;
  var tableWidth = tableContainer.outerWidth() > tableBorderWidth ? tableContainer.outerWidth() : 0;
  var dimensions = {height: tableHeight, width: tableWidth};
  for (i = 0; i < tableContainer.children().length; i++)
  {
    $(tableContainer.children()[i]).css('display', tableContainerChildrenDisplayStyle[i]);
  }
  tableContainer.css('display', tableContainerDisplayStyle);

  if (tableContainer[0].clientWidth == 0)
  {
    return null;
  }

  return dimensions;
};

/**
  * Find the first ancestor of an element with a specific class name
  * @param {jQuery} element the element to find the nearest class name to
  * @param {string} className the class name to look for
  * @return {jQuery|null} the element with the className, if there is none returns null 
  */
oj.TableDomUtils.prototype.getFirstAncestor = function(element, className) 
{
  var parents;
  
  if (element == null)
  {
    return null;
  }
  element = $(element);

  if (element.hasClass(className))
  {
    return element;
  }
  parents = element.parents('.' + className);
  if (parents.length != 0)
  {
    return parents.eq(0);
  }
  return null;
};

/**
  * Get the context object to pass into the renderer
  * @param {Object} row  oj.Row instance
  * @param {Object} parentElement element
  * @private
  */
oj.TableDomUtils.prototype.getRendererContextObject = function(row, parentElement)
{
  var context = [];
  context['component'] = this.component;
  var dataSource = this.options['data'];
  // unwrap the datasource if we have a PagingTableDataSource
  if (dataSource instanceof oj.PagingTableDataSource)
  {
    dataSource = dataSource.getWrappedDataSource();
  }
  context['datasource'] = dataSource;
  context['parentElement'] = parentElement;

  if (row != null)
  {
    context['status'] = this.getRendererStatusObject(row);
    var rowContext = row.context;
    var i;
    for (i in rowContext)
    {
      if (rowContext.hasOwnProperty(i))
      {
        context[i] = rowContext[i];
      }
    }
  }

  return context;
};

/**
 * Get the status object to pass into the renderer
 * @param {Object} row  oj.Row instance
 * @return {Object} status object
 * @private
 */
oj.TableDomUtils.prototype.getRendererStatusObject = function(row)
{
  return {'rowIndex': this.options['data'].indexOf(row),
    'rowKey': row['id'],
    'currentRow': this.component._getCurrentRow()};
};

/**
 * Return the scrollbar height
 * @return {number} scrolbar height
 * @private
 */
oj.TableDomUtils.prototype.getScrollbarHeight = function()
{
  var scroller = this.getScroller();
  if (scroller.get(0).clientHeight > 0)
  {
    var scrollbarHeight = scroller.get(0).offsetHeight - scroller.get(0).clientHeight;

    return scrollbarHeight;
  }
  return 0;
};

/**
 * Return the scrollbar width
 * @return {number} scrolbar width
 * @private
 */
oj.TableDomUtils.prototype.getScrollbarWidth = function()
{
  var scroller = this.getScroller();
  if (scroller.get(0).clientWidth > 0)
  {
    var scrollbarWidth = scroller.get(0).offsetWidth - scroller.get(0).clientWidth;

    return scrollbarWidth;
  }
  return 0;
};

/**
 * Return the table scroller
 * @return {jQuery} scrolbar
 */
oj.TableDomUtils.prototype.getScroller = function()
{
  if (!this.isDivScroller())
  {
    return this.getTableBody();
  }
  else
  {
    return this.getTableDivScroller();
  }
};
        
/**
 * Return the table element
 * @return {jQuery} jQuery table DOM element
 */
oj.TableDomUtils.prototype.getTable = function()
{
  return $(this.element);
};

/**
 * Return the table body element
 * @return {jQuery|null} jQuery tbody DOM element
 */
oj.TableDomUtils.prototype.getTableBody = function()
{
  if (!this._cachedDomTableBody)
  {
    var table = this.getTable();
    var tableBody = null;
    if (table)
    {
      tableBody = table.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_BODY_CLASS);
      if (tableBody && tableBody.length > 0)
      {
        this._cachedDomTableBody = $(tableBody.get(0));
      }
    }
  }

  return this._cachedDomTableBody;
};

/**
 * Return the cell element
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @param {jQuery|null} tableBodyRow  tr DOM element
 * @return {jQuery|null} jQuery td DOM element
 */
oj.TableDomUtils.prototype.getTableBodyCell = function(rowIdx, columnIdx, tableBodyRow)
{
  var tableBodyCells = this.getTableBodyCells(rowIdx, tableBodyRow);
  if (!tableBodyCells)
  {
    return null;
  }

  if (tableBodyCells.length > columnIdx)
  {
    return $(tableBodyCells[columnIdx]);
  }

  return null;
};

/**
 * Get checkbox cell for accessibility row selection
 * @param {jQuery} tableBodyRow  tr DOM element
 * @return {jQuery|null} jQuery td DOM element
 */
oj.TableDomUtils.prototype.getTableBodyCellAccSelect = function(tableBodyRow)
{
  if (tableBodyRow != null)
  {
    var accSelectionCell = tableBodyRow.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS);

    if (accSelectionCell != null && accSelectionCell.length > 0)
    {
      return $(accSelectionCell[0]);
    }
  }
  return null;
};

/**
 * Return all the cell elements in a row
 * @param {number} rowIdx  row index
 * @param {jQuery|null} tableBodyRow  tr DOM element
 * @return {jQuery|null} jQuery array of td DOM elements
 */
oj.TableDomUtils.prototype.getTableBodyCells = function(rowIdx, tableBodyRow)
{
  if (!tableBodyRow)
  {
    tableBodyRow = this.getTableBodyRow(rowIdx);
  }

  if (!tableBodyRow)
  {
    return null;
  }

  var tableBodyCellElements = tableBodyRow.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);

  if (tableBodyCellElements != null && tableBodyCellElements.length > 0)
  {
    return tableBodyCellElements;
  }

  return null;
};

/**
 * Return table row
 * @param {number|null} rowIdx  row index
 * @return {jQuery|null} jQuery tr DOM element
 */
oj.TableDomUtils.prototype.getTableBodyRow = function(rowIdx)
{
  var tableBodyRows = this.getTableBodyRows();

  if (!tableBodyRows)
  {
    return null;
  }
  
  if (rowIdx == null)
  {
    return null;
  }

  if (tableBodyRows.length > rowIdx)
  {
    return $(tableBodyRows[rowIdx]);
  }
  
  return null;
};

/**
 * Return all the table rows
 * @return {jQuery|null} jQuery array of tr DOM elements
 */
oj.TableDomUtils.prototype.getTableBodyRows = function()
{
  if (!this._cachedDomTableBodyRows)
  {
    var tableBody = this.getTableBody();
    var tableBodyRowElements = tableBody.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);

    if (tableBodyRowElements != null && tableBodyRowElements.length > 0)
    {
      this._cachedDomTableBodyRows = tableBodyRowElements;
    }
  }

  return this._cachedDomTableBodyRows;
};

/**
 * Return the table container
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableContainer = function()
{
  if (!this._cachedDomTableContainer)
  {
    if (!this.isDivScroller())
    {
      this._cachedDomTableContainer = $(this.element.get(0).parentNode);
    }
    else
    {
      this._cachedDomTableContainer = $(this.element.get(0).parentNode.parentNode);
    }
  }

  return this._cachedDomTableContainer;
};

/**
 * Return the table footer
 * @return {jQuery|null} jQuery tfoot DOM element
 */
oj.TableDomUtils.prototype.getTableFooter = function()
{
  var table = this.getTable();
  var tableFooter = null;
  if (table)
  {
    tableFooter = table.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CLASS);
    if (tableFooter && tableFooter.length > 0)
    {
      return $(tableFooter.get(0));
    }
  }

  return null;
};

/**
 * Return the footer cell element
 * @param {number} columnIdx  column index
 */
oj.TableDomUtils.prototype.getTableFooterCell = function(columnIdx)
{
  var tableFooterRow = this.getTableFooterRow();
  var tableFooterCells = $(tableFooterRow).children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS);

  if (tableFooterCells.length >= columnIdx)
  {
    return $(tableFooterCells[columnIdx]); 
  }

  return null;
};

/**
 * Return table footer row
 * @return {jQuery|null} jQuery tr DOM element
 */
oj.TableDomUtils.prototype.getTableFooterRow = function()
{
  if (!this._cachedDomTableFooterRow)
  {
    var tableFooter = this.getTableFooter();

    if (!tableFooter)
    {
      return null;
    }

    this._cachedDomTableFooterRow = $(tableFooter.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_ROW_CLASS).get(0));
  }

  return this._cachedDomTableFooterRow;
};

/**
 * Return the table header
 * @return {jQuery|null} jQuery thead DOM element
 */
oj.TableDomUtils.prototype.getTableHeader = function()
{
  if (!this._cachedDomTableHeader)
  {
    var table = this.getTable();
    var tableHeader = null;
    if (table)
    {
      tableHeader = table.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_CLASS);
      if (tableHeader && tableHeader.length > 0)
      {
        this._cachedDomTableHeader = $(tableHeader.get(0));
      }
    }
  }

  return this._cachedDomTableHeader;
};

/**
 * Return table column header
 * @param {number} columnIdx  column index
 * @return {jQuery|null} jQuery th DOM element
 */
oj.TableDomUtils.prototype.getTableHeaderColumn = function(columnIdx)
{
  var headerColumns = this.getTableHeaderColumns();

  if (!headerColumns)
  {
    return null;
  }

  if (headerColumns.length > columnIdx)
  {
    return $(headerColumns[columnIdx]);
  }

  return null;
};

/**
 * Get checkbox cell for accessibility column selection
 * @param {number} columnIdx  column index
 * @return {jQuery|null} jQuery td DOM element
 */
oj.TableDomUtils.prototype.getTableHeaderColumnAccSelect = function(columnIdx)
{
  var headerColumn = this.getTableHeaderColumn(columnIdx);

  if (headerColumn != null)
  {
    var accSelectionCell = headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_COLUMN_CLASS);

    if (accSelectionCell != null && accSelectionCell.length > 0)
    {
      return $(accSelectionCell[0]);
    }
  }
  return null;
};

/**
 * Return all table column headers
 * @return {jQuery|null} jQuery array of th DOM elements
 */
oj.TableDomUtils.prototype.getTableHeaderColumns = function()
{
  var tableHeaderRow = this.getTableHeaderRow();

  if (tableHeaderRow != null)
  {
    var headerColumnElements = tableHeaderRow.children('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CELL_CLASS);

    if (headerColumnElements != null && headerColumnElements.length > 0)
    {
      return headerColumnElements;
    }
  }

  return null;
};

/**
 * Return table header row
 * @return {jQuery|null} jQuery th DOM element
 */
oj.TableDomUtils.prototype.getTableHeaderRow = function()
{
  if (!this._cachedDomTableHeaderRow)
  {
    var tableHeader = this.getTableHeader();

    if (!tableHeader)
    {
      return null;
    }

    this._cachedDomTableHeaderRow = $(tableHeader.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_ROW_CLASS).get(0));
  }

  return this._cachedDomTableHeaderRow;
};

/**
 * Return the table div scroller
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableDivScroller = function()
{
  if (!this._cachedDomTableDivScroller)
  {
    var tableContainer = this.getTableContainer();
    if (tableContainer)
    {
      var tableDivScroller = tableContainer.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_SCROLLER_CLASS);
      if (tableDivScroller && tableDivScroller.length > 0)
      {
        this._cachedDomTableDivScroller = $(tableDivScroller.get(0));
      }
    }
  }
  return this._cachedDomTableDivScroller;
};

/**
 * Return the table no data message element
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableNoDataMessage = function()
{
  if (!this._cachedDomTableNoDataMessage)
  {
    var tableContainer = this.getTableContainer();
    if (tableContainer)
    {
      var noDataMessage = tableContainer.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_NO_DATA_MESSAGE_CLASS);
      if (noDataMessage && noDataMessage.length > 0)
      {
        this._cachedDomTableNoDataMessage = $(noDataMessage.get(0));
      }
    }
  }
  return this._cachedDomTableNoDataMessage;
};

/**
 * Return the table status message element
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableStatusMessage = function()
{
  if (!this._cachedDomTableStatusMessage)
  {
    var tableContainer = this.getTableContainer();
    if (tableContainer)
    {
      var statusMessage = tableContainer.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_STATUS_MESSAGE_CLASS);
      if (statusMessage && statusMessage.length > 0)
      {
        this._cachedDomTableStatusMessage = $(statusMessage.get(0));
      }
    }
  }

  return this._cachedDomTableStatusMessage;
};

/**
 * Insert a td element in the appropriate place in the DOM
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyCell  DOM element
 * @param {jQuery} tableBodyRow  tr DOM element
 */
oj.TableDomUtils.prototype.insertTableBodyCell = function(rowIdx, columnIdx, tableBodyCell, tableBodyRow)
{
  this.setTableBodyCellAttributes(rowIdx, columnIdx, tableBodyCell);

  var tableBodyCells = $(tableBodyRow).children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);

  if (columnIdx == 0)
  {
    // insert right after the acc cell
    var accSelectionCell = tableBodyRow.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS);

    if (accSelectionCell != null && accSelectionCell.length > 0)
    {
      $(accSelectionCell[0]).after(tableBodyCell);
    }
    else
    {
      // just prepend it
      tableBodyRow.prepend(tableBodyCell)
    }
  }
  else if (tableBodyCells.length >= columnIdx)
  {
    var previousCell = $(tableBodyCells.get(columnIdx - 1));
    previousCell.after(tableBodyCell);
  }
  else
  {
    $(tableBodyRow).append(tableBodyCell);
  }

  return tableBodyCell;
};

/**
 * Insert a tr element in the appropriate place in the DOM
 * @param {number} rowIdx  row index
 * @param {jQuery} tableBodyRow  DOM element
 * @param {Object} row  oj.Row
 * @param {Object} docFrag  document fragment
 */
oj.TableDomUtils.prototype.insertTableBodyRow = function(rowIdx, tableBodyRow, row, docFrag)
{
  var tableBodyRows = null;

  if (docFrag == null)
  {
    // if docFragm is null then get from the DOM nodes
    var tableBody = this.getTableBody();
    tableBodyRows = tableBody.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  }
  else
  {
    tableBodyRows = docFrag.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  }
  this.setTableBodyRowAttributes(rowIdx, row, tableBodyRow);

  if (docFrag == null)
  {
    if (rowIdx == 0)
    {
      // just prepend it
      tableBody.prepend(tableBodyRow);
    }
    else if (tableBodyRows.length >= rowIdx)
    {
      var previousRow = $(tableBodyRows.get(rowIdx - 1));
      previousRow.after(tableBodyRow);
    }
    else
    {
      tableBody.append(tableBodyRow);
    }
  }
  else
  {
    docFrag.append(tableBodyRow);
  }
  this.clearCachedDomRowData();
};

/**
 * Insert a td element in the appropriate place in the DOM
 * @param {number} columnIdx  column index
 * @param {jQuery} tableFooterCell  DOM element
 */
oj.TableDomUtils.prototype.insertTableFooterCell = function(columnIdx, tableFooterCell)
{
  var tableFooterRow = this.getTableFooterRow();
  var tableFooterCells = $(tableFooterRow).children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS);

  if (columnIdx == 0)
  {
    // insert right after the acc cell
    var accFooterCell = tableFooterRow.find('.' + oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);

    if (accFooterCell != null && accFooterCell.length > 0)
    {
      $(accFooterCell[0]).after(tableFooterCell);
    }
    else
    {
      // just prepend it
      tableFooterRow.prepend(tableFooterCell)
    }
  }
  else if (tableFooterRow.length >= columnIdx)
  {
    var previousCell = $(tableFooterCells.get(columnIdx - 1));
    previousCell.after(tableFooterCell);
  }
  else
  {
    tableFooterRow.append(tableFooterCell);
  }

  return tableFooterCell;
};

/**
 * Insert a th element in the appropriate place in the DOM
 * @param {number} columnIdx  column index
 * @param {jQuery} tableHeaderColumn  DOM element
 */
oj.TableDomUtils.prototype.insertTableHeaderColumn = function(columnIdx, tableHeaderColumn)
{
  var tableHeaderRow = this.getTableHeaderRow();
  var tableHeaderColumns = this.getTableHeaderColumns();
  // save the column index on the element
  this.setTableHeaderColumnAttributes(columnIdx, tableHeaderColumn);

  // if there is an existing th at the index then replace it
  var oldTableHeaderColumn = this.getTableHeaderColumn(columnIdx);
  if (oldTableHeaderColumn)
    oldTableHeaderColumn.replaceWith(tableHeaderColumn);
  else
  {
    if (columnIdx == 0)
    {
      // insert right after the acc column
      var accSelectionColumn = tableHeaderRow.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_ROW_CLASS);

      if (accSelectionColumn != null && accSelectionColumn.length > 0)
      {
        $(accSelectionColumn[0]).after(tableHeaderColumn);
      }
      else
      {
        // just prepend it
        tableHeaderRow.prepend(tableHeaderColumn)
      }
    }
    else if (tableHeaderColumns.length >= columnIdx)
    {
      var previousColumn = $(tableHeaderColumns.get(columnIdx - 1));
      previousColumn.after(tableHeaderColumn);
    }
    else
    {
      tableHeaderRow.append(tableHeaderColumn);
    }
  }
};

/**
  * Returns true if a div scroller is used. False if tbody scrolling is used.
  * @return {boolean} Whether div scroller is used
  */
oj.TableDomUtils.prototype.isDivScroller = function()
{
  return this._isIE() && this._isIE() < 10 ? true : false;
}

/**
  * Returns true if scrollHeight > clientHeight for height and width.
  * @return {Array} First element is height boolean, followed by width boolean.
  */
oj.TableDomUtils.prototype.isTableContainerScrollable = function()
{
  var tableContainer = this.getTableContainer();
  
  // temporarily hide the message divs to they don't messup our scrollHeight calculations
  var noDataMessage = this.getTableNoDataMessage();
  var noDataDisplay = noDataMessage.css('display').toString();
  noDataMessage.css('display', 'none');
  var statusMessage = this.getTableStatusMessage();
  var statusMessageDisplay = statusMessage.css('display').toString();
  statusMessage.css('display', 'none');
  
  var result = [];
  result[0] = this._tableContainerDimensions['height'] > 0 && tableContainer[0].clientHeight > 0 && tableContainer[0].scrollHeight > tableContainer[0].clientHeight ? true: false;
  result[1] = this._tableContainerDimensions['width'] > 0 && tableContainer[0].clientWidth > 0 && tableContainer[0].scrollWidth > tableContainer[0].clientWidth ? true: false;
  
  noDataMessage.css('display', noDataDisplay);
  statusMessage.css('display', statusMessageDisplay);
  
  return result;
}

/**
  * Refresh the table dimensions
  * @param {boolean} immediate  refresh immediately
  * @param {number} width  table container width
  * @param {number} height  table container height
  */
 oj.TableDomUtils.prototype.refreshTableDimensions = function(immediate, width, height)
{
  if (immediate)
  {
    this._refreshTableDimensions(width, height);
  }
  else
  {
    this._refreshTableDimensionsTimer = {width: width, height: height};
  } 
};

/**
 * Remove a tr element from the DOM
 * @param {number} rowIdx  row index
 */
oj.TableDomUtils.prototype.removeTableBodyRow = function(rowIdx)
{
  var tableBodyRow = this.getTableBodyRow(rowIdx);
  if (tableBodyRow != null)
  {
    tableBodyRow[0].parentNode.removeChild(tableBodyRow[0]);
    this.clearCachedDomRowData();
  }
};

/**
 * Render any delayed cell at the table index
 */
oj.TableDomUtils.prototype.renderDelayedTableBodyCell = function(rowIdx, columnIdx)
{
  var delayedCell = this._getDelayedRenderCell(rowIdx, columnIdx);

  if (delayedCell != null)
  {
    var cellColumnContent = delayedCell.cellRenderer({'cellContext': delayedCell.cellContext,
      'column': delayedCell.column,
      'data': delayedCell.data,
      'row': delayedCell.row.attributes});

    if (cellColumnContent != null)
    {
      // if the renderer returned a value then we set it as the content
      // for the cell
      delayedCell.tableBodyCell.append(cellColumnContent);
    }
    else
    {
      // if the renderer didn't return a value then the existing
      // cell was manipulated. So get it and set the required
      // attributes just in case it was replaced or the attributes
      // got removed
      var tableBodyCell = $(delayedCell.tableBodyRow.children(':not(' + '.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS + ')')[columnIdx]);
      this.setTableBodyCellAttributes(rowIdx, columnIdx, tableBodyCell);
      this.styleTableBodyCell(columnIdx, tableBodyCell);
    }
  }
};

/**
 * Render any delayed row at the table index
 */
oj.TableDomUtils.prototype.renderDelayedTableBodyRow = function(rowIdx)
{
  var delayedRow = this._getDelayedRenderRow(rowIdx);
  
  if (delayedRow != null)
  {
    var rowContent = delayedRow.rowRenderer({'rowContext': delayedRow.rowContext, 
                                             'row': delayedRow.row.attributes});

    var tableBodyRow = delayedRow.tableBodyRow;
    
    if (rowContent != null)
    {
      // if the renderer returned a value then we set it as the content
      // for the row
      tableBodyRow.append(rowContent);
    }
    else
    {
      // if the renderer didn't return a value then the existing
      // row was manipulated. So get it and set the required
      // attributes just in case it was replaced or the attributes
      // got removed
      var tableBody = this.getTableBody();
      tableBodyRow = $(tableBody.children()[rowIdx]);
      this.clearCachedDomRowData();
      this.setTableBodyRowAttributes(rowIdx, delayedRow.row, tableBodyRow);
      this.styleTableBodyRow(tableBodyRow);
    }
    this.createTableBodyCellAccSelect(rowIdx, tableBodyRow);

    // set the cell attributes and styling. Skip the 1st one
    // because it's the acc row select td
    var tableBodyCells = tableBodyRow.children('td');
    var i;
    for (i = 1; i < tableBodyCells.length; i++)
    {
      var tableBodyCell = $(tableBodyCells[i]);
      this.setTableBodyCellAttributes(rowIdx, i - 1, tableBodyCell);
      this.styleTableBodyCell(i - 1, tableBodyCell);
    }
  }
};

/**
 * Set the td cell. Calls the cell renderer or populates the value.
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyRow  tr DOM element
 * @param {Object} row  oj.Row
 * @param {function(Object)} cellRenderer cell renderer
 * 
 */
oj.TableDomUtils.prototype.setTableBodyCell = function(rowIdx, columnIdx, tableBodyRow, row, cellRenderer)
{
  var columns = this.component['columnMetaData']();
  var column = columns[columnIdx];

  var tableBodyCell = this.getTableBodyCell(rowIdx, columnIdx, tableBodyRow);

  if (!tableBodyCell)
  {
    tableBodyCell = this.createTableBodyCell(rowIdx, columnIdx);
    this.styleTableBodyCell(columnIdx, tableBodyCell);
    this.insertTableBodyCell(rowIdx, columnIdx, tableBodyCell, tableBodyRow);
  }
  else
  {
    tableBodyCell.empty();
  }
  var data = null;

  if (column.field != null)
  {
    data = row.get(column.field);
  }

  if (cellRenderer)
  {
    var cellContext = this.getRendererContextObject(row, tableBodyCell[0]);
    var delayedCellObj = {};
    delayedCellObj.cellRenderer = cellRenderer;
    delayedCellObj.cellContext = cellContext;
    delayedCellObj.data = data;
    delayedCellObj.row = row;
    delayedCellObj.column = column;
    delayedCellObj.tableBodyRow = tableBodyRow;
    delayedCellObj.tableBodyCell = tableBodyCell;
    this.addDelayedRenderCell(rowIdx, columnIdx, delayedCellObj);
  }
  else
  {
    tableBodyCell.append(data);
  }
};

/**
 * Set the attributes on the cell like rowIdx, columnIdx, etc
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyCell  td DOM element
 */
oj.TableDomUtils.prototype.setTableBodyCellAttributes = function(rowIdx, columnIdx, tableBodyCell)
{
  var accessibility = this.options['accessibility'];
  var column = this.component['columnMetaData'](columnIdx);
  var rowHeaderColumnId = null;
  var isTableHeaderless = this.getTableHeader() == null ? true : false;

  if (accessibility != null && accessibility['rowHeader'] != null)
  {
    rowHeaderColumnId = accessibility['rowHeader'];
  }
  else
  {
    rowHeaderColumnId = this.component['columnMetaData'](0).id;
  }

  var cellRowHeaderId = rowHeaderColumnId + '_' + rowIdx;

  var headers = column.id;
  if (rowHeaderColumnId == column.id)
  {
    tableBodyCell.attr('id', cellRowHeaderId);

    if (isTableHeaderless)
    {
      headers = '';
    }
  }
  else
  {
    if (!isTableHeaderless)
    {
      headers = headers + ' ' + cellRowHeaderId;
    }
    else
    {
      headers = cellRowHeaderId;
    }
  }

  if (!tableBodyCell.attr('headers'))
  {
    tableBodyCell.attr('headers', headers);
  }
};

/**
 * Set the attributes on the row like rowIdx, etc
 * @param {number} rowIdx  row index
 * @param {Object} row  oj.Row
 * @param {jQuery} tableBodyRow  tr DOM element
 */
oj.TableDomUtils.prototype.setTableBodyRowAttributes = function(rowIdx, row, tableBodyRow)
{
};

/**
 * Set the attributes on the header like columndx, etc
 * @param {number} columnIdx  column index
 * @param {jQuery} tableHeaderColumn  th DOM element
 */
oj.TableDomUtils.prototype.setTableHeaderColumnAttributes = function(columnIdx, tableHeaderColumn)
{
  var column = this.component['columnMetaData'](columnIdx);

  if (!tableHeaderColumn.attr('id'))
  {
    tableHeaderColumn.attr('id', column.id);
  }
};

/**
 * Style the initial table
 */
oj.TableDomUtils.prototype.styleInitialTable = function()
{
  var table = this.getTable();
  var tableContainer = this.getTableContainer();
  var tableHeader = table.children('thead');
  tableHeader = tableHeader.length > 0 ? $(tableHeader[0]) : null;
  var tableFooter = table.children('tfoot');
  tableFooter = tableFooter.length > 0 ? $(tableFooter[0]) : null;
  var tableBody = table.children('tbody');
  tableBody = tableBody.length > 0 ? $(tableBody[0]) : null;
  // set the tabindex
  table.attr('tabindex', '0');
  // set focusable
  this.component._focusable(table);
  // set focusable
  this.component._focusable(tableContainer);

  this.styleTableHeader(tableHeader);
  this.styleTableFooter(tableFooter);
  this.styleTableBody(tableBody);
};

/**
 * Style the tbody element
 * @param {jQuery} tableBody thead DOM element
 */
oj.TableDomUtils.prototype.styleTableBody = function(tableBody)
{
  tableBody.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_BODY_CLASS);
  // Add a special marker attribute to tell child components that they are container within table
  tableBody.attr(oj.Components._OJ_CONTAINER_ATTR, this.component['widgetName']);
};

/**
 * Style the td element
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyCell  td DOM element
 */
oj.TableDomUtils.prototype.styleTableBodyCell = function(columnIdx, tableBodyCell)
{
  var options = this.options;
  var column = this.component['columnMetaData'](columnIdx);

  if (column.style != null && tableBodyCell.attr('style') != column.style)
  {
    tableBodyCell.attr('style', column.style);
  }
  
  if (!tableBodyCell.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS))
  {
    tableBodyCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);
  }
  
  if (options.verticalGridVisible == oj.TableDomUtils._OPTION_ENABLED)
  {
    if (!tableBodyCell.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_VGRID_LINES_CLASS))
    {
      tableBodyCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_VGRID_LINES_CLASS);
    }
  }
  if (column.className)
  {
    if (!tableBodyCell.hasClass(column.className))
    {
      tableBodyCell.addClass(column.className);
    }
  }
};

/**
 * Style the tr element
 * @param {jQuery} tableBodyRow  tr DOM element
 */
oj.TableDomUtils.prototype.styleTableBodyRow = function(tableBodyRow)
{
  if (!tableBodyRow.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS))
  {
    tableBodyRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  }
  if (this.options.horizontalGridVisible == oj.TableDomUtils._OPTION_ENABLED)
  {
    if (!tableBodyRow.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HGRID_LINES_CLASS))
    {
      tableBodyRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HGRID_LINES_CLASS);
    }
  }

  this.component._hoverable(tableBodyRow);
};

/**
 * Style the table container
 * @param {jQuery} tableContainer  div DOM element
 */
oj.TableDomUtils.prototype.styleTableContainer = function(tableContainer)
{
  var options = this.options;
  
  // add rootAttributes
  var rootAttributes = this.options['rootAttributes'];
  tableContainer.attr('class', '');
  var attr, value;
  for (attr in rootAttributes)
  {
    if (rootAttributes.hasOwnProperty(attr))
    {
      value = rootAttributes[attr];
      tableContainer.attr(attr, value);
    }
  }
  // add main css class to container
  tableContainer.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CLASS);
  tableContainer.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CONTAINER_CLASS);
  tableContainer.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._WIDGET);
  
  // copy over the table styling
  var table = this.getTable();
  if (table.attr('style') != null)
  {
    tableContainer.attr('style', table.attr('style').toString());
  }
  tableContainer.css('display', 'block');
};

/**
 * Style the tfoot element
 * @param {jQuery} tableFooter tfoot DOM element
 */
oj.TableDomUtils.prototype.styleTableFooter = function(tableFooter)
{
  if (!tableFooter)
  {
    return;
  }
  tableFooter.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CLASS);
  var tableFooterRow = $(tableFooter.children('tr')[0]);
  tableFooterRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_ROW_CLASS);
};

/**
 * Style the td element
 * @param {number} columnIdx  column index
 * @param {jQuery} tableFooterCell  td DOM element
 */
oj.TableDomUtils.prototype.styleTableFooterCell = function(columnIdx, tableFooterCell)
{
  var options = this.options;
  var lastColumn = columnIdx == this.component['columnMetaData']().length - 1 ? true : false;
  var column = this.component['columnMetaData'](columnIdx);

  tableFooterCell.attr('style', column.footerStyle);
  if (!tableFooterCell.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS))
  {
    tableFooterCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS);
  }
  if (options.verticalGridVisible == oj.TableDomUtils._OPTION_ENABLED && !lastColumn)
  {
    tableFooterCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_VGRID_LINES_CLASS);
  }
  if (column.footerClassName)
  {
    tableFooterCell.addClass(column.footerClassName);
  }
};

/**
 * Style the thead element
 * @param {jQuery} tableHeader thead DOM element
 */
oj.TableDomUtils.prototype.styleTableHeader = function(tableHeader)
{
  if (!tableHeader)
  {
    return;
  }
  tableHeader.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_CLASS);
  tableHeader.css('display', 'table-header-group');
  var tableHeaderRow = $(tableHeader.children('tr')[0]);
  tableHeaderRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_ROW_CLASS);
  tableHeaderRow.css('position', 'relative');
};

/**
 * Style the th element
 * @param {number} columnIdx  column index
 * @param {jQuery} tableHeaderColumn  th DOM element
 * @param {string} columnSelectionMode  column selection mode
 */
oj.TableDomUtils.prototype.styleTableHeaderColumn = function(columnIdx, tableHeaderColumn, columnSelectionMode)
{
  var lastColumn = columnIdx == this.component['columnMetaData']().length - 1 ? true : false;
  var column = this.component['columnMetaData'](columnIdx);
  tableHeaderColumn.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CELL_CLASS);
  tableHeaderColumn.attr('style', column.headerStyle);
};

/**
  * Return delayed cell for rendering
  * @private
  * @param {number} rowIdx  row index
  * @param {number} columnIdx  column index
  * @return {Object} delayed cell
  */
oj.TableDomUtils.prototype._getDelayedRenderCell = function(rowIdx, columnIdx)
{
  if (this._delayedRenderCells != null)
  {
    if (this._delayedRenderCells[rowIdx] != null)
    {
      return this._delayedRenderCells[rowIdx][columnIdx];
    }
  }
  return null;
};

/**
  * Return delayed row for rendering
  * @private
  * @param {number} rowIdx  row index
  * @return {Object} delayed row
  */
oj.TableDomUtils.prototype._getDelayedRenderRow = function(rowIdx)
{
  if (this._delayedRenderRows != null)
  {
    return this._delayedRenderRows[rowIdx];
  }
  return null;
};

/**
  * Helper function which returns if the browser is IE and if so the version.
  * @private
  * @return {number|null} IE version. null if not IE.
  */
oj.TableDomUtils.prototype._isIE = function()
{
  var userAgent = navigator.userAgent;
  if (navigator.appName == 'Microsoft Internet Explorer')
  {
    var resultArray = (new RegExp('MSIE ([0-9]{1,}[\.0-9]{0,})')).exec(userAgent);
    if (resultArray != null)
    {
      return parseFloat(resultArray[1]);
    }
  }
  else if (userAgent.indexOf('Trident') >= 0)
  {
    return 11;
  }
  return null;
};

/**
  * Refresh the table dimensions
  * @param {number} width  table container width
  * @param {number} height  table container height
  */
 oj.TableDomUtils.prototype._refreshTableDimensions = function(width, height)
{
  var options = this.options;
  var table = this.getTable();
  var tableHeader = this.getTableHeader();
  var tableFooter = this.getTableFooter();
  var tableHeaderRow = this.getTableHeaderRow();
  var tableContainer = this.getTableContainer();
  var tableBody = this.getTableBody();
  var data = options['data'];
  
  if (typeof this._specifiedTableStyle == "undefined")
  {
    if (typeof table.attr('style') == "undefined")
    {
      this._specifiedTableStyle = null;
    }
    else
    {
      this._specifiedTableStyle = table.attr('style');
    }
  }
  
  if (width > 0 && height > 0 && 
      this._tableContainerWidthConstrained === false && this._tableContainerHeightConstrained === false)
  {
    // we do not need to re-size if the resize listener calls us but height/width are not constrained
    return;
  }
  
  // first remove any styling so that the browser sizes the table
  this._removeTableDimensionsStyling();
  table.attr('style', this._specifiedTableStyle);
  
  if (this._tableContainerDimensions != null)
  {
    if (width > 0 && this._tableContainerWidthConstrained)
    {
      this._tableContainerDimensions['width'] = width;
    }
    if (height > 0 && this._tableContainerHeightConstrained)
    {
      this._tableContainerDimensions['height'] = height;
    }
  }
  else
  {
    this._tableContainerDimensions = this.getTableContainerDimensions();
    
    if (this._tableContainerDimensions == null)
    {
      // call refreshTableDimensions at a later time if the browser hasn't
      // finished rendering yet
      var self = this;
      setTimeout(function(){self.refreshTableDimensions(false, null, null)}, 100);
      return;
    }

    // Denotes whether the table container dimensions are constrained
    // such as by stretching or absolute dimensions
    this._tableContainerHeightConstrained = true;
    this._tableContainerWidthConstrained = true;

    if (this._tableContainerDimensions['height'] == 0)
    {
      this._tableContainerHeightConstrained = false;
    }
    if (this._tableContainerDimensions['width'] == 0)
    {
      this._tableContainerWidthConstrained = false;
    }
  }
  
  if (!this._tableBorderWidth)
  {
    this._tableBorderWidth = tableContainer.outerWidth() - tableContainer.innerWidth();
  }
  if (!this._tableBorderHeight)
  {
    this._tableBorderHeight = tableContainer.outerHeight() - tableContainer.innerHeight();
  }
  
  var isTableHeightScrolled = this.isTableContainerScrollable()[0];
  var isTableWidthScrolled = this.isTableContainerScrollable()[1];
  var isTableMinHeightSet = false;
 
  // size the tableBody so it's at least min size
  var minHeight = parseInt(table.css('minHeight'), 10);
  var minWidth = parseInt(table.css('minWidth'), 10);
  if (minHeight > 0)
  {
    isTableMinHeightSet = true;
    var tableHeaderHeight = 0;
    if (tableHeader != null)
    {
      tableHeaderHeight = tableHeader.height();
    }
    var tableFooterHeight = 0;
    if (tableFooter != null)
    {
      tableFooterHeight = tableFooter.height();
    }
    tableBody.css('min-height', minHeight - tableHeaderHeight - tableFooterHeight - this._tableBorderHeight + 'px');
  }
  
  if (minWidth > 0)
  {
    tableBody.css('min-width', minWidth - this._tableBorderWidth + 'px');
  }

  if (!isTableHeightScrolled && !isTableWidthScrolled &&
    !this._tableContainerHeightConstrained && !this._tableContainerWidthConstrained &&
    !isTableMinHeightSet)
  {
    if (data != null && data.size() > 0)
    {
      // if we have data and height and width are not specified then
      // we want the databody to be the same size as the row data
      tableBody.css('display', 'table-row-group');
    }
    else
    {
      tableBody.css('display', 'block');
    }
    this._refreshTableMessagingPosition();
    this._removeTableBodyRowBottomBorder();

    // we don't need to set any other table dimensions if height or width are not specified
    // just let the browser do everything
    return;
  }

  // let the browser layout the column widths
  if (this._setColumnWidths() === false)
  {
    // call refreshTableDimensions at a later time if the browser hasn't
    // finished rendering yet
    var self = this;
    setTimeout(function(){self.refreshTableDimensions(false, null, null)}, 100);
    return;
  }
  table.css('display', 'block');
  
  var captionHeight = 0;
  var caption = table.children('caption');
  if (caption != null && caption.length > 0)
  {
    captionHeight = $(caption[0]).height();
    caption.css('position', 'absolute');
    caption.css('top', '0px');
    caption.css('display', 'inline');
    if (tableHeader != null)
    {
      tableHeader.css('border-top', tableContainer.css('border-top').toString());
    }
  }

  // apply the styling which sets the fixed column headers, etc
  var tableHeaderHeight = 0;
  if (tableHeader != null)
  {
    tableHeader.css('position', 'absolute');
    
    // if there is a caption, position the thead below it
    tableHeader.css('top', captionHeight + 'px');
    tableHeaderRow.css('display', 'block');
    tableHeaderHeight = tableHeader.height();
    
     if (this.isDivScroller())
    {
      // if we use fallback scrolling then the padding top of the container is used to 
      // position the table scroller to below the table header.
      tableContainer.css('padding-top', tableHeaderHeight + captionHeight + 'px');
    }
    else
    {
      tableBody.css('top', tableHeaderHeight + captionHeight + 'px');
    }
  }
  else
  {
    if (this.isDivScroller())
    {
      tableContainer.css('padding-top', captionHeight + 'px');
    }
  }
  
  var tableFooterHeight = 0;
  if (tableFooter != null)
  {
    tableFooter.css('position', 'absolute');
    tableFooter.css('display', 'block');
    tableFooterHeight = tableFooter.height();
  }

  tableBody.css('display', 'block');

  if (!this.isDivScroller())
  {
    tableBody.css('position', 'absolute');
    tableBody.css('overflow-y', 'auto');
    
    if (this._tableContainerWidthConstrained)
    {
      tableBody.css('width', this._tableContainerDimensions['width'] - this._tableBorderWidth);
    }
    
    if (isTableWidthScrolled)
    {
      if (data != null && data.size() > 0)
      {
        tableBody.css('overflow-x', 'auto');
        if (tableHeader != null)
        {
          tableHeader.css('width', this._tableContainerDimensions['width'] - this._tableBorderWidth);
        }
        tableContainer.css('overflow-x', 'hidden');
      }
      else
      {
        // if we have no data then use the tableContainer's horizontal scroller
        tableContainer.css('overflow-x', 'auto');
      }
      if (tableHeaderRow != null)
      {
        // add relative positioning so we can move the table header when width
        // is scrolled
        tableHeaderRow.css('position', 'relative');
      }
    }
    else
    {
      tableBody.css('overflow-x', 'hidden');
    }

    // if we don't use fallback scrolling then size the table body
    // to fit in the height
    var tableBodyHeight = this._tableContainerDimensions['height'] - tableHeaderHeight - tableFooterHeight - captionHeight - this._tableBorderHeight;
    if (tableBodyHeight > 0)
    {
      tableBody.css('height', tableBodyHeight + 'px');
      tableBody.css('min-height', tableBodyHeight + 'px');
    }
  }

  if (!isTableWidthScrolled)
  {
    if ((data == null || data.size() == 0) && tableHeader != null && tableHeader.width() > 0)
    {
      // if width is not set and we don't currently have any data. We should
      // set the tableBody width to the tableHeader width to prevent 
      // a zero width table.
      tableBody.css('width', tableHeader.width() + 'px');
    }
  }

  var tableBodyWidth = tableBody.width();

  if (tableHeader != null)
  {
    var scrollbarWidth = this.getScrollbarWidth();
      
    if (scrollbarWidth > 0)
    {
      // if we have scrollbars then size the tableheader 
      // to align with the scrollbars
      tableHeader.css('overflow', 'hidden');
      tableHeader.css('width', tableBodyWidth - scrollbarWidth - this._tableBorderWidth + 'px');
    }
    else
    {
      // else table header should be the same width as the table body
      tableHeader.css('width', tableBodyWidth + 'px');
    }
  }
  
  if (this.isDivScroller())
  {
    var tableDivScroller = this.getTableDivScroller();
    tableDivScroller.css('overflow', 'auto');

    if (isTableWidthScrolled)
    {
      tableDivScroller.css('width', this._tableContainerDimensions['width']);
    }

    if (isTableHeightScrolled)
    {
      tableDivScroller.css('height', this._tableContainerDimensions['height'] - tableHeaderHeight - tableFooterHeight);
    }
    tableBody.css('float', 'left');
  }
  
  if (tableFooter != null)
  {
    // position the footer at the bottom
    tableFooter.css('bottom', '0px');
    // table footer should be the same width as the table body
    tableFooter.css('width', tableBodyWidth + 'px');
  }
  
  if (this._tableContainerDimensions['width'] == 0)
  {
    if (!this.isDivScroller())
    {
      // if width is not specified then size everything to the tbody width
      // We need to manually do this because the thead/tbody/tfoot has absolute positioning
      // and hence does not get included in the container div sizing
      tableBody.css('display', 'inline-block');
      table.css('width', tableBody.width() + this._tableBorderWidth + 'px');
      tableContainer.css('width', tableBody.width() + this._tableBorderWidth + 'px');
      tableBody.css('display', 'block');
    }
    else
    {
      tableContainer.css('width', tableBody.width() + this._tableBorderWidth + 'px');
    }
  }

  if (this._tableContainerDimensions['height'] == 0)
  {
    // if no height is set then resize the
    // tableContainer div so that it includes the tbody and thead.
    // We need to manually do this because the thead/tbody/tfoot has absolute positioning
    // and hence does not get included in the container div sizing
    var totalHeight = tableHeaderHeight + tableFooterHeight + captionHeight + tableBody.height() + this._tableBorderHeight;
    if (totalHeight > minHeight)
    {
      if (!this.isDivScroller())
      {
        table.css('height', totalHeight + 'px');
      }
      tableContainer.css('height', totalHeight + 'px');
    }
  }

  this._removeTableBodyRowBottomBorder();
  this._refreshTableMessagingPosition();
};

/**
  * Refresh the table messaging position
  * @private
  */
oj.TableDomUtils.prototype._refreshTableMessagingPosition = function()
{
  var tableContainer = this.getTableContainer();
  var tableBody = this.getTableBody();
  var tableStatusMessage = this.getTableStatusMessage();
  var tableNoDataMessage = this.getTableNoDataMessage();
  
  // refresh the status message position
  var isRTL = (this.component._GetReadingDirection() === "rtl");
  // position status in the center
  var options = {'my': 'center', 'at': 'center', 'collision': 'none', 'of': tableContainer};
  options = oj.PositionUtils.normalizeHorizontalAlignment(options, isRTL);
  (/** @type {Object} */ (tableStatusMessage)).position(options);

  // refresh the no data message position
  options = {'my': 'start top', 'at': 'start top', 'collision': 'none', 'of': tableBody};
  options = oj.PositionUtils.normalizeHorizontalAlignment(options, isRTL);
  (/** @type {Object} */ (tableNoDataMessage)).position(options);
  tableNoDataMessage.css('left', '0px;');
};

/**
  * Iterate through the columns and remove the widths
  * @private
  */
oj.TableDomUtils.prototype._removeHeaderColumnAndCellColumnWidths = function()
{
  var data = this.options['data'];
  var columns = this.component['columnMetaData']();

  var i, headerColumn;
  for (i = 0; i < columns.length; i++)
  {
    headerColumn = this.getTableHeaderColumn(i);
    if (headerColumn != null)
    {
      headerColumn.css('min-width', '');
    }
  }

  if (data != null && data.size() > 0)
  {
    var tableBodyRows = this.getTableBodyRows();
    if (tableBodyRows != null && tableBodyRows.length > 0)
    {
      var tableBodyCell;
      for (i = 0; i < columns.length; i++)
      {

        tableBodyCell = this.getTableBodyCell(0, i, null);
        if (tableBodyCell != null)
        {
          tableBodyCell.css('min-width', '');
        }
      }
    }
  }
};

/**
 * Remove table cell bottom border
 * @private
 */
oj.TableDomUtils.prototype._removeTableBodyRowBottomBorder = function()
{
  if (this.options.horizontalGridVisible != oj.TableDomUtils._OPTION_ENABLED)
  {
    return;
  }
  
  var table = this.getTable();
  var tableContainer = this.getTableContainer();
  var tableBodyRows = this.getTableBodyRows();

  if (tableBodyRows != null && tableBodyRows.length > 0)
  {
    // first make sure that all rows have hgrid
    var i;
    for (i = 0; i < tableBodyRows.length; i++)
    {
      if (!$(tableBodyRows[i]).hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HGRID_LINES_CLASS))
      {
        $(tableBodyRows[i]).addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HGRID_LINES_CLASS);
      }
    }
    var lastTableBodyRow = $(tableBodyRows[tableBodyRows.length - 1]);
    var lastTableBodyRowRect = lastTableBodyRow[0].getBoundingClientRect();
    var tableRect = table[0].getBoundingClientRect();
    var borderBottomWidth = parseInt(lastTableBodyRow.css('borderBottomWidth'), 10) + parseInt(tableContainer.css('borderBottomWidth'), 10);

    if (Math.abs(lastTableBodyRowRect.bottom + borderBottomWidth - tableRect.bottom) <= 1)
    {
      lastTableBodyRow.removeClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HGRID_LINES_CLASS);
    }
  }
};
 
/**
 * Remove table dimensions styling
 * @private
 */
oj.TableDomUtils.prototype._removeTableDimensionsStyling = function()
{
  var table = this.getTable();
  var tableHeader = this.getTableHeader();        
  var tableHeaderRow = this.getTableHeaderRow();
  var tableBody = this.getTableBody();

  // first remove any styling so that the browser sizes the table
  if (tableHeader != null)
  {
    tableHeader.attr('style', '');
    tableHeaderRow.attr('style', '');
  }
  table.css('display', '');
  tableBody.attr('style', '');

  this._removeHeaderColumnAndCellColumnWidths();
};

/**
 * Iterate through the columns and get and then set the widths
 * for the columns and first row this is so that when we re-apply the styling
 * the headers and footers will align with the cells
 * @private
 */
oj.TableDomUtils.prototype._setColumnWidths = function()
{
 var data = this.options['data'];
 var columns = this.component['columnMetaData']();
 // used to track if the widths are zero. This happens when the browser hasn't
 // finished rendering the columns
 var notZeroWidth = null;
 var columnWidths = [];
 var columnPaddingWidths = [];
 var i, headerColumnCell, headerColumnDiv, headerColumnTextDivHeight, headerColumnTextDiv, footerCell;
 for (i = 0; i < columns.length; i++)
 {
   notZeroWidth = false;
   headerColumnCell = this.getTableHeaderColumn(i);
   if (headerColumnCell != null)
   {
     // read in the widths first. Set the widths in a separate loop so setting
     // the widths of early columns does not affect the widths of the rest
     if (headerColumnCell.width() > 0)
     {
       notZeroWidth = true;
     }
     columnWidths[i] = headerColumnCell.width();
     columnPaddingWidths[i] = parseInt(headerColumnCell.css('padding-right'), 10) + parseInt(headerColumnCell.css('padding-left'), 10);

     // also set the header heights
     headerColumnTextDivHeight = null;
     headerColumnTextDiv = headerColumnCell.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_TEXT_CLASS);
     if (headerColumnTextDiv && headerColumnTextDiv.length > 0)
     {
       headerColumnTextDivHeight = headerColumnTextDiv.get(0).clientHeight;
     }
     if (headerColumnTextDivHeight != null)
     {
       headerColumnDiv = headerColumnCell.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS);
       headerColumnDiv.css('min-height', headerColumnTextDivHeight + 'px');
     }
   }
 }
 for (i = 0; i < columns.length; i++)
 {
   headerColumnCell = this.getTableHeaderColumn(i);
   if (headerColumnCell != null)
   {
     headerColumnCell.css('min-width', columnWidths[i] + 'px');
   }
   footerCell = this.getTableFooterCell(i);
   if (footerCell != null)
   {
     footerCell.css('min-width', columnWidths[i] + 'px');
   }
 }

 if (data != null && data.size() > 0)
 {
   var tableBodyRows = this.getTableBodyRows();
   if (tableBodyRows != null && tableBodyRows.length > 0)
   {
     var tableBodyCell, tableBodyCellPaddingWidth, adjustedColumnWidth;
     for (i = 0; i < columns.length; i++)
     {

       tableBodyCell = this.getTableBodyCell(0, i, null);
        if (tableBodyCell != null)
        {
          if (tableBodyCell.width() > 0)
          {
            notZeroWidth = true;
          }
          tableBodyCellPaddingWidth = parseInt(tableBodyCell.css('padding-right'), 10) + parseInt(tableBodyCell.css('padding-left'), 10);
          adjustedColumnWidth = null;
          if (tableBodyCellPaddingWidth > columnPaddingWidths[i])
          {
            adjustedColumnWidth = columnWidths[i] - tableBodyCellPaddingWidth + columnPaddingWidths[i];
          }
          else
          {
            adjustedColumnWidth = columnWidths[i] + columnPaddingWidths[i] - tableBodyCellPaddingWidth;
          }
          tableBodyCell.css('min-width', adjustedColumnWidth + 'px');
        }
     }
   }
 }
 
 return notZeroWidth;
};

/**
 * @const
 */
oj.TableDomUtils.CSS_CLASSES =
  {
    _CHECKBOX_ACC_SELECT_COLUMN_CLASS: 'oj-table-checkbox-acc-select-column',
    _CHECKBOX_ACC_SELECT_ROW_CLASS: 'oj-table-checkbox-acc-select-row',
    _TABLE_CONTAINER_CLASS: 'oj-table-container',
    _TABLE_SCROLLER_CLASS: 'oj-table-scroller',
    _TABLE_CLASS: 'oj-table',
    _TABLE_ELEMENT_CLASS: 'oj-table-element',
    _TABLE_FOOTER_CLASS: 'oj-table-footer',
    _TABLE_FOOTER_ROW_CLASS: 'oj-table-footer-row',
    _TABLE_HEADER_CLASS: 'oj-table-header',
    _TABLE_HEADER_ROW_CLASS: 'oj-table-header-row',
    _COLUMN_HEADER_CELL_CLASS: 'oj-table-column-header-cell',
    _COLUMN_HEADER_ACC_SELECT_COLUMN_CLASS: 'oj-table-column-header-acc-select-column',
    _COLUMN_HEADER_ACC_SELECT_ROW_CLASS: 'oj-table-column-header-acc-select-row',
    _COLUMN_HEADER_CLASS: 'oj-table-column-header',
    _COLUMN_HEADER_TEXT_CLASS: 'oj-table-column-header-text',
    _COLUMN_HEADER_ASC_CLASS: 'oj-table-column-header-asc',
    _COLUMN_HEADER_DSC_CLASS: 'oj-table-column-header-dsc',
    _COLUMN_HEADER_SORT_PACEHOLDER_CLASS: 'oj-table-column-header-sort-placeholder',
    _COLUMN_HEADER_ACC_ASC_LINK_CLASS: 'oj-table-column-header-acc-asc-link',
    _COLUMN_HEADER_ACC_DSC_LINK_CLASS: 'oj-table-column-header-acc-dsc-link',
    _COLUMN_HEADER_ASC_LINK_CLASS: 'oj-table-column-header-asc-link',
    _COLUMN_HEADER_DSC_LINK_CLASS: 'oj-table-column-header-dsc-link',
    _COLUMN_HEADER_ASC_ICON_CLASS: 'oj-table-column-header-asc-icon',
    _COLUMN_HEADER_DSC_ICON_CLASS: 'oj-table-column-header-dsc-icon',
    _TABLE_BODY_CLASS: 'oj-table-body',
    _TABLE_DATA_ROW_CLASS: 'oj-table-body-row',
    _TABLE_DATA_CELL_CLASS: 'oj-table-data-cell',
    _TABLE_DATA_CELL_ACC_SELECT_CLASS: 'oj-table-data-cell-acc-select',
    _TABLE_VGRID_LINES_CLASS: 'oj-table-vgrid-lines',
    _TABLE_HGRID_LINES_CLASS: 'oj-table-hgrid-lines',
    _TABLE_FOOTER_CELL_CLASS: 'oj-table-footer-cell',
    _TABLE_FOOTER_CELL_VGRID_LINES_CLASS: 'oj-table-footer-cell-vgrid-lines',
    _TABLE_STATUS_MESSAGE_CLASS: 'oj-table-status-message',
    _TABLE_NO_DATA_MESSAGE_CLASS: 'oj-table-no-data-message',
    _WIDGET_ICON_CLASS: 'oj-component-icon',
    _HIDDEN_CONTENT_ACC_CLASS: 'oj-helper-hidden-accessible'
  };

/**
 * @const
 */
oj.TableDomUtils.MARKER_STYLE_CLASSES =
  {
    _WIDGET: 'oj-component',
    _ACTIVE: 'oj-active',
    _CLICKABLE_ICON: 'oj-clickable-icon',
    _DISABLED: 'oj-disabled',
    _ENABLED: 'oj-enabled',
    _FOCUS: 'oj-focus',
    _HOVER: 'oj-hover',
    _SELECTED: 'oj-selected'
  };
  
/**
 * @private
 * @const
 * @type {string}
 */
oj.TableDomUtils._COLUMN_HEADER_ROW_SELECT_ID =   '_hdrColRowSel';

/**
 * @private
 * @const
 * @type {string}
 */
oj.TableDomUtils._OPTION_ENABLED = 'enabled';
/**
 * @private
 * @const
 * @type {string}
 */
oj.TableDomUtils._OPTION_DISABLED = 'disabled';
/**
 * @private
 * @const
 */
oj.TableDomUtils._OPTION_SELECTION_MODES =
  {
    _SINGLE: 'single',
    _MULTIPLE: 'multiple'
  };
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.ModelRow
 * @classdesc Object representing name/value pairs for a row of data
 *
 * @param {oj.Model} model oj.Model object 
 * @param {Object=} options 
 *                  rowSet: rowSet for this row
 * @constructor
 */
oj.ModelRow = function(model, options)
{
  oj.ModelRow._init(this, model, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.ModelRow, oj.Row, "ModelRow.ModelRow");

oj.ModelRow.prototype.Init = function()
{
  oj.Row.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Row.
 * 
 * @type Object
 */
oj.ModelRow.prototype.attributes = {};

/**
 * @export
 * @desc The Row's unique ID. 
 * 
 * @type String
 */
oj.ModelRow.prototype.id = null;

/**
 * @export
 * @desc The name of the row property to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type String
 */
oj.ModelRow.prototype.idAttribute = null;

oj.ModelRow._init = function(row, model, options, properties)
{
  var prop = null, attrCopy;

  row.Init();

  row._model = model;
  row.id = model.id;
  row.idAttribute = model.idAttribute;
  row.attributes = model.attributes;
  row.index = model.index;

  options = options || {};

  // First, copy all properties passed in
  for (prop in properties)
  {
    if (properties.hasOwnProperty(prop))
    {
      row[prop] = properties[prop];
    }
  }
  row['context'] = options['context'];
};

/**
 * @export
 * Return a copy of the Row with identical attributes and settings
 */
oj.ModelRow.prototype.clone = function()
{
  return this._model.clone();
};

/**
 * Returns the value of the property from the Row.
 * @param {string} property Property to get from row
 * @return {Object} value of property
 * @export
 */
oj.ModelRow.prototype.get = function(property)
{
  return this._model.get(property);
};

/**
 * Return the oj.Model object which was wrapped
 * @return {oj.Model} oj.Model object
 * 
 * @export
 */
oj.ModelRow.prototype.getModel = function()
{
  return this._model;
};

/**
 * Set the value(s) of one or more attributes of the row
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in
 * @returns {Object||boolean} the row itself, false if failed
 * @export
 */
oj.ModelRow.prototype.set = function(property, value, options)
{
  return this._model.set(property, value, options);
};

/**
 * @export
 * Return all of the Row's attributes as an array
 * 
 * @returns {Array} array of all the Row's attributes
 */
oj.ModelRow.prototype.keys = function()
{
  return this._model.keys();
};

/**
 * @export
 * Return all of the Row's attributes values as an array
 * 
 * @returns {Array} array of all the Row's attributes values
 */
oj.ModelRow.prototype.values = function()
{
  return this._model.values();
};

/**
 * @export
 * Return an array of attributes/value pairs found in the Row 
 * 
 * @returns {Object} returns the Row's attribute/value pairs as an object property bag
 */
oj.ModelRow.prototype.pairs = function()
{
  return this._model.pairs();
};

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true*/

/**
 * @export
 * @class oj.CollectionRowSet
 * @classdesc RowSet wrapper for oj.Collection 
 * 
 * @param {oj.Collection} collection oj.Collection object 
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 */
oj.CollectionRowSet = function(collection, options) 
{
  // Initialize
  oj.CollectionRowSet._init(this, collection, options, null);
};

/**
 * @export
 * @desc If set, sort the rowSet using the given attribute of a row (if string); function(Row) returning a string attribute
 * by which the sort should take place; function(Row1, Row2) if a user-defined function comparing Row1 and Row2 (see the
 * JavaScript array.sort() for details)
 * 
 * @type {String|function(Object)|function(Object,Object)}
 */
oj.CollectionRowSet.prototype.comparator = null;

/**
 * @export
 * @desc If comparator is a string, define the sort direction (ascending or descending) for sorting
 * 
 * @type {String}
 */
oj.CollectionRowSet.prototype.sortDirection = null;

/**
 * @export
 * @desc Set to true if sort is supported.
 * 
 * @type boolean
 */
oj.CollectionRowSet.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.CollectionRowSet, oj.RowSet, "CollectionRowSet.CollectionRowSet");

oj.CollectionRowSet.prototype.Init = function()
{
  oj.CollectionRowSet.superclass.Init.call(this);
};

oj.CollectionRowSet._init = function(rowSet, collection, options, properties) 
{
  var prop;
  rowSet._eventHandlers = [];
  rowSet._startIndex = 0;
  
  rowSet.Init();

  // First, copy all properties passed in
  if (properties) 
  {
    for (prop in properties) 
    {
      if (properties.hasOwnProperty(prop)) 
      {
        rowSet[prop] = properties[prop];
      }
    }
  }
  rowSet._collection = collection;
  rowSet._addCollectionEventListeners();
};

/**
 * Return the row object found at the given index of the collection, or a promise object that will return the row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the collection is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual collection or
 *                  if deferred is specified and true, at will return a Promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.at = function(index, options)
{
  var model = this._collection.at(index, options);
  if (model != null)
  {
    if (model instanceof oj.Model)
    {
      return new oj.ModelRow(model);
    }
    else
    {
      return oj.Object.__getPromise(function(resolve, reject) {
        model.then(function(resolvedModel)
                           {
                             resolve(new oj.ModelRow(resolvedModel));
                           });
        });
    }
  }
  return null;
};

/**
 * Loads the data into the RowSet
 * @param {Object=} options Options to control fetch<p>
 *                  success: a user callback called when the fetch has completed successfully.<p>
 *                  error: a user callback function called if the fetch fails.<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.fetch = function(options)
{
  if (this._canFetch.call(this))
  {
    this._startFetch.call(this);

    options = options || {};
    var self = this;
    var isPaged =  options.startIndex != null ? true : false;
    this._startIndex = isPaged ? options.startIndex : 0;
    this._initFetch = true;
    var pageSize = options['pageSize'] > 0 ? options['pageSize'] : -1;
    options['pageSize'] = pageSize;
    options['startIndex'] = this._startIndex;
    options['refresh'] = true;
  
    if (isPaged)
    {
      this._collection.setRangeLocal(this._startIndex, pageSize).then(function() 
        {
          self._endFetch.call(self, options, null);
        });
    }
    else
    {
      this._collection.fetch({
        'success': function(collection, response, opts) 
        {
          self._collection = collection;
          self._endFetch.call(self, options, null);
        },
        'error': function(collection, e, opts) 
        {
          self._collection = collection;
          self._endFetch.call(self, options, e);
        }
      });
    }
  }
}

/**
 * Return the first row object from the collection whose row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {Object|string} id ID for which to return the row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} First row object in the collection where row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the row when done
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.get = function(id, options)
{
  return new oj.ModelRow(this._collection.get(id, options));
};

/**
 * Return the oj.Collection object which was wrapped
 * @return {oj.Collection} oj.Collection object
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.getCollection = function()
{
  return this._collection;
};

/**
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.hasMore = function()
{
  return this._collection['hasMore'];
};

/**
 * Return the array index location of the given row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 
 * @return {number} The index of the given row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.indexOf = function(row, options) 
{
  return this._collection.indexOf(row.getModel(), options);
};

/**
 * Determine if the rowset has any rows
 * 
 * @returns {boolean} true if collection is empty
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.isEmpty = function() 
{
  return this._collection.isEmpty();
};

/**
 * Return the length of the collection
 * @returns {number} length of the collection
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.size = function() 
{
  var size = this._collection.size();
  if (!this._initFetch)
  {
    // if a fetch hasn't been done yet and this is virtual then return -1
    // so an initial fetch will be called to execute setRangeLocal
    if (!this._collection.isRangeLocal(0, size))
    {
      return 0;
    }
  }
  return size;
};

/**
 * Sort the rows in the rowSet
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.sort = function() 
{
  if (this['comparator']) {
    this._collection['comparator'] = this['comparator'];
  }
  if (this['sortDirection']) { 
      this._collection['sortDirection'] = this['sortDirection'] === 'ascending' ? 1 : -1;
  }
  return this._collection.sort(null);
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.totalSize = function()
{
  return this._collection['totalResults'];
};

oj.CollectionRowSet.prototype.SetComparator = function(criteria) {
  
  if (criteria == null)
  {
    this['comparator'] = null;
    this._collection['comparator'] = null;
    return;
  }
  
  var key = criteria['key']; 
  var direction = criteria['direction'];
  var comparator = null;
  
  if (this._collection.__isVirtual()) {
      // Only strings are supported for virtual sorts
      this['comparator'] = key;
      this['sortDirection'] = direction;
      return;
  }
  
  if (direction == 'ascending')
  {
    comparator = function(row) {
      if ($.isFunction(row.get))
      {
        return row.get(key);
      }
      else
      {
        return row[key]();
      }
    };
  }
  else if (direction == 'descending')
  {
    comparator = function(rowA, rowB) {
      var a, b;
      if ($.isFunction(rowA.get))
      {
        a = rowA.get(key);
        b = rowB.get(key);
      }
      else
      {
        a = rowA[key]();
        b = rowB[key]();
      }
      if (a === b)
      {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  this['comparator'] = comparator;
};

/**
 * Add event listeners to the collection
 * @private
 */
oj.CollectionRowSet.prototype._addCollectionEventListeners = function()
{
  var self = this;
  this._collection.on(oj.Events.EventType['SYNC'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['SYNC'], event);
  });
  this._collection.on(oj.Events.EventType['ADD'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['ADD'], new oj.ModelRow(event));
  });
  this._collection.on(oj.Events.EventType['REMOVE'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['REMOVE'], new oj.ModelRow(event));
  });
  this._collection.on(oj.Events.EventType['RESET'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['RESET'], event);
  });
  this._collection.on(oj.Events.EventType['SORT'], function(event, eventOpts) {
    if (eventOpts == null || !eventOpts['add'])
    {
      oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['SORT'], event);
    }
  });
  this._collection.on(oj.Events.EventType['CHANGE'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['CHANGE'], new oj.ModelRow(event));
  });
  this._collection.on(oj.Events.EventType['DESTROY'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['REMOVE'], event);
  });
  this._collection.on(oj.Events.EventType['REFRESH'], function(event) {
      oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['REFRESH'], event);
  });
  this._collection.on(oj.Events.EventType['ERROR'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['ERROR'], event);
    // call endfetch in case a fetch caused the error
    self._endFetch.call(self, null, null);
  });
};

/**
 * Indicate whether we can start a fetch
 * @private
 */
oj.CollectionRowSet.prototype._canFetch = function()
{
  return !this._isFetching;
};

/**
 * Indicate starting fetch
 * @private
 */
oj.CollectionRowSet.prototype._startFetch = function()
{
  this._isFetching = true;
  oj.CollectionRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['REQUEST'], null);
};

/**
 * Indicate ending fetch
 * @private
 */
oj.CollectionRowSet.prototype._endFetch = function(options, e)
{
  options = options || {}; 
  var success = options['success'];
  var error = options['error'];
  
  this._isFetching = false;
  if (e != null)
  {
    oj.CollectionRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['ERROR'], e);
    
    if (error)
    { 
      error.call(this, options, e);
    }
  }
  else
  {
    oj.CollectionRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['SYNC'], options);
    
    if (success)
    {
      success.call(this, options);
    }
  }
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.CollectionTableDataSource
 * @classdesc Object representing data used by table component
 * @param {Object} data data supported by the components
 * @param {Object|null} options Array of options for the TableDataSource
 * @constructor
 */
oj.CollectionTableDataSource = function(data, options)
{
  // Initialize
  this.data = {};   // This was put in to keep closure happy...
  if (!(data instanceof oj.Collection))
  {
    // we only support Array, oj.Collection, oj.RowSet, or ko.observableArray. To
    // check for observableArray, we can't do instanceof check because it's
    // a function. So we just check if it contains a subscribe function.
    var errSummary = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_SUMMARY'];
    var errDetail = oj.TableDataSource._LOGGER_MSG['_ERR_DATA_INVALID_TYPE_DETAIL'];
    throw new Error(errSummary + '\n' + errDetail);
  }
  
  oj.CollectionTableDataSource.superclass.constructor.call(this, data, options);

  this._rowSet = new oj.CollectionRowSet(data, this.options);
  this._addRowSetEventListeners();
  
  this.Init();

  if ((options != null && (options['startFetch'] == 'enabled' || options['startFetch'] == null))
    || options == null)
  {
    this._startFetchEnabled = true;
  }
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.CollectionTableDataSource, oj.TableDataSource, "oj.CollectionTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.Init = function()
{
  oj.CollectionTableDataSource.superclass.Init.call(this);
};

/**
 * Return the oj.Row object found at the given index of the RowSet.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @return {Object} oj.Row object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.at = function(index)
{
  return this._rowSet.at(index);
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 *                  success: a user callback called when the fetch has completed successfully.<p>
 *                  error: a user callback function called if the fetch fails.<p>
 * @return {Promise} promise object triggering done when complete.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.fetch = function(options)
{
  options = options || {};
  var self = this;
  var success = options['success'];
  var error = options['error'];
  var context = options['context'] == null? this : options['context'];
  var fetchType = options['fetchType'];
  
  if (fetchType == 'init' && !this._startFetchEnabled)
  {
    return oj.Object.__getPromise(function(resolve, reject) {
        resolve();
      });
  }
  
  if (options['startIndex'] != null)
  {
    oj.CollectionTableDataSource.superclass.startIndex.call(this, options['startIndex']);
  }
  var data = this.data;
  
  return oj.Object.__getPromise(function(resolve, reject) {
    options['success'] = function()
    {
      if (success != null)
      {
        success.call(context, self, options);
      }
      resolve();
    };
    options['error'] = function(options, e)
    {
      if (error != null)
      {
        error.call(context, self, options, e);
      }
      reject();
    }
    if (options['startFetch'] == 'enabled')
    {
      // only do an initial fetch if rowSet is empty
      if (self._rowSet.isEmpty() ||
        (typeof self._rowSet.size() === 'undefined'))
      {
        self._rowSet.fetch(options);
      }
    }
    else
    {
      self._rowSet.fetch(options);
    }
  });
};

/**
 * Return the first oj.Row object from the RowSet whose Row id value is the given id
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.get = function(id)
{
  return this._rowSet.get(id);
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.hasMore = function()
{
  if (this._rowSet != null)
  {
    return this._rowSet.hasMore();
  }
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row oj.Row object to locate 
 * @return {number} The index of the given Row object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.indexOf = function(row)
{
  return this._rowSet.indexOf(row);
};

/**
 * Get the length of the RowSet.
 * limit it.
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.size = function()
{
  return this._rowSet.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @return {Promise} promise object triggering done when complete.
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.sort = function(criteria)
{ 
  this._rowSet.SetComparator(criteria);
  
  if (criteria == null)
  {
    return oj.Object.__getPromise(function(resolve, reject) {
      resolve();
    }); 
  }
  
  var self = this;
  return oj.Object.__getPromise(function(resolve, reject) {
      self._rowSet.sort();
      resolve();
  });    
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.totalSize = function()
{
  return this._rowSet.totalSize();
};

/**
 * Add event listeners to the RowSet
 * @private
 */
oj.CollectionTableDataSource.prototype._addRowSetEventListeners = function()
{
  var self = this;
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ADD'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['ADD'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REMOVE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['REMOVE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REQUEST'], function(event) {
    self.isFetching = true;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['REQUEST'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['RESET'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['RESET'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REFRESH'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['REFRESH'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SORT'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['SORT'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['CHANGE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['CHANGE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SYNC'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['SYNC'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ERROR'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.TableDataSource.EventType['ERROR'], event);
  });
};
/**
 * Creates an attribute group handler that will generate stylistic attribute values such as colors or shapes based on data set categories.
 * @param {Object} [matchRules] A map of key value pairs for categories and the matching attribute value e.g. {"soda" : "square", "water" : "circle", "iced tea" : "triangleUp"}.
 *                            Attribute values listed in the matchRules object will be reserved only for the matching categories when getAttributeValue is called.
 * @export
 * @constructor
 */
oj.AttributeGroupHandler = function(matchRules) {
  this.Init(matchRules);
};

oj.Object.createSubclass(oj.AttributeGroupHandler, oj.Object, "oj.AttributeGroupHandler");

oj.AttributeGroupHandler.prototype.Init = function(matchRules) {
  oj.AttributeGroupHandler.superclass.Init.call(this);
  this._matchRules = matchRules ? matchRules : {};
  this._assignments = {};
  this._valueIndex = 0;
  this.Values = this.getValueRamp();
  for (var key in this._matchRules) {
    // remove match rule value from attribute group values
    var idx = this.Values.indexOf(this._matchRules[key]);
    if (idx !== -1)
      this.Values.splice(idx, 1);
  }
}

/**
 * Returns the array of possible attribute values for this attribute group handler.
 * This array can be modified so subclasses should return a copy of its internal value ramp.
 * @returns {Array} The array of attribute values
 * @export
 */
oj.AttributeGroupHandler.prototype.getValueRamp = function() {
  return [];
}

/**
 * Assigns the given category an attribute value.  Will consistently return the same attribute value for equal categories.
 * @param {Object} category The category to assign
 * @returns {Object} The attribute value for the category
 * @export
 */
oj.AttributeGroupHandler.prototype.getValue = function(category) {
  if (this._matchRules[category])
    return this._matchRules[category];
  else if (this._assignments[category])
    return this._assignments[category];
  else {
    this._assignments[category] = this.Values[this._valueIndex];
    if (this._valueIndex == this.Values.length - 1)
      this._valueIndex = 0;
    else
      this._valueIndex++;
    return this._assignments[category];
  } 
}

/**
 * Returns the current map of key value pairs for categories and the assigned attribute values
 * @return {Array} The current list of category and value pairing
 * @export
 */
oj.AttributeGroupHandler.prototype.getCategoryAssignments  = function() {
  var assignments = [];
  for (var i in this._assignments)
    assignments.push({"category": i, "value": this._assignments[i]});
  return assignments;
}

/**
 * Reserves an attribute value for the given category
 * @param {String} category Used for checking inputs to getAttributeValue against when assigning an attribute value
 * @param {String} attributeValue The attribute value to assign for inputs matching the given category e.g. "square" or "circle"
 * @export
 */
oj.AttributeGroupHandler.prototype.addMatchRule = function(category, attributeValue) {
  this._matchRules[category] = attributeValue;
}
var DvtStyleProcessor = {
	'CSS_TEXT_PROPERTIES':
		function(node, styleString) {
			var ignoreProperties = {};
			if (node) {
				if (node.hasClass("oj-gaugeMetricLabel") && node.hasClass(node.parentNode, "oj-ledGauge")) {
					ignoreProperties ['font-size'] = true;
					ignoreProperties ['color'] = true;
				}
				if (node.hasClass(node, "oj-chartSliceLabel")) {
					ignoreProperties ['color'] = true;
				}
			}
			return DvtStyleProcessor._mergeOptionsAndDivStyle(node, styleString, false, ignoreProperties);
		},
	'CSS_BACKGROUND_PROPERTIES':
		function(node, styleString) {
			return DvtStyleProcessor._mergeOptionsAndDivStyle(node, styleString, true, {});
		},
	'CSS_URL':
		function(node, styleString) {
			return DvtStyleProcessor._parseUrl(node);
		}
	}
        
DvtStyleProcessor._INHERITED_FONT_COLOR = "rgb(254, 0, 254)";
DvtStyleProcessor._INHERITED_FONT_FAMILY = "Times";
DvtStyleProcessor._INHERITED_FONT_SIZE = "1px";
DvtStyleProcessor._INHERITED_FONT_WEIGHT = "1";
DvtStyleProcessor._INHERITED_FONT_STYLE = "normal";

// Chrome adjusts px font size when zooming, so only set the font size if the inherited size is less than 4px.
DvtStyleProcessor._FONT_SIZE_BUFFER = 4.0;

DvtStyleProcessor.defaultStyleProcessor = function(cssDiv, property) {
	return cssDiv.css(property);
}

/**
 * @param {Object} cssDiv The element with style class or with some default style
 */
DvtStyleProcessor._parseUrl = function(cssDiv) {
  var url = cssDiv.css('background-image');
  if (url && url.indexOf('url(') !== -1)
    return url.slice(url.indexOf('url(')+4, url.length-1).replace(/"/g,"");
  else
    return url;
}

/**
 * @param {Object} cssDiv The element with style class or with some default style
 * @return {string} The merged CSS background properties string including border-color, border-width, and background-color
 */
DvtStyleProcessor._buildCssBackgroundPropertiesString = function(cssDiv) {
  var styleString = "";
  if (cssDiv.css('border-top-color'))
  {
    styleString += "border-color: " + cssDiv.css('border-top-color') + ";";
  }
  // border without border-style is always nonsense (with width 0px)
  if (cssDiv.css('border-width') && (cssDiv.css('border-style') && cssDiv.css('border-style') != 'none'))
  {
    styleString += "border-width: " + cssDiv.css('border-width') + ";";
  }
  if (cssDiv.css('background-color'))
  {
    styleString += "background-color: " + cssDiv.css('background-color') + ";";
  }

  return styleString;
}

/**
 * build css style string
 * @param {Object} cssDiv The element with style class or with some default style
 * @param {Object} ignoreProperties The css properties to ignore
 * @return {string} The merged CSS text properties string including font-family, font-size, font-weight, color, and font-style
 */
DvtStyleProcessor._buildTextCssPropertiesString = function(cssDiv, ignoreProperties)
{
  var styleString = "";
  var value = cssDiv.css('font-family');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_FAMILY)
  {
    styleString += "font-family: " + value.replace(/"/g,"'") + ";";
  }
  value = cssDiv.css('font-size');
  if (value && !(value.indexOf("px") > -1 && parseFloat(value) < DvtStyleProcessor._FONT_SIZE_BUFFER) && !ignoreProperties ['font-size'])
  {
    styleString += "font-size: " + value + ";";
  }
  value = cssDiv.css('font-weight');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_WEIGHT)
  {
    styleString += "font-weight: " + value + ";";
  }
  value = cssDiv.css('color');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_COLOR && !ignoreProperties ['color'])
  {
    styleString += "color: " + value + ";";
  }
  value = cssDiv.css('font-style');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_STYLE)
  {
    styleString += "font-style: " + value + ";";
  }
  return styleString;
}

/**
 * Merges style on div with css text in optionsStyle.
 * 
 * @param {Object} cssDiv The element with style class or with some default style
 * @param {string} optionsStyle The extending CSS text style
 * @param {Object} ignoreProperties The css properties to ignore
 * @param {boolean} bIncludeBackgroundProps Whether to merge background properties in addition to text properties. Default is to merge only text properties.
 * @return {string} The merged CSS properties string
 */
DvtStyleProcessor._mergeOptionsAndDivStyle = function(cssDiv, optionsStyle, bIncludeBackgroundProps, ignoreProperties)
{
  if (!ignoreProperties)
    ignoreProperties = {};

  if (!cssDiv)
  {
    return optionsStyle;
  }

  var oldStyle;
  if (optionsStyle)
  {
    oldStyle = cssDiv.attr("style");
    if (oldStyle)
      cssDiv.attr("style", oldStyle + optionsStyle);
    else
      cssDiv.attr("style", optionsStyle);
  }

  var styleString = '';

  if (bIncludeBackgroundProps !== true)
  {
    styleString += this._buildTextCssPropertiesString(cssDiv, ignoreProperties);
  }

  if (bIncludeBackgroundProps !== false)
  {
    styleString += this._buildCssBackgroundPropertiesString(cssDiv);
  }
  if (oldStyle)
  {
    cssDiv.attr("style", oldStyle);
  }
  return styleString;
}

/**
 * Creates dummy divs for each component style class and merges their values with the component options object.
 * @param {Object} element DOM node to add CSS styles to for processing
 * @param {Object} options The options object to merge CSS properties with
 * @param {Array} componentClasses The style classes associated with the component
 * @param {Object} childClasses Style classes associated with a component's children
 * @private
 */ 
DvtStyleProcessor.processStyles = function(element, options, componentClasses, childClasses)
{
  // Add the component style classes to a hidden dummy div
  var outerDummyDiv = $(document.createElement("div"));
  outerDummyDiv.attr("style", "display:none;");
  element.append(outerDummyDiv);
  var styleClasses = '';
  for (var i=0; i<componentClasses.length; i++)
    styleClasses = styleClasses + componentClasses[i] + " ";
  outerDummyDiv.attr("class", styleClasses);

  // Add an inner dummy div to overwrite inherited values and prevent populating options object with them
  var innerDummyDiv = $(document.createElement("div"));
  outerDummyDiv.append(innerDummyDiv);
  innerDummyDiv.css("font-family", DvtStyleProcessor._INHERITED_FONT_FAMILY);
  innerDummyDiv.css("font-size", DvtStyleProcessor._INHERITED_FONT_SIZE);
  innerDummyDiv.css("color", DvtStyleProcessor._INHERITED_FONT_COLOR);
  innerDummyDiv.css("font-weight", DvtStyleProcessor._INHERITED_FONT_WEIGHT);
  innerDummyDiv.css("font-style", DvtStyleProcessor._INHERITED_FONT_STYLE);
  for (var styleClass in childClasses) {
    var dummyDiv = $(document.createElement("div"));
    dummyDiv.addClass(styleClass);
    innerDummyDiv.append(dummyDiv);
    DvtStyleProcessor._processStyle(options, dummyDiv, childClasses[styleClass]);
  }
}

/**
 * Resolves the css properties within a dummy div
 * @param {Object} options The options object to merge CSS properties with
 * @param {Object} cssDiv The div to use for processing CSS style
 * @param {Object} definition Map of CSS style attribute and values to process
 * @private
 */ 
DvtStyleProcessor._processStyle = function(options, cssDiv, definition)
{
  if (definition instanceof Array) {
    for (var i=0;i<definition.length; i++) 
      DvtStyleProcessor._resolveStyle(options, cssDiv, definition[i]);
  } else {
    DvtStyleProcessor._resolveStyle(options, cssDiv, definition);
  }
}
      
/**
 * Helper function to resolve the css properties within a dummy div.
 * @param {Object} options The options object to merge CSS properties with
 * @param {Object} cssDiv The div to use for processing CSS style
 * @param {Object} definition Map of CSS style attribute and values to process
 * @private
 */ 
DvtStyleProcessor._resolveStyle = function(options, cssDiv, definition)
{
  var path = new DvtJsonPath(options, definition['path']);
  var value;
  if(definition['property']) {
    var handler = DvtStyleProcessor[definition['property']];
    if (!handler)
      value = DvtStyleProcessor.defaultStyleProcessor(cssDiv, definition['property']);
    else
      value = handler(cssDiv, path.getValue());
  }
  if(value != null
     && !(typeof value == 'string' && value.replace(/^\s+/g, '') == '')) {
    path.setValue(value);
  }
}
oj.__registerWidget('oj.dvtBaseComponent', $['oj']['baseComponent'], {
 
  /** 
   * @override
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _ComponentCreate : function() {
    this._super();
    
    // Create a reference div within the element to be used for computing relative event coords.
    this._referenceDiv = $(document.createElement("div"));
    this._referenceDiv.attr("style", "visibility:hidden;");
    this.element.append(this._referenceDiv);
  
    // Create the DvtContext, which creates the svg element and adds it to the DOM.
    this._context = new DvtContext(this.element[0], null, this._referenceDiv[0]);
    
    // Set the reading direction on the context
    this._context.setReadingDirection(this._GetReadingDirection());
    
    // Set the tooltip and datatip div style classes on the context
    this._context.setTooltipStyleClass('oj-dvt-tooltip');
    this._context.setDatatipStyleClass('oj-dvt-datatip');
    
    // Set high contrast mode if needed
    if ($(document.body).hasClass('oj-hicontrast'))
      DvtAgent.setHighContrast(true);
    
    // Set the tabindex on the element to enable keyboard handling
    this.element.attr("tabIndex", 0);
    
    // Create and cache the component instance
    this._component = this._CreateDvtComponent(this._context, this._HandleEvent, this);

    // Add the component to the display tree of the rendering context.
    this._context.getStage().addChild(this._component);  
    
    // Merge css styles with with json options object
    this._ProcessStyles();
    
    // Retrieve and apply the translated strings onto the component bundle
    this._processTranslations();

    // Load component resources
    this._LoadResources();

    // Render the component
    this._Render();
    
    // Add resize listener
    oj.DomUtils.addResizeListener(this.element[0], $.proxy(this._handleResize, this));
  },
  
  /** 
   * @override
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  refresh : function() {
    this._super();
  
    // Update the reading direction on the context
    this._context.setReadingDirection(this._GetReadingDirection());
    
    // Retrieve and apply the translated strings onto the component bundle
    this._processTranslations();
  
    // Render the component with any changes
    this._Render();
  },
  
  /** 
   * @override
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  getNodeBySubId : function(locator) {
    // subcomponents should override for jsDoc to list subId values
    var automation;
    if (this._component && this._component.getAutomation)
      automation = this._component.getAutomation();
    if (automation)
      return automation.getDomElementForSubId(locator['subId']);
    return null;
  },
  
  /** 
   * @override
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  getSubIdByNode : function(node) {
    // subcomponents should override for jsDoc to list subId values
    var automation;
    if (this._component && this._component.getAutomation)
      automation = this._component.getAutomation();
    if (automation)
      return automation.getSubIdForDomElement(node);
    return null;
  },
  
  /**
   * Create dummy divs for style classes and merge style class values with json 
   * options object
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _ProcessStyles : function() {
    // Append the component style classes to the element
    var componentStyles = this._GetComponentStyleClasses();
    for(var i=0; i<componentStyles.length; i++) {
      this.element.addClass(componentStyles[i]);
    }
  	
  	// Process selectors for this component
    DvtStyleProcessor.processStyles(this.element, this.options, 
                                    this._GetComponentStyleClasses(), 
                                    this._GetChildStyleClasses());
  },
  
  /**
   * Returns the style classes associated with the component.
   * @return {Array}
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _GetComponentStyleClasses : function() {
    return ['oj-dvtbase'];
  },
  
  /**
   * Returns a map of the style classes associated with a component's children.
   * @return {Object}
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _GetChildStyleClasses : function() {
    return {};
  },
  
  /**
   * Returns an array of supported event types.  Used in conjunction with _setOptions to skip unnecessary rendering when 
   * event listeners are bound. Subclasses must override to return supported event types.
   * @return {Array}
   */
  _GetEventTypes : function() {
    return [];
  },
  
  /**
   * Returns a map containing keys corresponding to the string ids in ojtranslations.js and values corresponding to the 
   * toolkit constants for the DvtBundle objects.  This map must be guaranteed to be a new instance so that subclasses can
   * add their translations to it.
   * @return {Object}
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _GetTranslationMap: function() {
    var ret = {
      'DvtUtilBundle.CLEAR_SELECTION': this.getResource('labelClearSelection'),
      
      // Stages for Accessibility
      'DvtUtilBundle.STATE_SELECTED': this.getResource('stateSelected'),
      'DvtUtilBundle.STATE_UNSELECTED': this.getResource('stateUnselected'),
      'DvtUtilBundle.STATE_MAXIMIZED': this.getResource('stateMaximized'),
      'DvtUtilBundle.STATE_MINIMIZED': this.getResource('stateMinimized'),
      'DvtUtilBundle.STATE_EXPANDED': this.getResource('stateExpanded'),
      'DvtUtilBundle.STATE_COLLAPSED': this.getResource('stateCollapsed'),
      'DvtUtilBundle.STATE_ISOLATED': this.getResource('stateIsolated'),
      'DvtUtilBundle.STATE_HIDDEN': this.getResource('stateHidden'),
      'DvtUtilBundle.STATE_VISIBLE': this.getResource('stateVisible'),
      
      'DvtUtilBundle.SCALING_SUFFIX_THOUSAND': this.getResource('labelScalingSuffixThousand'),
      'DvtUtilBundle.SCALING_SUFFIX_MILLION': this.getResource('labelScalingSuffixMillion'),
      'DvtUtilBundle.SCALING_SUFFIX_BILLION': this.getResource('labelScalingSuffixBillion'),
      'DvtUtilBundle.SCALING_SUFFIX_TRILLION': this.getResource('labelScalingSuffixTrillion'),
      'DvtUtilBundle.SCALING_SUFFIX_QUADRILLION': this.getResource('labelScalingSuffixQuadrillion')
    };
    
    // Add abbreviated month strings
    var monthNames = oj.LocaleData.getMonthNames("abbreviated");
    ret['DvtUtilBundle.MONTH_SHORT_JANUARY'] = monthNames[0];
    ret['DvtUtilBundle.MONTH_SHORT_FEBRUARY'] = monthNames[1];
    ret['DvtUtilBundle.MONTH_SHORT_MARCH'] = monthNames[2];
    ret['DvtUtilBundle.MONTH_SHORT_APRIL'] = monthNames[3];
    ret['DvtUtilBundle.MONTH_SHORT_MAY'] = monthNames[4];
    ret['DvtUtilBundle.MONTH_SHORT_JUNE'] = monthNames[5];
    ret['DvtUtilBundle.MONTH_SHORT_JULY'] = monthNames[6];
    ret['DvtUtilBundle.MONTH_SHORT_AUGUST'] = monthNames[7];
    ret['DvtUtilBundle.MONTH_SHORT_SEPTEMBER'] = monthNames[8];
    ret['DvtUtilBundle.MONTH_SHORT_OCTOBER'] = monthNames[9];
    ret['DvtUtilBundle.MONTH_SHORT_NOVEMBER'] = monthNames[10];
    ret['DvtUtilBundle.MONTH_SHORT_DECEMBER'] = monthNames[11];
    
    return ret;
  },
  
  /**
   * Retrieves the translated resource with the specified 
   * @param {string} key The key used to retrieve the translated resource.
   * @param {Array.<string>} params The array of named parameters that need to be converted into index based parameters.
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _GetTranslatedResource: function(key, params) {
    var translatedResource = this.getResource(key);
    
    // If named parameters are defined, replace with index based params     
    if(params) {
      var paramMap = {};
      
      for(var i=0; i<params.length; i++) {
        paramMap[params[i]] = '{' + i + '}';
      }
      
      translatedResource = oj.Translations.applyParameters(translatedResource, paramMap);
    }

    return translatedResource;
  },
   
  /**
   * Called to process the translated strings for this widget.  
   * @private
   */
  _processTranslations: function() {
    // Retrieve the map of translation keys + DvtBundle identifiers
    var translationMap = this._GetTranslationMap();
    
    // Register with the DvtBundle
    DvtBundle.addLocalizedStrings(translationMap);
  },
  
  /**
   * @override
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _destroy : function() {
    // Call destroy on the JS component
    if (this._component.destroy)
      this._component.destroy();
      
    // Remove DOM resize listener  
    oj.DomUtils.removeResizeListener(this.element[0], $.proxy(this._handleResize, this));
    
    // Remove children and clean up DOM changes
    this.element.children().remove();
    this.element.removeAttr('role').removeAttr('tabIndex');
    
    // Remove style classes that were added
    var componentStyles = this._GetComponentStyleClasses();
    for(var i=0; i<componentStyles.length; i++) {
      this.element.removeClass(componentStyles[i]);
    }
    
    // Call super last for destroy
    this._super();
  },

  /**
   * @override
   * @memberof! oj.dvtBaseComponent
   * @instance
   * @protected
   */
  _setOptions : function(options) {
    // Call the super to update the property values
    this._superApply(arguments);
    
    // Render the component with the updated options.
    if(this._bUserDrivenChange) {
      // Option change fired in response to user gesture. Already reflected in UI, so no render needed.
      return;
    }
    else {
      // Event listeners don't require rendering.  Iterate through options to check for non-event options.
      var bRenderNeeded = false;
      var eventTypes = this._GetEventTypes();
      $.each(options, function(key, value) {
        if(eventTypes.indexOf(key) < 0) {
          bRenderNeeded = true;
          return false;
        }
      });
      
      // Render the component with the changes.
      if(bRenderNeeded)
        this._Render();
    }
  },
  
  /**
   * @override
   * @memberof! oj.dvtBaseComponent
   * @instance
   * @protected
   */
  _setOption : function (key, value)
  {  
    // If this property supports option change events, keep track of the previous value.
    var bSupportsOptionChange = this._SupportsOptionChangeEvent(key);
    var previousValue = this.options[key];
    
    // Call the super to set the option 
    var ret = this._superApply(arguments);
    
    // Trigger option change event if needed
    if (bSupportsOptionChange)
    {
      var newValue = this.options[key];
      
      // trigger a optionChange event only when the newValue is different from the previousValue to 
      // avoid recursion. E.g., setOption() triggers optionChange, which calls ko binding callback, 
      // which then writes to observable. Which then causes binding update to call set option again
      if (!oj.Object.__innerEquals(previousValue, newValue))
      {
        var ui = {
          'option': key, 'previousValue': previousValue, 'value': newValue,
          "optionMetadata": {'writeback': this._bUserDrivenChange ? "shouldWrite" : "shouldNotWrite"}
        };
        this._trigger('optionChange', null, ui);
      }
    }
    
    return ret;
  },
  
  /**
   * Called by _create to instantiate the specific DVT component instance.  Subclasses must override.
   * @param {DvtContext} context
   * @param {Function} callback
   * @param {Object} callbackObj
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return null; // subclasses must override
  },
  
  /**
   * Called by the component to process events.  Subclasses should override to delegate DVT component events to their 
   * JQuery listeners.
   * @param {Object} event
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _HandleEvent : function(event) {
    // subclasses should override to delegate component events to their listeners
  },
  
  /**
   * Called when the component is resized.
   * @param {number} width
   * @param {number} height
   * @private
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _handleResize : function(width, height) {
    // Render the component at the new size if it changed enough
    var newWidth = this.element.width();
    var newHeight = this.element.height();
    if(Math.abs(newWidth - this._width) + Math.abs(newHeight - this._height) >= 5) {    
      this._component.render(null, newWidth, newHeight);
      
      // Update the rendered size
      this._width = newWidth;
      this._height = newHeight;
    }
  },
  
  /**
   * Called once during component creation to load resources.
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _LoadResources : function() {
    // subcomponents should override
  }, 
          
  /**
   * Called to render the component at the current size.
   * @protected
   * @instance
   * @memberof! oj.dvtBaseComponent
   */
  _Render : function() {
    // Fix 18498656: If the component is not attached to a visible subtree of the DOM, rendering will fail because 
    // getBBox calls will not return the correct values.  Log an error message in this case and avoid rendering.
    // Note: Checking offsetParent() does not work here since it returns false for position: fixed.
    if(!this._context.isReadyToRender())
      oj.Logger.error(this.getResource('notReadyToRender')['summary']);
    else {
      // Render the component
      this._width = this.element.width();
      this._height = this.element.height();
      this._component.render(this.options, this._width, this._height);
    }
  },
  
  /**
   * Returns true if the specified option supports firing optionChange events.
   * @param {string} key The name of the option.
   * @return {boolean} true if the option supports optionChange events.
   * @memberof! oj.dvtBaseComponent
   * @instance
   * @protected
   */
  _SupportsOptionChangeEvent : function(key) {
    return false;
  },
  
  /**
   * Sets an option change that was driven by user gesture.  Used in conjunction with _setOption to ensure that the
   * correct optionMetadata flag for writeback is set.
   * @param {string} key The name of the option to set.
   * @param {Object} value The value to set for the option.
   * @memberof! oj.dvtBaseComponent
   * @instance
   * @protected
   */
  _UserOptionChange : function(key, value) {
    this._bUserDrivenChange = true;
    this.option(key, value);
    this._bUserDrivenChange = false;
  }
});
/**
 * Creates a shape attribute group handler that will generate shape attribute values.
 * @param {Object} [matchRules] A map of key value pairs for categories and the matching attribute value e.g. {"soda" : "square", "water" : "circle", "iced tea" : "triangleUp"}.
 *                            Attribute values listed in the matchRules object will be reserved only for the matching categories when getAttributeValue is called.
 * @export
 * @constructor
 * @extends {oj.AttributeGroupHandler}
 */
oj.ShapeAttributeGroupHandler = function(matchRules) {
  this.Init(matchRules);
}

oj.Object.createSubclass(oj.ShapeAttributeGroupHandler, oj.AttributeGroupHandler, "oj.ShapeAttributeGroupHandler");

oj.ShapeAttributeGroupHandler._attributeValues = ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp', 'human'];

/**
 * @override
 */
oj.ShapeAttributeGroupHandler.prototype.getValueRamp = function() {
  return oj.ShapeAttributeGroupHandler._attributeValues.slice();
}
/**
 * Creates a color attribute group handler that will generate color attribute values.
 * @param {Object} [matchRules] A map of key value pairs for categories and the matching attribute value e.g. {"soda" : "#336699", "water" : "#CC3300", "iced tea" : "#F7C808"}.
 *                            Attribute values listed in the matchRules object will be reserved only for the matching categories when getAttributeValue is called.
 * @export
 * @constructor
 * @extends {oj.AttributeGroupHandler}
 */
oj.ColorAttributeGroupHandler = function(matchRules) {
  this._attributeValues = [];
  // In high contrast mode attribute group colors get overridden to all
  // white or all black. In this case we should use the default colors.
  if ($(document.body).hasClass('oj-hicontrast'))  {
    this._attributeValues = oj.ColorAttributeGroupHandler._defaultColors.slice();
  } else {
    var attrGpsDiv = $(document.createElement("div"));
    attrGpsDiv.attr("style", "display:none;");
    attrGpsDiv.attr("id", "attrGps");
    $(document.body).append(attrGpsDiv);
    for (var i = 0; i < oj.ColorAttributeGroupHandler._styleClasses.length; i++) {
      var childDiv = $(document.createElement("div"));
      childDiv.addClass(oj.ColorAttributeGroupHandler._styleClasses[i]);
      attrGpsDiv.append(childDiv);
      this._attributeValues.push(childDiv.css('color'));
    }
    attrGpsDiv.remove();
  }
  this.Init(matchRules);
}

oj.Object.createSubclass(oj.ColorAttributeGroupHandler, oj.AttributeGroupHandler, "oj.ColorAttributeGroupHandler");

oj.ColorAttributeGroupHandler._styleClasses = ['oj-dvt-category1',
  'oj-dvt-category2', 'oj-dvt-category3', 'oj-dvt-category4',
  'oj-dvt-category5', 'oj-dvt-category6', 'oj-dvt-category7',
  'oj-dvt-category8', 'oj-dvt-category9', 'oj-dvt-category10',
  'oj-dvt-category11', 'oj-dvt-category12'];

oj.ColorAttributeGroupHandler._defaultColors = ['#267db3', '#68c182', '#fad55c',
                                                '#ed6647', '#8561c8', '#6ddbdb', 
                                                '#ffb54d', '#e371b2', '#47bdef', 
                                                '#a2bf39', '#a75dba', '#f7f37b'];
/**
 * @override
 */
oj.ColorAttributeGroupHandler.prototype.getValueRamp = function() {
  return this._attributeValues.slice();
}
/**
 * Class to help set css properties on the component root options object
 * @param {Object} object The root options object from which this path should be resolved
 * @param {string} path The string path within the options object to resolve
 * @constructor
 * @ignore
 */
var DvtJsonPath = function(object, path)
{
  this._path = path;
  this._root = object;
  this._delimiter = '/';
}

/**
 * Resolves the parameter of the leaf object and the leaf object itself
 * @param {Object} root The root object to update
 * @param {string} path The string path within the root object to resolve
 * @param {string} delimiter The string delimiter for the path string
 * @param {boolean} createIfMissing Flag to create the hierarchy of the namespaces if they do not exist
 * @return {Object} The resolved parameter
 * @private
 */
DvtJsonPath.prototype._resolveLeafObjectAndProperty = function(root, path, delimiter, createIfMissing)
{
  var result = {};
  while (root && path.indexOf(delimiter) > -1)
  {
    var subProperty = path.substring(0, path.indexOf(delimiter));
    if (createIfMissing && root[subProperty] === undefined)
    {
      root[subProperty] = {};
    }
    root = root[subProperty];
    path = path.substring(path.indexOf(delimiter) + 1, path.length);
  }

  if (root)
  {
    result['object'] = root;
    result['parameter'] = path;
  }

  return result;
}

/**
 * Resolves path to the leaf object and parameter of this object
 * @param {boolean} createIfMissing Flag to create the hierarchy of the namespaces if they do not exist
 * @private
 */
DvtJsonPath.prototype._resolvePath = function(createIfMissing)
{
  if (this._leaf === undefined)
  {
    var result = this._resolveLeafObjectAndProperty(this._root, this._path, this._delimiter, createIfMissing);

    this._leaf = result['object'];
    this._param = result['parameter'];
  }
}

/**
 * Returns value of the leaf element of the path.
 * @return {string} value The value of the leaf element or undefined if path structure is not yet created
 */
DvtJsonPath.prototype.getValue = function()
{
  this._resolvePath(false);
  return this._leaf === undefined ? undefined : this._leaf[this._param];
}

/**
 * Sets value of the leaf element of the path.
 * @param {String} value The value of the leaf element
 */
DvtJsonPath.prototype.setValue = function(value)
{
  this._resolvePath(true);

  if (this._leaf[this._param] !== value)
  {
    this._leaf[this._param] = value;
  }
}
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

// Base class for all gauge components
oj.__registerWidget('oj.dvtBaseGauge', $['oj']['dvtBaseComponent'], 
{
  /**
   * @override
   * @memberof! oj.dvtBaseGauge
   * @instance
   * @protected
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses['oj-gauge-metric-label'] = {'path' : 'metricLabel/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-gauge-tick-label'] = {'path' : 'tickLabel/style', 'property' : 'CSS_TEXT_PROPERTIES'};
// TODO HZHANG threshold colors needs bug fix 17334522
//    styleClasses['oj-gauge-threshold-index1'] = {'path' : '', 'type' : 'color'};
//    styleClasses['oj-gauge-threshold-index2'] = {'path' : '', 'type' : 'color'};
//    styleClasses['oj-gauge-threshold-index3'] = {'path' : '', 'type' : 'color'};
    return styleClasses;
  },
    
  /**
   * @override
   * @memberof! oj.dvtBaseGauge
   * @instance
   * @protected
   */
  _GetEventTypes : function() {
    return ['input', 'optionChange'];
  },
  
  /**
   * @override
   * @memberof! oj.dvtBaseGauge
   * @instance
   * @protected
   */
  _GetTranslationMap: function() {
    // Safe to modify super's map because function guarentees a new map is returned
    var ret = this._super();
    ret['DvtGaugeBundle.EMPTY_TEXT'] = this._GetTranslatedResource('msgNoData');
    return ret;
  },
  
  /**
   * @override
   * @memberof! oj.dvtBaseGauge
   * @instance
   * @protected
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null;
    if(type === DvtValueChangeEvent.TYPE) {
      // Fired after the value change interaction is complete
      this._UserOptionChange('value', event.getNewValue());
    }
    else if(type === DvtValueChangeEvent.TYPE_INPUT) {
      // Fired during the value change interaction for each change
      this._trigger('input', null, {'value': event.getNewValue()});
    }
    else {
      this._super(event);
    }
  },
  
  /**
   * @override
   * @memberof! oj.dvtBaseGauge
   * @instance
   * @protected
   */
  _SupportsOptionChangeEvent : function(key) {
    return key == 'value';
  }
});
/**
 * @class 
 * @name oj.ojStatusMeterGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="statusMeterGaugeOverview-section">
 *   JET Status Meter Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#statusMeterGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>Status meter gauge component for JET, supporting horizontal and circular status meters.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojStatusMeterGauge',
 *   value: 63, min: 0, max: 100, 
 *   thresholds: [{max: 33}, {max: 67}, {}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="statusMeterGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#statusMeterGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/statusMeterGauge.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Increase value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Decrease value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Decrease value in left-to-right locales. Increase value in right-to-left locales.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Increase value in left-to-right locales. Decrease value in right-to-left locales.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Status Meter Gauge.
 * @example <caption>Initialize the Status Meter Gauge with no options specified:</caption>
 * $(".selector").ojStatusMeterGauge();
 * 
 * @example <caption>Initialize the Status Meter Gauge with some options:</caption>
 * $(".selector").ojStatusMeterGauge({value: 63, min: 0, max: 100, thresholds: [{max: 33}, {max: 67}, {}]});
 * 
 * @example <caption>Initialize the Status Meter Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojStatusMeterGauge'}">
 */
oj.__registerWidget('oj.ojStatusMeterGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered during a value change gesture on mouse or touch move.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the value of the gauge
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">input</code> callback specified:</caption>
     * $(".selector").ojStatusMeterGauge({
     *   "input": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojinput</code> event:</caption>
     * $(".selector").on("ojinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojStatusMeterGauge
     * @instance
     */
    input : null,
    
    /**
     * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
     * intervention. If the new value is the same as the previous value, no event will be fired. Additional options may 
     * be supported in the future, so listeners should verify which option is changing before taking any action. 
     * Currently supports: <code class="prettyprint">value</code>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * @property {Object} ui.optionMetadata information about the option that is changing
     * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
     *                    <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojStatusMeterGauge({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojStatusMeterGauge
     * @instance
     */
    optionChange: null
  },
  
  /**
   * @override
   * @memberof! oj.ojStatusMeterGauge
   * @instance
   * @protected
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return DvtStatusMeterGauge.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   * @memberof! oj.ojStatusMeterGauge
   * @instance
   * @protected
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-statusmetergauge');
    return styleClasses;
  },
  
  /**
   * @override
   * @memberof! oj.ojStatusMeterGauge
   * @instance
   * @protected
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
    if(this.element.attr('title'))
    {
      this.options['shortDesc'] =  this.element.attr('title');
      this.element.data( this.element,'title', this.element.attr('title'));
      this.element.removeAttr('title');
    }
    else if (this.element.data('title'))
      this.options['shortDesc'] =  this.element.data('title');
  
    // Call the super to render
    this._super();
  },
  
  /**
   * Returns the gauge's metric label. 
   * @return {Object} The metric label object
   * @expose
   * @instance
   * @memberof! oj.ojStatusMeterGauge
   */
  getMetricLabel: function() {
    var auto = this._component.getAutomation();
    return auto.getMetricLabel();
  }
});
/**
 * @class 
 * @name oj.ojLedGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="ledGaugeOverview-section">
 *   JET LED Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ledGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>LED gauge component for JET.  LED gauges are used to highlight a specific metric value in relation to its 
 * thresholds.<p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojLedGauge',
 *   value: 63, min: 0, max: 100, 
 *   thresholds: [{max: 33}, {max: 67}, {}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="ledGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ledGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/ledGauge.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.</p>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET LED Gauge.
 * @example <caption>Initialize the LED Gauge with no options specified:</caption>
 * $(".selector").ojLedGauge();
 * 
 * @example <caption>Initialize the LED Gauge with some options:</caption>
 * $(".selector").ojLedGauge({value: 63, min: 0, max: 100, thresholds: [{max: 33}, {max: 67}, {}]});
 * 
 * @example <caption>Initialize the LED Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojLedGauge'}">
 */
oj.__registerWidget('oj.ojLedGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
  },
  
  /**
   * @override
   * @memberof! oj.ojLedGauge
   * @instance
   * @protected
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return DvtLedGauge.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   * @memberof! oj.ojLedGauge
   * @instance
   * @protected
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-ledgauge');
    return styleClasses;
  },
  
  /**
   * @override
   * @memberof! oj.ojLedGauge
   * @instance
   * @protected
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
    if(this.element.attr('title'))
    {
      this.options['shortDesc'] =  this.element.attr('title');
      this.element.data( this.element,'title', this.element.attr('title'));
      this.element.removeAttr('title');
    }
    else if (this.element.data('title'))
      this.options['shortDesc'] =  this.element.data('title');
  
    // Call the super to render
    this._super();
  },
  
  /**
   * Returns the gauge's metric label. 
   * @return {Object} The metric label object
   * @expose
   * @instance
   * @memberof! oj.ojLedGauge
   */
  getMetricLabel: function() {
    var auto = this._component.getAutomation();
    return auto.getMetricLabel();
  }
});
/**
 * @class 
 * @name oj.ojRatingGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="ratingGaugeOverview-section">
 *   JET Rating Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ratingGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>Rating gauge component for JET.  Rating gauges are typically used to display or accept user feedback on a product
 * or service.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {component: 'ojRatingGauge', value: 4}"/>
 * </code>
 * </pre>
 * 
 * <h3 id="ratingGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ratingGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/ratingGauge.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Increase value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Decrease value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Decrease value in left-to-right locales. Increase value in right-to-left locales.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Increase value in left-to-right locales. Decrease value in right-to-left locales.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Rating Gauge.
 * @example <caption>Initialize the Rating Gauge with no options specified:</caption>
 * $(".selector").ojRatingGauge();
 * 
 * @example <caption>Initialize the Rating Gauge with some options:</caption>
 * $(".selector").ojRatingGauge({value: 4});
 * 
 * @example <caption>Initialize the Rating Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojRatingGauge'}">
 */
oj.__registerWidget('oj.ojRatingGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered during a value change gesture on mouse or touch move.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the value of the gauge
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">input</code> callback specified:</caption>
     * $(".selector").ojRatingGauge({
     *   "input": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojinput</code> event:</caption>
     * $(".selector").on("ojinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojRatingGauge
     * @instance
     */
    input : null,
    
    /**
     * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
     * intervention. If the new value is the same as the previous value, no event will be fired. Additional options may 
     * be supported in the future, so listeners should verify which option is changing before taking any action. 
     * Currently supports: <code class="prettyprint">value</code>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * @property {Object} ui.optionMetadata information about the option that is changing
     * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
     *                    <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojRatingGauge({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojRatingGauge
     * @instance
     */
    optionChange: null
  },
  
  /**
   * @override
   * @memberof! oj.ojRatingGauge
   * @instance
   * @protected
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return DvtRatingGauge.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   * @memberof! oj.ojRatingGauge
   * @instance
   * @protected
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-ratinggauge');
    //TODO HZHANG Add style classes for rating gauge selected/hover/unselected/changed
    return styleClasses;
  },
  
  /**
   * @override
   * @memberof! oj.ojRatingGauge
   * @instance
   * @protected
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
    if(this.element.attr('title'))
    {
      this.options['shortDesc'] =  this.element.attr('title');
      this.element.data( this.element,'title', this.element.attr('title'));
      this.element.removeAttr('title');
    }
    else if (this.element.data('title'))
      this.options['shortDesc'] =  this.element.data('title');
  
    // Call the super to render
    this._super();
  },
  
  /**
   * @override
   * @memberof! oj.ojRatingGauge
   * @instance
   * @protected
   */
  _SupportsOptionChangeEvent : function(key) {
    return key == 'value' || key == 'changed';
  },
  
  /**
   * @override
   * @memberof! oj.ojRatingGauge
   * @instance
   * @protected
   */
  _UserOptionChange : function(key, value) {
    this._superApply(arguments);
    
    // If this was a value change, also update the changed value
    if(key == 'value')
      this._UserOptionChange('changed', true);
  }
});
/**
 * @class 
 * @name oj.ojDialGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="dialGaugeOverview-section">
 *   JET Dial Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>Dial gauge component for JET.  Dial gauges are used to display a metric value in relation to the minimum and 
 * maximum possible values for that metric.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojDialGauge',
 *   value: 63, min: 0, max: 100, 
 *   metricLabel: {rendered: 'on'}
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="dialGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/dialGauge.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Increase value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Decrease value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Decrease value in left-to-right locales. Increase value in right-to-left locales.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Increase value in left-to-right locales. Decrease value in right-to-left locales.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Dial Gauge.
 * @example <caption>Initialize the Dial Gauge with no options specified:</caption>
 * $(".selector").ojDialGauge();
 * 
 * @example <caption>Initialize the Dial Gauge with some options:</caption>
 * $(".selector").ojDialGauge({value: 63, min: 0, max: 100, metricLabel: {rendered: 'on'}});
 * 
 * @example <caption>Initialize the Dial Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojDialGauge'}">
 */
oj.__registerWidget('oj.ojDialGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered during a value change gesture on mouse or touch move.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the value of the gauge
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">input</code> callback specified:</caption>
     * $(".selector").ojDialGauge({
     *   "input": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojinput</code> event:</caption>
     * $(".selector").on("ojinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojDialGauge
     * @instance
     */
    input : null,
    
    /**
     * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
     * intervention. If the new value is the same as the previous value, no event will be fired. Additional options may 
     * be supported in the future, so listeners should verify which option is changing before taking any action. 
     * Currently supports: <code class="prettyprint">value</code>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * @property {Object} ui.optionMetadata information about the option that is changing
     * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
     *                    <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojDialGauge({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojDialGauge
     * @instance
     */
    optionChange: null
  },
  
  /**
   * @override
   * @memberof! oj.ojDialGauge
   * @instance
   * @protected
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return DvtDialGauge.newInstance(context, callback, callbackObj);
  },

  /**
   * @override
   * @memberof! oj.ojDialGauge
   * @instance
   * @protected
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-dialgauge');
    return styleClasses;
  },
  
  /**
   * @override
   * @memberof! oj.ojDialGauge
   * @instance
   * @protected
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
    if(this.element.attr('title'))
    {
      this.options['shortDesc'] =  this.element.attr('title');
      this.element.data( this.element,'title', this.element.attr('title'));
      this.element.removeAttr('title');
    }
    else if (this.element.data('title'))
      this.options['shortDesc'] =  this.element.data('title');
	
    // Set images for dial gauge	
    this._setImages();
	
    // Call the super to render
    this._super();
  },
  
  /**
   * Applies image URLs to the options object passed into the dial gauge.
   * @private
   */
  _setImages: function() {
    // Pass the correct background image information set the default circleAlta and needleAlta.
    var backgroundImages = this.options['background'];
    var backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/alta-circle-200x200.png'), width: 200, height: 200},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/alta-circle-400x400.png'), width: 400, height: 400}];;
    var indicatorImages = this.options['indicator'];
    var indicatorInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/alta-needle-1600x1600.png'),  width: 374, height: 575}];;
    
    if(typeof backgroundImages === 'string') {
      if(backgroundImages === "rectangleAlta") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/alta-rectangle-200x200.png'), width: 200, height: 154},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/alta-rectangle-400x400.png'), width: 400, height: 309}];
        }
      
      else if(backgroundImages === "domeAlta") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/alta-dome-200x200.png') , width: 200, height: 154},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/alta-dome-400x400.png') , width: 400, height: 309}];
      }
      
      else if(backgroundImages === "circleAntique") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/antique-circle-200x200.png'), width: 200, height: 200},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/antique-circle-400x400.png'), width: 400, height: 400}];
      }
      
      else if(backgroundImages === "rectangleAntique") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/antique-rectangle-200x200.png'), width: 200, height: 168},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/antique-rectangle-400x400.png'), width: 400, height: 335}];
      }
      
      else if(backgroundImages === "domeAntique") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/antique-dome-200x200.png'), width: 200, height: 176},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/antique-dome-400x400.png'), width: 400, height: 352}];
      }
      
      else if(backgroundImages === "circleLight") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/light-circle-200x200.png'), width: 200, height: 200},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/light-circle-400x400.png'), width: 400, height: 400}];
      }
      
      else if(backgroundImages === "rectangleLight") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/light-rectangle-200x200.png'), width: 200, height: 154},
      {src: oj.Config.getResourceUrl('resources\internal-deps/dvt/gauge/light-rectangle-400x400.png'), width: 400, height: 307}];
      }
      
      else if(backgroundImages === "domeLight") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/light-dome-200x200.png'), width: 200, height: 138},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/light-dome-400x400.png'), width: 400, height: 276}];
      }
      
      else if(backgroundImages === "circleDark") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/dark-circle-200x200.png'), width: 200, height: 200},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/dark-circle-400x400.png'), width: 400, height: 400}];
      }
      
      else if(backgroundImages === "rectangleDark") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/dark-rectangle-200x200.png'), width: 200, height: 154},
      {src: oj.Config.getResourceUrl('resources\internal-deps/dvt/gauge/dark-rectangle-400x400.png'), width: 400, height: 307}];
      }
      else if(backgroundImages === "domeDark") {
        backgroundInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/dark-dome-200x200.png'), width: 200, height: 138},
      {src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/dark-dome-400x400.png'), width: 400, height: 276}];
      }
      this.options['_backgroundImages'] = backgroundInfo;
    }
    if(typeof indicatorImages === 'string') {
      if(indicatorImages === "needleAntique") {
        indicatorInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/antique-needle-1600x1600.png'), width: 81, height: 734}];
        }
      
      else if(indicatorImages === "needleDark") {
        indicatorInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/dark-needle-1600x1600.png'),  width: 454, height: 652}];
      }
      
      else if(indicatorImages === "needleLight") {
        indicatorInfo = [{src: oj.Config.getResourceUrl('resources/internal-deps/dvt/gauge/light-needle-1600x1600.png'),  width: 454, height: 652}];
      }
      this.options['_indicatorImages'] = indicatorInfo;
    }  
  },
	
  /**
   * Returns the gauge's metric label. 
   * @return {Object} The metric label object
   * @expose
   * @instance
   * @memberof! oj.ojDialGauge
   */
  getMetricLabel: function() {
    var auto = this._component.getAutomation();
    return auto.getMetricLabel();
  }
});
/*jslint browser: true,devel:true*/
/**
 * Implementation of PagingDataSource backed by an oj.Collection.  CollectionPagingDataSource
 * provides a window into the collection, presenting both a standard JavaScript array and Knockout observable array for consumption.
 * @export
 * @class oj.CollectionPagingDataSource
 * @classdesc Implementation of PagingDataSource using an oj.Collection
 * @param {oj.Collection} collection the collection to use as source data for this paging control
 * @constructor
 */
oj.CollectionPagingDataSource = function(collection)
{
    this.collection = collection;
    // Start at the beginning
    this.current = 0;
    this.Init();  
    // Default the page size to 10
    var self = this;
    this.dataWindow = [];
    this._noInit = true;
    try {
        this.setPageSize(10);
    }
    finally {
        this._noInit = false;
    }
};

// Subclass from oj.PagingDataSource 
oj.Object.createSubclass(oj.CollectionPagingDataSource, oj.PagingDataSource, "oj.CollectionPagingDataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.CollectionPagingDataSource.prototype.Init = function()
{
  oj.CollectionPagingDataSource.superclass.Init.call(this);
};


oj.CollectionPagingDataSource.prototype._getSize = function() {
    if (!this.hasMore()) {
        // Return a size representing only what's left if we'd go over the bounds
        return this.totalSize() - this.startIndex();
    }
    // Otherwise window size should match the page size
    return this.pageSize;
};

oj.CollectionPagingDataSource.prototype._refreshDataWindow = function() {
    // Reinit the array
    this.dataWindow = new Array(this._getSize());
    var self = this;
    return this.collection.IterativeAt(this.startIndex(), this.startIndex() + this.dataWindow.length).then(function(array) {
        // Copy from the source data
        for (var i = 0; i < array.length; i++) {
            self.dataWindow[i] = array[i];
        }
        // Update the observable array
        self._refreshObservableDataWindow();       
    });        
};

oj.CollectionPagingDataSource.prototype._refreshObservableDataWindow = function() {
    if (this.observableDataWindow !== undefined) {
        // Manage the observable window array
        this.observableDataWindow.removeAll();
        for (var i = 0; i < this.dataWindow.length; i++) {
            this.observableDataWindow.push(oj.KnockoutUtils.map(this.dataWindow[i]));
        }
    }
};

/**
 * @export
 * Return the current set of data in the paging window
 * 
 * @returns {Array} the current set of data in the paging window
 */
oj.CollectionPagingDataSource.prototype.getWindow = function() {
    return this.dataWindow;
};

/**
 * @export
 * Get the observable array representing the current set of data in the paging window
 * 
 * @returns {Object} an observable array representing the current data in the paging window
 */
oj.CollectionPagingDataSource.prototype.getWindowObservable = function() {
    if (this.observableDataWindow === undefined) {
        this.observableDataWindow = ko.observableArray();
        this._refreshObservableDataWindow();
    }
    return this.observableDataWindow;
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 *                  success: Callback once the records have been fetched.<p>
 *                           If set, this will be called.  If not set, the fetch callback<p>
 *                           property will be checked and that called on fetch success, if set<p>
 *                          
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionPagingDataSource
 * @instance
 */
oj.CollectionPagingDataSource.prototype.fetch = function(options)
{
    // No fetching, but set up window according to options
    var opts = options || {};
    if (opts['startIndex'] !== undefined) {
        this.current = opts['startIndex'];
    }
    if (opts['pageSize'] !== undefined) {
        this.pageSize = opts['pageSize'];
    }
    
    var self = this;
    // Call collection fetch, and refresh the window on success
    // Allow for the fact that this collection might not be backed by a rest service
    try {
        this.collection.fetch({success:function() {
            self._refreshDataWindow().then(function() {
                self._processSuccess(opts)});
        }});
    }
    catch (e) {
        self._refreshDataWindow().then(function() {
            self._processSuccess(opts)});
    }
};

oj.CollectionPagingDataSource.prototype._processSuccess = function(opts) {
    var options = opts || {};
    this.handleEvent("sync", null);
    
    if (options['success']) {
        options['success']();
    }
/*    else if (this.fetchCallback) {
        this.fetchCallback();
    }*/
};
    
oj.CollectionPagingDataSource.prototype.handleEvent = function(eventType, event)
{
    oj.CollectionPagingDataSource.superclass.handleEvent.call(this, eventType, event);
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.CollectionPagingDataSource
 * @instance
 */
oj.CollectionPagingDataSource.prototype.hasMore = function()
{
  return this.startIndex() + this.pageSize < this.totalSize();
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionPagingDataSource
 * @instance
 */
oj.CollectionPagingDataSource.prototype.next = function()
{
    if (!this.hasMore()) {
        // At the limit
        this._processSuccess(null);
        return;
    }
    // Bump the position by page size
    this.current += this.pageSize;
    var self = this;
    return this._refreshDataWindow().then(function() {
                self._processSuccess(null)});
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionPagingDataSource
 * @instance
 */
oj.CollectionPagingDataSource.prototype.previous = function()
{
    if (this.startIndex() - this.pageSize < 0) {
        // Don't go below 0!
        this.current = 0;
    }
    else {
        this.current -= this.pageSize;
    }
    var self = this;
    return this._refreshDataWindow().then(function() {
                self._processSuccess(null)});
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 */
oj.CollectionPagingDataSource.prototype.setPageSize = function(n)
{
  this.pageSize = n;
/*  if (!this._noInit) {
    var self = this;
    return this._refreshDataWindow().then(function() {
                self._processSuccess(null)});
  }*/
};

oj.CollectionPagingDataSource.prototype.setFetchCallback = function(callback) {
    this.fetchCallback = callback;
};

/**
 * @export
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @expose
 * @memberof! oj.CollectionPagingDataSource
 * @instance
 */
oj.CollectionPagingDataSource.prototype.startIndex = function()
{
  return this.current;
};

/**
 * @export
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @expose
 * @memberof! oj.CollectionPagingDataSource
 * @instance
 */
oj.CollectionPagingDataSource.prototype.size = function()
{
  var w = this.getWindow();
  return w ? w.length : 0;
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.CollectionPagingDataSource
 * @instance
 */
oj.CollectionPagingDataSource.prototype.totalSize = function()
{
    return this.collection.length;
};


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*jslint browser: true,devel:true*/
/**
 * Implementation of PagingDataSource backed by an array of data.  ArrayPagingDataSource
 * provides a window into the array in both standard JavaScript array and Knockout observable array formats.
 * @export
 * @class oj.ArrayPagingDataSource
 * @classdesc Implementation of PagingDataSource using array data
 * @param {Array} data
 * @constructor
 */
oj.ArrayPagingDataSource = function(data)
{
  this.data = data;
  // Start at the beginning
  this.current = 0;
  this.Init();  
  // Default the page size to 10
  this.setPageSize(10);
};

// Subclass from oj.PagingDataSource 
oj.Object.createSubclass(oj.ArrayPagingDataSource, oj.PagingDataSource, "oj.ArrayPagingDataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.ArrayPagingDataSource.prototype.Init = function()
{
  oj.ArrayPagingDataSource.superclass.Init.call(this);
};


oj.ArrayPagingDataSource.prototype._getSize = function() {
    if (!this.hasMore()) {
        // Return a size representing only what's left if we'd go over the bounds
        return this.totalSize() - this.startIndex();
    }
    // Otherwise window size should match the page size
    return this.pageSize;
};

oj.ArrayPagingDataSource.prototype._refreshDataWindow = function() {
    // Reinit the array
    this.dataWindow = new Array(this._getSize());
    // Copy from the source data
    for (var i = 0; i < this.dataWindow.length; i++) {
        this.dataWindow[i] = this.data[this.startIndex() + i];
    }
    
    // Update the observable array
    this._refreshObservableDataWindow();
    
    this.handleEvent("sync", null);    
};

oj.ArrayPagingDataSource.prototype._refreshObservableDataWindow = function() {
    if (this.observableDataWindow !== undefined) {
        // Manage the observable window array
        this.observableDataWindow.removeAll();
        for (var i = 0; i < this.dataWindow.length; i++) {
            this.observableDataWindow.push(this.dataWindow[i]);
        }
    }
};

    
oj.ArrayPagingDataSource.prototype.handleEvent = function(eventType, event)
{
    oj.ArrayPagingDataSource.superclass.handleEvent.call(this, eventType, event);
};

/**
 * @export
 * Return the current set of data in the paging window
 * 
 * @returns {Array} the current set of data in the paging window
 */
oj.ArrayPagingDataSource.prototype.getWindow = function() {
    return this.dataWindow;
};

/**
 * @export
 * Get the observable array representing the current set of data in the paging window
 * 
 * @returns {Object} an observable array representing the current data in the paging window
 */
oj.ArrayPagingDataSource.prototype.getWindowObservable = function() {
    if (this.observableDataWindow === undefined) {
        this.observableDataWindow = ko.observableArray();
        this._refreshObservableDataWindow();
    }
    return this.observableDataWindow;
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayPagingDataSource
 * @instance
 */
oj.ArrayPagingDataSource.prototype.fetch = function(options)
{
    // No fetching, but set up window according to options
    var opts = options || {};
    if (opts['startIndex'] !== undefined) {
        this.current = opts['startIndex'];
    }
    if (opts['pageSize'] !== undefined) {
        this.pageSize = opts['pageSize'];
    }
    this._refreshDataWindow();
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.ArrayPagingDataSource
 * @instance
 */
oj.ArrayPagingDataSource.prototype.hasMore = function()
{
  return this.startIndex() + this.pageSize < this.totalSize();
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayPagingDataSource
 * @instance
 */
oj.ArrayPagingDataSource.prototype.next = function()
{
    if (!this.hasMore()) {
        // At the limit
        return;
    }
    // Bump the position by page size
    this.current += this.pageSize;
    this._refreshDataWindow();
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayPagingDataSource
 * @instance
 */
oj.ArrayPagingDataSource.prototype.previous = function()
{
    if (this.startIndex() - this.pageSize < 0) {
        // Don't go below 0!
        this.current = 0;
    }
    else {
        this.current -= this.pageSize;
    }
    this._refreshDataWindow();
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 */
oj.ArrayPagingDataSource.prototype.setPageSize = function(n)
{
  this.pageSize = n;
  this._refreshDataWindow();
};

/**
 * @export
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @expose
 * @memberof! oj.ArrayPagingDataSource
 * @instance
 */
oj.ArrayPagingDataSource.prototype.startIndex = function()
{
  return this.current;
};

/**
 * @export
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @expose
 * @memberof! oj.ArrayPagingDataSource
 * @instance
 */
oj.ArrayPagingDataSource.prototype.size = function()
{
  return this.getWindow().length;
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.ArrayPagingDataSource
 * @instance
 */
oj.ArrayPagingDataSource.prototype.totalSize = function()
{
    return this.data.length;
};


/**
 * An object used for automation verification of sunburst nodes
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.SunburstNode = function(data) {
  this._data = data;
};

/**
 * Returns the color of the node
 * @returns {String} The node color
 * @export
 */
oj.SunburstNode.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the label of the node
 * @returns {String} The node label
 * @export
 */
oj.SunburstNode.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};

/**
 * Returns the size of the node
 * @returns {Number} The node size
 * @export
 */
oj.SunburstNode.prototype.getSize = function() {
  return this._data ? this._data['size'] : null;
};

/**
 * Returns the tooltip of the node
 * @returns {String} The node tooltip
 * @export
 */
oj.SunburstNode.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns whether or not the node is selected
 * @returns {Boolean} The node selection state
 * @export
 */
oj.SunburstNode.prototype.isSelected = function() {
  return this._data ? this._data['selected'] : false;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class 
 * @name oj.ojSunburst
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="sunburstOverview-section">
 *   JET Sunburst Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sunburstOverview-section"></a>
 * </h3>
 * 
 * <p>Sunburst component for JET. Sunbursts are used to display hierarchical data across two dimensions, represented by 
 * the size and color of the sunburst nodes.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojSunburst',
 *   nodes: [{value: 100, color: "#FFFF00", label: "Total Sales", 
 *            nodes: [{value: 75, color: "#00FF00", label: "Candy"},
 *                    {value: 20, color: "#FFFF00", label: "Fruit"},
 *                    {value: 15, color: "#FF0000", label: "Vegetables"}]}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="sunburstOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sunburstOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/sunburst.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.  Since component terminology for keyboard 
 * and touch shortcuts can conflict with those of the application, it is the 
 * application's responsibility to provide these shortcuts, possibly via a help 
 * popup.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>
 *         Move focus and selection to the first adjacent sector in an inner or outer layer (ring). In 
 *         the northern hemisphere of the sunburst, this will move away from the center, while it will move towards the 
 *         center in the southern hemisphere of the sunburst.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>
 *         Move focus and selection to the first adjacent sector in an inner or outer layer (ring). In 
 *         the northern hemisphere of the sunburst, this will move towards the center, while it will move away from the
 *         center in the southern hemisphere of the sunburst.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move focus and selection counterclockwise to adjacent sector in the same layer (ring).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move focus and selection clockwise to adjacent sector in the same layer (ring).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+UpArrow</kbd></td>
 *       <td>
 *         Move focus and extend selection to the first adjacent sector in an inner or outer layer (ring). In 
 *         the northern hemisphere of the sunburst, this will move away from the center, while it will move towards the 
 *         center in the southern hemisphere of the sunburst.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+DownArrow</kbd></td>
 *       <td>
 *         Move focus and extend selection to the first adjacent sector in an inner or outer layer (ring). In 
 *         the northern hemisphere of the sunburst, this will move towards the center, while it will move away from the
 *         center in the southern hemisphere of the sunburst.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+LeftArrow</kbd></td>
 *       <td>Move focus and extend selection counterclockwise to adjacent sector in the same layer (ring).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+RightArrow</kbd></td>
 *       <td>Move focus and extend selection clockwise to adjacent sector in the same layer (ring).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+UpArrow</kbd></td>
 *       <td>
 *         Move focus to the first adjacent sector in an inner or outer layer (ring), without changing the 
 *         current selection. In the northern hemisphere of the sunburst, this will move away from the center, while it 
 *         will move towards the center in the southern hemisphere of the sunburst.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+DownArrow</kbd></td>
 *       <td>
 *         Move focus to the first adjacent sector in an inner or outer layer (ring), without changing the 
 *         current selection. In the northern hemisphere of the sunburst, this will move towards the center, while it 
 *         will move away from the center in the southern hemisphere of the sunburst.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+LeftArrow</kbd></td>
 *       <td>Move focus counterclockwise to adjacent sector in the same layer (ring), without changing the current 
 *       selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+RightArrow</kbd></td>
 *       <td>Move focus clockwise to adjacent sector in the same layer (ring), without changing the current 
 *       selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+Spacebar</kbd></td>
 *       <td>Multi-select sectors with focus.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Alt+LeftArrow</kbd></td>
 *       <td>Rotate 5 degrees counterclockwise.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Alt+RightArrow</kbd></td>
 *       <td>Rotate 5 degrees clockwise.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Sunburst.
 * @example <caption>Initialize the Sunburst with no options specified:</caption>
 * $(".selector").ojSunburst();
 * 
 * @example <caption>Initialize the Sunburst with some options:</caption>
 * $(".selector").ojSunburst({nodes: [{value: 75, color: "#00FF00", label: "Candy"}, {value: 20, color: "#FFFF00", label: "Fruit"}, {value: 15, color: "#FF0000", label: "Vegetables"}]});
 * 
 * @example <caption>Initialize the Sunburst via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojSunburst'}">
 */
oj.__registerWidget('oj.ojSunburst', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
     * intervention. If the new value is the same as the previous value, no event will be fired. Additional options may 
     * be supported in the future, so listeners should verify which option is changing before taking any action. 
     * Currently supports: <code class="prettyprint">selectedNodes</code>, <code class="prettyprint">startAngle</code>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * @property {Object} ui.optionMetadata information about the option that is changing
     * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
     *                    <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojSunburst({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojSunburst
     * @instance
     */
    optionChange: null,
      
    /**
     * Triggered after user rotation is completed.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the start angle of the sunburst, in degrees
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">rotate</code> callback specified:</caption>
     * $(".selector").ojSunburst({
     *   "rotate": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojrotate</code> event:</caption>
     * $(".selector").on("ojrotate", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojSunburst
     * @instance
     */
    rotate : null,
    
    /**
     * Triggered during user rotation of the sunburst.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the start angle of the sunburst, in degrees
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">rotateInput</code> callback specified:</caption>
     * $(".selector").ojSunburst({
     *   "rotateInput": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojrotateinput</code> event:</caption>
     * $(".selector").on("ojrotateinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojSunburst
     * @instance
     */
    rotateInput : null,
    
    /**
     * Triggered after data items are selected or de-selected.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.items an array containing objects describing the selected nodes
     * @property {string} ui.items.id the id of the node
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
     * $(".selector").ojSunburst({
     *   "select": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
     * $(".selector").on("ojselect", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojSunburst
     * @instance
     */
    select : null
  },
  
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return DvtSunburst.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-sunburst');
    return styleClasses;
  },
  
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
    // TODO HZHANG fill in the urls after expand/collapse are supported
// 		styleClasses['oj-sunburst-expand-icon'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-expand-icon oj-hover'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-expand-icon oj-active'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-collapse-icon'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-collapse-icon oj-hover'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-collapse-icon oj-active'] = {'path' : '', 'property' : 'CSS_URL'};
    styleClasses['oj-sunburst-attribute-type-text'] = {'path' : 'styleDefaults/_attributeTypeTextStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-sunburst-attribute-value-text'] = {'path' : 'styleDefaults/_attributeValueTextStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    // TODO HZHANG add this once drilling is supported
//    styleClasses['oj-sunburst-current-text'] = {'path' : '', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-sunburst-node'] = {'path' : 'nodeDefaults/labelStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-sunburst-node oj-hover'] = {'path' : 'nodeDefaults/hoverColor', 'property' : 'border-top-color'};
    styleClasses['oj-sunburst-node oj-selected'] = [
      {'path' : 'nodeDefaults/selectedOuterColor', 'property' : 'border-top-color'},
      {'path' : 'nodeDefaults/selectedInnerColor', 'property' : 'border-bottom-color'}
    ];
    return styleClasses;
  },
    
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _GetEventTypes : function() {
    return ['optionChange', 'rotate', 'rotateInput', 'select'];
  },
  
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _GetTranslationMap: function() {
    // Safe to modify super's map because function guarentees a new map is returned
    var ret = this._super();   
    ret['DvtSunburstBundle.COLOR'] = this._GetTranslatedResource('labelColor');
    ret['DvtSunburstBundle.SIZE'] = this._GetTranslatedResource('labelSize');
    return ret;
  },
  
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null, selectedItems, selection, selectedItem, i;
    if(type === DvtSelectionEvent.TYPE) {
      selectedItems = [];
      selection = event.getSelection();
      for(i=0; i<selection.length; i++) {
        selectedItem = {'id': selection[i]};
        selectedItems.push(selectedItem);  
      }
      // update the options selection state
      this._UserOptionChange('selectedNodes', selection);
      this._trigger('select', null, {'items': selectedItems});
    }
    else if(type === DvtSunburstRotationEvent.TYPE) {
      // Fired after the rotate interaction is complete
      this._UserOptionChange('startAngle', event.getStartAngle());
      this._trigger('rotate', null, {'value': event.getStartAngle()});
    }
    else if(type === DvtSunburstRotationEvent.TYPE_INPUT) {
      // Fired during the rotate interaction for each change
      this._trigger('rotateInput', null, {'value': event.getStartAngle()});
    }
    else {
      this._super(event);
    }
  },
   
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _LoadResources : function() {
    // Ensure the resources object exists
    if(this.options['_resources'] == null)
      this.options['_resources'] = {};
      
    var resources = this.options['_resources'];
      
    // Add cursors
    resources['rotateCursor'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/sunburst/rotate.cur');
  },
    
  /**
   * @override
   * @memberof! oj.ojSunburst
   * @instance
   * @protected
   */
  _SupportsOptionChangeEvent : function(key) {
    return key == 'selectedNodes' || key == 'startAngle';
  },
  
  /**
   * Returns the subcomponent node represented by the documented locator attribute values.
   * Test authors should target sunburst sub elements using the following locators:
   * <ul>
   *   <li>node[nodeIndex0][nodeIndex1]...[nodeIndexN] - A sunburst node indexed by its position in the hierarchy</li>
   * </ul>
   * @override
   * @expose
   * @memberof! oj.ojSunburst
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   *        whose value is a string, documented by the component, that allows 
   *        the component to look up the subcomponent associated with that 
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one 
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component 
   *        expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
  getNodeBySubId : function(locator) {
    return this._super(locator);
  },
  
  /**
   * Returns the subId string for the given child DOM node. Valid sunburst subIds include:
   * <ul>
   *   <li>node[nodeIndex0][nodeIndex1]...[nodeIndexN] - A sunburst node indexed by its position in the hierarchy</li>
   * </ul>
   * @override
   * @expose
   * @memberof! oj.ojSunburst
   * @instance
   * @param {Element} node The subcomponent node used by the component to lookup the subId string
   * @return {string|null} - the subId for the DOM node or null when none is found
   */
  getSubIdByNode:function(node) {
    return this._super(node);  
  },
  
  /**
   * Returns a SunburstNode object for automation testing verification.
   * @param {Array} subIdPath The array of indices in the subId for the desired node
   * @return {Object} An object containing data for the node at the given subIdPath, or null if none exists
   * @expose
   * @instance
   * @memberof! oj.ojSunburst
   */
  getNode : function(subIdPath) {
    var auto = this._component.getAutomation();
    return new oj.SunburstNode(auto.getNode(subIdPath));
  }
});
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

// jim retrieved from https://raw.github.com/jquery/jquery-ui/1-10-stable/ui/jquery.ui.button.js on 6/29/2013, and then modified

// -------------------------------------------------------------------------------------------------------
// This file contains both the Button and Buttonset components,
// so that they can share the same wrapper function / closure containing shared "private static members".
// -------------------------------------------------------------------------------------------------------

(function() // Button / Buttonset wrapper function, to keep "private static members" private
{

/**
 * @class
 * @name oj.ojButton
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="buttonOverview-section">
 *   JET Button Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant push buttons and toggle buttons, with appropriate styles for hover, active, checked, and disabled.
 * 
 * <p>There are two types of JET Buttons: push buttons and toggle buttons.
 * 
 * 
 * <h3 id="pushButtons-section">
 *   Push Buttons
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pushButtons-section"></a>
 * </h3>
 * 
 * <p>Push buttons are ordinary buttons that do not stay pressed in when clicked.  
 * Push buttons are created from buttons, anchors, and inputs of type button, submit, and reset.  Button elements are typically a good general-purpose choice.
 * 
 * 
 * <h3 id="toggleButtons-section">
 *   Toggle Buttons
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toggleButtons-section"></a>
 * </h3>
 * 
 * <p>Toggle buttons are buttons that toggle between a selected state and an unselected state when clicked.  
 * Toggle buttons are created from radio buttons and checkboxes (inputs of type radio and checkbox).
 * 
 * <p>For toggle buttons, the input must have a label, which must be a sibling of the input that precedes the input.
 * The label's <code class="prettyprint">for</code> attribute must refer to the input's <code class="prettyprint">id</code> attribute. 
 * 
 * <p>A new wrapper element is created around the label and input, so that the component has a single root, while avoiding the accessibility problems
 * caused by nesting the input inside the label.  
 * 
 * <p>The label-precedes-input requirement ensures compatibility with the JET <code class="prettyprint">ojComponent</code> binding on the input element, 
 * which expects all relevant DOM elements, including label, to be already available with all their attributes resolved.
 * 
 * <p>The wrapper and label are styled to appear as the button, while the underlying input is updated on click. 
 * 
 * <p> Note that a given radio button must not be both checked and disabled, unless all radios in the group are disabled, since this removes 
 * the entire radio group from the tab order in mainstream browsers.  This issue applies to native radios and is not unique to JET.
 * 
 * 
 * <h3 id="buttonsetToolbar-section">
 *   Buttonsets and Toolbars
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetToolbar-section"></a>
 * </h3>
 * 
 * <p>The [JET Buttonset]{@link oj.ojButtonset} component can be used to group related buttons, such as a group of radios or checkboxes.  Buttonset provides
 * visual and semantic grouping and WAI-ARIA-compliant focus management.  See the Buttonset API doc for more information.
 * 
 * <p>Also, buttons and buttonsets can be placed in a [JET Toolbar]{@link oj.ojToolbar}.  Like Buttonset, Toolbar is themable and provides WAI-ARIA-compliant 
 * focus management.  See the Toolbar API doc for more information.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>For push and toggle buttons:
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
 *       <td>Invokes a push button's action, or toggles a toggle button.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <p>For menu buttons, with focus on the button:
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd>, <kbd>Space</kbd>, or <kbd>DownArrow</kbd></td>
 *       <td>Opens and enters the menu.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Closes the menu.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <p>See the [Menu]{@link oj.ojMenu} keyboard doc for keystrokes that apply when focus is on the menu.
 * 
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>Per WAI-ARIA requirements for role="button", all flavors of JET Button support invocation via both <kbd>Enter</kbd> and <kbd>Space</kbd>, even when the 
 * underlying DOM element does not.
 * 
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio, 
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>, 
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which 
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user 
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio 
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 * 
 * 
 * <h3 id="eventHandling-section">
 *   Event Handling
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
 * </h3>
 * 
 * <p>It's most reliable to register click handlers directly on the button, rather than on an ancestor.  For example, if any of the button's DOM is swapped out in a click 
 * handler (e.g. alternating the text and icon between "Play" and "Pause"), the bubbling will stop if the click target was part of the content that was removed in the swap.
 * 
 * <p>In lieu of a shared listener on an ancestor, syntax like <code class="prettyprint">$( "#ancestor :oj-button" ).click( myFunc );</code> can be used to set a handler on many 
 * buttons at once. 
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-button</code> pseudo-selector can be used in jQuery expressions to select JET Buttons.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-button" ) // selects all JET Buttons on the page
 * $myEventTarget.closest( ":oj-button" ) // selects the closest ancestor that is a JET Button
 * </code></pre>
 * 
 * 
 * <h3 id="state-section">
 *   Setting Component State
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#state-section"></a>
 * </h3>
 * 
 * <p>In JET, when setting component state after create time, the correct approach depends on whether the component has a JS API for that state.
 * 
 * <p>State with a JS API, such as Button's disabled state, checked state, and label, should be set after creation via that API (which in those examples is 
 * <code class="prettyprint">option()</code>), not by directly manipulating the DOM after creation.  This can be done by calling that JS API directly, or by binding 
 * a component option like <code class="prettyprint">disabled</code> to an observable using the <code class="prettyprint">ojComponent</code> binding.  
 * In the latter case, updates should always be made via the observable, since updates to the observable will update the option, while updates flow from the 
 * component option to the observable only for UI interaction, not for programmatic updates via the API.
 * 
 * <p>Built-in KO bindings, like KO's <code class="prettyprint">disable</code> binding, should not be used for state with a JS API, since that is tatamount to 
 * updating the DOM directly.  The component option should be bound instead, via JET's <code class="prettyprint">ojComponent</code> binding.
 * 
 * <p>If a button's checked state needs to be set programmatically, then it should be wrapped in a Buttonset so that its <code class="prettyprint">checked</code> 
 * option can be used.  It is OK for a Buttonset to contain only one Button.
 * 
 * <p>State with no JS API should be set by manipulating the DOM directly in an allowable way, and then calling <code class="prettyprint">refresh()</code> 
 * on the affected component(s).  E.g. the reading direction (LTR / RTL) is changed by by setting the <code class="prettyprint">"dir"</code> attribute on the 
 * <code class="prettyprint">&lt;html></code> node and calling <code class="prettyprint">refresh()</code>.  
 * 
 * <p>When using a built-in Knockout binding (as opposed to the <code class="prettyprint">ojComponent</code> binding), keep in mind that those bindings do not 
 * execute the necessary <code class="prettyprint">refresh()</code> call after updating the DOM.  Updates that flow from the component to the observable, 
 * as a result of user interaction, are not problematic.  But updates in the other direction, that programmatically update the DOM because the observable changed, 
 * will not be picked up until the next <code class="prettyprint">refresh()</code>.
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <!-- TODO: discuss component state, refresh(), etc. -->
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 *   <li>JQUI Button has a Boolean <code class="prettyprint">text</code> option indicating whether to hide the label when icons are present.
 *       In JET, we prefer to avoid Booleans for future flexibility, so JET Button instead has an expandable <code class="prettyprint">display</code> option accepting 
 *       the values <code class="prettyprint">"all"</code> and <code class="prettyprint">"icons"</code>.</li>
 *   <li>In JQUI Button, the <code class="prettyprint">icons</code> option accepts keys named <code class="prettyprint">"primary"</code> and 
 *       <code class="prettyprint">"secondary"</code>.  For clarity, these options have been renamed in JET Button to <code class="prettyprint">"start"</code> and 
 *       <code class="prettyprint">"end"</code>, our standard directionality-neutral terms for (in LTR) "left" and "right".</li>
 *   <li>JET Button can be effectively disabled without having its <code class="prettyprint">disabled</code> option set.  See [Buttonset.disabled]{@link oj.ojButtonset#disabled}.</li>
 * </ol>
 * 
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "button" or "menu".  
 * E.g. the JQUI <code class="prettyprint">buttoncreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Buttons (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-button", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Button.  If called after the button is already created, it is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the button with no options specified:</caption>
 * $( ".selector" ).ojButton();
 * 
 * @example <caption>Initialize the button with some options and callbacks specified:</caption>
 * $( ".selector" ).ojButton( { "label": "Copy", "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize a push button via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;button id="paste" data-bind="ojComponent: { component: 'ojButton', 
 *                                              label: 'Paste', 
 *                                              create: setupButton }">
 * 
 * @example <caption>Initialize a toggle button via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;label for="check">Toggle&lt;/label>
 * &lt;input type="checkbox" id="check" data-bind="ojComponent: {component: 'ojButton'}"/>
 */
oj.__registerWidget("oj.ojButton", $['oj']['baseComponent'], 
{
    defaultElement: "<button>", // added to externs.js, since this is an override of a superclass member.  (That's the rule for public methods, what about protected fields?)  Would @override do the job and be better than externing?
    widgetEventPrefix : "oj", 
    options: // options is in externs.js, so no need for quotes
    { 
        /**
         * <p>Disables the button if set to <code class="prettyprint">true</code>.
         * 
         * <p>If the button is in a buttonset, setting the buttonset's <code class="prettyprint">disabled</code> option effectively disables all its Buttons, without affecting 
         * their <code class="prettyprint">disabled</code> options.  Thus, a Button is effectively disabled if either its own 
         * <code class="prettyprint">disabled</code> option is set, or the Buttonset's <code class="prettyprint">disabled</code> option is set.
         * 
         * <p>After create time, the <code class="prettyprint">disabled</code> state should be set via this API, not by setting the underlying DOM attribute.
         * 
         * <p>The 2-way <code class="prettyprint">disabled</code> binding offered by the <code class="prettyprint">ojComponent</code> binding 
         * should be used instead of Knockout's built-in <code class="prettyprint">disable</code> and <code class="prettyprint">enable</code> bindings, 
         * as the former sets the API, while the latter sets the underlying DOM attribute.
         * 
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {?boolean}
         * @default <code class="prettyprint">false</code>
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">disabled</code> option specified:</caption>
         * $( ".selector" ).ojButton( { "disabled": true } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
         * // getter
         * var disabled = $( ".selector" ).ojButton( "option", "disabled" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "disabled", true );
         */
        disabled: null,
        
        /**
         * Whether to display both the label and icons (<code class="prettyprint">"all"</code>) or just the icons (<code class="prettyprint">"icons"</code>).
         * In the latter case, the label is displayed in a tooltip instead, unless a tooltip was already supplied at create time.  
         * 
         * <p>The <code class="prettyprint">display</code> option will be ignored if no icons are specified via the <code class="prettyprint">icons</code> option.
         * 
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {string}
         * @ojvalue {string} "all" Display both the label and icons.
         * @ojvalue {string} "icons" Display only the icons.
         * @default <code class="prettyprint">"all"</code>
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">display</code> option specified:</caption>
         * $( ".selector" ).ojButton( { "display": "icons" } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">display</code> option, after initialization:</caption>
         * // getter
         * var display = $( ".selector" ).ojButton( "option", "display" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "display", "icons" );
         */
        display: "all",
        
        /**
         * Text to show in the button. 
         * 
         * <p>When not specified at create time, the element's HTML content is used, or its 
         * <code class="prettyprint">value</code> attribute if the element is an input element of type button, submit, or reset, or 
         * the HTML content of the associated label element if the element is an input of type radio or checkbox.
         * 
         * <p>After create time, the label should be set via this API, not by modifying the underlying DOM.
         * 
         * <p>The 2-way <code class="prettyprint">label</code> binding offered by the <code class="prettyprint">ojComponent</code> 
         * binding should be used instead of Knockout's built-in <code class="prettyprint">text</code> binding, as the former 
         * sets the API, while the latter sets the underlying DOM attribute.
         * 
         * <p>Values set on this option, at create time or later, are treated as plain text, not HTML.  If the label is specified via 
         * DOM at create time as described above, that HTML content is kept.
         * 
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {?string}
         * @default <code class="prettyprint">null</code>
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">label</code> option specified:</caption>
         * $( ".selector" ).ojButton( { "label": "custom label" } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">label</code> option, after initialization:</caption>
         * // getter
         * var label = $( ".selector" ).ojButton( "option", "label" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "label", "custom label" );
         */
        label: null,
        
        /**
         * <p>Icons to display in the button.  Support is as follows:
         * <ul>
         *   <li>Any combination of start and end icons can be specified, with or without the label (see <code class="prettyprint">display</code> option).</li>
         *   <li>Icons are supported for push buttons created from buttons and anchors, and for toggle buttons (radios and checkboxes).</li>
         *   <li>Icons are not supported for push buttons created from inputs of type button, submit, and reset.</li>
         * </ul>
         * 
         * <p>The start icon is displayed before the label text (on the left in LTR), and the end icon is displayed after the 
         * label (on the right in LTR).  In RTL, the positions are reversed.
         * 
         * <p>The <code class="prettyprint">start</code> and <code class="prettyprint">end</code> properties accept one or more 
         * style class names (as seen in the examples), or <code class="prettyprint">null</code>, indicating "no icon."
         * 
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {Object}
         * @default <code class="prettyprint">{ start: null, end: foo }</code>, where foo is 
         * <code class="prettyprint">"oj-component-icon oj-button-menu-dropdown-icon"</code> if this is a menu button, and 
         * <code class="prettyprint">null</code> otherwise.  See the <code class="prettyprint">menu</code> option.
         * 
         * @example <caption>Initialize the button, specifying both icons:</caption>
         * $( ".selector" ).ojButton({ "icons": { start: "demo-icon-font demo-bookmark-icon-16", 
         *                                        end: "demo-icon-font demo-grid-icon-16" } });
         * 
         * @example <caption>Get or set the <code class="prettyprint">icons</code> option, after initialization:</caption>
         * // getter
         * var icons = $( ".selector" ).ojButton( "option", "icons" );
         * 
         * // setter, specifying both icons:
         * $( ".selector" ).ojButton( "option", "icons", { start: "oj-fwk-icon-caret-start oj-fwk-icon", 
         *                                                 end: "demo-icon-font demo-grid-icon-16" } );
         */
        icons:
        {
            /**
             * <p>The start icon of the button.  See the top-level <code class="prettyprint">icons</code> option for details.
             * 
             * @expose
             * @alias icons.start
             * @memberof! oj.ojButton
             * @instance
             * @type {?string|undefined}
             * @default <code class="prettyprint">null</code>
             * 
             * @example <caption>Get or set the <code class="prettyprint">icons.start</code> sub-option, after initialization:</caption>
             * // getter
             * var startIcon = $( ".selector" ).ojButton( "option", "icons.start" );
             * 
             * // setter:
             * $( ".selector" ).ojButton( "option", "icons.start", "oj-fwk-icon-caret-start oj-fwk-icon" );
             */
            start: undefined,
            /**
             * <p>The end icon of the button.  See the top-level <code class="prettyprint">icons</code> option for details.
             * 
             * @expose
             * @alias icons.end
             * @memberof! oj.ojButton
             * @instance
             * @type {?string|undefined}
             * @default <code class="prettyprint">null</code>
             * 
             * @example <caption>Get or set the <code class="prettyprint">icons.end</code> sub-option, after initialization:</caption>
             * // getter
             * var startIcon = $( ".selector" ).ojButton( "option", "icons.end" );
             * 
             * // setter:
             * $( ".selector" ).ojButton( "option", "icons.end", "demo-icon-font demo-grid-icon-16" );
             */
            end: undefined 
        },
        
        /**
         * <p>JQ selector identifying the JET Menu that the button should launch. If specified, the button is a menu button.  
         * 
         * <p>By default, menu buttons have a downward pointing "dropdown" arrow for their end icon.  See the <code class="prettyprint">icons</code> option for details.
         * 
         * <p>Menu button functionality is supported for Buttons based on button or anchor tags.  (Buttons based on input tags either do not support the dropdown icon, 
         * or do not make sense for use as a menu button, or both.)
         * 
         * <p>It is recommended to place the menu immediately after the button in the document, so that the resulting tab order is intuitive.
         * 
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {Object}
         * @default <code class="prettyprint">null</code>
         * 
         * @example <caption>Initialize a menu button:</caption>
         * $( ".selector" ).ojButton({ "menu": "#myMenu" });
         * 
         * @example <caption>Get or set the <code class="prettyprint">menu</code> option, after initialization:</caption>
         * // getter
         * var menu = $( ".selector" ).ojButton( "option", "menu" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "menu", ".my-marker-class" );
         */
        menu: null

        // Events
        
        /**
         * Triggered when the button is created.
         *
         * @event 
         * @name create
         * @memberof oj.ojButton
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Currently empty
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojButton({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
    },
    
    _create: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        // Add "form reset" handler to form (if any) that updates checked state of all buttons on form.
        // Register on the form once with a "static" button namespace, not once per button with each particular button's namespace, 
        // so handler doesn't get removed if this particular button is destroyed.
        this.element.closest( "form" )
            .unbind( "reset" + BUTTON_EVENT_NAMESPACE )
            .bind( "reset" + BUTTON_EVENT_NAMESPACE, function() {
                var form = $( this );
                setTimeout(function() {
                    var $buttons = form.find( ":oj-button" ).each(function() {
                        $( this ).data( "oj-ojButton" )._applyCheckedStateFromDom(false);
                    });
                    
                    // if last button in form has been destroyed or moved out, remove the handler
                    if (!$buttons.length)
                        form.unbind( "reset" + BUTTON_EVENT_NAMESPACE );
                }, 1 );
            } );
        
        // Sync up disabled option and disabled DOM property.
        // If app set the option to valid value (true/false), then that wins, else DOM wins (which always has a valid value).
        if ( typeof this.options.disabled !== "boolean" )
        {   // then app either didn't set the option from its initial value of null, or they set it 
            // to invalid value which we'll ignore, so set the option from the DOM.  Just set the ivar without calling _setOption()
            // here, since we call it below.
            // For anchors, this line always sets it to false.  (Neither JQUI nor JET look for the .oj-disabled class for anchors, 
            // so the only way to disable an anchor button at create time is via the API.  At refresh time, JQUI did look 
            // for the .oj-disabled class, but our refresh doesn't handle disabled.)
            this.options.disabled = !!this.element.prop( "disabled" );
        } // else the app definitely set the option to true or false, since default was null, so set app's value 
        // on the DOM.  No need to do that here, since we call _setOption("disabled"...) below, which sets the DOM property.
        
        // facilitate removing menuButton handlers separately, if app sets/clears the "menu" option
        this.menuEventNamespace = this.eventNamespace + "menu";
        
        this._initButtonTypes();
        this.hasTitle = !!this.rootElement.attr( "title" );

        var self = this,
            options = this.options,
            toggleButton = this._isToggle,
            activeClass = !toggleButton ? "oj-active" : "",
            focusClass = "oj-focus";

        this.rootElement.addClass( BASE_CLASSES );
        
        this.buttonElement
            .bind( "mouseenter" + this.eventNamespace, function() {
                if ( self._IsEffectivelyDisabled() )
                    return;
                if ( this === _lastActive ) 
                    self.rootElement.addClass( "oj-active" );

                self.rootElement.addClass( "oj-hover" )
                                .removeClass( "oj-default oj-focus-only" );
            })
            .bind( "mouseleave" + this.eventNamespace, function() {
                self.rootElement.removeClass( "oj-hover" );

                if ( self._IsEffectivelyDisabled() )
                    return;
                self.rootElement.removeClass( activeClass );
                self._toggleDefaultClasses();
            })
            .bind( "click" + this.eventNamespace, function( event ) {
                var effectivelyDisabled = self._IsEffectivelyDisabled();
                if ( /*self.type === "anchor" || */ effectivelyDisabled )
                {
                    // preventDefault for anchors to avoid adding # to URL and scrolling to top of page
                    // TODO: commenting out the anchor part pending conversation with architects.  Should 
                    // anchor-based buttons be like menu links, where apps handle via click handler, not href, 
                    // and we preventDefault to avoid URL pollution and scrolling?  Or is href-nav OK, in which 
                    // case it's up to app (and our demos) to preventDefault?
                    event.preventDefault();
                }
                if ( effectivelyDisabled )
                {
                    event.stopImmediatePropagation();
                }
            });

        this.element
            .attr( "role", "button" )
            .bind( "focus" + this.eventNamespace, function() {
                // no need to check disabled, focus won't be triggered anyway
                self.rootElement.addClass( focusClass );
                self._toggleDefaultClasses();
            })
            .bind( "blur" + this.eventNamespace, function() {
                self.rootElement.removeClass( focusClass );
                self._toggleDefaultClasses();
            });

        if ( toggleButton )
        {
            this.element.bind( "change" + this.eventNamespace, function( event ) {
                self._applyCheckedStateFromDom(true); // we just get one change event for entire radio group, even though up to 2 changed, so must refresh entire radio group, not just this button
                
                // if in a buttonset that tracks checked state (i.e. checkbox set or single 
                // radio group), then set that option and fire optionChange event
                var buttonset = $( this ).closest( ":oj-buttonset" ).data( "oj-ojButtonset" );
                var checkedState = buttonset && buttonset._getCheckedFromDom(buttonset.$buttons);
                if (buttonset && checkedState!==undefined)
                {
                    buttonset._optionChangeOriginalEvent = event;
                    
                    // only sets the option and fires optionChange, since _optionChangeOriginalEvent ivar is set
                    buttonset._setOption("checked", checkedState);
                }
            });
            
            // Required for FF, where click-drag on checkbox/radio btn's label(JET decorates label as button for toggle buttons ) 
            // will not yield in to click event and also trasfers focus out of the <input> element and hence breaks arrow navigation. 
            // To fix, If mouse moves between mouseDown/mouseUp (drag) with in the boundaries of button then focus should be set 
            // on the button which will ensure proper arrow key navigation(see bug 18477039 for more details).
            this.buttonElement
                .bind("mousedown" + this.eventNamespace, function(event) {
                    if (self._IsEffectivelyDisabled())
                        return;
                    _lastToggleActive = this;
                    self.document.one("mouseup", function() {
                        _lastToggleActive = null;
                    });
                })
                .bind("mouseup" + this.eventNamespace, function(event) {
                    if (self._IsEffectivelyDisabled())
                        return;
                    if (this === _lastToggleActive) {
                        self.element.focus();
                    }
                });
        }

        if ( this.type === "checkbox" )
        {
            this.buttonElement.bind( "click" + this.eventNamespace, function(event) {
                if ( self._IsEffectivelyDisabled() )
                    return false;
            });
            
            // role="button" requires both Space and Enter support, but radios and checkboxes natively support only Space, so add Enter.
            // This fire-click-on-Enter logic gives Enter the same behavior as Space for checkboxes in Chrome, FF, and IE9:
            // In Chrome28 and IE9, for Space and Enter on Checkboxes, first the "checked" value updates, then change event, then click event.
            // In FF22, for Space and Enter on Checkboxes, first the "checked" value updates, then click event, then change event.
            // Unlike the radio Enter handler, we get this good behavior by only firing "click".
            this.element.bind( "keyup" + this.eventNamespace, function(event) {
                if ( event.keyCode === $.ui.keyCode.ENTER ) {
                    if ( !self._IsEffectivelyDisabled() ) {
                        //console.log("checkbox Enter handler firing click event");
                        self.element.click();
                    }
                }
            });
        } else if ( this.type === "radio" )
        {
            this.buttonElement.bind( "click" + this.eventNamespace, function() {
                if ( self._IsEffectivelyDisabled() )
                {
                    return false;
                }
            });
            
            // role="button" requires both Space and Enter support, but radios and checkboxes natively support only Space, so add Enter.
            // For radios, this handler gives Enter in Chrome28/ IE9/ FF22 the same behavior as Space on Chrome.  Since Space in IE/FF is 
            // different than Space in Chrome, this means that Enter and Space are not quite the same within those browsers.
            // For Space and Enter on unchecked radios in Chrome28 and IE9:
            //   - first the "Checked" value updates, then change event, then click event.
            // For already-checked radios, where activation would just check it again:
            //   - Space and Enter in Chrome28, and Enter in IE9:  do nothing.
            //   - Space in IE9:  first the "Checked" value updates, then click event.  (No change event since nothing changed.)
            //     (This is the only Chrome/IE9 Space/Enter difference.)
            // In FF22:
            //   - Space on unchecked radios: first the "Checked" value updates, then click event, then change event.
            //   - Enter on unchecked radios is same as Chrome.  (Different event ordering than FF.)
            //   - Space on checked radios is like IE9: first the "Checked" value updates, then click event.  (No change event since nothing changed.)
            //   - Enter on checked radios is same as Chrome.  (Do-nothing.)
            this.element.bind( "keyup" + this.eventNamespace, function(event) {
                if ( event.keyCode === $.ui.keyCode.ENTER )
                {
                    if ( !self.element[0].checked && !self._IsEffectivelyDisabled() ) {
                        //console.log("radio Enter handler found radio unchecked, so checking it and firing click event");

                        // Unlike the checkbox Enter handler, we set checked=true and fire changed before firing click, without which 
                        // we didn't get the exact behavior described above.  Without setting checked, the click handlers in all 3 desktop
                        // browsers saw the "old" "checked" value when Enter was pressed on radios, which broke Buttonset's focus mgmt logic.
                        // If we set checked, then change no longer fires automatically, in at least some browsers, so we have to fire it 
                        // manually, both for apps that rely on it, and because our code relies on our change listener to update the "checked" styling.
                        self.element[0].checked = true;
                        self.element.change();
                        self.element.click();
                    }
                }
            });
        } else // neither checkbox nor radio, so not a toggle button, so element, buttonElement, and rootElement are all the same node
        {
            this.buttonElement
                .bind( "mousedown" + this.eventNamespace, function( event ) {
                    if ( self._IsEffectivelyDisabled() ) {
                        return false;
                    }
                    if ( event.which === 1 ) // don't show active/pressed-down state unless left mouse button, since only that button will click the button after mouseup
                    { 
                        $( this ).addClass( "oj-active" )
                                 .removeClass( "oj-default oj-focus-only" );
                        _lastActive = this;
                        self.document.one( "mouseup", function() { // TODO: prob need capture listener like Menu for reliability
                            _lastActive = null;
                        });
                    }
                })
                .bind( "mouseup" + this.eventNamespace, function() {
                    if ( self._IsEffectivelyDisabled() ) 
                        return false;
                    $( this ).removeClass( "oj-active" );
                    self._toggleDefaultClasses();
                })
                .bind( "keydown" + this.eventNamespace, function(event) {
                    if ( self._IsEffectivelyDisabled() ) 
                        return false;
                    var isSpace = event.keyCode === $.ui.keyCode.SPACE;
                    if ( self.type === "anchor" && isSpace ) {
                        event.preventDefault(); // prevent scrolling down one page when clicking anchor button via Spacebar.  Only prevent for anchor!
                    }
                    if ( isSpace || event.keyCode === $.ui.keyCode.ENTER ) {
                        $( this ).addClass( "oj-active" )
                                 .removeClass( "oj-default oj-focus-only" );
                    }
                })
                // see #8559, we bind to blur here in case the button element loses
                // focus between keydown and keyup, it would be left in an "active" state
                .bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                    $( this ).removeClass( "oj-active" );
                    self._toggleDefaultClasses();
                });

            if ( this.type === "anchor" ) 
            {
                //Chrome is not updating document.activeElement on click of <a> which is needed for ojPopup and 
                //setting tabIndex to a non-negative value will fix this. Refer bug 18744322 
                var tabIndex = this.buttonElement.attr( "tabindex" ); 
                if( tabIndex === 'undefined' || tabIndex === null || isNaN(tabIndex) ) // Don't override if user already set a tabIndex.
                {
                    this.buttonElement.attr( "tabindex", "0" ); 
                }   

                this.buttonElement.bind( "keyup" + this.eventNamespace, function(event) {
                    if ( event.keyCode === $.ui.keyCode.SPACE ) 
                    {
                        // JQUI's TODO: pass through original event correctly (just as 2nd argument doesn't work)
                        $( this ).click();
                    }
                });
            }
        } // end of: if (checkbox) {} else if (radio) {} else {} 
        
        this._setOption( "disabled", options.disabled );
        this._handleLabelAndIconsAtCreateTime();
        this._doEagerMenuButtonSetup();
        
        // call this at the *end* of _create, since it needs to know whether any state classes like oj-active, oj-disabled, oj-selected, oj-hover, .oj-focus 
        // have been applied.
        this._toggleDefaultClasses();

        this._super();
    },
   
    _initButtonTypes: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    { 
        var labelSelector, checked;

        // for toggle buttons (radio/checkbox), element is <input>, buttonElement is <label>,
        // and rootElement is a new wrapper element we create.
        if ( this.element.is("input[type=checkbox]") ) {
            this.type = "checkbox";
            this._isToggle = true;
        } else if ( this.element.is("input[type=radio]") ) {
            this.type = "radio";
            this._isToggle = true;
        }
        
        // for push buttons (next 3 cases), element, buttonElement, and rootElement are all the same elem.  We ignore <label> if present.
        else if ( this.element.is("input[type=button],input[type=submit],input[type=reset]") )
            this.type = "inputPush";
        else if ( this.element.is("button"))
            this.type = "button";
        else if ( this.element.is("a")) 
            this.type = "anchor";
        else 
            throw new Error("JET Button not supported on this element type");

        if ( this._isToggle ) 
        {
            // TBD: rather than requiring the label to be supplied, should we just create one for them if it's not there?
            labelSelector = "label[for='" + this.element.attr("id") + "']";
            this.buttonElement = this.element.siblings().filter( labelSelector ).addClass( "oj-button-label" );
             
            this.element
                .addClass( "oj-helper-hidden-accessible" )
                .add(this.buttonElement) // doesn't mutate this.element
                .wrapAll("<span></span>"); // add root node around label/input

            this.rootElement = this.element.parent(); // the new root
            
            checked = this.element[0].checked;
            if ( checked ) {
                this.rootElement.addClass( "oj-selected" )
                                .removeClass( "oj-default oj-focus-only" );
            }
            // else no need to removeClass since this code runs only at _create time
            
            // must be set for toggle buttons even if false, since presence of this attr conveys to AT's 
            // whether it's a toggle button or push button.
            this.element.attr( "aria-pressed", checked );
        } else 
        {
            this.buttonElement = this.element;
            this.rootElement = this.element;
        }
    },

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the element visually representing the button.  For checkboxes and radios, this is the label, not the input.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose
     * @memberof oj.ojButton
     * @instance
     * @return {jQuery} the button
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojButton( "widget" );
     */
    widget: function() // Override of public base class method.  Method name needn't be quoted since is in externs.js.
    { 
        return this.rootElement;
    },
    
    _destroy: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this._removeMenuBehavior();
        
        // TBD: won't need this after the restore-attrs feature is in place.
        this.element
            .removeClass( "oj-helper-hidden-accessible" )
            .removeAttr( "role" )
            .removeAttr( "aria-pressed" );
        
        var isToggle = this._isToggle;
        
        // TBD: won't need this after the restore-attrs feature is in place.
        if ( !isToggle ) 
            this.rootElement.removeClass( BASE_CLASSES + " " + STATE_CLASSES + " " + TYPE_CLASSES );
        
        this.buttonElement.html( this.buttonElement.find(".oj-button-text").html() );
        
        if ( !isToggle )
        {
            // TBD: won't need this after the restore-attrs feature is in place.
            if ( !this.hasTitle )
                this.rootElement.removeAttr( "title" );
        } else 
        {
            this.buttonElement.removeClass( "oj-button-label" ); // TBD: won't need this after the restore-attrs feature is in place.
            
            // Bug 18721589: If the button is stamped out by a KO foreach (with or without a containing buttonset), and the foreach 
            // observable is updated to no longer include the button, then _destroy() is called.  Due to the ordering of tasks, if 
            // unwrap() is called directly, the nodes winds up back into the DOM.  To avoid this, we use setTimeout(0).  Per 
            // architect request, we don't call unwrap() if the wrapper has no parent, as in this KO case, to avoid uncertainty as 
            // to what unwrap would do.  (In case this ever causes a problem for apps intentionally destroying a disconnected button, 
            // note that in practice it doesn't seem to cause problems to unwrap in that case.)
            var self = this;
            setTimeout(function() {
                if (self.rootElement.parent().length) {
                    self.element.unwrap(); // remove rootElement
                }
            }, 0 );
        }

        if( _lastToggleActive === this.buttonElement[0] )
        {
            _lastToggleActive = null; //clear _lastToggleActive flag, while destroying the button.
        }
    },
    
    // TODO: what was the resolution of this framework issue?  Is _NotifyDetached even being called?  Should this code disappear or change?
    // In browsers [Chrome v35, Firefox v24.5, IE9, Safari v6.1.4], blur and mouseleave events are generated for hidden content but not detached content, 
    // so for detached content only, we must use this hook to remove the focus and hover classes.  
    _NotifyDetached: function() {
        //Remove focus/hover/active style classes when button element got detached from document. 
        //This ensures that button is displayed without hover/focus state when it is re-attached to DOM. Refer bug 18819266.
        this.rootElement.removeClass("oj-active oj-hover oj-focus");
        this._toggleDefaultClasses();
    },

    __setAncestorComponentDisabled: function( disabled )
    {
        this._super( disabled ); // sets this._ancestorDisabled
        this._updateEffectivelyDisabled();
    },

    // Prereq:  this.options.disabled and this._ancestorDisabled must already be set to their updated values before calling this method.
    // 
    // When called by __setAncestorComponentDisabled(), it has already set this._ancestorDisabled.
    // 
    // When called by _setOption("disabled"), its _super() has already done the following things:
    // - Set this.options.disabled.
    // - Applied .oj-disabled and aria-disabled to rootElement, often incorrectly per comments below.  The below code fixes it up.  The _super() code has tbd to fix this.
    // - If option is being set to true, it's removed .oj-hover/focus/active from associated "-ables".  (The first 2 of 3 are relevant to button.)
    _updateEffectivelyDisabled: function()
    {
        var effectivelyDisabled = this._IsEffectivelyDisabled();

        // Unlike JQUI, root element should have exactly one of .oj-enabled and .oj-disabled at any point in time, for all flavors of Button.
        // _setOption._super() sets .oj-disabled to potentially wrong value since it doesn't know about "effectively disabled".  This fixes it up.  
        this.rootElement.toggleClass( "oj-disabled", effectivelyDisabled );
        this.rootElement.toggleClass( "oj-enabled", !effectivelyDisabled ); // _setOption._super() doesn't try to set this

        if (this.type !== "anchor") // i.e. <button> or <input> (including type=radio|checkbox|other)
        {
            // <button> and <input> (including type=radio|checkbox|other) have this property, but <a> doesn't
            this.element.prop( "disabled", effectivelyDisabled ); // JQUI's _setOption sets this for <a>'s too, which seems harmless but is incorrect.

            // _setOption._super() puts aria-disabled on the rootElement.  Per A11y team, don't put aria-disabled on element already having disabled 
            // attr.  (And if we DID apply aria-disabled, for radios/checkboxes it should go on the element / input, not the buttonElement / label or rootElement, 
            // so the _setOption._super() behavior used by JQUI button is doubly wrong.)  Further, _setOption._super() can set it wrong since it doesn't know 
            // about "effectively disabled".  This fixes it up.
            this.rootElement.removeAttr( "aria-disabled" );
        } else { // else is <a>
            // Unlike radios/checkboxes, _setOption._super() puts aria-disabled on the correct element for <a>'s since element and rootElement are both the <a>.
            // However, it sets it to potentially wrong value since it doesn't know about "effectively disabled".  This fixes it up.
            this.rootElement.attr( "aria-disabled", effectivelyDisabled );
        }

        if (effectivelyDisabled)
        {
            // TBD: when the handling of oj-active in baseComponent._setOption("disabled") is finalized, review whether this should be handled there instead.
            
            this.widget().removeClass("oj-active oj-default oj-focus-only oj-hover oj-focus");
            _lastActive = null; // avoid (very slight) possibility that first mouseIn after button is subsequently re-enabled will set oj-active

            // when disabling a menu button, dismiss the menu if open
            this._dismissMenu();
        }
        else
        {
            this._toggleDefaultClasses();
        }
    },

    _setOption: function( key, value, flags ) // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this._super( key, value, flags );
        
        switch (key) 
        {
            case "disabled":
                // must call this *after* _super() so it can fix the wrong things that _super() does, as discussed in callee
                this._updateEffectivelyDisabled();
                break;
            case "label":
                this._setLabelOption();
                break;
            case "display":
                if ( this.type !== "inputPush" ) // <input type=button|submit|reset> doesn't support child nodes, thus no icons, icon-only buttons, etc.
                    this._setDisplayOptionOnDom();
                break;
            case "icons":
                this._setIconsOption(true);
                break;
            case "menu": // setting/clearing the menu sets whether this is a menuButton
                this._doEagerMenuButtonSetup();
                break;
        }
    },
    
    /**
     * Refreshes the button. JET components require a <code class="prettyprint">refresh()</code> after a supported DOM change is made 
     * that affects the component, of which the component would otherwise be unaware.  In particular, if the Button is reparented from 
     * inside a Buttonset to a location that's not in a Buttonset, then <code class="prettyprint">refresh()</code> must be called.
     * 
     * <p>Note that anything having a JS API, such as the Button's label, disabled state, and checked state, must be set via the API, not 
     * by mutating the DOM and calling <code class="prettyprint">refresh()</code>.  (For the checked state, see Buttonset's 
     * <code class="prettyprint">checked</code> option.)  
     * 
     * @expose 
     * @memberof oj.ojButton
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojButton( "refresh" );
     */
    refresh: function() // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
    {
        this._super();
        
        // TODO:
        // - There are other things we should do in the "no longer in buttonset" case, like removing buttonset listeners.  Anything else too?
        // - The reason the jsdoc doesn't mention the "moved into Buttonset (possibly from another buttonset)" case is that in that case 
        //   Bset.refresh() must be called.  However, not sure that it's doing all the necessary things for the "from another Bset" case.
        
        // Handle the case where we just got reparented out of a disabled Buttonset
        if ( this._ancestorDisabled && !$( this ).closest( ":oj-buttonset" ).length )
            this.__setAncestorComponentDisabled(false);
    },
    
    // If this button is radio/checkbox, then this method gets the checked state from DOM's 
    // "checked" prop and toggles oj-selected and aria-pressed accordingly.
    // If wholeGroup param is true, and this button is a radio, then do that for all buttons in the group.
    _applyCheckedStateFromDom: function(wholeGroup) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if ( this.type === "radio" ) 
        {
            (wholeGroup ? _radioGroup( this.element[0] ) : this.element ).each(function() {
                var $radioWidget = $( this ).data( "oj-ojButton" ); // definitely exists because _radioGroup() checks for :oj-button 
                
                if ( this.checked )
                {
                    $radioWidget.rootElement.addClass( "oj-selected" )
                                            .removeClass( "oj-default oj-focus-only" );
                    $radioWidget.element.attr( "aria-pressed", "true" );
                } else 
                {
                    $radioWidget.rootElement.removeClass( "oj-selected" );
                    $radioWidget._toggleDefaultClasses();
                    $radioWidget.element.attr( "aria-pressed", "false" );
                }
            });
        } else if ( this.type === "checkbox" ) 
        {
            if ( this.element[0].checked ) 
            {
                this.rootElement.addClass( "oj-selected" )
                                .removeClass( "oj-default oj-focus-only" );
                this.element.attr( "aria-pressed", "true" );
            } else 
            {
                this.rootElement.removeClass( "oj-selected" );
                this._toggleDefaultClasses();
                this.element.attr( "aria-pressed", "false" );
            }
        }
    },
    
    /* 
     * Method name sums it up.  Should only be called at create time.
     */
    _handleLabelAndIconsAtCreateTime: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var keepDom = false;
        if ( this.options.label === null ) {
            keepDom = true;
            this.options.label = (this.type === "inputPush" ? this.buttonElement.val() : this.buttonElement.html());
        }
        
        if ( this.type === "inputPush" ) { // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
            this._setLabelOnDomOfSpanlessButton();
        } else { // <button>, <a>, checkboxes, and radios
            var textSpan = this._setLabelOnDomAtCreateTime(keepDom);
            
            if (this.options.icons.end === undefined) // if app didn't set it, then default as follows
                this.options.icons.end = this.options.menu ? "oj-component-icon oj-button-menu-dropdown-icon" : null;
            var hasStartIcon = this._setIconOnDom(true);
            var hasEndIcon = this._setIconOnDom(false);
            
            this._setDisplayOptionOnDom(textSpan, hasStartIcon, hasEndIcon);
        }
    },
    
    /*
     * Replace the button contents with a span containing the label:
     * - If app didn't set the label option, then reparent their DOM label to the new span.
     * - If app set the label option, then set escaped version onto label span.
     * Either way, button contents are completely replaced with the new span.
     * 
     * Should only be called at create time.
     * 
     * return the new textSpan
     */
    _setLabelOnDomAtCreateTime: function(keepDom) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var buttonElement = this.buttonElement;
        var textSpan = $( "<span class='oj-button-text'></span>", this.document[0] );
        
        if (keepDom) {
            textSpan.append(buttonElement.contents());
        } else { 
            buttonElement.empty();
            textSpan.text(this.options.label); // performs escaping; e.g. if label is <a>foo</a>, then text() replaces the span's contents with a text node containing that literal string (rather than setting innerHtml).
        }
        
        buttonElement.append(textSpan);
        return textSpan;
    },
    
    /*
     * Following is an old TBD from before the refactoring.  Now that we've sharply reduced the amount of unnecessary DOM replacement when 
     * options like label and icons are set, is this still an issue?  If so, can we further minimize the churn to fix it?
     * TBD: Per http://www.quirksmode.org/blog/archives/2007/01/a_note_about_ev.html, if a click handler blows away the thing that was 
     * clicked, it stops the click event from bubbling any further.  For antonym buttons like Play/Pause where the app puts a click handler
     * on the button that toggles its label and/or icons, this method replaces the clicked element, e.g. a <span> inside the <button>, 
     * stopping the bubble. [UPDATE: we keep the span now but change its contents.  Does that fix it?].  This makes bubbling brittle.  
     * Consider improving and/or doc'ing the issue.
     */
    
    /*
     * This method takes care of everything that needs to happen when the "label" option is set *after* create time.
     */
    _setLabelOption: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if ( this.type === "inputPush" ) { // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
            this._setLabelOnDomOfSpanlessButton();
        } else {
            var textSpan = this.buttonElement.find( '.oj-button-text' );
            textSpan.text(this.options.label); // performs escaping; e.g. if label is <a>foo</a>, then text() replaces the span's contents with a text node containing that literal string (rather than setting innerHtml).
            this._setDisplayOptionOnDom(textSpan);
        }
    },
    
    /*
     * This method should only be called when the button is a "spanless" button, i.e. <input type=button|submit|reset>. It is called when the label is set, 
     * both at create time and when it is set later.  
     */
    _setLabelOnDomOfSpanlessButton: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        // TBD: The "if label" check is from JQUI.  Is there some reason that setting "" should be ignored?
        // Probably not too harmful since they should set "display" option to "icons" instead, or set " " if they really want to.
        if ( this.options.label )
            this.element.val( this.options.label ); // escaping is automatic; e.g. if label is <span>foo</span>, then val() sets that literal string on the input's "value" attr.
    },
    
    _setIconsOption: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if ( this.type === "inputPush" ) // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
            return;
        
        var hasStartIcon = this._setIconOnDom(true);
        var hasEndIcon = this._setIconOnDom(false);
        this._setDisplayOptionOnDom(undefined, hasStartIcon, hasEndIcon);
    },
    
    /*
     * This method sets either the start or end icon on the DOM, depending on the param, adding or removing the 
     * icon span as needed.  It is called both at create time and when the icon changes later.
     * 
     * param isStart boolean, whether is start or end icon
     * return boolean indicating whether an icon was set on DOM
     */
    _setIconOnDom: function(isStart) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (isStart) {
            var iconSpanSelector = '.oj-button-icon.oj-start';
            var standardIconClasses = 'oj-button-icon oj-start';
            var appIconClass = this.options.icons.start;
            var lastIvar = "_lastStartIcon";
            var pendTo = "prependTo";
        } else {
            iconSpanSelector = '.oj-button-icon.oj-end';
            standardIconClasses = 'oj-button-icon oj-end';
            appIconClass = this.options.icons.end;
            lastIvar = "_lastEndIcon";
            pendTo = "appendTo";
        }
        
        var iconSpan = this.buttonElement.find( iconSpanSelector );
        
        if ( appIconClass ) {
            if ( iconSpan.length ) {
                // remove the app icon class we set last time
                var oldAppIconClass = this[lastIvar];
                iconSpan.removeClass(oldAppIconClass);
            } else {
                iconSpan = $( "<span></span>" )
                    .addClass( standardIconClasses )
                    [pendTo]( this.buttonElement );
            }
            iconSpan.addClass( appIconClass );
        } else {
            iconSpan.remove();
        }
        
        // remember the app icon class we set, so we can remove it next time
        this[lastIvar] = appIconClass;
        
        return !!appIconClass;
    },
    
    /*
     * Hides / shows the label, and adds / removes the rootElement tooltip, depending on whether 
     * display is "icons" (and whether there are in fact icons).  Doesn't add/remove the 
     * tooltip if app provided one initially.
     * 
     * Sets the corresponding root style class, e.g. "oj-button-text-only" or "oj-button-text-icon-start".
     * 
     * Note: if rootAttributes ever supports "title", then need to call this *after* _SetRootAttributes so 
     * app has a chance to set their own tooltip for checkbox/radio.  
     * 
     * Must be called when display, icons, or label options are set.
     * (If icons.end ever supports "auto" and is set to "auto", then must be called when menu option is set.)
     * 
     * Caller must check that it's not a spanless button before calling this method.
     * 
     * All params optional.
     */
    _setDisplayOptionOnDom: function(textSpan, hasStartIcon, hasEndIcon) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (textSpan === undefined)
            textSpan = this.buttonElement.find( '.oj-button-text' );
        if (hasStartIcon === undefined)
            hasStartIcon = !!this.options.icons.start;
        if (hasEndIcon === undefined)
            hasEndIcon = !!this.options.icons.end;
        
        var multipleIcons = hasStartIcon && hasEndIcon;
        var atLeastOneIcon = hasStartIcon || hasEndIcon;
        var displayIsIcons = this.options.display === "icons";
        
        if ( atLeastOneIcon && displayIsIcons )
        {
            textSpan.addClass( "oj-helper-hidden-accessible" );
            
            if ( !this.hasTitle )
            {
                var buttonText = /** @type {string}  tell GCC is getter, not setter, overload of text() */
                                 (textSpan.text());
                this.rootElement.attr( "title", $.trim( buttonText ) ); // use buttonText, which is escaped, not options.label, which isn't!
            }
        } else
        {
            textSpan.removeClass( "oj-helper-hidden-accessible" );
            
            if ( !this.hasTitle )
                this.rootElement.removeAttr( "title" );
        }
        
        var buttonClass = 
            !atLeastOneIcon
                ? "oj-button-text-only"
                : displayIsIcons
                    ? multipleIcons ? "oj-button-icons-only" : "oj-button-icon-only"
                    : multipleIcons 
                        ? "oj-button-text-icons"
                        : hasStartIcon
                            ? "oj-button-text-icon-start" 
                            : "oj-button-text-icon-end";
        
        this.rootElement.removeClass( TYPE_CLASSES )
                        .addClass( buttonClass );
    },
    
    /*
     * Call this method at create time and whenever the "menu" option is set by the app.  
     * 
     * - This method first removes menuButton stuff from the element and from any Menu previously set on this Button.
     * - Then, if the Button's "menu" option is set, this it sets the needed listeners on the button.  
     * 
     * We don't set listeners on the menu until _doLazyMenuButtonSetup is called on the first launch, 
     * so that the menu needn't be inited before the button.  
     */
    _doEagerMenuButtonSetup: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if ( this.options.menu && this.element.is("input")) // both push and toggle buttons based on <input>
            throw new Error("Menu Button functionality is not supported on input elements.");
        
        this._removeMenuBehavior();
        
        if ( this.options.menu ) 
        {
            var self = this;
            this.element
                .attr("aria-haspopup", true)
                .on( "keydown" + this.menuEventNamespace, function( event ) { 
                    if (event.which === $.ui.keyCode.DOWN) 
                    {
                        self._showMenu(event, "firstItem");
                        event.preventDefault();
                        return true;
                    } else if (event.which === $.ui.keyCode.ESCAPE)
                    {
                        self._dismissMenu(event);
                        return false;
                    }

                    return true;
                })
                .on( "click" + this.menuEventNamespace, function( event ) {
                    //console.log("mb click handler");
                    var menu = self._getMenu();
                    if (!menu.__spaceEnterDownInMenu)
                    {
                        // console.log("mb click handler showing menu");
                        // Ideally a click (Enter/Space) would toggle (open/close) the menu without moving focus to it, per WAI-ARIA.  
                        // But on IE, JAWS is not recognizing the menu on click/Enter/Space.
                        // Workaround for this, cleared with A11y team, is to move focus to menu like DownArrow. Ref bug 19022228. 
                        self._showMenu(event, "firstItem");
                    }
                    menu.__spaceEnterDownInMenu = false;
                    event.preventDefault();
                    return true;
                });
        }
    },
    
    /* 
     * This method sets the needed listeners on the menu.  
     * 
     * Wait until the first launch of the menuButton's menu to call this method, so that the menu needn't be inited before the button.  
     * 
     * param: menu required non-null
     */
    _doLazyMenuButtonSetup: function(menu) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        this._menu = menu;
        
        var self = this;
        menu.widget()
            .on( "oj__dismiss" + this.menuEventNamespace, function( event, ui ) {
                //console.log(self.options.label + ": mb dismiss handler");
                self._menuDismissHandler(event);
            })
            .on( "ojbeforeopen" + this.menuEventNamespace, function( event, ui ) {
                //console.log(self.options.label + ": mb beforeopen handler");

                // if something else launches the same menu (including the case where it's our own *context* menu),
                // then the *menuButton* menu is no longer showing, so unpress the button.
                if (!self._launchingMenu)
                {
                    //console.log(self.options.label + ": mb beforeopen handler calling dismiss handler");
                    self._menuDismissHandler(event);
                }
                self._launchingMenu = false;
            });
    },
    
    /*
     * This method removes menuButton functionality from the element
     */
    _removeMenuBehavior: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.element
            .removeAttr( "aria-haspopup" )
            .off( this.menuEventNamespace );
    
        this._dismissMenu();
        this._menu && this._menu.widget().off( this.menuEventNamespace );
        this._menu = undefined;
    },
    
    /* 
     * Do not call this method at create time, since it logs if the Menu is not already inited, since we want it to be OK to init the Button first.
     * Instead, call when menu is launched, by which time the menu should be inited.
     * 
     * Lazily gets and returns the menu instance pointed to by the "menu" option, or undefined if no Menu found.  The latter happens when:
     * - "menu" is not set. (OK)
     * - the selector specified in "menu" doesn't find an element.  (Log.)
     * - it finds an element that is not (yet) a JET Menu.  (Log.)
     * 
     * (Do NOT return null just because button is disabled, since that would mean disabled menuButtons lose their dropdown arrow, and possibly other problems.)
     */
    _getMenu: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var menu = this._menu;
        
        if (!menu) {
            // TODO: I should have moved all this code into _dLMBS(), and had that method return the menu to this method...
            
            // if selector finds >1 element, .data() uses the first one, and returns undefined iff it's not a JET Menu.
            // if selector finds 0 elements, .data() returns undefined.
            menu = $(this.options.menu).data( "oj-ojMenu" ); 

            if (menu) {
                this._doLazyMenuButtonSetup(menu); // sets this._menu and applies listeners to menu
            } else if (this.options.menu) {
                oj.Logger.warn('JET Button: "menu" option specified, but does not reference a valid JET Menu.');
            } // else menu option isn't set, in which case this method probably wouldn't be called
        }
        
        return menu;
    },
    
    /*
     * Shows the menuButton menu if there is one and we're not disabled.
     * 
     * MenuButton types:
     * - We support menuButtons on push buttons based on <button> and <a>.
     *     - Architects require that we support menuButtons on at least some types of push buttons.
     *       I.e. if checkbox-based menuButtons were supported, it would not be OK for that to be the only type that's supported.
     * - <input type=button|submit|reset> work fine using the same code path as <button> and <a>, but architects approved proposal 
     *   not to support them for following reasons:
     *     - submit/reset menubuttons are semantically / behaviorally absurd.
     *     - these types don't support icons, i.e. the dropdown icon.
     *     - reduces exposure to issues like we had for checkboxes, without sacrificing anything since these flavors were undesirable
     *       for menuButton use anyway.
     *  - Radios are inappropriate for menuButtons.  Alternate clicks should open and close the menu, with corresponding visual 
     *    feedback from button, but radios are idempotent: they stay pressed on repeated clicks.
     *  - Architects approved proposal not to support checkboxes for following reasons:  
     *      - Checkbox-based menuButtons were considered a bit odd, and we had zero requirements for it.
     *      - The only thing they buy anyone is the checked state corresponding to the menu-open state, but there are several ways for 
     *        apps to find out if the menu is open, e.g. check its "hidden" status, check whether the oj-selected class is present, etc.
     *      - They proved to be somewhat brittle, with *different* event-ordering problems in each browser.  Even if we spent the time 
     *        to fix it, they could still be a source of problems later, which didn't seem worth it for a flavor no one wanted.
     * 
     * param event required
     * param focus required
     */
    _showMenu: function(event, focus) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (this._IsEffectivelyDisabled()) 
            return;
        
        var menu = this._getMenu();
        
        // don't strictly need this null-check, since this method is only called if app set the "menu" option, in which case
        // it is app error if no menu is found
        if (menu) 
        {
            // Per UX requirements, menuButtons should look pressed/checked iff the menu is open:
            // - For push buttons, per architectural review, just add/remove oj-selected even though it's a push button.
            //     - Per a11y review, that's fine, but do NOT apply aria-pressed to push buttons, which would turn it into a toggle button for AT users.  He said that 
            //       would just confuse things, and that the visual pressed-in look was just eye candy in this case, not semantics that we need to show to AT users. 
            // - If checkbox menuButtons were supported, obviously we'd toggle the pressed look by checking/unchecking the button, which in turn would toggle oj-selected.
            //   In that case, we'd fire DOM checked event (right?) and if wrapped in Buttonset, update its checked option and fire optionChange event.
            this.rootElement.addClass( "oj-selected" )
                            .removeClass( "oj-default oj-focus-only" );
            
            // No need to fire click event, since not appropriate for DownArrow, and already fired for user click.
            
            this._launchingMenu = true;
            menu.open(event, {"launcher": this.element, "initialFocus": focus});
            this._menuVisible = true;
        }
    },
    
    /*
     * Dismisses the menuButton menu if there is one, and if either we're not disabled or force is true
     * 
     * param event optional
     * param menu optional. pass it if already have it
     */
    _dismissMenu: function(event) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        // this._menuVisible is set iff *we* launched the menu.  If *something else* launched it, don't dismiss it.
        if (this._menuVisible) // then this._menu is non-null
        {
            this._menu.__collapseAll( event, true ); //Close open menus before hiding the popup so that submenus will not be shown on reopen.
            this._menu.__dismiss(event); // causes _menuDismissHandler to be called
        }    
    },
    
    /*
     * Handles menu dismissals, whether or not we dismissed it ourselves.  
     * See comments on similar code in _showMenu().
     * 
     * Also called by the beforeOpen listener we put on the menu, *if* the launch was by something else, 
     * including our own context menu.  So if something steals our menu, we uncheck the button.
     * 
     * param event must remain optional, since some callers of _dismissMenu have no event
     */
    _menuDismissHandler: function(event) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        //console.log(this.options.label + ": button._menuDismissHandler called");
        if ( this.type === "button" || this.type === "anchor" ) { // <button>, <a>
            // then only reason for .oj-selected to be present is if it's an open menu button, 
            // in which case remove the class since the menu is being dismissed
            this.rootElement.removeClass( "oj-selected" );
            this._toggleDefaultClasses();
        }
        // else it's not a menu button.  Probably never called in that case, but if it is, there's no need to 
        // clear oj-selected.  If this is a toggle button, doing so w/b harmful.

        
        this._menuVisible = false;
    },
    
    /*
     * Let the "state classes" be oj-active, oj-disabled, oj-selected, oj-hover, and oj-focus. 
     * This method ensures that the root element has:
     *   - the oj-default class iff it has none of the state classes, and 
     *   - the oj-focus-only class iff it has oj-focus but no other state classes.
     */
    _toggleDefaultClasses: function()
    {
        var otherStates = this.rootElement.is( ".oj-hover, .oj-active, .oj-selected, .oj-disabled" );
        var defaultState, focusedOnly;
        
        if (otherStates) {
            defaultState = false;
            focusedOnly = false;
        } else {
            var focused = this.rootElement.is( ".oj-focus" );
            defaultState = !focused;
            focusedOnly = focused;
        }

        this.rootElement.toggleClass( "oj-default", defaultState );
        this.rootElement.toggleClass( "oj-focus-only", focusedOnly );
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Removes the button functionality completely. This will return the element back to its pre-init state.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojButton#destroy
     * @memberof oj.ojButton
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojButton( "destroy" );
     */
});

/**
 * @class
 * @name oj.ojButtonset
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="buttonsetOverview-section">
 *   JET Buttonset Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant visual and semantic grouping container for [JET Buttons]{@link oj.ojButton}.
 * 
 * <p>The JET Buttonset component can be used to group related buttons, such as a group of radios or checkboxes.  Buttonset provides
 * visual and semantic grouping and WAI-ARIA-compliant focus management.
 * 
 * <p>When a Buttonset is created or refreshed, it creates JET Buttons out of all contained DOM elements supported by JET Button 
 * that are not already Buttons, by calling <code class="prettyprint">.ojButton()</code> on them.
 * 
 * <p>A buttonset that contains radios should contain all radios in the radio group.  Checkboxes and radios in the buttonset should specify the 
 * <code class="prettyprint">value</code> attribute, since the <code class="prettyprint">checked</code> option refers to that attribute.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>JET Buttonset is a single tabstop, with arrow-key navigation within the buttonset, as follows:
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td>Navigates to the next enabled button, wrapping around at the end.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td>Navigates to the previous enabled button, wrapping around at the end.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <p>See also the [JET Button]{@link oj.ojButton} keyboard doc, for details on interacting with 
 * the individual buttons.
 * 
 * 
 * <h3 id="keyboard-appdev-section">
 *   Keyboard Application Developer Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-appdev-section"></a>
 * </h3>
 * 
 * <p>The application should not do anything to interfere with the Buttonset's focus management, such as setting the <code class="prettyprint">tabindex</code> 
 * of the buttons.  Also, enabled buttons should remain user-visible, without which arrow-key navigation to the button would cause the focus to seemingly disappear.
 * 
 * <p>The buttonset's focus management should be turned off when placing the buttonset in a [JET Toolbar]{@link oj.ojToolbar}.  See the <code class="prettyprint">focusManagement</code> option.
 * In this case, the "Keyboard End User Information" documented above is superseded by the Toolbar's documented keyboard behavior.
 * 
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>As shown in the online demos, the application is responsible for applying <code class="prettyprint">aria-label</code> and/or 
 * <code class="prettyprint">aria-controls</code> attributes like the following to the buttonset element, if applicable per the instructions that follow:
 * 
 * <pre class="prettyprint">
 * <code>aria-label="Choose only one beverage."
 * aria-controls="myTextEditor"
 * </code></pre>
 * 
 * <p>The <code class="prettyprint">aria-label</code> attribute is appropriate for a buttonset consisting of a radio group, in order to convey the "select one" semantics 
 * to AT users.  It should be omitted for checkboxes and push buttons.
 * 
 * <p>The <code class="prettyprint">aria-controls</code> attribute is appropriate if the buttonset is controlling something else on the page, e.g. 
 * bold / italic / underline buttons controlling a rich text editor.  
 *
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio, 
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>, 
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which 
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user 
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio 
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the 
 * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
 * is changed post-create, the buttonset must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded. 
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-buttonset</code> pseudo-selector can be used in jQuery expressions to select JET Buttonsets.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-buttonset" ) // selects all JET Buttonsets on the page
 * $myEventTarget.closest( ":oj-buttonset" ) // selects the closest ancestor that is a JET Buttonset
 * </code></pre>
 * 
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <p>For components like Buttonset and Menu that contain a number of like items, applications may wish to use a <code class="prettyprint">foreach</code> Knockout binding 
 * to stamp out the contents.  This binding cannot live on the same node as the JET <code class="prettyprint">ojComponent</code> binding, and must instead live on a nested 
 * virtual element as follows:
 * 
 * <pre class="prettyprint">
 * <code>&lt;div id="drinkset" aria-label="Choose only one beverage."
 *      data-bind="ojComponent: {component: 'ojButtonset', checked: drink}">
 *     &lt;!-- ko foreach: drinkRadios -->
 *         &lt;label data-bind="attr: {for: id}">&lt;/label>
 *         &lt;input type="radio" name="beverage"
 *                data-bind="value: id, attr: {id: id}, 
 *                           ojComponent: { component: 'ojButton', label: label }"/>
 *     &lt;!-- /ko -->
 * &lt;/div>
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 *   <li>JQUI Buttonset has an undocumented <code class="prettyprint">items</code> option allowing apps to get and set the selector used by Buttonset to find all its 
 *       buttonizable descendants.  This option has been removed in JET, as we do not want this to be settable.</li>
 *   <li>The focus management functionality is new in JET.</li>
 *   <li>JET Buttonset's [disabled]{@link oj.ojButtonset#disabled} option effectively disables its Buttons without affecting their <code class="prettyprint">disabled</code> 
 *       options.</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "buttonset" or "menu".  
 * E.g. the JQUI <code class="prettyprint">buttonsetcreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Buttonsets (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-buttonset", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Buttonset.  If called after the buttonset is already created, is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the buttonset with no options specified:</caption>
 * $( ".selector" ).ojButtonset();
 * 
 * @example <caption>Initialize the buttonset with some options and callbacks specified:</caption>
 * $( ".selector" ).ojButtonset( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the buttonset via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="beverages" data-bind="ojComponent: { component: 'ojButtonset', 
 *                                               disabled: true, 
 *                                               create: setupButtonset }">
 */
oj.__registerWidget("oj.ojButtonset", $['oj']['baseComponent'], 
{
    // private.  Was an undocumented JQUI option, which we removed, so I moved from options to here and added underscore.  Leave unquoted so gets renamed by GCC as desired.
    _items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a",
    
    widgetEventPrefix : "oj", 

    options: // options is in externs.js.  TODO: same as other prototype fields.
    {
        /**
         * The <code class="prettyprint">checked</code> option indicates which radio or checkboxes in the Buttonset are selected.
         * It corresponds to the <code class="prettyprint">value</code> attribute of those elements, which should always be set.
         * 
         * <p>If this Buttonset consists of a single radio group, and no other buttons, then <code class="prettyprint">checked</code> 
         * is a string equal to the <code class="prettyprint">value</code> attribute of the checked radio.  The option is 
         * <code class="prettyprint">null</code> if and only if no radio is selected.  Thus, an n-radio group has n+1 valid 
         * <code class="prettyprint">checked</code> values: the n radio values, and <code class="prettyprint">null</code> .
         * 
         * <p>If this Buttonset consists of one or more checkboxes, and no other buttons, then <code class="prettyprint">checked</code> is 
         * a possibly empty, non-<code class="prettyprint">null</code> string array containing the <code class="prettyprint">value</code> 
         * attributes of the checked checkboxes.  This array has "set", not "list", semantics; i.e. order is neither important nor guaranteed.
         * Thus, an n-checkbox set has 2^n valid <code class="prettyprint">checked</code> values: the 2^n possible subsets of n checkboxes.
         * 
         * <p>In all other cases, <code class="prettyprint">checked</code> is <code class="prettyprint">null</code>.
         * 
         * <p>After create time, the <code class="prettyprint">checked</code> state should be set via this API, not by setting the underlying DOM attribute.  
         * 
         * <p>The 2-way <code class="prettyprint">checked</code> binding offered by the <code class="prettyprint">ojComponent</code> binding 
         * should be used instead of Knockout's built-in <code class="prettyprint">checked</code> or <code class="prettyprint">attr</code> bindings,
         * as the former sets the API, while the latter two set the underlying DOM attribute.
         * 
         * <p>It's still possible for the <code class="prettyprint">checked</code> option and DOM to get out of synch by other means, e.g. if set of Buttons 
         * contained in the Buttonset changes, possibly due to a Knockout binding.  In this case, the app is responsible for updating the 
         * <code class="prettyprint">checked</code> option. 
         * 
         * <p>An <code class="prettyprint">optionChange</code> event is fired whenever this option changes, whether due to user interaction 
         * or programmatic intervention.  If the value is the same as the previous value (using order-independent "set" equality for 
         * checkboxes), no event will be fired.
         * 
         * <p>Often there is no need to listen for this event, since the <code class="prettyprint">ojComponent</code> 
         * <code class="prettyprint">checked</code> binding, discussed above, will update the bound observable whenever the 
         * <code class="prettyprint">checked</code> state changes.  The declarative binding is often preferable to an explicit listener.
         * 
         * <p>A click listener should not be used to detect changes to the <code class="prettyprint">checked</code> state.  
         * The <code class="prettyprint">ojComponent</code> <code class="prettyprint">checked</code> binding and/or 
         * the <code class="prettyprint">optionChange</code> event should be used instead.
         * 
         * @expose
         * @memberof oj.ojButtonset
         * @instance
         * @type {?string|Array.<string>|undefined}
         * @default If not initially set, is initialized to reflect the initial DOM state
         * 
         * @example <caption>Initialize a buttonset with the <code class="prettyprint">checked</code> option specified:</caption>
         * // radio
         * $( ".selector" ).ojButtonset( { "checked": "tea" } );
         * 
         * // checkbox
         * $( ".selector" ).ojButtonset( { "checked": ["bold", "italic"] } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">checked</code> option, after initialization:</caption>
         * // getter
         * var display = $( ".selector" ).ojButtonset( "option", "checked" );
         * 
         * // radio setter
         * $( ".selector" ).ojButtonset( "option", "checked", "tea" );
         * 
         * // checkbox setter
         * $( ".selector" ).ojButtonset( "option", "checked", ["bold", "italic"] );
         */
        checked: undefined, // initial value that's different from any valid values like null, so _create() can tell whether app set it.
                            // At Create time will definitely be replaced with valid value.
        
        /**
         * <p>Setting the Buttonset's <code class="prettyprint">disabled</code> option effectively disables all its Buttons, without affecting 
         * their <code class="prettyprint">disabled</code> options.  Thus, a Button is effectively disabled if either its own 
         * <code class="prettyprint">disabled</code> option is set, or the Buttonset's <code class="prettyprint">disabled</code> option is set.
         * 
         * @member
         * @name disabled
         * @memberof oj.ojButtonset
         * @instance
         * @type {boolean}
         * @default <code class="prettyprint">false</code>
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">disabled</code> option specified:</caption>
         * $( ".selector" ).ojButtonset( { "disabled": true } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
         * // getter
         * var disabled = $( ".selector" ).ojButtonset( "option", "disabled" );
         * 
         * // setter
         * $( ".selector" ).ojButtonset( "option", "disabled", true );
         */
        // disabled option declared in superclass, but we still want the above API doc
        
        // Blake wants us to consider getting rid of this option in the future.  Under his proposal (whose particulars we agreed needed to be ironed out), 
        // rather than using this option to turn off Bset's handling, Bset would always handle arrow keys and preventDefault or stopPropagation.  Arrow 
        // keys would no longer wrap around when reach end of Bset, in which case Bset would let the event bubble up to Toolbar (or to whoever if 
        // not in a TB).  Any edge cases?  e.g. with tabstops, TB contents with special arrow-key behavior like inputTexts, etc.?
        /**
         * The <code class="prettyprint">focusManagement</code> option should be set to <code class="prettyprint">"none"</code> when the 
         * Buttonset is placed in a [JET Toolbar]{@link oj.ojToolbar}.  This allows the Toolbar to manage the focus with no interference from the Buttonset, 
         * so that arrow keys move within the entire Toolbar, not just within the Buttonset.  
         * 
         * @expose
         * @memberof oj.ojButtonset
         * @instance
         * @type {string}
         * @ojvalue {string} "oneTabstop" Focus management is enabled.  The Buttonset is a single tabstop with arrow-key navigation.
         * @ojvalue {string} "none" Focus management is disabled, to avoid interfering with the focus management of a containing component.
         * @default <code class="prettyprint">"oneTabstop"</code>
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">focusManagement</code> option specified:</caption>
         * $( ".selector" ).ojButtonset( { "focusManagement": "none" } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">focusManagement</code> option, after initialization:</caption>
         * // getter
         * var display = $( ".selector" ).ojButtonset( "option", "focusManagement" );
         * 
         * // setter
         * $( ".selector" ).ojButtonset( "option", "focusManagement", "none" );
         */
        focusManagement: "oneTabstop",
        
        // Events
        
        /**
         * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
         * intervention.  If the new value is the same as the previous value, no event will be fired.
         * 
         * <p>Currently there is one supported option, <code class="prettyprint">checked</code>.  Additional 
         * options may be supported in the future, so listeners should verify which option is changing 
         * before taking any action.
         * 
         * <p>Often there is no need to listen for this event, since the 2-way <code class="prettyprint">checked</code> 
         * binding offered by the <code class="prettyprint">ojComponent</code> binding will update the bound 
         * observable whenever the <code class="prettyprint">checked</code> state changes.
         * 
         * @expose 
         * @event 
         * @memberof oj.ojButtonset
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {string} ui.option the name of the option that is changing
         * @property {?string|Array.<string>} ui.previousValue the previous value of the option.
         *     <code class="prettyprint">null</code> iff the previous value was <code class="prettyprint">null</code>.
         * @property {?string|Array.<string>} ui.value the current value of the option.
         *     <code class="prettyprint">null</code> iff the current value is <code class="prettyprint">null</code>.
         * @property {Object} ui.optionMetadata information about the option that is changing
         * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or 
         *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">optionChange</code> callback specified:</caption>
         * $( ".selector" ).ojButtonset({
         *     "optionChange": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
         * $( ".selector" ).on( "ojoptionchange", function( event, ui ) {} );
         */
        optionChange: null
        
        /**
         * Triggered when the buttonset is created.
         *
         * @event 
         * @name create
         * @memberof oj.ojButtonset
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Currently empty
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojButtonset({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
    },
    
    // If this is a radio or checkbox buttonset, and the specified checked value is valid, 
    //   then sets it on the buttons' checked properties in the DOM, and returns true,
    // Else it's an invalid value, or it's the non-radio, non-checkbox case and null was passed, which is valid for that case, 
    //   then returns false without changing DOM.
    // Does not set oj-selected or aria-pressed, so must call _applyCheckedStateFromDom() after this.  
    //   TBD: optionally, this method could do that work, perhaps controlled by a param
    // This method is called by _setOption("checked", ...) and _create > _setup.  
    // Does NOT require the buttons to already be JET Buttons (useful for _setup caller).
    _setCheckedOnDom: function(checked, $buttons) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var type = $.type(checked);
        var valid;
        
        // If caller passes null there are 3 cases: (the radio branch handles null in all cases)
        // - This is a radio group, for which null means "no radio checked".  The radio branch will uncheck all radios
        //   and return true indicating that it was a valid value so it updated the DOM.
        // - This is a checkbox set, for which null is an invalid value.  The radio branch will correctly do nothing and return false.  
        // - Neither radio nor checkbox case, for which null is the one and only valid value.  The radio branch will do nothing 
        //   (correct; there's nothing to set on the DOM) and return false.  The only caller than calls in this case is the 
        //   _create > _setup caller, for which either return value is OK, since it can either keep the null value or call 
        //   _getCheckedFromDom which will return null.  _setOption doesn't call this method in this 3rd case.  
        if (type === "string" || type === "null") // radio
        {
            // before setting *any* buttons, verify that *all* buttons are radios in same group, and that the checked 
            // value to be set is null or matches one of the radio values
            var name = $buttons[0].name;
            valid = (name || $buttons.length<=1) // if name is "" and there's >1 radio, then they're in separate radio groups
                && $buttons.filter("input[type=radio][name=" + name + "]").length === $buttons.length 
                && (checked===null || $buttons.filter("[value=" + checked + "]").length);
            
            if ( valid )
            {
                $buttons.each(function() {
                    this.checked = (this.value === checked);
                });
            }
            
            return valid;
        } else if (type === "array") // checkbox
        {
            // before setting any buttons, verify that the checked value to be set is valid:
            
            // verify that all buttons are checkboxes, since is array
            valid = $buttons.filter("input[type=checkbox]").length === $buttons.length;
            
            // in a sorted copy of the array (concat makes a copy), verify no dupes and 
            // that all entries are values in the buttonset
            var last;
            valid = valid && checked.concat().sort().every(function(elem, index, array) {
                var retVal = elem !== last && $buttons.filter("[value=" + elem + "]").length;
                last = elem;
                return retVal;
            });
            
            if (valid)
            {
                $buttons.each(function() {
                    this.checked = (checked.indexOf(this.value) > -1);
                });
            }
            return valid;
        } else 
        {
            // didn't set on DOM b/c value was invalid (not the right type for *any* kind of buttonset)
            return false; 
        }
    },
    
    // if all buttons are radios with same group, returns value attr of selected radio (string), or null if none selected
    // else if all buttons are checkboxes, returns non-null, possibly empty string array containing values of selected checkboxes
    // else returns undefined.  In the API we use null, not undefined, for this case, so callers should map undefined to null before setting on DOM. 
    _getCheckedFromDom: function($buttons) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var checked = undefined;
        var isRadio = null;
        var name = null;
        
        $buttons.each(function(index) {
            // at this point, all previous buttons, if any, were all radios in same group, or were all checkboxes
            var tagName = this.tagName.toLowerCase();
            if (tagName !== "input")
            {
                checked = undefined;
                return false; // stop iterating
            }
            
            var currentType = this.type.toLowerCase();
            var currentIsRadio;
            var currentName;
            
            if (currentType === "radio"){
                currentIsRadio = true;
                currentName = this.name.toLowerCase();
            } else if (currentType === "checkbox")
            {
                currentIsRadio = false;
                currentName = null;
            } else 
            {
                checked = undefined;
                return false; // stop iterating
            }
            
            // at this point, current button is input of type radio or checkbox
            
            // If this is not the first button, then bail if:
            // - this is a radio and previous were checkboxes or vice versa
            // - this is a radio in a different group than previous ones, which can happen 
            //   if the group names are different, or if the names are all "", in which 
            //   case each radio is in a separate radio group.
            if ( (checked !== undefined) // must be !== not != 
                 && ( currentIsRadio !== isRadio 
                      || currentName !== name
                      || (isRadio && !name) ) )
            { 
                checked = undefined;
                return false; // stop iterating
            }
            
            // at this point, all buttons so far including this one are either all radios in same group, or are all checkboxes
            
            if (checked === undefined) // this is first button
            {
                checked = currentIsRadio 
                    ? this.checked ? this.value : null
                    : this.checked ? [this.value] : [];
                isRadio = currentIsRadio;
                name = currentName;
            } else if (this.checked)
            {
                if (isRadio) 
                    checked = this.value;
                else
                    checked.push(this.value);
            } // else not first button and not checked, so leave "checked" at whatever value we set on previous iteration
        });
        
        return checked;
    },
    
    // are 2 checked option values equal?
    _checkedEquals: function(checked1, checked2) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        // handle null, string, and (rare) identically equal arrays
        if (checked1 === checked2)
            return true;
        else // handle arrays.  order needn't be same
            return $.type(checked1) === "array" && $.type(checked2) === "array" 
                   && !$(checked1).not(checked2).length && !$(checked2).not(checked1).length;
        
    },
    
    _create: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this.element
            .addClass( "oj-buttonset oj-component" );
        
        if(this.options.focusManagement === "oneTabstop")    
            this.element.attr( "role", "toolbar" );

        // call _setup from _create, not _init, so create listeners (called after _create before _init) see a fully inited component.
        // We don't implement _init at all, since it's intended to perform startup behaviors like autoOpen, 
        // not initing state or performing a refresh, and we have no such startup behaviors.
        this._setup(true);
        
        this._super(); // TODO: call this at beginning of method.  This will happen as part of the JET create-time refactoring.
    },

    _OpenContextMenu: function(menu, event)
    {
        // set launcher to the current tabbable button
        menu.open(event, {"launcher": this.element.find(":oj-button[tabindex=0]"), "initialFocus": "menu"});
    },

    _propagateDisabled: function( disabled ) {
        disabled = !!disabled;
        this.$buttons.each(function() {
            $( this ).data( "oj-ojButton" ).__setAncestorComponentDisabled(disabled);
        });
    },

    _setOption: function( key, value ) // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        var bail = false;
        
        // if Button is calling this method due to user interaction checking a button, this is set; else it's not.
        var optionChangeOriginalEvent = this._optionChangeOriginalEvent;
        this._optionChangeOriginalEvent = null;
        
        if ( key === "disabled" )
            this._propagateDisabled( value );
        
        // if app called option(), but not if called because user clicked button.  In latter case we know we 
        // passed a valid non-undefined value, and DOM is already up to date.
        if ( key === "checked" && !optionChangeOriginalEvent) 
        {
            if (value === null && this._getCheckedFromDom(this.$buttons) === undefined)
            {
                // _getCheckedFromDom() returns undefined iff buttonset is neither a single radio group nor a checkbox set.
                // In this case, when they pass null (the only valid value), there's nothing to set on DOM, 
                // but let_super() call and event firing logic run since it's a valid value.  The event almost always 
                // won't fire since the old value would have been null too, but if it was a different value the event 
                // will fire as it should.  The only way that could happen is if this buttonset was previously a checkbox set 
                // or single radio group, but now is not (e.g. incompatible button added), and buttonset hasn't been refreshed since then.
            } else 
            {
                var successful = this._setCheckedOnDom(value, this.$buttons);
                if (successful) 
                {
                    // Set oj-selected/aria-pressed on all buttons' DOM:
                    this.$buttons.each(function() {
                        $( this ).data( "oj-ojButton" )._applyCheckedStateFromDom(false);
                    });
                    // Let _super() call and event firing happen.
                } else 
                { // invalid value
                    // Don't set anything on DOM.
                    bail = true; // don't fire event or call _super()
                    // TODO: Maybe log.
                }
            }
        }
        
        if (!bail)
        {
            var previousValue = this.options[key];
            this._superApply( arguments );
            // TBD: optionally could reference some metadata somewhere rather than hard-coding list of supported options and their equals methods here,
            //      e.g. static buttonsetOptionChangeMap = { "checked" : {equals: checkedEquals} }
            if ( key === "checked" ) // the only supported optionChange option
                this._fireOptionChange(key, previousValue, value, this._checkedEquals, optionChangeOriginalEvent); 
        }
    },
    
    // TBD: this method could be pushed up to superclass if desired.
    _fireOptionChange: function(key, previousValue, value, equals, originalEvent) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (!equals.call(this, previousValue, value))
        {
            var ui = { 
                "option": key,
                "previousValue": previousValue, 
                "value": value,
                // (originalEvent is non-null) iff (option change is due to user interaction) iff (binding should write back the value)
                "optionMetadata": {"writeback": originalEvent ? "shouldWrite" : "shouldNotWrite"}
            };
            this._trigger( "optionChange", originalEvent, ui );
        }
    },
    
    /**
     * Refreshes the buttonset, including the following:
     * 
     * <ul>
     *   <li>Creates JET Buttons out of all contained DOM elements supported by JET Button that are not already Buttons, by calling <code class="prettyprint">.ojButton()</code> on them.
     *   <li>Re-applies focus management / keyboard navigation.
     *   <li>Applies special styles to the first and last button of the buttonset (e.g. for rounded corners, depending on theming).
     *   <li>Rechecks the reading direction (LTR vs. RTL).
     * </ul>
     * 
     * <p>A <code class="prettyprint">refresh()</code> is required in the following circumstances:
     * <ul>
     *   <li>After buttons are added to or removed from the buttonset.</li>
     *   <li>After a change to the <code class="prettyprint">disabled</code> status of any of the buttons in the buttonset.</li>
     *   <li>After the reading direction (LTR vs. RTL) changes.</li>
     * </ul>
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof oj.ojButtonset
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojButtonset( "refresh" );
     */
    refresh: function() // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
    {
        this._super();
        this._setup(false);
    },
    
    _setup: function(isCreate) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var self = this;
        this.isRtl = this._GetReadingDirection() === "rtl";
        this.$buttons = this.element.find( this._items );
        
        if (isCreate) 
        {
            // At create time, if app provided a valid "checked" option, it wins over whatever's in the DOM.
            var successful = this._setCheckedOnDom(this.options.checked, this.$buttons);
            // Successful or not, don't call _setOption(), since don't want to fire optionChange event at create time
            // (The JQUI framework does NOT call _setOption at create time.)  Refresh happens below.
            if (!successful) // option value wasn't valid
            {
                var newChecked = this._getCheckedFromDom(this.$buttons);
                this.options.checked = newChecked === undefined ? null : newChecked;
            }
            // At create time, successful set or not, checked option and checked props are now in synch, so we just need to 
            // set .oj-selected and aria-pressed on each button.  This is done below by either the _applyCheckedStateFromDom()
            // call (for existing buttons) or the initializer call (for new buttons).
        } // else it's refresh time.  If the DOM's checked state is out of synch with the checked option, it's either because 
          // the app directly set the "checked" attr of an existing Button in the Buttonset, which we don't support (they should 
          // have used the component API instead), or the set of buttons in the set has changed (possibly because a KO foreach 
          // binding added/removed buttons).  In the latter case, we require that the app update the "checked" option, by setting 
          // the bound observable (if present) or calling option() (otherwise). 
        
        this.$buttons
            // refresh any buttons underneath us that already exist, like JQUI does
            // TBD:  Now that Bset has a checked option, the recursive refreshing of the Bset's buttons is necessary in more cases than before.  
            //   Review whether it's still desirable to add a refresh() param that would allow turning off this recursive
            //   refreshing.  That was previously approved, but changing the default (compared to JQUI) was not approved.
            //   The refresh param wouldn't help for creates; for that we'd need to add a Buttonset option.  
            //   See also _destroy() code comment.
            .filter( ":oj-button" )
                .ojButton( "refresh" )
                .each(function() {
                    $( this ).data( "oj-ojButton" )._applyCheckedStateFromDom(false); // set .oj-selected and aria-pressed
                })
            .end()
            
            // Create buttons underneath us
            .not( ":oj-button" )
                .ojButton() // sets .oj-selected and aria-pressed
            .end()
        
            // Update rounded corners, etc.
            .map(function() {
                return $( this ).ojButton( "widget" )[ 0 ];
            })
                .removeClass( "oj-buttonset-first oj-buttonset-last" )
                .filter( ":first" )
                    .addClass( "oj-buttonset-first" )
                .end()
                .filter( ":last" )
                    .addClass( "oj-buttonset-last" )
                .end()
            .end()
            
        // Must do this after creating the buttons above since callee calls Button API.
        // Must do this before the focus mgmt code, which needs to know which buttons are effectively disabled.
        // Must do this at refresh time, not just create time, in case new buttons were added to the Bset (whether 
        // reparented or created e.g. by KO foreach).
        this._propagateDisabled( this.options.disabled );
       
        if (this.options.focusManagement==="oneTabstop")
        {
            // When buttonset is binding listeners to buttons, use the Buttonset's eventNamespace, not the Button's 
            // eventNamespace, to facilitate later unbinding only the Buttonset listeners.
        
            // For checkbox/radio, we're binding to inputs, not labels.
            
            // Put listeners on every button, b/c it's too unreliable to put them on the buttonset node and rely on event bubbling.
            // - E.g. bubbling doesn't work for antonym buttons (is this still true after the refactoring?) -- see comment on Button._setLabelOption().
            // - Likewise, focus mgmt can't just break if app listener stops propagation.
            // - Both of these problems still happen when using the delegation / selector overload of .on(); there is no special JQ bubbling magic.
            
            this.$buttons
                .unbind( "keydown" + this.eventNamespace )
                .bind( "keydown" + this.eventNamespace, function(event) { 
                    self._handleKeyDown(event, $(this)); 
                })

                .unbind( "click" + this.eventNamespace )
                .bind( "click" + this.eventNamespace, function(event) {
                    if ( !$( this ).data( "oj-ojButton" )._IsEffectivelyDisabled() )
                    { 
                        // Normally the button will be tabbable after the click, since (a) if we reach here, the clicked button is enabled, and 
                        // (b) an unchecked radio before the click will normally be checked after the click.  But just in case it's unchecked 
                        // (e.g. due to app listener), we let callee run it thru _mapToTabbable() before using, as usual.
                        self._setTabStop( $(this) );
                    }
                })
                .unbind( "focus" + this.eventNamespace )
                .bind( "focus" + this.eventNamespace, function(event) { 
                    self._setTabStop( $(this) );
                });
        
            // the subset of Buttonset buttons that are enabled.  Effectively disabled buttons are not tabbable.
            this.$enabledButtons = this.$buttons.filter(function(index) {
                return !$( this ).data( "oj-ojButton" )._IsEffectivelyDisabled();
            });

            this._initTabindexes(isCreate);
        }
    },
    
    // For create, make only the first enabled button tabbable.  (We decided to have Shift-Tab go to first, not last, button.)
    // For refreshes, keep the existing tabstop if we can, otherwise proceed as with create.
    // Either way, if that button is a radio and some radio in its group is checked, make that one tabbable instead.
    // If there are no enabled buttons, makes them all untabbable.
    // No return value.
    _initTabindexes: function(isCreate) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        // even for refreshes where we'll wind up keeping the same tabstop, must make everything untabbable first, to ensure any new buttons become untabbable.
        var $last = $(this._lastTabStop);
        this._lastTabStop = undefined;
        this.$buttons.attr( "tabindex", "-1" );
        var $newTabStop; // callee might map this to radio groupmate
        
        // TBD: for refreshes when $last is an effectively disabled radio with a checked enabled groupmate and they are in the buttonset, the groupmate would be 
        // a valid tabstop, but this defaults to the first.
        if (isCreate || !$last.is(this.$enabledButtons)) 
        {
            // is create, or is refresh but must treat like create b/c $last is empty, or not enabled, or no longer in the buttonset
            $newTabStop = this.$enabledButtons.first(); // if empty (none enabled), no tabstop will be set
        } else 
        {
            // is a refresh, and $last is non-empty and is an enabled button still in the buttonset.  May be a radio whose groupmate
            // has become checked, in which case callee will map it to that groupmate.
            $newTabStop = $last;
        }
        this._setTabStop( $newTabStop );
    },
    
    // For each button in $button (in our usage always 0-1 button hence $button singular), if that button is an unchecked radio 
    // with a checked groupmate (which means it's not tabbable), then map it to the checked one (checked enabled radios are 
    // tabbable, and we know it's enabled per the argument below).
    // 
    // $button contains 0 or more buttons to map.  Must be enabled since effectively disabled buttons aren't tabbable.
    // Returns the mapped JQ object (which the caller will make the tabstop).
    // 
    // We know that this.$enabledButtons contains all buttons in $button, and all of their potentially checked radio-groupmates, since:
    // - The above "enabled" requirement guarantees that $button's contents are all in $enabledButtons.
    // - The prohibition against radio groupmates that are not in the buttonset, and the prohibition against checked disabled groupmates 
    //   of enabled radios, guarantee that if $button is a radio, then all of its potentially checked groupmates are enabled and thus in 
    //   $enabledButtons.
    // 
    // Firefox browser issue:   (TODO: should we doc this?  File FF and/or JET bug?)
    // 
    // When this method maps an unchecked radio to its checked groupmate, the caller ensures that the former still has focus, but the latter
    // is the tabstop for when the user tabs out and back in.  When tabbing / Shift-Tabbing from the unchecked radio in the direction of the 
    // checked one, Chrome and IE9 are smart enough to tab out of the radio group to the adjacent tabstop as desired.  But in FF, focus goes to 
    // the checked one, which is not what we want.
    // 
    // Reason: Chrome and IE9 are smart enough never to tab within a radio group.  If focus is in the radio group, Tab and Shift-Tab exit the radio group.
    // But in FF, [a radio is reachable via Tab/Shift-Tab from within the group] if [it's enabled, tabindex != -1, and either checked or has no 
    // checked groupmates], i.e. [it would be reachable via Tab/Shift-Tab from outside the group if all its groupmates happened to be untabbable 
    // (e.g. disabled)].  In other words, FF is the only one that fails to distinguish between radios that could be valid tabstops from outside, and
    // those that should be valid tabstops from inside.  
    // 
    // This impl improves on the native behavior.  In FF, in an unchecked radio group, every single radio is a tabstop.  Our use of tabindex=-1 
    // guarantees that we never tab within the group in that case.  It's only a checked groupmate that can be tabbed to from within. (So at 
    // most one unwanted tabstop.)
    // 
    // After much time and effort, the latter issue seems to be infeasible to fix in any robust, non-brittle way.  E.g.:
    // - Clearing all tabstops and restoring on tab-out of buttonset:  FF provides no reliable way to find out whether a blur is exiting the entire 
    //   buttonset.  The obvious setTimeout workaround needed to be unacceptably long (e.g. 250ms) and even then was unreliable.  If we ever fail 
    //   to restore the tabstop, the buttonset becomes untabbable and inaccessible.
    // - Every other approach had similar robustness issues. 
    _mapToTabbable: function( $button ) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var $enabledButtons = this.$enabledButtons;
        return $button.map(function(index, elem) {
            // Buttons other than radios, and checked radios, are always tabbable if they're enabled, which this method requires.
            // Radios w/ name="" (incl name omitted) are not in a radio group, not even with other radios with w/ name="".  Radios 
            // with no groupmates are always tabbable, since either they're checked, or they're unchecked with no checked groupmate.
            if (elem.type != "radio" || elem.checked || elem.name == "")
                return elem;
            else 
            {
                // elem is unchecked radio in real (not "") group, which is tabbable iff no groupmate is checked.  Per above doc, we know that 
                // all of its potentially checked groupmates are in $enabledButtons.
                var $checkedRadio = _radioGroup(elem, $enabledButtons).filter(":checked");
                return ($checkedRadio.length ? $checkedRadio[0] : elem);
            }
        });
    },
    
    // Set which button is in the tab sequence.
    // $button should contain 0 or 1 button to be made tabbable (since at most one should be tabbable at a time).
    //   If 0 (i.e. no enabled buttons), all will become untabbable.  If 1, it must be tabbable in every way (e.g. enabled) except possibly 
    //   being an unchecked radio with a checked groupmate, which this method will map to its checked groupmate, which 
    //   we know is enabled thus tabbable since we require that checked radios with enabled groupmates not be disabled.  
    // No return value.
    _setTabStop: function( $button ) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
//        if (!window.setTabStopCounter) window.setTabStopCounter=1; // REMOVE, is only for console.log's
//        console.log("in _setTabStop: " + window.setTabStopCounter++ + ".  Orig (premap) button checked: " + $button[0].checked); // + " and is:");
//        console.log($button[0]);
        
        $button = this._mapToTabbable( $button );
        var button = $button[0]; // button is undefined iff $button is empty iff we need to clear all tabstops b/c there are no enabled buttons to make tabbable
        var last = this._lastTabStop; // last is undefined iff $(last) is empty iff there are no existing tabstops to clear (b/c _initTabindexes just ran 
                                      // or previously there were no enabled buttons to make tabbable)
        
//        console.log("mapped button and last button are:");  console.log(button);  console.log(last);  console.log(".");
        
        // Cases: both are undefined: have no tabstops; want to keep it that way (b/c none enabled), so do nothing
        //        both are node X: X is the tabstop; want to keep it that way, so do nothing
        //        last is node X; button is undefined: X is the tabstop; want to clear it w/o replacing it (b/c none enabled).  This logic does that.
        //        last is undefined; button is node X: no existing tabstop; want to make X the tabstop.  This logic does that.
        //        last is node X; button is node Y: X is the tabstop; want to clear it and make Y the tabstop.  This logic does that.
        if ( button !== last) {
            //console.log("setting tab stop to " + $button.attr("id"));  console.log("$(last).length:");  console.log($(last).length);
            
            $(last).attr( "tabindex", "-1" ); // no-op iff $(last) is empty iff (see comment above)
            $button.attr( "tabindex", "0" ); // no-op iff $button is empty iff (see comment above)
            this._lastTabStop = button;
        }
    },
    
    // No return value.
    _handleKeyDown: function(event, $button) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        switch (event.which) {
            case $.ui.keyCode.LEFT:  // left arrow
            case $.ui.keyCode.RIGHT: // right arrow
                event.preventDefault();
                
                var $enabledButtons = this.$enabledButtons;
                var length = $enabledButtons.length;
                if (length<2) // nowhere to navigate to; currently focused button is the only enabled one in buttonset
                    break;
                
                var oldIndex = $enabledButtons.index($button);
                var increment = ((event.which == $.ui.keyCode.RIGHT) ^ this.isRtl) ? 1 : -1;
                var newIndex = (oldIndex+increment+length)%length; // wrap around if at start/end of buttonset
                
                // A11y office recommended treating radios like other buttons: Arrow moves focus without selecting, Spacebar selects, 
                // which we prefer too.  Since we're using role='button', not 'radio', we don't need to follow the WAI-ARIA radio behavior 
                // where Arrow moves focus and selects, Ctrl-Arrow moves focus without selecting.  
                $enabledButtons.eq(newIndex).focus();
                break;
            case $.ui.keyCode.UP:   // up arrow
            case $.ui.keyCode.DOWN: // down arrow
                // Per above comment, treating radios like buttons, which have no native or WAI-ARIA-mandated up/down arrow behavior, 
                // so disable native focus-and-select behavior.  
                if ( $button.attr("type")=="radio" )
                    event.preventDefault();
                break;
            
            // Don't need Space/Enter handlers.  For all buttons except already-checked radios in some browsers, Space/Enter fire a click event 
            // (natively or manually), which already calls _setTabStop.  For checked radios (which are focused if they're getting 
            // this key event), _setTabStop has already been called for whichever happened 2nd:  focus (an already checked radio) or
            // check (an already focused radio) via click/Space/Enter.  We don't support programmatically checking the button; it must 
            // be done via the "checked" option.
        }
    },
    
    _destroy: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this.element
            .removeClass( "oj-buttonset oj-component" )
            .removeAttr( "role" );
        
        if (this.options.focusManagement==="oneTabstop") 
            this.$buttons.attr( "tabindex", "0" );
        
        this.$buttons
            .map(function() {
                return $( this ).ojButton( "widget" )[ 0 ];
            })
                // do .removeClass outside the filter in case button has been destroyed but still has these Buttonset styles on it.
                // TBD: if this has definitely been taken care of already for destroyed buttons, then move inside filter.
                .removeClass( "oj-buttonset-first oj-buttonset-last" )
            .end()
    
            // Recursively destroy Bset's buttons like JQUI.  
            // TBD: The recursive destroy makes it impossible to ungroup the buttons if desired, i.e. destroy the Buttonset without destroying its buttons.
            //   As discussed in _setup() code comment, it was approved to add refresh() and/or destroy() params that would allow turning off
            //   the recursive behavior, but changing the default (compared to JQUI) was not approved.
            //   When not destroying the buttons, must instead restore the buttons to a not-in-buttonset state, i.e. remove Bset stuff, restore any 
            //   Button stuff we removed, etc.
            .ojButton( "destroy" );
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the buttonset element.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojButtonset#widget
     * @memberof oj.ojButtonset
     * @instance
     * @return {jQuery} the buttonset element
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojButtonset( "widget" );
     */

    /**
     * Removes the buttonset functionality completely, including focus management, and recursively <code class="prettyprint">destroy()</code>s 
     * the contained buttons. This will return the element back to its pre-init state.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojButtonset#destroy
     * @memberof oj.ojButtonset
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojButtonset( "destroy" );
     */
});

// -----------------------------------------------------------------------------
// "private static members" shared by all buttons and buttonsets
// -----------------------------------------------------------------------------

var _lastActive;
var _lastToggleActive;
    
    // "static" namespace for events associated with all buttons on page/form/etc., not just one.  E.g. see form reset handler at top of _create().
    // this.eventNamespace, used for individual button instances, is .ojButtonX, whereX = 0, 1, 2, etc.
var BUTTON_EVENT_NAMESPACE = ".ojButton",
    
    BASE_CLASSES = "oj-button oj-component oj-enabled oj-default", // oj-enabled is a state class, but convenient to include in this var instead
    STATE_CLASSES = "oj-hover oj-active oj-selected", // TBD: oj-hover doesn't really need to be listed here since this var is only used to remove classes from rootElement at destroy time, which already happens because we register rootElement as a hoverable.  Same might apply to oj-active if we switch to an activeable paradigm.
    TYPE_CLASSES = "oj-button-icons-only oj-button-icon-only oj-button-text-icons oj-button-text-icon-start oj-button-text-icon-end oj-button-text-only",
    
    /**
     * In all cases, the return value includes only radios that are an :oj-button, i.e. radios that have been buttonized.
     * 
     * Where this method looks for radio groupmates:
     *
     * - If $elems is present (even if empty), 
     *     - This method will only look in that set, and will not attempt to weed out any false positives as defined below. 
     *       (So in this case, return value includes the specified radio iff it's an :oj-button in $elems.)
     * - Else this method looks in exactly the places where groupmates (including the original radio) would live, i.e. not in 
     *   the places false positives would live.  (So in both of the following cases, return value includes the specified radio 
     *   iff it's an :oj-button.)  Specifically:
     *     - If radio is in a form, this method will only look in that form.
     *     - Else, this method will look in the radio's document, but not in any forms.
     * 
     * Radios w/ name="" (incl name omitted) are not in a radio group (i.e. no SelectOne semantics), not even with other radios with 
     * w/ name="".  So if radio is nameless, the return value will include only radio (or nothing at all if it isn't an :oj-button, or 
     * if $elems is passed and it doesn't include radio).  
     * 
     * False positives: radios with nonempty names that match radio's name, but are actually not groupmates (i.e. no SelectOne 
     * relationship), e.g. because they're from a different form.
     * 
     * 
     * @param {!Element} radio  a radio button.  Not a JQ object, other button or element type, or null.
     * @param {jQuery=} $elems  optional JQ object, containing 0 or more elems that aren't necessarily radios or buttons, in which to look for groupmates.
     *                          E.g. the elements in a buttonset or toolbar.  Must not contain any false positives as defined above.
     */
    _radioGroup = function( radio, $elems )
    {
        var name = radio.name,
            form = radio.form,
            $radios;
        if ( name ) 
        {
            name = name.replace( /'/g, "\\'" ); // escape single quotes
            var selector = ":radio[name='" + name + "']:oj-button";
            if ( $elems ) 
            {
                $radios = $elems.filter( selector );
            } else if ( form ) 
            {
                $radios = $( form ).find( selector );
            } else 
            {
                $radios = $( selector, radio.ownerDocument )
                    .filter(function() {
                        return !this.form;
                    });
            }
        } else 
        {
            $radios = ($elems ? $elems.filter( radio ) : $( radio )).filter(":oj-button");
        }
        return $radios;
    };

}() ); // end of Button / Buttonset wrapper function

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

(function() {

/**
 * @class 
 * @name oj.ojMenu
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="menuOverview-section">
 *   JET Menu Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#menuOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant menu with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Menu can be created from any valid markup as long as the elements have a strict parent/child relationship 
 * and each menu item has an anchor. The most commonly used element is the unordered list ( <code class="prettyprint">&lt;ul></code> ):
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu">
 *   &lt;li>&lt;a href="#">Item 1&lt;/a>&lt;/li>
 *   &lt;li>&lt;a href="#">Item 2&lt;/a>&lt;/li>
 *   &lt;li>&lt;a href="#">Item 3&lt;/a>
 *     &lt;ul>
 *       &lt;li>&lt;a href="#">Item 3-1&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-2&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-3&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-4&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-5&lt;/a>&lt;/li>
 *     &lt;/ul>
 *   &lt;/li>
 *   &lt;li>&lt;a href="#">Item 4&lt;/a>&lt;/li>
 *   &lt;li>&lt;a href="#">Item 5&lt;/a>&lt;/li>
 * &lt;/ul>
 * </code></pre>
 * 
 * <p>If you use a structure other than <code class="prettyprint">&lt;ul></code>/<code class="prettyprint">&lt;li></code>, including using the same element for the menu and the menu items, use the 
 * <code class="prettyprint">menuSelector</code> option to specify a way to differentiate the two elements, e.g., <code class="prettyprint">menuSelector: "div.menuElement"</code>.
 * 
 * <p>Any menu item can be disabled by adding the <code class="prettyprint">oj-disabled</code> class to that element.  As with any DOM change, doing so post-init 
 * requires a <code class="prettyprint">refresh()</code> of the component.  
 * 
 * 
 * <h3 id="icons-section">
 *   Icons
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#icons-section"></a>
 * </h3>
 * 
 * <p>The submenu icon can be customized via theming.  See the "Theming" chapter of the Oracle JET Developer Guide for details.
 * 
 * <p>To add other icons to menu items, include them in the markup:  
 * <!-- TODO: if they're required to include oj-menu-item-icon, should probably call that out.  Is that our rqmt?  Likewise, should we mention the class name they use to set the submenu icon? -->
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu">
 *   &lt;li id="foo">&lt;a href="#">&lt;span class="oj-menu-item-icon demo-icon-font demo-palette-icon-24">&lt;/span>Foo&lt;/a>&lt;/li>
 * &lt;/ul>
 * </code></pre>
 * 
 * 
 * <h3 id="dividers-section">
 *   Dividers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dividers-section"></a>
 * </h3>
 * 
 * <p>Divider elements can be created by including unlinked menu items that contain only spaces and/or dashes, or nothing at all:  
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu">
 *   &lt;li>&lt;a href="#">Item 1&lt;/a>&lt;/li>
 *   &lt;li>---&lt;/li>
 *   &lt;li>&lt;a href="#">Item 2&lt;/a>&lt;/li>
 * &lt;/ul>
 * </code></pre>
 * 
 * <p>For WAI-ARIA compliance, JET automatically adds <code class="prettyprint">role="separator"</code> to the divider element.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
 *       <td>Invokes the focused menu item's action, which may be opening a submenu.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Moves focus to the previous menu item, wrapping around at the top.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Moves focus to the next menu item, wrapping around at the bottom.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td>Opens the submenu, if any.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td>If focus is in a submenu, closes the submenu and moves focus to the parent menu item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>If focus is in a submenu, closes the submenu and moves focus to the parent menu item.<br>
 *           If focus is on a top-level menu item of a popup menu, closes the popup menu and moves focus to the launcher.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Moves focus to the first menu item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Moves focus to the last menu item.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <p>Typing a letter moves focus to the first item whose title starts with that character. Repeating the same character cycles through matching items. 
 * Typing more characters within the one second timer matches those characters.  
 * 
 * <p>Note that the "Search for text when I start typing" feature in Firefox can interfere with web content that accepts keystrokes, such as this "type a letter" feature of JET Menu.  
 * 
 * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
 * 
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio, 
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>, 
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which 
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user 
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio 
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the 
 * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
 * is changed post-init, the menu must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded. 
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-menu</code> pseudo-selector can be used in jQuery expressions to select JET Menus.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-menu" ) // selects all JET Menus on the page
 * $myEventTarget.closest( ":oj-menu" ) // selects the closest ancestor that is a JET Menu
 * </code></pre>
 * 
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <p>For components like Menu and Buttonset that contain a number of like items, applications may wish to use a <code class="prettyprint">foreach</code> Knockout binding
 * to stamp out the contents.  This binding cannot live on the same node as the JET <code class="prettyprint">ojComponent</code> binding, and must instead live on a nested 
 * virtual element as follows:
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu" data-bind="ojComponent: {component: 'ojMenu'}">
 *     &lt;!-- ko foreach: menuItems -->
 *         &lt;li data-bind="attr: {id: id}, css: {'oj-disabled': disabled}">
 *             &lt;a href="#" data-bind="text: label">&lt;/a>
 *         &lt;/li>
 *     &lt;!-- /ko -->
 * &lt;/ul>
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 *   <li>For clarity, JQUI Menu's <code class="prettyprint">menus</code> option has been renamed to <code class="prettyprint">menuSelector</code> in JET Menu.</li>
 *   <li>JQUI Menu's <code class="prettyprint">position</code> option is now a field of the <code class="prettyprint">submenuOpenOptions</code> option in JET Menu.</li>
 *   <li>JQUI Menu has a <code class="prettyprint">role</code> option, which defaults to <code class="prettyprint">"menu"</code>.  This option was removed in JET Menu.  Reason: 
 *       JET Menu is a menu component; thus we feel that the only appropriate WAI-ARIA role for our component is <code class="prettyprint">"menu"</code>.</li>
 *   <li>JQUI Menu has <code class="prettyprint">isFirstItem()</code> and <code class="prettyprint">isLastItem()</code> methods, which were removed in JET Menu.  Reason:  To 
 *       keep the API lean, we prefer to avoid methods with such specific functionality.</li>
 *   <li>JQUI Menu has a number of "programmatic navigation" methods, and <code class="prettyprint">focus</code> / <code class="prettyprint">blur</code> events, that were 
 *       removed in JET Menu due to lack of a use case.</li>
 *   <li>JET Menu swaps the functionality of the left and right arrow keys in RTL.</li>
 *   <li>JET Menu creates WAI-ARIA compliant separator elements, by applying <code class="prettyprint">role="separator"</code> to them.</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "menu" or "button".  
 * E.g. the JQUI <code class="prettyprint">menucreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Menus (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-menu", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Menu.  If called after the menu is already created, it is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the menu with no options specified:</caption>
 * $( ".selector" ).ojMenu();
 * 
 * @example <caption>Initialize the menu with some options and callbacks specified:</caption>
 * $( ".selector" ).ojMenu( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the menu via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;ul id="menu" data-bind="ojComponent: { component: 'ojMenu', 
 *                                         disabled: true, 
 *                                         select: menuItemSelect }">
 */
oj.__registerWidget("oj.ojMenu", $['oj']['baseComponent'], {
    defaultElement: "<ul>", // added to externs.js, since this is an override of a superclass member.  (That's the rule for public methods, what about protected fields?)  TODO: Would @override do the job and be better than externing?
    delay: 300, // Doesn't get renamed even when unquoted and not in (our) externs.js file, so I'm leaving it unquoted for now.  TBD: This is private, but do NOT rename to _delay since there's an inherited instance method by that name, so rename so something else prefixed with _.
    role: "menu", // private.  I moved from options to here since no longer public option.  Leave unquoted so gets renamed by GCC as desired.
    widgetEventPrefix : "oj",
    _MENU_CLICK_AWAY_HANDLER_KEY:"ojMenuClickAwayHandler", 
    options: { // options is in externs.js, so no need for quotes
        /**
         * Disables the menu if set to <code class="prettyprint">true</code>.
         * 
         * @member
         * @name disabled
         * @memberof oj.ojMenu
         * @instance
         * @type {boolean}
         * @default <code class="prettyprint">false</code>
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">disabled</code> option specified:</caption>
         * $( ".selector" ).ojMenu( { "disabled": true } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
         * // getter
         * var disabled = $( ".selector" ).ojMenu( "option", "disabled" );
         * 
         * // setter
         * $( ".selector" ).ojMenu( "option", "disabled", true );
         */
        // disabled option declared in superclass, but we still want the above API doc
        
        /**
         * Selector for the elements that serve as the menu container, including submenus.
         * 
         * <p>Note: The <code class="prettyprint">menuSelector</code> option should not be changed after initialization. Existing submenus will not be updated.
         * 
         * @expose 
         * @memberof oj.ojMenu
         * @instance
         * @type {string}
         * @default <code class="prettyprint">"ul"</code>
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">menuSelector</code> option specified:</caption>
         * $( ".selector" ).ojMenu({ menuSelector: "div" });
         * 
         * @example <caption>Get the <code class="prettyprint">menuSelector</code> option, after initialization:</caption>
         * // getter
         * var menuSelector = $( ".selector" ).ojMenu( "option", "menuSelector" );
         */
        menuSelector: "ul",
        
        /**
         * <p>A collection of settings impacting the launch of a popup menu.  These <code class="prettyprint">openOptions</code> 
         * may be accessed and overridden individually or collectively, as seen in the examples.
         * 
         * <p>This option affects the top-level menu, while <code class="prettyprint">submenuOpenOptions</code> affects submenus.
         * 
         * <p>The values set here can be overridden on a per-launch basis by passing the corresponding params into the 
         * <code class="prettyprint">open()</code> method.
         * 
         * @expose 
         * @memberof oj.ojMenu
         * @instance
         * @type {Object}
         * 
         * @example <caption>Initialize the menu, setting some <code class="prettyprint">openOptions</code>.  This syntax leaves the 
         * other <code class="prettyprint">openOptions</code> intact at create time, but not if called after create time:</caption>
         * $( ".selector" ).ojMenu({ openOptions: { "initialFocus": "none", "launcher": "#myLauncher" } });
         * 
         * @example <caption>Get or set the <code class="prettyprint">openOptions</code> option, after initialization:</caption>
         * // Get one
         * var value = $( ".selector" ).ojMenu( "option", "openOptions.launcher" );
         * 
         * // Get all
         * var values = $( ".selector" ).ojMenu( "option", "openOptions" );
         * 
         * // Set one, leaving the others intact
         * $( ".selector" ).ojMenu( "option", "openOptions.initialFocus", "none" );
         * 
         * // Set many.  Any existing openOptions not listed are lost
         * $( ".selector" ).ojMenu( "option", "openOptions", { launcher: "#myLauncher",
         *                                                     initialFocus: "firstItem",
         *                                                     position: myPositionObj } );
         */
        openOptions: {
            /**
             * Determines focus behavior when the popup menu is initially opened.
             * 
             * @expose
             * @alias openOptions.initialFocus
             * @memberof! oj.ojMenu
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"menu"</code>
             * @ojvalue {string} "none" Leaves focus where it is, e.g. on the launching component.
             * @ojvalue {string} "menu" Focuses the menu itself, with no menu item focused (e.g. typical Context Menu behavior).
             * @ojvalue {string} "firstItem": Focuses the first menu item (e.g. MenuButton <kbd>DownArrow</kbd> behavior).
             *
             * @example <caption>Initialize the menu with the <code class="prettyprint">openOptions.initialFocus</code> sub-option specified:</caption>
             * $( ".selector" ).ojMenu({ openOptions: { initialFocus: "firstItem" } });
             * 
             * @example <caption>Get or set the <code class="prettyprint">openOptions.initialFocus</code> sub-option, after initialization:</caption>
             * // getter
             * var initialFocus = $( ".selector" ).ojMenu( "option", "openOptions.initialFocus" );
             * 
             * // setter:
             * $( ".selector" ).ojMenu( "option", "openOptions.initialFocus", "none" );
             */
            initialFocus : "menu",
            
            /**
             * <p>The DOM node (which may or may not be a JET component) that launches this popup menu.  
             * This node must be focusable, as focus is returned to it upon menu dismissal.  
             * 
             * <p>Can be a <code class="prettyprint">string</code> JQ selector indicating the DOM node, or a <code class="prettyprint">jQuery</code> 
             * object containing the node.
             * 
             * <p>The launcher must either be specified in this component option, or on each menu launch -- see <code class="prettyprint">open()</code> 
             * and <code class="prettyprint">beforeOpen</code>.
             * 
             * @expose
             * @alias openOptions.launcher
             * @memberof! oj.ojMenu
             * @instance
             * @type {string|jQuery}
             * @default <code class="prettyprint">null</code>
             * 
             * @example <caption>Initialize the menu with the <code class="prettyprint">openOptions.launcher</code> sub-option specified:</caption>
             * $( ".selector" ).ojMenu({ openOptions: { launcher: "#myLauncher" } });
             * 
             * @example <caption>Get or set the <code class="prettyprint">openOptions.launcher</code> sub-option, after initialization:</caption>
             * // getter
             * var launcher = $( ".selector" ).ojMenu( "option", "openOptions.launcher" );
             * 
             * // setter:
             * $( ".selector" ).ojMenu( "option", "openOptions.launcher", "#myLauncher" );
             */
            launcher: null, 
            
            /**
             * <p>Determines the position of this menu when launched via the <code class="prettyprint">open()</code> method or via menu button or 
             * context menu functionality.
             * 
             * <p>By default, the menu is positioned relative to the launching event if that event is a right-click mouse event, and the launcher 
             * element otherwise.  This behavior is appropriate for context menus and menu buttons.  If a value is set on the 
             * <code class="prettyprint">of</code> field, then the menu is positioned relative to that element or position instead.  
             * 
             * <p>Please refer to the jQuery UI [Position]{@link http://api.jqueryui.com/position/} utility for more details about the various choices.
             *
             * <p>In addition to the JQUI syntax given there, note that JET supports <code class="prettyprint">start</code> and <code class="prettyprint">end</code> 
             * values in the <code class="prettyprint">my</code> and <code class="prettyprint">at</code> fields wherever <code class="prettyprint">left</code> 
             * and <code class="prettyprint">right</code> are supported.  The <code class="prettyprint">start</code> value means "left in LTR; right in RTL", 
             * while the <code class="prettyprint">end</code> value means "right in LTR; left in RTL."
             *              * 
             * @expose
             * @alias openOptions.position
             * @memberof! oj.ojMenu
             * @instance
             * @type {Object}
             * @default <code class="prettyprint">{ "my": "start top", "at": "start bottom" }</code>
             * 
             * @example <caption>Initialize the menu with the <code class="prettyprint">openOptions.position</code> option specified:</caption>
             * $( ".selector" ).ojMenu({ openOptions: { position: { "my": "start top", "at": "end-5 top+5" } } });
             * 
             * @example <caption>Get or set the <code class="prettyprint">openOptions.position</code> sub-option, after initialization:</caption>
             * // getter
             * var position = $( ".selector" ).ojMenu( "option", "openOptions.position" );
             * 
             * // setter:
             * $( ".selector" ).ojMenu( "option", "openOptions.position", { "my": "start top", "at": "end-5 top+5" } );
             */
            position: {
                /** @expose */
                my: "start top",
                /** @expose */
                at: "start bottom"
            }
        },
        
        // Omitting the usual verbiage about whether the "other" sub-options are clobbered by a given setter syntax, 
        // since only one sub-option currently.
        // TBD: restore that verbiage (copy from openOptions) if gain 2nd sub-option.  
        /**
         * <p>A collection of settings impacting the launch of submenus.  
         * 
         * <p>This option affects submenus, while the similar <code class="prettyprint">openOptions</code> affects the top-level menu.
         * 
         * @expose 
         * @memberof oj.ojMenu
         * @instance
         * @type {Object}
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">submenuOpenOptions</code> option specified:</caption>
         * $( ".selector" ).ojMenu({ submenuOpenOptions: { "position": { "my": "start top", "at": "end-5 top+5" } } });
         * 
         * @example <caption>Get or set the <code class="prettyprint">submenuOpenOptions</code> option, after initialization:</caption>
         * // Get one
         * var value = $( ".selector" ).ojMenu( "option", "submenuOpenOptions.position" );
         * 
         * // Get all (currently only one)
         * var values = $( ".selector" ).ojMenu( "option", "submenuOpenOptions" );
         * 
         * // Set one
         * $( ".selector" ).ojMenu( "option", "submenuOpenOptions.position", { "my": "start top", "at": "start bottom" } );
         * 
         * // Set many (currently only one)
         * $( ".selector" ).ojMenu( "option", "submenuOpenOptions", { position: { "my": "start top", "at": "start bottom" } } );
         */
        submenuOpenOptions: {
            /**
             * Determines the position of submenus.  By default, the submenu is positioned relative to the parent menu item, but if a value is set on 
             * the <code class="prettyprint">of</code> field, then the submenu is positioned relative to that element or position instead.  
             * 
             * <p>Please refer to the jQuery UI [Position]{@link http://api.jqueryui.com/position/} utility for more details about the various choices.
             * 
             * In addition to the JQUI syntax given there, note that JET supports <code class="prettyprint">start</code> and <code class="prettyprint">end</code> 
             * values in the <code class="prettyprint">my</code> and <code class="prettyprint">at</code> fields wherever <code class="prettyprint">left</code> 
             * and <code class="prettyprint">right</code> are supported.  The <code class="prettyprint">start</code> value means "left in LTR; right in RTL", 
             * while the <code class="prettyprint">end</code> value means "right in LTR; left in RTL."
             * 
             * @expose
             * @alias submenuOpenOptions.position
             * @memberof! oj.ojMenu
             * @instance
             * @type {Object}
             * @default <code class="prettyprint">{ "my": "start top", "at": "end top" }</code>
             * 
             * @example <caption>Initialize the menu with the <code class="prettyprint">submenuOpenOptions.position</code> option specified:</caption>
             * $( ".selector" ).ojMenu({ openOptions: { position: { "my": "start top", "at": "end-5 top+5" } } });
             * 
             * @example <caption>Get or set the <code class="prettyprint">submenuOpenOptions.position</code> sub-option, after initialization:</caption>
             * // getter
             * var position = $( ".selector" ).ojMenu( "option", "submenuOpenOptions.position" );
             * 
             * // setter:
             * $( ".selector" ).ojMenu( "option", "submenuOpenOptions.position", { "my": "start top", "at": "end-5 top+5" } );
             */
            position: {
                /** @expose */
                my: "start top",
                /** @expose */
                at: "end top"
            }
        },

        // Events
        
        // Benefit of making openOptions live is this: 
        //
        // - For MenuButton and ContextMenu, the app doesn't control the call to Menu.open().
        // - Our internal call to this method may pass in overrides to things like "initialFocus", in cases where the Right Thing for (say) MenuButtons differs 
        //   from Menu's default option value (which may be tailored to, say, contextMenus). 
        //     - This way, we don't have to rely on the app to set these things correctly, and we don't have to permanently set the Menu's options, which may be 
        //       shared between (say) a MenuButton, a ContextMenu, and some custom app usage of the menu. 
        // - The remaining piece of the puzzle is to give the app a way to override the values set in our internal call to open().  A live payload field handles this.
        // - It's also useful for components like Table, Tree, DataGrid, and Tabs, that want to set the position to be the current cell / node / tab / etc.  (Another 
        //   way to do it would be to override _OpenContextMenu() and modify its call to open().)
        //
        // If ever needed, we can add a "submenuOpenOptions" payload field alongside the "openOptions" field.
        /**
         * <p>Triggered before this menu is launched via the <code class="prettyprint">open()</code> method or via menu button or context menu functionality.
         * The launch can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         * 
         * <p>The <code class="prettyprint">ui.openOptions</code> payload field contains the settings being used for this menu launch, 
         * resulting from merging the <code class="prettyprint">openOptions</code> passed to <code class="prettyprint">open()</code>, if any, 
         * with the <code class="prettyprint">openOptions</code> component option.  
         * 
         * <p>This field is "live", meaning that the listener can alter fields such as <code class="prettyprint">position</code> to affect this launch without 
         * affecting the component option.  Since these changes are applied to the merged object, they supersede both the <code class="prettyprint">openOptions</code> 
         * passed to <code class="prettyprint">open()</code> and the <code class="prettyprint">openOptions</code> component option.
         * 
         * <p>If any of the above techniques are used to alter the built-in menu button or context menu functionality, it is the app's responsibility to ensure that 
         * the result is both correct and accessible.  
         *
         * @expose 
         * @event 
         * @memberof oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {Object} ui.openOptions Settings in use for this menu launch.
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">beforeOpen</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "beforeOpen": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeopen</code> event:</caption>
         * $( ".selector" ).on( "ojbeforeopen", function( event, ui ) {} );
         */
        beforeOpen: null,
        
        /**
         * Triggered when the menu is created.
         *
         * @event 
         * @name create
         * @memberof oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Currently empty
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
        
        /**
         * <p>Triggered when the active menu item changes.  Private; do not use.
         * 
         * <p>Internal notes:  
         * 
         * <p>We've replaced JQUI's focus/blur events with this internal event, and made their focus/blur methods internal.
         * It's been agreed with the architects that if we ever need any of this API 
         * to be public, we'll have a focusedItem option, read-only or R/W, with an optionChange event, instead 
         * of the removed API.  (Exact name TBD, but they favored focusedRow, with "ed",  for Table if it had an option rather than 
         * a method.)  If for some reason we keep a separate event instead of an optionChange event, do NOT call this event 
         * "focusedItem", since that will prevent ever having an "focusedItem" option since same namespace.  Instead, call this 
         * "focusedItemChange" in that case.
         * 
         * <p>In the meantime, we'll keep firing this private event, since it's used so extensively and usefully in the unit tests to make sure 
         * other stuff works, and since keeping this working and tested means that we can just change the name to optionChange if 
         * we ever need the public event.  
         * 
         * <p>The difference between this method and JQUI's focus event is that it fires for blurs too, it doesn't fire if the old 
         * and new active item are the same, and we fire a single event, not both a blur and focus, when the active state moves from item A to 
         * item B.
         *
         * @event 
         * @name _activeItem
         * @memberof oj.ojMenu
         * @instance
         * @private
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.previousItem the previously focused menu item
         * @property {jQuery} ui.item the currently focused menu item
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">_activeItem</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "_activeItem": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">oj_activeitem</code> event:</caption>
         * $( ".selector" ).on( "oj_activeitem", function( event, ui ) {} );
         */
        
        /**
         * Triggered when a menu item is selected.  The only correct, supported way to react to the selection of a 
         * menu item is to listen for this event.  Click listeners and <code class="prettyprint">href</code> navigation should not be used. 
         *
         * @expose 
         * @event 
         * @memberof oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.item the selected menu item 
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">select</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "select": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
         * $( ".selector" ).on( "ojselect", function( event, ui ) {} );
         */
        select: null
    },

    _create: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        // Create aliases, that won't be renamed, for the private methods that are called by unit tests.  These unit tests come 
        // from JQUI, in which these methods were actually public.  With these aliases, we don't have to @expose private method names 
        // (which prevents renaming and bloats minified code), and our internal calls to these methods can be this._focus rather than this["_focus"].
        // TBD: perhaps the unit tests could simulate keyboard events rather than calling these methods.
        this["_focusForTesting"] = this._focus;
        this["_nextForTesting"] = this._next;
        this["_selectForTesting"] = this._select;
        
        this.activeMenu = this.element;
        // flag used to prevent firing of the click handler
        // as the event bubbles up through nested menus
        this.mouseHandled = false;
        this.element
            .uniqueId()
            .addClass( "oj-menu oj-component" )
            
            .toggleClass( "oj-menu-icons", !!this.element.find( ".oj-component-icon" ).length )
            
            .attr({
                "role": this.role,
                "tabIndex": "0"
            });
            // pass true to catch these events on all menus, not just enabled menus
            this._on(true, {
                //Required to stick the focus on disabled menu.
                "mousedown .oj-menu-item": function(event) {
                    if (this.options.disabled) {
                        event.preventDefault();
                    }
                },
                "click": function(event) {
                    if (this.options.disabled) {
                        event.preventDefault();
                    }
                },
                //On Esc key focus should be shifted to launcher and dismiss menu.
                "keydown": function(event) {
                    if (this.options.disabled) {
                        if (event.keyCode === $.ui.keyCode.ESCAPE) {
                            if (this._launcher) { // if this is a popup menu that's currently shown
                                this._focusLauncherAndDismiss(event);
                            }
                        }
                    }
                }
            });
        
        // needed since _setOption() is not automatically called at create time.
        // TBD: Would be a little better to toggle these 2 things rather than only setting them if true, as in superclass _setOption().
        if ( this.options.disabled ) {
            this.element
                .addClass( "oj-disabled" )
                .attr( "aria-disabled", "true" );
        }

        this._on({
            // Prevent focus from sticking to links inside menu after clicking
            // them (focus should always stay on UL during navigation).
            "mousedown .oj-menu-item > a": function( event ) {
                event.preventDefault();
            },
            "click .oj-disabled > a": function( event ) {
                event.preventDefault();
            },
            "click": function(event) {
                // when the click event bubbles out of the root menu element, we're done with it, so 
                // reset this flag to its initial value of false in preparation for the next click
                this.mouseHandled = false;
            },
            "click .oj-menu-item:has(a)": function( event ) {
                var target = $( event.target ).closest( ".oj-menu-item" );
                // the mouseHandled var ensures that the click is handled only for the originally clicked
                // menu item, not for the parent menu items to which it bubbles.
                if ( !this.mouseHandled && target.not( ".oj-disabled" ).length ) {
                    this.mouseHandled = true;
                    
                    // prevent page scrolling and appending # to page URL, which can interfere with routing, etc.
                    // Do this before the bailout so these things are prevented when user clicks a 2nd time on parent menu item.
                    // No need to additionally do this for Enter/Space handler, because menu root, not the anchor, has browser focus
                    // in that case, so anchor click behavior doesn't happen, so doesn't need to be prevented.
                    event.preventDefault();
                    
                    if (this.active && this.active.closest(target).length && this.active.get(0) != target.get(0)) {
                        //If current active menu item  is decendent of (and not equal to) target menu item then 
                        //sub menu of the curent target is already open and hence no need to 
                        //1. expand the sub menu 
                        //2. as current target is a menu item having sub menu no need to invoke this._select(event).
                        return;
                    }
                    // Open submenu on click
                    if ( target.has( ".oj-menu" ).length ) {
                        this._expand( event );
                    }
                    else {
                        //Invoke _select() only for leaf menu items
                        this._select(event);
                        if (!this.element.is(":focus")) {
                            // Redirect focus to the menu
                            this.element.trigger("focus", [true]);

                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if (this.active && this.active.parents(".oj-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                }
            },
            "mouseenter .oj-menu-item": function( event ) {
                var target = $( event.currentTarget );
                // Remove oj-focus-ancestor class from siblings of the newly focused menu item
                // to avoid a jump caused by adjacent elements both having a class with a border
                target.siblings().children( ".oj-focus-ancestor" ).removeClass( "oj-focus-ancestor" );
                this._focus( event, target );
            },
            "mouseleave": function( event ) {
                this._collapse( event, "eventSubtree" );
            },
            "mouseleave .oj-menu": function( event ) {
                this._collapse( event, "eventSubtree" );
            },
            "focus": function( event, keepActiveItem ) {
                if ( !keepActiveItem ) {
                    // If there's already an active item, keep it active
                    // If not, make the first item active
                    // TBD: is there a reason that JQUI needed to redundantly call _focus() on this.active when this.active was already set?
                    //      Or should we only call it when it's not set and we're calling it on the first menu item?
                    var item = this.active || this.element.children( ".oj-menu-item" ).eq( 0 );
                    this._focus( event, item );
                }
            },
            "keydown": this._keydown,
            "keyup": function( event ) {
                if (event.keyCode == $.ui.keyCode.ENTER || event.keyCode == $.ui.keyCode.SPACE) 
                    this.__spaceEnterDownInMenu = false;
            }
        });
        
        this._setup();

        this._registerClickAwayHandler();
        this._super();
    },

    //Registers one click away handler on document, only if it is not already registered by another menu widget.
    _registerClickAwayHandler: function() {
        var clikAwayHandler = this.document.data(this._MENU_CLICK_AWAY_HANDLER_KEY);
        if (!clikAwayHandler) {
        // Clicks outside of a menu collapse any open menus, and dismiss the entire menu if it's a popup
            clikAwayHandler = function(event) {
                //Focus event needs to be captured because, in case of menu button (where focus is still on menu button instead of open menu), if user does 
                //a taboff to another element then menu should be closed. With this we also no need to have additional "blur" handler on menu to close the menu popup/submenus.
                
                //Despite of focus/mousedown, still keydown listener is required for contextmenu events especially for menubutton with browser default context menu 
                //and user pressed contextmenu keyboard key(not right mouse click). 
                
                //Checking event.KeyCode along with event.which as currently event created by jquery-simulate.js is setting only event.keyCode for chrome/IE. 
                //This avoids test failures. This can be removed after jquery simulates event properly.
                
                if (event.type === "focus" || event.type === "mousedown" || event.which == 93 || (event.which == 121 && event.shiftKey) || event.keyCode == 93) { // Windows contextMenu key (93) or Shift-F10 (121)
                    //Clone _openPopupMenus as __dismiss() will remove the open menu from _openPopupMenus list                   
                    var openPopupMenus = _openPopupMenus.slice(0, _openPopupMenus.length);
                    $.each(openPopupMenus , function(index, menu) {
                        //Close all open menus unless the mouseDown/focus/keyDown event came from that specific menu.
                        if (!$(event.target).closest(menu.element).length &&  // if event target is outside of menu element AND one of the following is true then close the menu.
                            (event.type === "keydown" || (event.type === "mousedown" && event.which === 3) ||  //1. if it is a contextmenu event(see event.which on outer if)
                             !$(event.target).closest(menu._launcher).length ||  // 2. When focus is moved on to other than launcher or left/middle mousedown on element other than launcher
                             (menu._isContextMenu && event.type === "mousedown" && event.which !== 3))) { //3. If event is a left/middle-mousedown on launcher and current menu is contextmenu ( see bug 18745414)
                            menu._collapse(event, "eventSubtree"); // is effectively "all" since we check that event is outside menu.  "all" would be clearer, but just in case, leaving it as is.
                            if (menu._launcher)
                                menu.__dismiss(event);
                        }
                    });
                };
            }

            this.document.data(this._MENU_CLICK_AWAY_HANDLER_KEY, clikAwayHandler);
            //Capture the event on document to close the menu popup. Must do this in capture phase so that menu is closed even if something eats the event.
            this.document[0].addEventListener("keydown", clikAwayHandler, true);    
            this.document[0].addEventListener("mousedown", clikAwayHandler, true);
            this.document[0].addEventListener("focus", clikAwayHandler, true);
        }
    },

    //Unregisters click away handler on document, only if there are no menu widgets on the page.
    _unregisterClickAwayHandler: function() {
        var clikAwayHandler = this.document.data(this._MENU_CLICK_AWAY_HANDLER_KEY);
        //Remove click away handler while destroying last menu instance.
        if (clikAwayHandler && $(":oj-menu").length === 1 ) {
            //Ensure that all listeners removed on document while destroying the menu.   
            this.document[0].removeEventListener("keydown", clikAwayHandler, true);
            this.document[0].removeEventListener("mousedown", clikAwayHandler, true);
            this.document[0].removeEventListener("focus", clikAwayHandler, true);
            this.document.removeData(this._MENU_CLICK_AWAY_HANDLER_KEY);
        }
    },
    
    _setOption: function( key, value ) { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this._superApply( arguments );
        
        // this._submenuPosition is used every time a *sub*menu is opened.
        // For non-popup menus, this is set only here and in _setup().
        // For popup menus, this is set in each call to open(), and not changed by the following code while the popup is still open,
        // since while it is still open it should keep using the merged value from open()/beforeOpen, not the new value of the component option.
        if (!this._launcher) { // if this is not a popup menu that's currently shown
            if (key === "submenuOpenOptions")
                this._submenuPosition = oj.PositionUtils.normalizeHorizontalAlignment(value.position, this.isRtl);
            else if (key === "submenuOpenOptions.position")
                this._submenuPosition = oj.PositionUtils.normalizeHorizontalAlignment(value, this.isRtl);
        }
    },
    
    _destroy: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        // Destroy (sub)menus
        this.element
            .removeAttr( "aria-activedescendant" )
            .find( ".oj-menu" ).addBack()
                .removeClass( "oj-menu oj-component oj-menu-icons" )
                .removeAttr( "role" )
                .removeAttr( "tabIndex" )
                .removeAttr( "aria-labelledby" )
                .removeAttr( "aria-hidden" )
                .removeAttr( "aria-disabled" )
                .removeUniqueId()
                .show();

        // Destroy menu items
        this.element.find( ".oj-menu-item" )
            .removeClass( "oj-menu-item" )
            .removeAttr( "role" )
            .children( "a" )
                .removeAttr( "aria-disabled" )
                .removeUniqueId()
                .removeClass( "oj-hover" )
                .removeAttr( "tabIndex" )
                .removeAttr( "role" )
                .removeAttr( "aria-haspopup" )
                .children().each( function() {
                    var elem = $( this );
                    if ( elem.data( "oj-ojMenu-submenu-icon" ) ) {
                        elem.remove();
                    }
                });

        // Destroy anchors
        this.element.find( "a" ).removeAttr( "aria-expanded" );
        
        // Destroy menu dividers
        this.element.find( ".oj-menu-divider" )
            .removeClass( "oj-menu-divider" )
            .removeAttr( "role" );
        
        this._unregisterClickAwayHandler();

        // Remove the menu from openPopupMenus list if it is still added.
        if(_openPopupMenus.indexOf(this) >= 0)
            _openPopupMenus.splice(_openPopupMenus.indexOf(this),1);
    },

    _keydown: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        /*jshint maxcomplexity:20*/
        var match, prev, character, skip, regex,
            preventDefault = true;

        function escape( value ) {
            return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
        }

        switch ( event.keyCode ) {
        case $.ui.keyCode.HOME:
            this._move( "first", "first", event );
            break;
        case $.ui.keyCode.END:
            this._move( "last", "last", event );
            break;
        case $.ui.keyCode.UP:
            this._previous( event );
            break;
        case $.ui.keyCode.DOWN:
            this._next( event );
            break;
        case $.ui.keyCode.LEFT:
        case $.ui.keyCode.RIGHT:
            var isExpand = (event.keyCode === $.ui.keyCode.RIGHT) ^ this.isRtl;
            if (isExpand) {
                if ( this.active && !this.active.is( ".oj-disabled" ) ) {
                    this._expand( event );
                }
            } else {
                this._collapse( event, "active" );
            }
            break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
            this._handleEnterSpace( event );
            
            this.__spaceEnterDownInMenu = true;
            var self = this;
            
            // The spaceEnterDelay and __spaceEnterDownInMenu code addresses an issue where closing a menu, from within the menu via 
            // Space or Enter, can immediately reopen the menu, because the keyUp can happen after focus has jumped to the button, 
            // which clicks the button, which reopens the menu.  Repros most readily (only??) in Firefox.
            // TODO: try calling preventDefault() on the event in Menu (which is good practice anyway since it's handling the event), and 
            // checking isDefaultPrevented() in Button.  If works, should be cleaner / more reliable than this existing fix.
            var spaceEnterDelay = 100; // 1 not enough in FF; 100 seems to do it.  If continued problems, try increasing this value.

            setTimeout(function () {
                self.__spaceEnterDownInMenu = false;
            }, spaceEnterDelay); 
            
            break;
        // this handles enabled menus.  For disabled menus, see this handler: this._on(true, {...});
        case $.ui.keyCode.ESCAPE:
            if (this._launcher) { // if this is a popup menu that's currently shown
                var activeItemId = this.element.attr("aria-activedescendant"); // <a> or nothing.  Always the same as this.active now that we change them in lockstep.
                var topLevelAnchorSelector = "#" + this.element.attr("id") + ">*>a"; // * is typically <li>
                var submenuOpen = activeItemId && !$("#" + activeItemId).is( topLevelAnchorSelector );

                if (submenuOpen)
                    this._collapse( event, "active" );
                else
                    this._focusLauncherAndDismiss( event );
            } else {
                this._collapse( event, "active" );
            }
            break;
        default:
            preventDefault = false;
            prev = this.previousFilter || "";
            character = String.fromCharCode( event.keyCode );
            skip = false;

            clearTimeout( this.filterTimer );

            if ( character === prev ) {
                skip = true;
            } else {
                character = prev + character;
            }

            regex = new RegExp( "^" + escape( character ), "i" );
            match = this.activeMenu.children( ".oj-menu-item" ).filter(function() {
                return regex.test( $( this ).children( "a" ).text() );
            });
            match = skip && match.index( this.active.next() ) !== -1 ?
                this.active.nextAll( ".oj-menu-item" ) :
                match;

            // If no matches on the current filter, reset to the last character pressed
            // to move down the menu to the first item that starts with that character
            if ( !match.length ) {
                character = String.fromCharCode( event.keyCode );
                regex = new RegExp( "^" + escape( character ), "i" );
                match = this.activeMenu.children( ".oj-menu-item" ).filter(function() {
                    return regex.test( $( this ).children( "a" ).text() );
                });
            }

            if ( match.length ) {
                this._focus( event, match );
                if ( match.length > 1 ) {
                    this.previousFilter = character;
                    this.filterTimer = this._delay(function() {
                        delete this.previousFilter;
                    }, 1000 );
                } else {
                    delete this.previousFilter;
                }
            } else {
                delete this.previousFilter;
            }
        }

        if ( preventDefault ) {
            event.preventDefault();
        }
    },

    /*
     * Called for Space and Enter
     */
    _handleEnterSpace: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if ( !this.active.is( ".oj-disabled" ) ) {
            if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
                this._expand( event );
            } else {
                this._select( event );
            }
        }
    },

    /**
     * Refreshes the visual state of the menu. JET components require a <code class="prettyprint">refresh()</code> after the DOM is 
     * programmatically changed underneath the component.  For Menu, this includes:
     * 
     * <ul>
     *   <li>After menu items or submenus are added or removed.</li>
     *   <li>After a change to a menu item's disabled status (which is set by applying or removing the <code class="prettyprint">oj-disabled</code> 
     *       class from the menu item).</li>
     *   <li>After the reading direction (LTR vs. RTL) changes.</li>
     * </ul>
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof oj.ojMenu
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojMenu( "refresh" );
     */
    refresh: function() { // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
        this._super();
        this._setup();
    },

    _setup: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.isRtl = this._GetReadingDirection() === "rtl";
        
        // Used every time a *sub*menu is opened.
        // For non-popup menus, this is set only here and in _setOption().
        // For popup menus, this is set in each call to open().  
        this._submenuPosition = oj.PositionUtils.normalizeHorizontalAlignment(this.options.submenuOpenOptions.position, this.isRtl);
        
        var self=this,
            menus,
            submenus = this.element.find( this.options.menuSelector );

        // Initialize nested menus
        submenus.filter( ":not(.oj-menu)" )
            .addClass( "oj-menu oj-component" )
            .hide()
            .attr({
                "role": this.role,
                "aria-hidden": "true"
            })
            .each(function() {
                var menu = $( this ),
                    item = self._getSubmenuItem( menu ),
                    submenuIcon = $( "<span>" );
                
                submenuIcon   // separate stmt rather than chaining, since GCC can't tell that this is the setter overload of .data().
                    .addClass( "oj-menu-submenu-icon oj-component-icon" )
                    .data( "oj-ojMenu-submenu-icon", true ); // TODO: can't we just look for the class at destroy time rather than adding this data?

                item
                    .attr( "aria-haspopup", "true" )
                    .attr( "aria-expanded", "false" ) // per a11y team, live on <a>, not <ul> like JQUI
                    .prepend( submenuIcon );
                var itemId = /** @type {string|undefined}  tell GCC is getter, not setter, overload of attr() */
                             (item.attr( "id" ));
                
                // itemId is undefined if id attr not present, in which case following stmt is a chainable no-op (returns 
                // "this" and doesn't set anything).
                menu.attr( "aria-labelledby", itemId );
            });

        menus = submenus.add( this.element );
        var children = menus.children();
        
        // Anything that used to be a divider, but now has an "a", should become a menu element.
        children.filter( ".oj-menu-divider" ).has("a")
            .removeClass("oj-menu-divider oj-menu-item") // remove oj-menu-item if somehow present to ensure that it enters following block
            .removeAttr("role");
        
        // Don't refresh list items that are already adapted
        // TBD: .has prob has better perf than :has
        children.filter( ":not(.oj-menu-item):has(a)" )
            .addClass( "oj-menu-item" )
            .attr( "role", "presentation" )
            .children( "a" )
                .uniqueId()
                .attr({
                    "tabIndex": "-1",
                    "role": this._itemRole()
                });

        // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
        children.filter( ":not(.oj-menu-item)" ).each(function() {
            var item = $( this );
            // hyphen, em dash, en dash
            if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
                item.addClass( "oj-menu-divider" )
                    .attr( "role", "separator" );
            }
        });

        // Add aria-disabled to any disabled menu item, and remove it from any recently enabled menu item
        children.filter( ".oj-disabled" ).children( "a" ).attr( "aria-disabled", "true" );
        children.filter( ":not(.oj-disabled)" ).children( "a" ).removeAttr( "aria-disabled" );

        // If the active item has been removed, blur the menu
        if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
            this._blur();
        }
    },
    
    /*
     * Given a list of one or more submenus (typically <ul>'s), finds the <a>'s that are their labels.  
     */
    _getSubmenuItem: function(submenu) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return submenu.prev( "a" );
    },

    _itemRole: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return "menuitem"; 
//        {
//            "menu": "menuitem",
//            "listbox": "option"
//        }[ this.role ];
    },

    /**
     * Focuses the specified menu item and triggers the menu's <code class="prettyprint">_activeItem</code> event.
     * 
     * @memberof oj.ojMenu
     * @instance
     * @private
     * @param {Event} event - What triggered the menu item to gain focus.  May be <code class="prettyprint">null</code>, but may not be omitted.
     * @param {!jQuery} item - The menu item to focus.  Its containing submenu, if any, must already be expanded.
     */
    _focus: function( event, item ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // JQUI called blur() here.  This "if blah clearTimeout" is the only thing from that call that we (presumably) still want to do here.
        if ( !(event && event.type === "focus") )
            clearTimeout( this.timer );

        item = item.first();
        this._makeActive(item, event);

        // Highlight active parent menu item, if any
        item // li
            .parent() // ul
            .closest( ".oj-menu-item" ) // li
            .children( "a:first" ) // a
            .addClass( "oj-focus-ancestor" );

        if ( event && event.type === "keydown" ) {
            this._close();
        } else {
            this.timer = this._delay(function() {
                this._close();
            }, this.delay );
        }

        var nested = item.children( ".oj-menu" ); // immediately nested submenu.  length 0 or 1.
        if ( nested.length && event && ( /^mouse/.test( event.type ) && !this.active.hasClass( "oj-disabled" ) ) ) {
            this._startOpening(nested);
        }
        this.activeMenu = item.parent();
    },

    /*
     * Sets this.active (<li>), aria-activeDescendant (<a>), and oj-focus (<a>) in lockstep.  
     * Never set those things outside of _makeActive() and _removeActive(), so they stay in synch!
     * 
     * param item length-1 JQ object containing the <li> to focus
     */
    _makeActive: function( item, event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // don't need to check for "both items null/empty", and don't need to null-check item, since item required to be length-1 JQ object
        var same = item.is(this.active);
        if (same) {
            return;
        }
        
        var previousItem = this.active ? this.active : $();
        var anchor = item.children( "a" );
        
        this.active = item;
        this.element.attr( "aria-activedescendant", anchor.attr( "id" ) );
        
        previousItem.children( "a" ).removeClass( "oj-focus" );
        anchor.addClass( "oj-focus" );
        
        // see private API doc on the private _activeItem event declaration in this file
        this._trigger( "_activeItem", event, { "previousItem": previousItem , "item": item, "privateNotice": "The _activeItem event is private.  Do not use." } );
    },

    /*
     * Unsets this.active (<li>), aria-activeDescendant (<a>), and oj-focus (<a>) in lockstep.
     * Never set those things outside of _makeActive() and _removeActive(), so they stay in synch!
     * 
     * Don't call this if you are immediately going to call _makeActive, to avoid firing the event twice (and redundant work).
     */
    _removeActive: function(event) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if ( this.active ) { // then there is definitely a change, from "something focused" to "nothing focused", so proceed.
            var previousItem = this.active; // non-null, so don't need null-check
            
            this.active = null;
            this.element.removeAttr( "aria-activedescendant");
            
            previousItem.children( "a" ).removeClass( "oj-focus" );
            
        // see private API doc on the private _activeItem event declaration in this file
            this._trigger( "_activeItem", event, { "previousItem": previousItem, "item": $(), "privateNotice": "The _activeItem event is private.  Do not use." } );
        }
    },

    /**
     * @memberof oj.ojMenu
     * @instance
     * @private
     * @param {Event=} event - What triggered the menu item to blur.  May be <code class="prettyprint">null</code> or omitted.
     */
    _blur: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        clearTimeout( this.timer );
        this._removeActive(event);
    },
    
    _focusLauncherAndDismiss: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this._launcher.focus();
        this.__dismiss( event );
    },
    
    /*
     * TODO: JSDoc, including making it private-but-actually-internal, then add 2nd star above
     * Could make this method, and the event, public, if ever needed.
     * 
     */
    __dismiss: function(event) { // Internal visibility; called by Button's MenuButton functionality.  Not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.element.hide().attr( "aria-hidden", "true" );
        this._launcher = undefined;
        
        // TODO: if keep this, check whether actually open first, to avoid spurious events
        this._trigger( "__dismiss", event, {} ); // internal event

        //Remove menu from openPopupMenus list
        if(_openPopupMenus.indexOf(this) >= 0)
            _openPopupMenus.splice(_openPopupMenus.indexOf(this),1);
    },
    
    /**
     * <p>Launches this menu as a popup, after firing the <code class="prettyprint">beforeOpen</code> event.  Listeners to that event can cancel the launch 
     * via <code class="prettyprint">event.preventDefault()</code>.
     * 
     * <p>This method's optional <code class="prettyprint">openOptions</code> and <code class="prettyprint">submenuOpenOptions</code> params can be used to specify 
     * per-launch values for the settings in the corresponding component options, without altering those options.  Those per-launch values can 
     * be further customized by a <code class="prettyprint">beforeOpen</code> listener.
     * 
     * @expose
     * @memberof oj.ojMenu
     * @instance
     * 
     * @param {Event=} event What triggered the menu launch.  May be <code class="prettyprint">null</code>.  May be omitted if subsequent params are omitted.
     * @param {Object=} openOptions Options to merge with the <code class="prettyprint">openOptions</code> option.  May be <code class="prettyprint">null</code>.  May be omitted if subsequent params are omitted.
     * @param {Object=} submenuOpenOptions Options to merge with the <code class="prettyprint">submenuOpenOptions</code> option.  May be <code class="prettyprint">null</code> or omitted.
     * 
     * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
     * // override the launcher for this launch only, without affecting the other 
     * // openOptions, and without affecting the component's openOptions option
     * $( ".selector" ).ojMenu( "open", myEvent, {launcher: "#myLauncher"} );
     */
    open: function( event, openOptions, submenuOpenOptions ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        openOptions = $.extend({}, this.options.openOptions, openOptions);
        submenuOpenOptions = $.extend({}, this.options.submenuOpenOptions, submenuOpenOptions);

        // we don't know at create time that we're a popup, so do popup init on first call to open, which is when we find out we're a popup.
        if (!this._popupInited) {
            this._popupInit();
            this._popupInited = true;
        }
        
        this._isContextMenu = event ? (((event.type === "mousedown" || event.type === "contextmenu") && event.which === 3) || 
                                            event.which == 93 || 
                                            (event.which == 121 && event.shiftKey))
                                    : false;
        
        // Important:  Do the merging *before* calling _trigger(), and don't use the merged values until *after* the call.
        // Reason:  Per doc on open() and beforeOpen event, we pass the merged openOptions to beforeOpen listeners as a "live" object, 
        // so the listener can both read and write the values used for this launch.  We may eventually pass submenuOpenOptions too.
        var cancelled = !this._trigger( "beforeOpen", event, {openOptions: openOptions});
        
        if (cancelled) 
            return;
        
        var launcher = openOptions.launcher;
        launcher = $.type(launcher) === "string" 
                   ? $(launcher)
                   : launcher;
        
        if (!launcher || !launcher.length) {
            // need launcher so can return focus to it.
            oj.Logger.warn("When calling Menu.open(), must specify openOptions.launcher via the component option, method param, or beforeOpen listener.  Ignoring the call.");
            return;
        }
        
        //Close all other open menus
        var currentMenu = this.element[0];
        //Clone _openPopupMenus as __dismiss() will remove the open menu from _openPopupMenus list
        var openPopupMenus = _openPopupMenus.slice(0, _openPopupMenus.length);
        $.each(openPopupMenus , function(index, menu) {
            if (menu.element[0] !== currentMenu) {
                menu._collapse( event, "eventSubtree"); // TBD: should this be "all"?
                if (menu._launcher)
                    menu.__dismiss(event);
            }
        });
        
        var position = oj.PositionUtils.normalizeHorizontalAlignment(openOptions.position, this.isRtl);
        
        if (position.of == null) {
            // TBD: this isRightClick check works so far, but supposedly browsers are supposed to fire contextmenu event for Shift-F10 too, 
            // so might have to check other stuff like coordinates to distinguish from keyboard.
            var isRightClick = (event && event.type === "contextmenu");
            position.of = isRightClick ? event : launcher;
        }
        
        // cache the merged value for use while the (outer) menu is still open
        this._submenuPosition = oj.PositionUtils.normalizeHorizontalAlignment(submenuOpenOptions.position, this.isRtl);
        
        this.element
            .show()
            .removeAttr( "aria-hidden" )
            .position( position );
    
        var initialFocus = openOptions.initialFocus;
        
        var focusFirstItem = initialFocus === "firstItem";
        var focusMenu = focusFirstItem || initialFocus === "menu" ;
        
        if (focusMenu)
            this.element.focus();

        if (focusFirstItem) {
            this._focus(event, this.element.children().first());
        } else {
            this._blur(event);
        }

        // store launcher so we can return focus to it, e.g. if Esc pressed.  Ivar is non-null iff menu is a popup and is currently shown.
        this._launcher = launcher;

        //Add current menu to openPopupMenus so that it will be closed on focus lost/click away.
        _openPopupMenus.push(this);
    },
    
    _popupInit: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.element.css({position: 'absolute'}); // make it a popup menu
    },
    
    _startOpening: function( submenu ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        clearTimeout( this.timer );

        // Don't open if already open fixes a Firefox bug that caused a .5 pixel
        // shift in the submenu position when mousing over the submenu icon
        if ( submenu.attr( "aria-hidden" ) !== "true" ) {
            return;
        }

        this.timer = this._delay(function() {
            this._close();
            this._open( submenu );
        }, this.delay );
    },
    
    // opens a *sub*menu
    _open: function( submenu ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var position = $.extend( {"of": this.active}, this._submenuPosition); // normalizeHorizontalAlignment() was already called on the ivar

        clearTimeout( this.timer );
        this.element.find( ".oj-menu" ).not( submenu.parents( ".oj-menu" ) )
            .hide()
            .attr( "aria-hidden", "true" );

        submenu
            .show()
            .removeAttr( "aria-hidden" )
            .position( position );
        
        this._getSubmenuItem(submenu).attr( "aria-expanded", "true" );
        
        if (!this._launcher && _openPopupMenus.indexOf(this) < 0) {
            _openPopupMenus.push(this);
        }
    },

    /*
     * Same as calling _collapse(event, "eventSubtree") or _collapse(event, "all"), except that, if delay param is not passed, it collapses the menu immediately.
     */
    __collapseAll: function(event, all, delay) {
        clearTimeout(this.timer);
        var self = this;
        var collapseMenu = function() {
            // If we were passed an event, look for the submenu that contains the event
            var currentMenu = all ? self.element :
                $(event && event.target).closest(self.element.find(".oj-menu"));

            // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
            if (!currentMenu.length) {
                currentMenu = self.element;
            }

            self._close(currentMenu);

            self._blur(event);
            self.activeMenu = currentMenu;
        };
        if (delay) {
            this.timer = this._delay(collapseMenu, delay);
        } else {
            collapseMenu();
        }
    },

    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function( startMenu ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if ( !startMenu ) {
            startMenu = this.active ? this.active.parent() : this.element;
        }

        var menus = startMenu.find( ".oj-menu" );
        menus.hide()
             .attr( "aria-hidden", "true" );
        this._getSubmenuItem( menus ).attr( "aria-expanded", "false" );
        startMenu.find( "a.oj-focus-ancestor" ).removeClass( "oj-focus-ancestor" );

        if (!this._launcher) {
            // If the current menu is not a popup menu and it's submenu is already open then remove the menu from _openPopupMenus 
            // while closing the submenus of top level menu.
            if (_openPopupMenus.indexOf(this) >= 0) {
                if (startMenu === this.element) {
                    _openPopupMenus.splice(_openPopupMenus.indexOf(this), 1);
                }
            }
        }
    },

    /**
     * Closes one or more open submenus.
     * 
     * @memberof oj.ojMenu
     * @instance
     * @private
     * @param {Event=} event - What triggered the menu to collapse.  May be <code class="prettyprint">null</code>.  
     *                         May be omitted if the <code class="prettyprint">which</code> parameter is omitted.
     * @param {string=} which - Optional; defaults to <code class="prettyprint">"active"</code>.  Values are the following <code class="prettyprint">string</code>s:
     *     <ul>
     *       <li><code class="prettyprint">"active"</code>: Closes the currently active submenu.</li>
     *       <li><code class="prettyprint">"all"</code>: Closes all submenus.</li>
     *       <li><code class="prettyprint">"eventSubtree"</code>: Closes submenus below but not including the menu that is or contains the target of the triggering event.</li>
     *     </ul>
     */
    _collapse: function( event, which ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (which == null || which === "active") {
            var newItem = this.activeMenu &&
                this.activeMenu.closest( ".oj-menu-item", this.element );
            if ( newItem && newItem.length ) {
                this._close();
                this._focus( event, newItem );
            }
        } else if ( which === "all" || which === "eventSubtree") {
            this.__collapseAll(event, which === "all", this.delay);
        } else {
            oj.Logger.warn("Invalid param " + which + " passed to Menu._collapse().  Ignoring the call.");
        }
    },

    /**
     * Opens the submenu below the currently focused item, if one exists.
     * 
     * @memberof oj.ojMenu
     * @instance
     * @private
     * @param {Event=} event - What triggered the menu to expand.  May be <code class="prettyprint">null</code> or omitted.
     */
    _expand: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var newItem = this.active &&
            this.active
                .children( ".oj-menu " )
                .children( ".oj-menu-item" )
                .first();

        if ( newItem && newItem.length ) {
            this._open( newItem.parent() );

            // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
            this._delay(function() {
                this._focus( event, newItem );
            });
        }
    },

    /**
     * Focuses the next menu item, wrapping at the bottom, as if <kbd>DownArrow</kbd> had been pressed.
     * 
     * @memberof oj.ojMenu
     * @instance
     * @private
     * @param {Event=} event - What triggered the focus to move.  May be <code class="prettyprint">null</code> or omitted.
     */
    _next: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this._move( "next", "first", event );
    },

    /**
     * Focuses the previous menu item, wrapping at the top, as if <kbd>UpArrow</kbd> had been pressed.
     * 
     * @memberof oj.ojMenu
     * @instance
     * @private
     * @param {Event=} event - What triggered the focus to move.  May be <code class="prettyprint">null</code> or omitted.
     */
    _previous: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this._move( "prev", "last", event );
    },

    _isFirstItem: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return this.active && !this.active.prevAll( ".oj-menu-item" ).length;
    },

    _isLastItem: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return this.active && !this.active.nextAll( ".oj-menu-item" ).length;
    },

    _move: function( direction, filter, event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var next;
        if ( this.active ) {
            if ( direction === "first" || direction === "last" ) {
                next = this.active
                    [ direction === "first" ? "prevAll" : "nextAll" ]( ".oj-menu-item" )
                    .eq( -1 );
            } else {
                next = this.active
                    [ direction + "All" ]( ".oj-menu-item" )
                    .eq( 0 );
            }
        }
        if ( !next || !next.length || !this.active ) {
            next = this.activeMenu.children( ".oj-menu-item" )[ filter ]();
        }

        this._focus( event, next );
    },

    /* TODO: update JSdoc to be something like this revised version, once todo's in code are resolved.  
     * Let selectItem be the currently focused menu item if any, else the menu item containing the target of the supplied event if any, else null.
     * 
     * If selectItem is non-null, this method selects that item, collapses all submenus, and triggers the menu's 
     * <code class="prettyprint">select</code> event.
     *
     * Internally, this method should not be invoked for parent menu items or disabled menu items. But still there is a chance of 
     * invoking _select() externally. (Not anymore now that it's private.) In that case, if focused menu item is a disabled or parent menu item then a warning message will be logged.
     */
    /**
     * Selects the currently focused menu item, collapses all submenus and triggers the menu's <code class="prettyprint">select</code> event.  
     * 
     * @memberof oj.ojMenu
     * @instance
     * @private
     * @param {Event=} event - What triggered the selection.  May be <code class="prettyprint">null</code> or omitted.
     */
    _select: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // If no menu item is focused, then infer one from the event if possible.  TBD: still need this now that not public?  Or is this.active always set?
        if (!this.active && event && event.target ) {
            var menuItem = $( event.target ).closest( ".oj-menu-item" );
            if (menuItem.closest( this.element ).length)
                this._makeActive(menuItem, event);
        }
        
        if (!this.active) {
            // If we reach here, this must be an external call to the method.
            oj.Logger.warn("Menu._select() called when no menu item is focused and no menu item can be inferred from event param.");
            return;
        }
        
        // now we know this.active is non-null
        if (this.active.has( ".oj-menu" ).length || this.active.is( ".oj-disabled" )) {
            // If we reach here, this must be an external call to the method.
            oj.Logger.warn("Selecting a disabled menu item or parent menu item is not allowed.");
            return;
        }
        
        var ui = { "item": this.active }; // must grab this.active before calling __collapseAll, which clears this.active
        
        // The menu item has been selected, so we can collapse all menus immediately with no timeout via __collapseAll.
        // If we call the version with a timeout, _collapse(event, "all"), then mouseleave event handler will invoke _collapse(event, "eventSubtree") on event.target 
        // which will clear our scheduled _collapse(event, "all") on this.element, so that submenu will not be collapsed,
        // which means that when the menu is later re-launched, the submenu is already open. 
        this.__collapseAll( event, true );

        // if this is a popup menu that's currently shown
        if (this._launcher) {
            this._focusLauncherAndDismiss(event);
        }
        
        // TODO: should this fire before or after calling __collapseAll (clears this.active and fires 
        // _activeItem event) and/or _focusLauncherAndDismiss() (browser-blurs and hides poupup menu)?
        this._trigger( "select", event, ui );
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the menu.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojMenu#widget
     * @memberof oj.ojMenu
     * @instance
     * @return {jQuery} the menu
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojMenu( "widget" );
     */

    /**
     * Removes the menu functionality completely. This will return the element back to its pre-init state.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojMenu#destroy
     * @memberof oj.ojMenu
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojMenu( "destroy" );
     */
});

// "private static members" shared by all menus

// Array to track all opened menu popups. All the menus opened by Menu Buttons/ Context Menu/using menu.open() and standalone menus having open submenus, will be added to list 
// and later will be removed on __dismiss()/_close() on menu popup/standalone menu.
var _openPopupMenus = new Array();

}());

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/*
** Important:
** - This file is designed to be shared verbatim among the ADFui products.
** - Do not add framework-specific dependencies in this file (it must be self-contained).
** - Do not change this file without testing it in other ADFui products (ADF Faces, JET, etc.).
*/
if (!window.adf) { /** @expose */ window.adf = {}; };
//explicitly declare var adf to avoid compilation error in JET
var adf                        = window.adf;
adf.shared                     = adf.shared || {};
adf.shared.impl                = adf.shared.impl || {};
adf.shared.impl.conveyorBelt   = adf.shared.impl.conveyorBelt || {};
// must be explicitly assigned to the window.adf.shared.impl object for cross-framework sharing
/**
 * Constructor.
 * @param {Object} elem DOM element associated with the conveyor
 * @param {string} orientation Direction of scrolling, either horizontal or vertical
 * @param {Object} contentParent DOM element whose children are the items to scroll
 * @param {boolean} bRtl True if the reading direction is right-to-left, otherwise false
 * @param {Object} buttonInfo Map of properties for the following button information:
 *  - prevButtonId: Id to use for the scroll previous button,
 *  - nextButtonId: Id to use for the scroll next button,
 *  - prevButtonStyleClass: Style class name to use for the scroll previous button,
 *  - nextButtonStyleClass: Style class name to use for the scroll next button,
 *  - prevButtonIcon: Icon element to use for the scroll previous button,
 *  - nextButtonIcon: Icon element to use for the scroll next button,
 * @param {Object} callbackInfo Map of properties for the following callback information:
 *  - scrollFunc: Callback function to animate scrolling a DOM element, 
 *  - firstVisibleItemChangedFunc: Callback function to notify when the first visible item changes, 
 *  - addResizeListener: Callback function to add a resize listener for a DOM element
 *  - removeResizeListener: Callback function to remove a resize listener for a DOM element
 *  - callbackObj: Optional object on which the callback functions are defined
 *    has changed
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon = function(
  elem, orientation, contentParent, bRtl, buttonInfo, callbackInfo)
{
  this._elem = elem;
  this._orientation = orientation;
  this._contentParent = contentParent;
  this._bRtl = bRtl;
  if (buttonInfo)
  {
    //need to check for existence of properties on buttonInfo before assigning 
    //them to vars because advanced closure compiler will otherwise complain if 
    //they're not defined
    if (buttonInfo.prevButtonId)
      this._prevButtonId = buttonInfo.prevButtonId;
    if (buttonInfo.nextButtonId)
      this._nextButtonId = buttonInfo.nextButtonId;
    if (buttonInfo.prevButtonStyleClass)
      this._prevButtonStyleClass = buttonInfo.prevButtonStyleClass;
    if (buttonInfo.nextButtonStyleClass)
      this._nextButtonStyleClass = buttonInfo.nextButtonStyleClass;
    if (buttonInfo.prevButtonIcon)
      this._prevButtonIcon = buttonInfo.prevButtonIcon;
    if (buttonInfo.nextButtonIcon)
      this._nextButtonIcon = buttonInfo.nextButtonIcon;
  }
  if (callbackInfo)
  {
    //need to check for existence of properties on callbackInfo before assigning 
    //them to vars because advanced closure compiler will otherwise complain if 
    //they're not defined
    if (callbackInfo.scrollFunc)
      this._scrollFunc = callbackInfo.scrollFunc;
    if (callbackInfo.firstVisibleItemChangedFunc)
      this._firstVisibleItemChangedFunc = callbackInfo.firstVisibleItemChangedFunc;
    if (callbackInfo.callbackObj)
      this._callbackObj = callbackInfo.callbackObj;
    if (callbackInfo.addResizeListener)
      this._addResizeListenerFunc = callbackInfo.addResizeListener;
    if (callbackInfo.removeResizeListener)
      this._removeResizeListenerFunc = callbackInfo.removeResizeListener;
  }
  
  this._bExternalScroll = true;
  this._firstVisibleItemIndex = 0;
  
  //copied basic checks from AdfAgent
  var navUserAgent = navigator.userAgent;
  var agentName = navUserAgent.toLowerCase();
  if (agentName.indexOf("gecko/") !== -1)
  {
    this._bAgentGecko = true;
  }
  else if (agentName.indexOf("opera") !== -1)
  {
    this._bAgentOpera = true;
  }
  else if (agentName.indexOf("applewebkit") !== -1 ||
           agentName.indexOf("safari") !== -1)
  {
    this._bAgentWebkit = true;
  }
};

/**
 * Setup the conveyor belt.
 * @param {boolean} bInit True for initialization, false for refresh
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype.setup = function(bInit)
{
  var self = this;
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  if (bInit)
  {
    //create the content and overflow containers
    this._createInnerContainers();
    
    //create the next/prev buttons
    this._createPrevButton(this._prevButtonId, this._prevButtonStyleClass, this._prevButtonIcon);
    this._createNextButton(this._nextButtonId, this._nextButtonStyleClass, this._nextButtonIcon);
    
    var nextButton = this._nextButton;
    var tableCellDivNextButton = this._tableCellDivNextButton;
    if (tableCellDivNextButton)
    {
      //use the width of the div containing the button because it will include 
      //any margins specified in the button style class
      this._buttonWidth = tableCellDivNextButton.offsetWidth;
      this._buttonHeight = nextButton.offsetHeight;
    }
    else
    {
      var vertDivNextButton = this._vertDivNextButton;
      this._buttonWidth = nextButton.offsetWidth;
      //use the height of the div containing the button because it will include 
      //any margins specified in the button style class
      this._buttonHeight = vertDivNextButton.offsetHeight;
    }
    
    //hide the buttons until we know we need them
    this._hidePrevButton();
    this._hideNextButton();
    
    //handle the mouse wheel on the whole conveyor
    this._mouseWheelListener = function (event) {self._handleMouseWheel(event);};
    cbcClass._addBubbleEventListener(this._elem, "mousewheel", this._mouseWheelListener);
    cbcClass._addBubbleEventListener(this._elem, "wheel", this._mouseWheelListener);
    
    //handle swipe gestures on the overflow container, which excludes the next/prev buttons
    this._touchStartListener = function (event) {self._handleTouchStart(event);};
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchstart", this._touchStartListener);
    this._touchMoveListener = function (event) {self._handleTouchMove(event);};
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchmove", this._touchMoveListener);
    this._touchEndListener = function (event) {self._handleTouchEnd(event);};
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchend", this._touchEndListener);
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchcancel", this._touchEndListener);
    
    this._origScroll = 0;
  }
  else
  {
    //need to restore inner DOM to its initial state before we can accurately
    //calculate sizes
    this._reinitializeInnerDom();
  }

  //clear any old sizes so that new sizes will be calculated
  this._clearCachedSizes();
  //adjust overflow size
  this._adjustOverflowSize(bInit);
  //handle an initial resize
  this._handleResize(true);
  
  if (bInit && this._addResizeListenerFunc)
  {
    this._handleResizeFunc = function(width, height) {self._handleResize(false);};
    //listen for resizes on both the conveyor itself and on its content
    this._addResizeListenerFunc.call(this._callbackObj, this._elem, this._handleResizeFunc);
    this._addResizeListenerFunc.call(this._callbackObj, this._contentContainer, this._handleResizeFunc);
  }
};

/**
 * Destroy the conveyor belt.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype.destroy = function()
{
  var elem = this._elem;
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  cbcClass._removeBubbleEventListener(elem, "mousewheel", this._mouseWheelListener);
  cbcClass._removeBubbleEventListener(elem, "wheel", this._mouseWheelListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchstart", this._touchStartListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchmove", this._touchMoveListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchend", this._touchEndListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchcancel", this._touchEndListener);
  this._mouseWheelListener = null;
  this._touchStartListener = null;
  this._touchMoveListener = null;
  this._touchEndListener = null;
  
  //remove listeners before reparenting original children and clearing member 
  //variables
  if (this._removeResizeListenerFunc && this._handleResizeFunc)
  {
    this._removeResizeListenerFunc.call(this._callbackObj, elem, this._handleResizeFunc);
    this._removeResizeListenerFunc.call(this._callbackObj, this._contentContainer, this._handleResizeFunc);
  }
  this._handleResizeFunc = null;
  
  //move the original content children from the _contentTableDiv back to the 
  //original DOM element
  cbcClass._reparentChildrenFromTable(this._contentTableDiv, elem, this._isHorizontal());
  //clear the stored array of content elements
  this._arContentElements = null;
  if (this._tableDiv)
  {
    //the overflow, content, and buttons are all children of the table div
    elem.removeChild(this._tableDiv);
  }
  else
  {
    //the _contentContainer is a child of the _overflowContainer, so will be removed with it
    elem.removeChild(this._overflowContainer);
    elem.removeChild(this._vertDivNextButton);
    elem.removeChild(this._vertDivPrevButton);
  }
  
  this._nextButton = null;
  this._prevButton = null;
  this._contentContainer = null;
  this._overflowContainer = null;
  this._contentTableDiv = null;
  this._tableDiv = null;
  this._tableCellDivPrevButton = null;
  this._tableCellDivNextButton = null;
  this._prevButtonWrapper = null;
  this._nextButtonWrapper = null;
  this._vertDivPrevButton = null;
  this._vertDivNextButton = null;
  this._clearCachedSizes();
  
  this._elem = null;
  this._scrollFunc = null;
  this._firstVisibleItemChangedFunc = null;
  this._addResizeListenerFunc = null;
  this._removeResizeListenerFunc = null;
  this._callbackObj = null;
};

/**
 * Set the id of the item to make first visible.
 * @param {string} id id of the item to make first visible
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype.setFirstVisibleItem = function(id)
{
  var sizes = this._getSizes();
  for (var i = 0; i < sizes.length; i++)
  {
    var sizeObj = sizes[i];
    if (sizeObj.id === id)
    {
      this._setCurrScroll(sizeObj.start, true);
      break;
    }
  }
};

/**
 * Reparent the DOM child nodes from their old parent node to a new parent table
 * node.
 * @param {Object} fromNode Old parent DOM node
 * @param {Object} toTable New parent table DOM node
 * @param {boolean} bHoriz True to make the table horizontal, false for vertical
 * @return {Array} Array of child elements reparented to the table
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._reparentChildrenToTable = function(fromNode, toTable, bHoriz)
{
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var tableRow = null;
  if (bHoriz)
  {
    tableRow = cbcClass._createTableRowDiv();
    toTable.appendChild(tableRow);
  }
  var arElements = null;
  
  var fromNodeChildren = fromNode.childNodes;
  while (fromNodeChildren.length > 0)
  {
    if (!arElements)
      arElements = [];
    
    var child = fromNodeChildren[0];
    if (child.nodeType === 1)
    {
      if (!bHoriz)
      {
        tableRow = cbcClass._createTableRowDiv();
        toTable.appendChild(tableRow);
      }
      
      var tableCell = cbcClass._createTableCellDiv();
      tableCell.appendChild(child);
      tableRow.appendChild(tableCell);
      arElements.push(child);
    }
    else
    {
      //if child is not an element node, simply append it to the table or 
      //tableRow without wrapping it in a tableCell
      if (bHoriz)
      {
        tableRow.appendChild(child);
      }
      else
      {
        toTable.appendChild(child);
      }
    }
  }
  return arElements;
};

/**
 * Reparent the DOM child nodes from a table to a new parent node.
 * @param {Object} fromTable Old parent table DOM node
 * @param {Object} toNode New parent DOM node
 * @param {boolean} bHoriz True if the table is horizontal, false if vertical
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._reparentChildrenFromTable = function(fromTable, toNode, bHoriz)
{
  if (!fromTable)
    return;
  
  var tableRows = fromTable.childNodes;
  while (tableRows.length > 0)
  {
    var tableRow = tableRows[0];
    if (tableRow.nodeType === 1)
    {
      var tableCells = tableRow.childNodes;
      while (tableCells.length > 0)
      {
        var tableCell = tableCells[0];
        if (tableCell.nodeType === 1)
        {
          var cellContent = tableCell.firstChild;
          toNode.appendChild(cellContent);
          //only reparented child of tableCell, so still need to remove
          //tableCell itself
          tableRow.removeChild(tableCell);
        }
        else
        {
          //if child is not an element node, simply append it to the new parent
          toNode.appendChild(tableCell);
        }
      }
      //need to remove row from table
      fromTable.removeChild(tableRow);
    }
    else
    {
      //if child is not an element node, simply append it to the new parent
      toNode.appendChild(tableRow);
    }
  }
};

/**
 * Get the computed style of the given DOM element.
 * @param {Object} elem DOM element
 * @return {Object} Computed style for the element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getComputedStyle = function(elem)
{
  var elemOwnerDoc = elem.ownerDocument;
  var defView = elemOwnerDoc.defaultView;
  var computedStyle = null;
  if (defView)
  {
    //this line copied from AdfAgent.getComputedStyle()
    computedStyle = defView.getComputedStyle(elem, null);
  }
  else
  {
    //this line copied from AdfIEAgent.getComputedStyle()
    computedStyle = elem.currentStyle;
  }
  return computedStyle;
};

/**
 * Get the inner width of the given DOM element (inside borders and padding).
 * @param {Object} elem DOM element
 * @return {number} Width of element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getElemInnerWidth = function(elem)
{
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var computedStyle = cbcClass._getComputedStyle(elem);
  //the computedStyle width is the inner width of the elem
  return cbcClass._getCSSLengthAsInt(computedStyle.width);
};

/**
 * Get the inner height of the given DOM element (inside borders and padding).
 * @param {Object} elem DOM element
 * @return {number} Height of element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getElemInnerHeight = function(elem)
{
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var computedStyle = cbcClass._getComputedStyle(elem);
  //the computedStyle height is the inner height of the elem
  return cbcClass._getCSSLengthAsInt(computedStyle.height);
};

/**
 * Get the int value of a CSS length.
 * @param {string} cssLength cssLength as a String
 * @return {number} cssLength as an int
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getCSSLengthAsInt = function(cssLength)
{
  //this function copied from AdfAgent.getCSSLengthAsInt
  if ((cssLength.length) > 0 && (cssLength != 'auto'))
  {
    var intLength = parseInt(cssLength, 10);

    if (isNaN(intLength))
      intLength = 0;

    return intLength;
  }
  return 0;
};

/**
 * Add a bubble event listener to the given DOM node.
 * @param {Object} node DOM node
 * @param {string} type Event type
 * @param {Function} listener Listener function
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._addBubbleEventListener = function(node, type, listener)
{
  if (node.addEventListener)
  {
    node.addEventListener(type, listener, false);
  }
  else if (node.attachEvent)
  {
    node.attachEvent("on" + type, listener);
  }
};

/**
 * Remove a bubble event listener from the given DOM node.
 * @param {Object} node DOM node
 * @param {string} type Event type
 * @param {Function} listener Listener function
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._removeBubbleEventListener = function(node, type, listener)
{
  if (node.removeEventListener)
  {
    node.removeEventListener(type, listener, false);
  }
  else if (node.detachEvent)
  {
    node.detachEvent("on" + type, listener);
  }
};

/**
 * Get the wheel delta from a mousewheel event.
 * @param {Object} event Event object
 * @return {number} Wheel delta
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getWheelDelta = function(event)
{
  var wheelDelta = 0;
  if (event.wheelDelta != null)
  {
    wheelDelta = event.wheelDelta;
  }
  //use bracket notation to avoid compilation warning in JET
  else if (event["deltaY"] != null)
  {
    wheelDelta = -event["deltaY"];
  }
  else
  {
    wheelDelta = -event.detail;
  }
  return wheelDelta;
};

/**
 * Create a div styled like a table.
 * @return {Node} div styled like a table row
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._createTableDiv = function()
{
  var tableDiv = document.createElement("div");
  var style = tableDiv.style;
  style.display = "table";
  return tableDiv;
};

/**
 * Create a div styled like a table row.
 * @return {Node} div styled like a table row
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._createTableRowDiv = function()
{
  var tableRowDiv = document.createElement("div");
  var style = tableRowDiv.style;
  style.display = "table-row";
  return tableRowDiv;
};

/**
 * Create a div styled like a table cell.
 * @return {Node} div styled like a table cell
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._createTableCellDiv = function()
{
  var tableCellDiv = document.createElement("div");
  var style = tableCellDiv.style;
  style.display = "table-cell";
  return tableCellDiv;
};

/**
 * Wrap the given element in an inline-block div and append it to the given 
 * parent element.  Restrict the max size of the wrapper div to be its reported 
 * offset size.  This helps prevent off-by-one pixel errors when the size of the
 * element is really a float instead of an int, as reported by the offset size.  
 * @param {Node} elem DOM element to wrap
 * @param {Node} parentElem Parent DOM element to append child to
 * @param {boolean} bWidth True to restrict the element's width, false otherwise
 * @param {boolean} bHeight True to restrict the element's height, false otherwise
 * @return {Node} The wrapper div element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._wrapAndRestrictSize = function(
  elem, parentElem, bWidth, bHeight)
{
  var wrapperDiv = document.createElement("div");
  var wrapperDivStyle = wrapperDiv.style;
  //make sure the wrapper div fits its content
  wrapperDivStyle.display = "inline-block";

  //need to add everything to the DOM before getting sizes
  wrapperDiv.appendChild(elem);
  parentElem.appendChild(wrapperDiv);
  
  //restrict the size of the wrapper div so that it's an integer value
  if (bWidth)
  {
    wrapperDivStyle.maxWidth = wrapperDiv.offsetWidth + "px";
  }
  if (bHeight)
  {
    wrapperDivStyle.maxHeight = wrapperDiv.offsetHeight + "px";
  }
  
  return wrapperDiv;
};

/**
 * Determine if this conveyor belt is horizontal or vertical.
 * @return {boolean} True if the conveyor belt is horizontal, false if vertical
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isHorizontal = function()
{
  return (this._orientation === "horizontal");
};

/**
 * Determine if this conveyor belt is empty.
 * @return {boolean} True if the conveyor belt is empty, false if not
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isEmpty = function()
{
  var contentParent = this._getContentParent();
  return !contentParent.hasChildNodes();
};

/**
 * Restore inner DOM to its initial state before sizes were calculated.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._reinitializeInnerDom = function()
{
  //restore inner DOM to initial state in order to accurately calculate new sizes

  //save original scroll value for use in _adjustOverflowSize()
  this._origScroll = this._getCurrScroll();
  this._clearOverflowMaxSize();
  this._setOverflowScroll(0);

  //hide the buttons until we know we need them
  this._hidePrevButton();
  this._hideNextButton();
};

/**
 * Clear cached sizes.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._clearCachedSizes = function()
{
  this._totalSize = null;
  this._sizes = null;
};

/**
 * Handle a component resize.
 * @param {boolean} bSetup True when called from setup, false otherwise
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleResize = function(bSetup)
{
  //if this is not the first call, need to reinitialize the inner DOM before
  //we can accurately calculate new sizes (if this is the first call, DOM
  //is already in initial state)
  if (!bSetup)
  {
    this._reinitializeInnerDom();
  }
  this._clearCachedSizes();
  if (!this._totalSize || !this._sizes)
  {
    //measure content size
    this._totalSize = this._measureContents();
  }
  //if this is not the first call, need to adjust the overflow size (if this 
  //is the first call, the overflow size was already adjusted in setup)
  if (!bSetup)
  {
    this._adjustOverflowSize();
  }
  //center buttons orthogonal to conveyor orientation
  var totalSize = this._totalSize;
  this._alignButtons(totalSize.w, totalSize.h);
};

/**
 * Center the overflow buttons orthogonal to the conveyor orientation.
 * @param {number} w Width to align inside
 * @param {number} h Height to align inside
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._alignButtons = function(w, h)
{
  var nextButton = this._nextButton;
  var prevButton = this._prevButton;
  var nextButtonStyle = nextButton.style;
  var prevButtonStyle = prevButton.style;
  
  if (this._isHorizontal())
  {
    var vOffset = .5 * (h - this._buttonHeight);
    nextButtonStyle.top = vOffset + "px";
    prevButtonStyle.top = vOffset + "px";
  }
  else
  {
    var hOffset = .5 * (w - this._buttonWidth);
    if (!this._bRtl)
    {
      nextButtonStyle.left = hOffset + "px";
      prevButtonStyle.left = hOffset + "px";
    }
    else
    {
      nextButtonStyle.left = -hOffset + "px";
      prevButtonStyle.left = -hOffset + "px";
    }
  }
};

/**
 * Adjust the overflow size.
 * @param {boolean} bInit True for initialization, false for refresh
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._adjustOverflowSize = function(bInit)
{
  var contentContainer = this._contentContainer;
  var bHoriz = this._isHorizontal();

  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var elemInnerSize = bHoriz ? 
                      cbcClass._getElemInnerWidth(this._elem) : 
                      cbcClass._getElemInnerHeight(this._elem);
  //constrain the max overflow size if necessary
  if ((bHoriz ? contentContainer.offsetWidth : contentContainer.offsetHeight) > elemInnerSize)
  {
    this._setOverflowMaxSize(elemInnerSize);
  }
  
  this._minScroll = 0;
  //take the button size into account for max scroll position
  this._maxScroll = bHoriz ? 
                    contentContainer.offsetWidth - elemInnerSize + this._buttonWidth : 
                    contentContainer.offsetHeight - elemInnerSize + this._buttonHeight;
  //constrain max scroll
  if (this._maxScroll < 0)
  {
    this._maxScroll = 0;
  }
  
  //hide buttons AFTER calculating sizes above, but BEFORE updating scroll position below
  this._hidePrevButton();
  this._hideNextButton();
  
  //refresh current scroll position AFTER calculating sizes above
  this._setCurrScroll(bInit ? this._minScroll : this._origScroll, true);
  this._origScroll = 0;
};

/**
 * Create the inner overflow and content containers.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._createInnerContainers = function()
{
  //the original children of the conveyor elem will be reparented to the contentContainer;
  //the conveyor elem will contain the overflowContainer, which will contain the contentContainer, which
  //will contain the original children
  
  var self = this;
  var bHoriz = this._isHorizontal();
  
  var overflowContainer = document.createElement("div");
  this._overflowContainer = overflowContainer;
  var overflowContainerStyle = overflowContainer.style;
  overflowContainerStyle.overflow = "hidden";
  overflowContainerStyle.display = this._getCssDisplay();
  overflowContainerStyle.position = "relative";
  //ojTabs: verticalAlign top is needed so there's no gap between the tab bar and the tab content in Jet Tabs
  if (bHoriz)
  {
    overflowContainerStyle.verticalAlign = "top";
  }
  
  var elem = this._elem;
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var contentContainer = document.createElement("div");
  this._contentContainer = contentContainer;
  var contentContainerStyle = contentContainer.style;
  contentContainerStyle.position = "relative";
  if (bHoriz)
  {
    //ojTabs: set display of content container to inline-block so that its size
    //will be driven by its children
    contentContainerStyle.display = "inline-block";
  }
  overflowContainer.appendChild(contentContainer);
  
  var tableDiv = null;
  if (bHoriz)
  {
    //layout the buttons and overflow container in divs styled like table cells
    //in a single row in order to guarantee that they don't accidentally wrap
    //(don't want to specify white-space:nowrap because that would get inherited
    //by the content and either conveyor or the app would potentially have to
    //restore the initial value)
    tableDiv = cbcClass._createTableDiv();
    this._tableDiv = tableDiv;
    var tableRowDiv = cbcClass._createTableRowDiv();
    var tableCellDivPrevButton = cbcClass._createTableCellDiv();
    this._tableCellDivPrevButton = tableCellDivPrevButton;
    var tableCellDivOverflow = cbcClass._createTableCellDiv();
    var tableCellDivNextButton = cbcClass._createTableCellDiv();
    this._tableCellDivNextButton = tableCellDivNextButton;
    
    //FIX BUG 18728785: in IE, the table cell divs wrapping the buttons must
    //specify vertical-align:top in order for the buttons to start out top
    //aligned
    var tableCellDivPrevButtonStyle = tableCellDivPrevButton.style;
    var tableCellDivNextButtonStyle = tableCellDivNextButton.style;
    tableCellDivPrevButtonStyle.verticalAlign = "top";
    tableCellDivNextButtonStyle.verticalAlign = "top";
    
    tableCellDivOverflow.appendChild(overflowContainer);
    tableRowDiv.appendChild(tableCellDivPrevButton);
    tableRowDiv.appendChild(tableCellDivOverflow);
    tableRowDiv.appendChild(tableCellDivNextButton);
    tableDiv.appendChild(tableRowDiv);
  }
  
  //reparent children from elem to contentContainer before adding overflow and
  //content containers to elem;
  //create table to hold content items to enforce either single column or single
  //row layout
  var contentTableDiv = cbcClass._createTableDiv();
  var arContentElements = cbcClass._reparentChildrenToTable(elem, contentTableDiv, bHoriz);
  //if there is a nested contentParent, then we need to put its children into
  //arContentElements instead of the children of the elem
  if (this._contentParent)
  {
    arContentElements = [];
    var contentParent = this._contentParent;
    var contentChildren = contentParent.children;
    var numContentChildren = contentChildren.length;
    for (var i = 0; i < numContentChildren; i++)
    {
      var child = contentChildren[i];
      if (child.nodeType === 1)
      {
        arContentElements.push(child);
      }
    }
  }
  //save the content elements so we can walk through them in _measureContents
  //instead of walking through the table div itself
  this._arContentElements = arContentElements;
  //only need to save the content table and add it to the content container if 
  //there is actual content (this also helps _isEmpty() to function correctly)
  if (arContentElements && arContentElements.length > 0)
  {
    this._contentTableDiv = contentTableDiv;
    contentContainer.appendChild(contentTableDiv);
  }
  
  if (tableDiv)
  {
    elem.appendChild(tableDiv);
  }
  else
  {
    var vertDivPrevButton = document.createElement("div");
    this._vertDivPrevButton = vertDivPrevButton;
    var vertDivNextButton = document.createElement("div");
    this._vertDivNextButton = vertDivNextButton;
    elem.appendChild(vertDivPrevButton);
    elem.appendChild(overflowContainer);
    elem.appendChild(vertDivNextButton);
  }
  
  if (bHoriz)
  {
    //the overflow container is sometimes taller than the content container,
    //apparently because the content container is an inline-block, so we 
    //compensate for that extra, artificial vertical space by reducing the 
    //bottom margin of the overflow container
    var overflowHeight = overflowContainer.offsetHeight;
    var contentHeight = contentContainer.offsetHeight;
    if (overflowHeight > contentHeight)
    {
      overflowContainerStyle.marginBottom = (contentHeight - overflowHeight) + "px";
    }
  }
  
  //the overflow container listens to DOM scroll events in case the scroll was triggered externally,
  //for example when the user tabs through the child content
  cbcClass._addBubbleEventListener(overflowContainer, "scroll", function (event) {self._handleScroll(event);});
};

/**
 * Get the value to use for the CSS display attribute.
 * @return {string} Value to use for CSS display attribute
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getCssDisplay = function()
{
  return this._isHorizontal() ? "inline-block" : "block";
};

/**
 * Create the prev button.
 * @param {string} buttonId Id to use for the button
 * @param {string} buttonStyleClass Style class to use for the button
 * @param {Node} icon Button icon element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._createPrevButton = function(
  buttonId, buttonStyleClass, icon)
{
  var self = this;
  var prevButton = document.createElement("div");
  this._prevButton = prevButton;
  if (buttonId)
  {
    prevButton.setAttribute("id", buttonId);
  }
  prevButton.setAttribute("class", buttonStyleClass);
  //hide the button from screen readers because it is not keyboard accessible
  prevButton.setAttribute("aria-hidden", "true");
  var prevButtonStyle = prevButton.style;
  prevButtonStyle.display = this._getCssDisplay();
  prevButtonStyle.position = "relative";
  var bHoriz = this._isHorizontal();
  if (bHoriz)
  {
    prevButtonStyle.verticalAlign = "top";
  }
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  cbcClass._addBubbleEventListener(prevButton, "click", function (event) {self._scrollPrev();});
  if (this._tableCellDivPrevButton)
  {
    //the button belongs to the table cell
    var tableCell = this._tableCellDivPrevButton;
    
    //wrap the button in another div that we can use to get the size, because
    //the table cell div seems to be one pixel bigger (maybe when the button
    //size is really a float?);
    //then the wrapper div size will be restricted to be the actual reported
    //size of the button, which results in the table cell div being the same size
    this._prevButtonWrapper = cbcClass._wrapAndRestrictSize(prevButton, tableCell, bHoriz, !bHoriz);
  }
  else
  {
    //make the prev button the first child
    var elem = this._vertDivPrevButton;
    elem.appendChild(prevButton);
  }
  
  if (icon)
  {
    prevButton.appendChild(icon);
  }
};

/**
 * Create the next button.
 * @param {string} buttonId Id to use for the button
 * @param {string} buttonStyleClass Style class to use for the button
 * @param {Node} icon Button icon element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._createNextButton = function(
  buttonId, buttonStyleClass, icon)
{
  var self = this;
  var nextButton = document.createElement("div");
  this._nextButton = nextButton;
  if (buttonId)
  {
    nextButton.setAttribute("id", buttonId);
  }
  nextButton.setAttribute("class", buttonStyleClass);
  //hide the button from screen readers because it is not keyboard accessible
  nextButton.setAttribute("aria-hidden", "true");
  var nextButtonStyle = nextButton.style;
  nextButtonStyle.display = this._getCssDisplay();
  nextButtonStyle.position = "relative";
  var bHoriz = this._isHorizontal();
  if (bHoriz)
  {
    nextButtonStyle.verticalAlign = "top";
  }
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  cbcClass._addBubbleEventListener(nextButton, "click", function (event) {self._scrollNext();});
  if (this._tableCellDivNextButton)
  {
    //the button belongs to the table cell
    var tableCell = this._tableCellDivNextButton;
    
    //wrap the button in another div that we can use to get the size, because
    //the table cell div seems to be one pixel bigger (maybe when the button
    //size is really a float?);
    //then the wrapper div size will be restricted to be the actual reported
    //size of the button, which results in the table cell div being the same size
    this._nextButtonWrapper = cbcClass._wrapAndRestrictSize(nextButton, tableCell, bHoriz, !bHoriz);
  }
  else
  {
    //make the next button the last child
    var elem = this._vertDivNextButton;
    elem.appendChild(nextButton);
  }
  
  if (icon)
  {
    nextButton.appendChild(icon);
  }
};

/**
 * Get the content parent.
 * @return {Object} parent DOM element of the content
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getContentParent = function()
{
  //if an explicit content parent was not specified, it will be the _contentContainer
  var contentParent = this._contentParent;
  if (!contentParent)
  {
    contentParent = this._contentContainer;
  }
  return contentParent;
};

/**
 * Measure the contents of the conveyor.
 * @return {Object} Total size of the contents
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._measureContents = function()
{
  var contentParent = this._getContentParent();
  var contentTableDiv = this._contentTableDiv;
  var arContentElements = this._arContentElements;
  var totalSize = {w: 0, h: 0};
  var sizes = [];
  if (contentParent.hasChildNodes() && contentTableDiv && arContentElements &&
      arContentElements.length > 0)
  {
    var children = arContentElements;
    var bHoriz = this._isHorizontal();
    var contentWidth = 0;

    //get the width of the contentContainer, not the contentParent, because
    //in JET, if the children are in a buttonset, for example, the offsetLeft
    //of the children is relative to the contentContainer, not the 
    //contentParent
    var contentContainer = this._contentContainer;
    contentWidth = contentContainer.offsetWidth;

    var startOffset = 0;
    var prevSizeObj = null;
    for (var i = 0; i < children.length; i++)
    {
      var child = children[i];
      if (child.nodeType === 1)
      {
        var ww = child.offsetWidth;
        var hh = child.offsetHeight;
        var childId = child.id;
        var sizeObj = {w: ww, h: hh, id: childId};
        //calculating the start assumes that the browser has done the appropriate layout;
        //subtract 1 from the end so it's the last pixel of this child, not the start of the next child
        if (bHoriz)
        {
          //FIX BUG 18827615: in IE, the conveyor items all report offsetLeft=0,
          //so we need to get the offset from the parent wrapping table cell div
          //instead
          var offLeft = child.offsetLeft;
          if (!this._contentParent && offLeft === 0)
          {
            var childParent = child.parentNode;
            offLeft = childParent.offsetLeft;
          }
          
          //if RTL, still want to save the start coords in logical, ascending order beginning with 0
          if (this._bRtl)
          {
            sizeObj.start = contentWidth - (offLeft + ww);
          }
          else
          {
            sizeObj.start = offLeft;
          }
          
          //Offset each item's start coord by the first item's offset to handle cases like text-align:right,
          //where the items may be right-aligned within the content container.  We still want our logical 
          //coords to start at 0.
          if (i === 0)
            startOffset = sizeObj.start;
          sizeObj.start -= startOffset;
          
          totalSize.w = sizeObj.start + ww;
          totalSize.h = Math.max(totalSize.h, hh);
          sizeObj.end = totalSize.w - 1;
        }
        else
        {
          //FIX BUG 18827615: in IE, the conveyor items all report offsetTop=0,
          //so we need to get the offset from the parent wrapping table cell div
          //instead
          var offTop = child.offsetTop;
          if (!this._contentParent && offTop === 0)
          {
            var childParent = child.parentNode;
            offTop = childParent.offsetTop;
          }
          
          sizeObj.start = offTop;
          totalSize.w = Math.max(totalSize.w, ww);
          totalSize.h = sizeObj.start + hh;
          sizeObj.end = totalSize.h - 1;
        }
        
        //if this item overlaps the previous item, adjust the previous item to
        //end just before this item (can happen, for example, with horizontal
        //JET buttonsets)
        if (prevSizeObj)
        {
          if (prevSizeObj.end >= sizeObj.start)
          {
            var overlap = prevSizeObj.end - (sizeObj.start - 1);
            prevSizeObj.end -= overlap;
            if (bHoriz)
            {
              prevSizeObj.w -= overlap;
            }
            else
            {
              prevSizeObj.h -= overlap;
            }
          }
        }
        
        sizes.push(sizeObj);
        prevSizeObj = sizeObj;
      }
    }
  }
  this._sizes = sizes;
  return totalSize;
};

/**
 * Get the array of content sizes.
 * @return {Array} Array of content sizes
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getSizes = function()
{
  //only calculate sizes if they haven't been calculated already
  if (!this._sizes)
  {
    var totalSize = this._measureContents();
    //only save the total size if it hasn't already been saved
    if (!this._totalSize)
    {
      this._totalSize = totalSize;
    }
  }
  return this._sizes;
};

/**
 * Get the DOM element to use to show or hide the next button.
 * @return {Node} DOM element to use to show or hide the next button
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getNextButtonDisplayElem = function()
{
  return this._nextButtonWrapper ? this._nextButtonWrapper : this._nextButton;
};

/**
 * Get the DOM element to use to show or hide the prev button.
 * @return {Node} DOM element to use to show or hide the prev button
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getPrevButtonDisplayElem = function()
{
  return this._prevButtonWrapper ? this._prevButtonWrapper : this._prevButton;
};

/**
 * Show the next button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._showNextButton = function()
{
  var elem = this._getNextButtonDisplayElem();
  var style = elem.style;
  style.display = this._getCssDisplay();
};

/**
 * Show the prev button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._showPrevButton = function()
{
  var elem = this._getPrevButtonDisplayElem();
  var style = elem.style;
  style.display = this._getCssDisplay();
};

/**
 * Hide the next button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._hideNextButton = function()
{
  var elem = this._getNextButtonDisplayElem();
  var style = elem.style;
  style.display = "none";
};

/**
 * Hide the prev button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._hidePrevButton = function()
{
  var elem = this._getPrevButtonDisplayElem();
  var style = elem.style;
  style.display = "none";
};

/**
 * Determine if the next button is shown.
 * @return {boolean} true if shown, false if hidden
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isNextButtonShown = function()
{
  var elem = this._getNextButtonDisplayElem();
  var style = elem.style;
  return style.display !== "none";
};

/**
 * Determine if the prev button is shown.
 * @return {boolean} True if shown, false if hidden
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isPrevButtonShown = function()
{
  var elem = this._getPrevButtonDisplayElem();
  var style = elem.style;
  return style.display !== "none";
};

/**
 * Get the size of a next/prev button along the direction of conveyor orientation.
 * @return {number} Size of a button
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getButtonSize = function()
{
  return this._isHorizontal() ? this._buttonWidth : this._buttonHeight;
};

/**
 * Update visibility of the next/prev buttons and adjust scroll position accordingly.
 * @param {number} scroll Desired scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._updateButtonVisibility = function(scroll)
{
  var buttonSize = this._getButtonSize();
  var ovScroll = this._getCurrScroll();
  var ovSize = this._getCurrViewportSize();
  var bNeedsScroll = this._needsScroll();
  //if scrolling to the start, hide the prev button and reclaim its space
  if (scroll <= this._minScroll)
  {
    if (this._isPrevButtonShown())
    {
      ovSize += buttonSize;
      ovScroll -= buttonSize;
    }
    this._hidePrevButton();
  }
  //if not at the start, show the prev button and allocate space for it
  else if (bNeedsScroll)
  {
    if (!this._isPrevButtonShown())
    {
      ovSize -= buttonSize;
      ovScroll += buttonSize;
    }
    this._showPrevButton();
  }

  //if scrolling to the end, hide the next button and reclaim its space
  if (scroll >= this._maxScroll)
  {
    if (this._isNextButtonShown())
    {
      ovSize += buttonSize;
    }
    this._hideNextButton();
  }
  //if not at the end, show the next button and allocate space for it
  else if (bNeedsScroll)
  {
    if (!this._isNextButtonShown())
    {
      ovSize -= buttonSize;
    }
    this._showNextButton();
  }
  //update the overflow container
  this._setOverflowScroll(ovScroll);
  if (bNeedsScroll)
  {
    this._setOverflowMaxSize(ovSize);
  }
  else
  {
    this._clearOverflowMaxSize();
  }
};

/**
 * Set the max size of the overflow container.
 * @param {number} size Overflow max size
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setOverflowMaxSize = function(size)
{
  var overflowContainer = this._overflowContainer;
  var overflowContainerStyle = overflowContainer.style;
  var s = size + "px";
  if (this._isHorizontal())
  {
    overflowContainerStyle.maxWidth = s;
  }
  else
  {
    overflowContainerStyle.maxHeight = s;
  }
};

/**
 * Clear the max size of the overflow container.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._clearOverflowMaxSize = function()
{
  var overflowContainer = this._overflowContainer;
  var overflowContainerStyle = overflowContainer.style;
  if (this._isHorizontal())
  {
    overflowContainerStyle.maxWidth = "";
  }
  else
  {
    overflowContainerStyle.maxHeight = "";
  }
};

/**
 * Set the overflow scroll position.
 * @param {number} scroll Overflow logical scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setOverflowScroll = function(scroll)
{
  var overflowContainer = this._overflowContainer;
  if (this._isHorizontal())
  {
    overflowContainer.scrollLeft = this._convertScrollLogicalToBrowser(scroll);
  }
  else
  {
    overflowContainer.scrollTop = scroll;
  }
};

/**
 * Get the current overflow viewport size.
 * @return {number} Overflow viewport size
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getCurrViewportSize = function()
{
  var overflowContainer = this._overflowContainer;
  return this._isHorizontal() ? overflowContainer.offsetWidth : overflowContainer.offsetHeight;
};

/**
 * Set the scroll position.
 * @param {number} scroll Desired scroll position
 * @param {boolean} bImmediate True to make the change immediately, false to animate it
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setCurrScroll = function(scroll, bImmediate)
{
  //don't do anything if we're already in the middle of scrolling
  if (!this._bScrolling)
  {
    //if this function is called, the conveyor internally initiated the scroll, so turn off the 
    //flag for an externally triggered scroll
    this._bExternalScroll = false;
    this._setCurrScrollHelper(scroll, bImmediate);
  }
};

/**
 * Helper function to set scroll position.
 * @param {number} scroll Desired scroll position
 * @param {boolean} bImmediate True to make the change immediately, false to animate it
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setCurrScrollHelper = function(scroll, bImmediate)
{
  if (this._isEmpty())
    return;
  
  this._bScrolling = true;
  scroll = this._constrainScroll(scroll);
  //update button visibility before scrolling
  this._updateButtonVisibility(scroll);
  var scrollFunc = this._scrollFunc;
  //if making the change immediately, simply call the anim end function
  if (bImmediate || !scrollFunc || scroll === this._getCurrScroll())
  {
    this._onScrollAnimEnd(scroll);
  }
  //if animating the change, call out to the provided callback
  else
  {
    var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
    // 1.1 px/ms is the desired animation speed, so calculate the duration based on the distance to scroll
    var duration = Math.abs(this._getCurrScroll() - scroll) / cbcClass._SCROLL_SPEED;
    var self = this;
    var onEndFunc = function () {self._onScrollAnimEnd(scroll);};
    //need to convert the logical scroll to the browser value for animating
    scrollFunc.call(this._callbackObj, this._overflowContainer, this._convertScrollLogicalToBrowser(scroll), 
                    duration, onEndFunc);
  }
};

/**
 * Get the current scroll position.
 * @return {number} Logical scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getCurrScroll = function()
{
  var overflowContainer = this._overflowContainer;
  return this._isHorizontal() ? this._convertScrollBrowserToLogical(overflowContainer.scrollLeft) : 
                                overflowContainer.scrollTop;
};

/**
 * Determine if the conveyor needs to show scroll buttons.
 * @return {boolean} True if scrolling is needed, false if not
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._needsScroll = function()
{
  var contentContainer = this._contentContainer;
  var overflowContainer = this._overflowContainer;
  return this._isHorizontal() ? 
    contentContainer.offsetWidth > overflowContainer.offsetWidth : 
    contentContainer.offsetHeight > overflowContainer.offsetHeight;
};

/**
 * Constrain the scroll position.
 * @param {number} scroll Desired scroll position
 * @return {number} Constrained scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._constrainScroll = function(scroll)
{
  if (!this._needsScroll() || scroll < this._minScroll)
  {
    scroll = this._minScroll;
  }
  else if (scroll > this._maxScroll)
  {
    scroll = this._maxScroll;
  }
  return scroll;
};

/**
 * Handle a mousewheel event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleMouseWheel = function(event)
{
  //if we're already scrolling, just consume the event
  var bConsumeEvent = this._bScrolling;
  if (this._needsScroll() && !this._bScrolling)
  {
    var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
    var wheelDelta = cbcClass._getWheelDelta(event);
    if (wheelDelta < 0 && this._isNextButtonShown())
    {
      bConsumeEvent = true;
      this._scrollNext();
    }
    else if (wheelDelta > 0 && this._isPrevButtonShown())
    {
      bConsumeEvent = true;
      this._scrollPrev();
    }
  }
  if (bConsumeEvent)
  {
    event.preventDefault();
    event.stopPropagation();
  }
};

/**
 * Handle a touchstart event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleTouchStart = function(event)
{
  var eventTouches = event.touches;
  if (this._needsScroll() && !this._bScrolling && eventTouches.length === 1)
  {
    this._bTouch = true;
    //save off some initial information at the start of a swipe
    var firstTouch = eventTouches[0];
    this._touchStartCoord = this._isHorizontal() ? firstTouch.pageX : firstTouch.pageY;
    this._touchStartScroll = this._getCurrScroll();
    this._touchStartNextScroll = this._calcNextScroll();
    this._touchStartPrevScroll = this._calcPrevScroll();
  }
};

/**
 * Handle a touchmove event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleTouchMove = function(event)
{
  //only need to do something if we also received the touchstart
  if (this._bTouch)
  {
    var bHoriz = this._isHorizontal();
    var eventTouches = event.touches;
    var firstTouch = eventTouches[0];
    var touchCoord = bHoriz ? firstTouch.pageX : firstTouch.pageY;
    var diff = touchCoord - this._touchStartCoord;
    //only scroll next/prev if the swipe is longer than the threshold; if it's less, then just
    //drag the items with the swipe
    var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
    var overflowContainer = this._overflowContainer;
    var threshold = cbcClass._SWIPE_THRESHOLD * 
                    (bHoriz ? overflowContainer.offsetWidth : overflowContainer.offsetHeight);
    //if swiping under the threshold, just move the conveyor with the swipe
    if (Math.abs(diff) < threshold)
    {
      this._setCurrScroll(this._touchStartScroll - diff, true);
    }
    //if swiping beyond the threshold, scroll to the next/prev set of items
    else
    {
      //in non-RTL, if swiping left or up, scroll next; otherwise scroll prev
      //in RTL, if swiping right or up, scroll next; otherwise scroll prev
      var bNext = (bHoriz && this._bRtl) ? (diff > 0) : (diff < 0);
      this._setCurrScroll(bNext ? this._touchStartNextScroll : this._touchStartPrevScroll);
      //don't scroll again for this same swipe
      this._bTouch = false;
    }
  }
};

/**
 * Handle a touchend event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleTouchEnd = function(event)
{
  //if a full page swipe hasn't happened, scroll back to the original position
  if (this._bTouch)
  {
    this._setCurrScroll(this._touchStartScroll);
  }
  this._bTouch = false;
};

/**
 * Handle a DOM scroll event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleScroll = function(event)
{
  //if the scroll was triggered externally, for example by tabbing through 
  //child items, then update the visual state of the conveyor to match the
  //new scroll state
  if (this._bExternalScroll && !this._bScrolling)
  {
    this._setCurrScrollHelper(this._getCurrScroll(), true);
  }
};

/**
 * Function called after a scroll finishes.
 * @param {number} scroll Scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._onScrollAnimEnd = function(scroll)
{
  //set the desired value after the animation to make sure that the final value is exactly what was intended,
  //in case the animation introduced interpolation errors
  this._setOverflowScroll(scroll);
  //toggle the externalScroll flag in a timeout so that it happens after any current processing finishes
  this._setExternalScrollTimeout();
  this._bScrolling = false;
  //if there is a callback to notify about a change of first visible item, call it now
  if (this._firstVisibleItemChangedFunc)
  {
    this._firstVisibleItemIndex = this._calcFirstVisibleItemIndex();
    //if there is more than one item visible, and the first item is only 
    //partially visible, then save the second item as the actual first visible 
    //item for state purposes (if the last navigation had been prev,
    //we would want the last visible item to remain visible)
    var lastVisIndex = this._calcLastVisibleItemIndex();
    var sizes = this._getSizes();
    var sizeObj = sizes[this._firstVisibleItemIndex];
    if (this._firstVisibleItemIndex !== lastVisIndex &&
        this._getCurrScroll() > sizeObj.start &&
        this._firstVisibleItemIndex < sizes.length - 2)
    {
      this._firstVisibleItemIndex++;
      sizeObj = sizes[this._firstVisibleItemIndex];
    }
    this._firstVisibleItemId = sizeObj.id;
    var firstVisibleItemChangedFunc = this._firstVisibleItemChangedFunc;
    firstVisibleItemChangedFunc.call(this._callbackObj, this._firstVisibleItemId);
  }
};

/**
 * Set a timout to reset the externalScroll flag.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setExternalScrollTimeout = function()
{
  var self = this;
  var f = function () {if (self) self._bExternalScroll = true;};
  window.setTimeout(f, 0); 
};

/**
 * Scroll to the next set of items.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._scrollNext = function()
{
  if (!this._bScrolling)
    this._setCurrScroll(this._calcNextScroll());
};

/**
 * Scroll to the previous set of items.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._scrollPrev = function()
{
  if (!this._bScrolling)
    this._setCurrScroll(this._calcPrevScroll());
};

/**
 * Calculate the scroll position for the next set of items.
 * @return {number} Next scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcNextScroll = function()
{
  var nextIndex = this._calcNextVisibleItemIndex();
  var scroll = 0;
  //if single item is bigger than viewport, then scroll by viewport size
  if (nextIndex === this._calcFirstVisibleItemIndex())
  {
    scroll = this._getCurrScroll() + this._getCurrViewportSize();
  }
  else
  {
    scroll = this._calcStartScroll(nextIndex);
  }
  return scroll;
};

/**
 * Calculate the scroll position for the previous set of items.
 * @return {number} Previous scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcPrevScroll = function()
{
  var prevIndex = this._calcPrevVisibleItemIndex();
  var scroll = 0;
  //if single item is bigger than viewport, then scroll by viewport size
  if (prevIndex === this._calcLastVisibleItemIndex())
  {
    scroll = this._getCurrScroll() - this._getCurrViewportSize();
  }
  else
  {
    scroll = this._calcEndScroll(prevIndex);
  }
  //if at the end and scrolling prev, anticipate the next button becoming 
  //visible and adjust the scroll position
  if (!this._isNextButtonShown())
  {
    scroll += this._getButtonSize();
  }
  //if scrolling prev and the scroll position is less than the size of the prev button, just
  //scroll to the very beginning because the prev button should get hidden
  if (scroll < this._getButtonSize())
  {
    scroll = this._minScroll;
  }
  return scroll;
};

/**
 * Calculate the scroll position for the start of the specified item.
 * @param {number} index Index of the item to scroll to
 * @return {number} Scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcStartScroll = function(index)
{
  var sizes = this._getSizes();
  var sizeObj = sizes[index];
  return sizeObj.start;
};

/**
 * Calculate the scroll position for the end of the specified item.
 * @param {number} index Index of the item to scroll to
 * @return {number} Scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcEndScroll = function(index)
{
  var sizes = this._getSizes();
  var sizeObj = sizes[index];
  return sizeObj.end - this._getCurrViewportSize() + 1;
};

/**
 * Calculate the index of the first visible item.
 * @return {number} Index of first visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcFirstVisibleItemIndex = function()
{
  var currScroll = this._getCurrScroll();
  var i = this._calcItemIndex(currScroll);
  return (i < 0) ? 0 : i;
};

/**
 * Calculate the index of the last visible item.
 * @return {number} Index of last visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcLastVisibleItemIndex = function()
{
  var elemSize = this._getCurrViewportSize();
  var currScroll = this._getCurrScroll() + elemSize - 1;
  var i = this._calcItemIndex(currScroll);
  var sizes = this._getSizes();
  return (i < 0) ? sizes.length - 1 : i;
};

/**
 * Calculate the index of the previous visible item.
 * @return {number} Index of previous visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcPrevVisibleItemIndex = function()
{
  var currScroll = this._getCurrScroll() - 1;
  var i = this._calcItemIndex(currScroll);
  return (i < 0) ? 0 : i;
};

/**
 * Calculate the index of the next visible item.
 * @return {number} Index of next visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcNextVisibleItemIndex = function()
{
  var elemSize = this._getCurrViewportSize();
  var currScroll = this._getCurrScroll() + elemSize;
  var i = this._calcItemIndex(currScroll);
  var sizes = this._getSizes();
  return (i < 0) ? sizes.length - 1 : i;
};

/**
 * Calculate the index of the item at the given scroll position.
 * @param {number} scroll Scroll position
 * @return {number} Index of item at given scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcItemIndex = function(scroll)
{
  var sizes = this._getSizes();
  for (var i = 0; i < sizes.length; i++)
  {
    var sizeObj = sizes[i];
    if (scroll <= sizeObj.end)
      return i;
  }
  return -1;
};

/**
 * Convert a logical scroll position to its corresponding browser value.
 * @param {number} scroll logical scroll position
 * @return {number} browser scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._convertScrollLogicalToBrowser = function(scroll)
{
  //(comment mostly copied from AdfConveyorBeltSupport)
  //If this is LTR or RTL mode in IE, then we want the default positive new scroll value.
  //If FF in RTL, then get the negative scroll value
  //If Webkit in RTL, to scroll to a position, we resolve this equation:
  // contentContainerWidth - browserScroll = overflowContainerWidth + logicalScroll
  var newScroll = scroll;
  if (this._bRtl && this._isHorizontal())
  {
    if (this._bAgentGecko) {
      newScroll = -scroll;
    }
    else if (this._bAgentWebkit || this._bAgentOpera) {
      var contentContainer = this._contentContainer;
      var overflowContainer = this._overflowContainer;
      newScroll = contentContainer.offsetWidth - overflowContainer.offsetWidth - scroll;
    }
  }
  return newScroll;
};

/**
 * Convert a browser scroll position to its corresponding logical value.
 * @param {number} scroll browser scroll position
 * @return {number} logical scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._convertScrollBrowserToLogical = function(scroll)
{
  //(comment mostly copied from AdfConveyorBeltSupport)
  //If this is LTR or RTL mode in IE, then we want the default positive new scroll value.
  //If FF in RTL, then get the negative scroll value
  //If Webkit in RTL, to scroll to a position, we resolve this equation:
  // contentContainerWidth - browserScroll = overflowContainerWidth + logicalScroll
  
  //because the equations are the same whether converting from browser -> logical or logical -> browser,
  //simply call _convertScrollLogicalToBrowser from here
  //(NOTE: want to leave _convertScrollBrowserToLogical as a separate function so that it's clear from the
  //calling code which conversion direction is used, and in case the conversion impls ever need to be changed)
  return this._convertScrollLogicalToBrowser(scroll);
};

/**
 * Scroll animation speed (px/ms).
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._SCROLL_SPEED = 1.1;
/**
 * Touch swipe threshold (percentage of conveyor size).
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._SWIPE_THRESHOLD = .33;
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class 
 * @constructor
 * @name oj.ojConveyorBelt
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="conveyorBeltOverview-section">
 *   JET ConveyorBelt Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#conveyorBeltOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Container component that manages overflow for its child
 * components and allows scrolling among them.
 * 
 * <p>A JET ConveyorBelt can be created from any 
 * <code class="prettyprint">&lt;div></code> element that contains
 * multiple child elements at the same level to scroll among.  The root must be
 * a <code class="prettyprint">&lt;div></code> element because the ConveyorBelt 
 * will create additional DOM elements between the root and the scrollable child
 * elements.  
 * <p>The size of the ConveyorBelt must somehow be constrained in order for 
 * there to be overflow to manage, for example by specifying CSS 
 * <code class="prettyprint">max-width</code> or
 * <code class="prettyprint">max-height</code>.  
 * <p>If the elements to be scrolled among are direct children of the
 * ConveyorBelt, then ConveyorBelt will ensure that they are laid out
 * appropriately for its orientation.  However, if the elements to be scrolled
 * among are contained by a single nested descendant element, the 
 * <code class="prettyprint">contentParent</code>, then it is up to calling code
 * to ensure that the elements are laid out appropriately.  For example, 
 * elements can be forced horizontal by using CSS
 * <code class="prettyprint">white-space:nowrap</code>, or vertical by using 
 * <code class="prettyprint">display:block</code>, before creating the 
 * ConveyorBelt.  
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="conveyorBelt" style="max-width:100px;"
 *      data-bind="ojComponent: {component: 'ojConveyorBelt'}">
 *   &lt;button id="button1">Alpha&lt;/button>
 *   &lt;button id="button2">Beta&lt;/button>
 *   &lt;button id="button3">Gamma&lt;/button>
 *   &lt;button id="button4">Delta&lt;/button>
 *   &lt;button id="button5">Epsilon&lt;/button>
 *   &lt;button id="button6">Zeta&lt;/button>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * <p>ConveyorBelt does not directly support keyboard interaction.
 * 
 * 
 * <h3 id="keyboard-appdev-section">
 *   Keyboard Application Developer Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-appdev-section"></a>
 * </h3>
 * 
 * <p>Providing keyboard support for the items in the conveyor belt is the 
 * responsibility of the application developer, if the items do not already
 * support keyboard interaction.  This could be done, for example, by specifying 
 * <code class="prettyprint">tabindex</code> on each item to enable tab
 * navigation.  Alternatively, this could be done by adding a keyboard listener
 * and responding to key events, like pressing the arrow keys.
 * 
 * 
 * <h3 id="accessibility-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
 * </h3>
 *
 * <p>ConveyorBelt itself does nothing special for accessibility.  
 * It is the responsibility of the application developer to make the items in 
 * the conveyor accessible.  Sighted keyboard-only users need to be able to 
 * access the items in the conveyor just by using the keyboard.
 * It is up to the child items of the ConveyorBelt to support keyboard 
 * navigation.  If child items support tab navigation, the browser may scroll 
 * them into view when they receive focus.  If child items support other forms 
 * of keyboard navigation, for example by using the arrow keys, it is up to the 
 * child items to scroll themselves into view.  This may be done, for example, 
 * by calling the DOM function <code class="prettyprint">focus()</code> or 
 * <code class="prettyprint">scrollIntoView()</code> on the item.  
 * ConveyorBelt will be aware of tab based or programmatic scrolling and will 
 * honor it, updating itself to toggle visibility of the overflow indicators as 
 * needed.  
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality 
 * (LTR or RTL) changes post-init, the conveyorBelt must be 
 * <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-conveyorbelt</code> pseudo-selector can 
 * be used in jQuery expressions to select JET ConveyorBelt.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-conveyorbelt" ) // selects all JET ConveyorBelts on the page
 * $myEventTarget.closest( ":oj-conveyorbelt" ) // selects the closest ancestor that is a JET ConveyorBelt
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <p>Event names for all JET components are prefixed with "oj", instead of 
 * component-specific prefixes like "conveyorBelt".  
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET ConveyorBelt. 
 * @example <caption>Initialize the conveyorBelt with no options specified:</caption>
 * $( ".selector" ).ojConveyorBelt();
 * 
 * @example <caption>Initialize the conveyorBelt with some options specified:</caption>
 * $( ".selector" ).ojConveyorBelt( { "orientation": "vertical" } );
 * 
 * @example <caption>Initialize the conveyorBelt via the JET 
 * <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="conveyorBelt" data-bind="ojComponent: { component: 'ojConveyorBelt', orientation: 'vertical'}">
 */
(function()
{
oj.__registerWidget("oj.ojConveyorBelt", $['oj']['baseComponent'],
{
  defaultElement: "<div>",
  widgetEventPrefix: "oj",

  options:
  {
    /** 
     * Specify the orientation of the conveyorBelt.
     *
     * @expose 
     * @memberof! oj.ojConveyorBelt
     * @instance
     * @type {string}
     * @ojvalue {string} "horizontal" Orient the conveyorBelt horizontally.
     * @ojvalue {string} "vertical" Orient the conveyorBelt vertically.
     * @default <code class="prettyprint">"horizontal"</code>
     *
     * @example <caption>Initialize the conveyorBelt with the 
     * <code class="prettyprint">orientation</code> option specified:</caption>
     * $( ".selector" ).ojConveyorBelt( { "orientation": "vertical" } );
     * 
     * @example <caption>Get or set the <code class="prettyprint">orientation</code> 
     * option after initialization:</caption>
     * // getter
     * var orientation = $( ".selector" ).ojConveyorBelt( "option", "orientation" );
     * 
     * // setter
     * $( ".selector" ).ojConveyorBelt( "option", "orientation", "vertical" );
     */
    orientation: "horizontal",
    /** 
     * Specify the selector of the descendant DOM element in the conveyorBelt
     * that directly contains the items to scroll among.  
     * 
     * <p>This option is <code class="prettyprint">null</code> by default, 
     * meaning that the items to scroll among are direct children of the 
     * conveyorBelt DOM element.  In some cases, the items to scroll among
     * are not direct children of the conveyorBelt DOM element, but are instead
     * nested in a descendant DOM element.  In such cases, this option should be 
     * specified to point to the descendant DOM element whose direct children
     * are the items to scroll among.  For example, if the items to scroll
     * among are buttons in a buttonset, the buttons are direct children of 
     * the DOM element representing the buttonset.  The buttonset would be 
     * the direct child of the conveyorBelt.  If the 
     * <code class="prettyprint">id</code> of the buttonset DOM element were
     * <code class="prettyprint">'myContentDiv'</code>, then contentParent
     * would be specified as <code class="prettyprint">'#myContentDiv'</code>.
     * 
     * <p><b>WARNING:</b> The selector specified for this option should match 
     * only a single descendant DOM element.  If multiple elements are matched, 
     * then only the first one will be used.  Applications should not depend on 
     * this behavior because we reserve the right to change it in the future in 
     * order to allow and use multiple matching elements.  
     *
     * @expose 
     * @memberof! oj.ojConveyorBelt
     * @instance
     * @type {?string}
     * @default <code class="prettyprint">null</code>
     *
     * @example <caption>Initialize the conveyorBelt with the 
     * <code class="prettyprint">contentParent</code> option specified:</caption>
     * // HTML
     * &lt;div>                       // conveyorBelt DOM element
     *   &lt;div id="myContentDiv">     // contentParent DOM element
     *     &lt;button>Item 1&lt;/button>     // items to scroll among... 
     *     &lt;button>Item 2&lt;/button>
     *     &lt;button>Item 3&lt;/button>
     *     &lt;button>Item 4&lt;/button>
     *     &lt;button>Item 5&lt;/button>
     *   &lt;/div>
     * &lt;/div>
     * 
     * // JS
     * $( ".selector" ).ojConveyorBelt( { "contentParent": "#myContentDiv" } );
     * 
     * @example <caption>Get or set the <code class="prettyprint">contentParent</code> 
     * option after initialization:</caption>
     * // getter
     * var contentParent = $( ".selector" ).ojConveyorBelt( "option", "contentParent" );
     * 
     * // setter
     * $( ".selector" ).ojConveyorBelt( "option", "contentParent", "#myContentDiv" );
     */
    contentParent: null
    
    /**
     * To avoid tight coupling between a ConveyorBelt and its contents, JET 
     * ConveyorBelt does not support the <code class="prettyprint">disabled</code> 
     * option.
     * 
     * <p><b>WARNING:</b> Applications should not depend on this behavior 
     * because we reserve the right to change it in the future in order to 
     * support <code class="prettyprint">disabled</code> and propagate it to 
     * child components of ConveyorBelt.  
     * 
     * @member
     * @name disabled
     * @memberof oj.ojConveyorBelt
     * @instance
     * @type {boolean}
     * @default <code class="prettyprint">false</code>
     */
    // disabled option declared in superclass, but we still want the above API doc
  },

  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @instance
   * @memberof! oj.ojConveyorBelt
   */
  _ComponentCreate : function () // Override of protected base class method.  
  {
    //call superclass first
    this._super();
    
    var elem = this.element;  
    elem.addClass("oj-conveyorbelt oj-component");
    
    //FIX BUG 18943900: log warning message when "disabled" option set
    var options = this.options;
    if (options.disabled)
    {
      oj.Logger.warn(_WARNING_DISABLED_OPTION);
    }
  },

  /** 
   * Called every time ojConveyorBelt is called without attributes. It's essentially
   * a hard-reset.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @protected
   */
  _init: function() // Override of protected base class method.  
  {
    this._setup(true);
  },

  // This method currently runs at create, init, and refresh time (since refresh() is called by _init()).
  /**
   * Refreshes the visual state of the conveyorBelt. JET components require a 
   * <code class="prettyprint">refresh()</code> or re-init after the DOM is 
   * programmatically changed underneath the component.
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose 
   * @memberof! oj.ojConveyorBelt
   * @instance
   * 
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" ).ojConveyorBelt( "refresh" );
   */
  refresh: function() // Override of public base class method.  
  {
    this._super();
    
    //if RTL has changed, just destroy and recreate the ConveyorBeltCommon
    var bRTL = (this._GetReadingDirection() === "rtl");
    var bRecreate = (bRTL !== this._bRTL);
    if (bRecreate)
    {
      this._destroyCBCommon();
    }
    this._setup(bRecreate);
  },

  // isInit is true for init (create and re-init), false for refresh
  /** 
   * Setup the conveyorBelt.
   * @param {boolean} isInit true if _setup is called from _init(), false
   *        if called from refresh()
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @private
   */
  _setup: function(isInit) // Private, not an override (not in base class).  
  {
    this._bRTL = (this._GetReadingDirection() === "rtl");
    var elem = this.element;  
    var options = this.options;
    if (isInit)
    {
      if (!this._cbCommon)
      {
        var orientation = options.orientation;
        var prevStyleClass = null;
        var nextStyleClass = null;
        var prevIcon = null;
        var nextIcon = null;
        var animateScrollFunc = null;
        if (orientation !== "vertical")
        {
          prevStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-start oj-default";
          nextStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-end oj-default";
          prevIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-start");
          nextIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-end");
          animateScrollFunc = this._animateScrollLeft;
        }
        else
        {
          prevStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-top oj-default";
          nextStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-bottom oj-default";
          prevIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-top");
          nextIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-bottom");
          animateScrollFunc = this._animateScrollTop;
        }
        var buttonInfo = {};
        buttonInfo.prevButtonStyleClass = prevStyleClass;
        buttonInfo.nextButtonStyleClass = nextStyleClass;
        buttonInfo.prevButtonIcon = prevIcon;
        buttonInfo.nextButtonIcon = nextIcon;
        var callbackInfo = {};
        callbackInfo.addResizeListener = oj.DomUtils.addResizeListener;
        callbackInfo.removeResizeListener = oj.DomUtils.removeResizeListener;
        //disable scroll animation during testing
        if (oj.Config.getAutomationMode() !== "enabled")
        {
          callbackInfo.scrollFunc = animateScrollFunc;
        }
        var contentParentElem = null;
        if (options.contentParent)
        {
          //only use the first result returned from the contentParent selector
          contentParentElem = $(options.contentParent)[0];
        }
        this._cbCommon = new window.adf.shared.impl.conveyorBelt.ConveyorBeltCommon(
            elem[0],
            orientation, 
            contentParentElem,
            this._bRTL, 
            buttonInfo, 
            callbackInfo);
      }
    }
    var cbCommon = this._cbCommon;
    cbCommon.setup(isInit);
    if (isInit)
    {
      var children = elem.find(".oj-conveyorbelt-overflow-indicator");
      var numChildren = children.size();
      for (var i = 0; i < numChildren; i++)
      {
        var child = children.get(i);
        this._setupButtonMouseStyles(child);
      }
    }
  },

  /** 
   * Destroy the conveyorBelt.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @protected
   */
  _destroy: function() // Override of protected base class method.  
  {
    this._destroyCBCommon();
    var elem = this.element;
    elem.removeClass("oj-conveyorbelt oj-component");
    
    //call superclass last
    this._super();
  },

  /** 
   * Set an option on the conveyorBelt.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @protected
   */
  _setOption: function(key, value, flags) // Override of protected base class method.
                                   // Method name needn't be quoted since is in externs.js.
  {
    var bRecreate = false;
    switch (key) 
    {
      //when changing containerParent or orientation, just destroy and recreate
      //the ConveyorBeltCommon
      case "containerParent":
      case "orientation":
        bRecreate = true;
        break;
      case "disabled":
        //FIX BUG 18943900: log warning message when "disabled" option set
        oj.Logger.warn(_WARNING_DISABLED_OPTION);
        break;
    }
    //if recreating, destroy the ConveyorBeltCommon before calling superclass
    //_setOption
    if (bRecreate)
    {
      this._destroyCBCommon();
    }
    this._super(key, value, flags);
    //if recreating, setup the new ConveyorBeltCommon after calling superclass
    //_setOption
    if (bRecreate)
    {
      this._setup(true);
    }
  },

  /** 
   * Destroy the ConveyorBeltCommon.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @private
   */
  _destroyCBCommon: function()
  {
    var cbCommon = this._cbCommon;
    if (cbCommon)
    {
      cbCommon.destroy();
    }
    this._cbCommon = null;
  },

  /** 
   * Setup mouse listeners to change button styles.
   * @param {Element} element DOM element to affect
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _setupButtonMouseStyles: function(element)
  {
    this._on(element,
      {
        mousedown: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).addClass("oj-active");
        },
        mouseup: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).removeClass("oj-active");
        },
        mouseenter: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).addClass("oj-hover");
          $(currTarget).removeClass("oj-default");
        },
        mouseleave: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).removeClass("oj-hover");
          $(currTarget).removeClass("oj-active");
          $(currTarget).addClass("oj-default");
        }
      });
  },

  /** 
   * Create a DOM element for an icon.
   * @param {string} iconStyleClass Style class for the icon
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _createIcon: function(iconStyleClass)
  {
    var span = document.createElement("span");
    span.setAttribute("class", "oj-component-icon oj-clickable-icon " + iconStyleClass);
    return span;
  },

  /** 
   * Animate setting the scrollLeft DOM property.
   * @param {Element} elem DOM element to scroll
   * @param {number} value Scroll value
   * @param {number} duration Duration of animation, in ms
   * @param {function()} onEndFunc Function to call when the animation ends
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _animateScrollLeft: function(elem, value, duration, onEndFunc)
  {
    var props = {};
    props["scrollLeft"] = value;
    //use swing instead of easeInOutCubic because easeInOutCubic isn't found
    //when running in the cookbook
    $(elem).animate(props, duration, "swing", onEndFunc);
  },

  /** 
   * Animate setting the scrollTop DOM property.
   * @param {Element} elem DOM element to scroll
   * @param {number} value Scroll value
   * @param {number} duration Duration of animation, in ms
   * @param {function()} onEndFunc Function to call when the animation ends
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _animateScrollTop: function(elem, value, duration, onEndFunc)
  {
    var props = {};
    props["scrollTop"] = value;
    //use swing instead of easeInOutCubic because easeInOutCubic isn't found
    //when running in the cookbook
    $(elem).animate(props, duration, "swing", onEndFunc);
  },
  
  /**
   * Return the subcomponent node represented by the documented locator 
   * attribute values.
   * Test authors should target sub elements using the following names:
   * <ul>
   * <li><b>oj-conveyorbelt-start-overflow-indicator</b>: the start overflow indicator of a
   * horizontal ConveyorBelt</li>
   * <li><b>oj-conveyorbelt-end-overflow-indicator</b>: the end overflow indicator of a
   * horizontal ConveyorBelt</li>
   * <li><b>oj-conveyorbelt-top-overflow-indicator</b>: the top overflow indicator of a
   * vertical ConveyorBelt</li>
   * <li><b>oj-conveyorbelt-bottom-overflow-indicator</b>: the bottom overflow indicator of
   * a vertical ConveyorBelt</li>
   * </ul>
   * @expose
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @param {Object} locator An Object containing at minimum a subId property 
   *        whose value is a string, documented by the component, that allows 
   *        the component to look up the subcomponent associated with that 
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one 
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component 
   *        expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    var subId = locator['subId'];
    if (subId === "oj-conveyorbelt-start-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-start")[0];
    }
    if (subId === "oj-conveyorbelt-end-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-end")[0];
    }
    if (subId === "oj-conveyorbelt-top-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-top")[0];
    }
    if (subId === "oj-conveyorbelt-bottom-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-bottom")[0];
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  }
}); // end of oj.__registerWidget

// start static members and functions //////////////////////////////////////////

//FIX BUG 18943900: log warning message when "disabled" option set
var _WARNING_DISABLED_OPTION = "JET ConveyorBelt: 'disabled' option not supported";
    
// end static members and functions ////////////////////////////////////////////

}()); // end of ConveyorBelt wrapper function
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class 
 * @name oj.ojThematicMap
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="thematicMapOverview-section">
 *   JET Thematic Map Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#thematicMapOverview-section"></a>
 * </h3>
 * 
 * <p>Thematic Map component for JET. Thematic maps are used to display data corresponding to a geographic location
 * or region, such as election data for a state or sales by territory for a product.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojThematicMap',
 *   basemap: 'usa',
 *   areaLayers: [{
 *     layer: 'states',
 *     areaDataLayer: {
 *       areas: [{color:'#003366', location:'FL'},
 *               {color:'#CC3300', location:'TX'},
 *               {color:'#99CC33', location:'CA'}]
 *     }
 *   }]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="thematicMapOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#thematicMapOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/thematicMap.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.  Since component terminology for keyboard 
 * and touch shortcuts can conflict with those of the application, it is the 
 * application's responsibility to provide these shortcuts, possibly via a help 
 * popup.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *   <tr><td><kbd>Tab</kbd></td><td>Move focus to map and then to next component</td></tr>
 *   <tr><td><kbd>Shift+Tab</kbd></td><td>Move focus to map and then to previous component</td></tr>
 *   <tr><td><kbd>= or +</kbd></td><td>Zoom in one level if zooming is enabled</td></tr>
 *   <tr><td><kbd>- or _</kbd></td><td>Zoom out one level if zooming is enabled</td></tr>
 *   <tr><td><kbd>0</kbd></td><td>Zoom to fit map if zooming is enabled</td></tr>
 *   <tr><td><kbd>Ctrl+Alt+0</kbd></td><td>Zoom to fit region with focus</td></tr>
 *   <tr><td><kbd>Ctrl+0</kbd></td><td>Zoom to fit selected regions</td></tr>
 *   <tr><td><kbd>Ctrl+Shift+0</kbd></td><td>Reset map</td></tr>
 *   <tr><td><kbd>PageUp</kbd></td><td>Pan up</td></tr>
 *   <tr><td><kbd>PageDown</kbd></td><td>Pan down</td></tr>
 *   <tr><td><kbd>Shift+PageUp</kbd></td><td>Pans left in left to right locales.  Pans right in right to left locales.</td></tr>
 *   <tr><td><kbd>Shift+PageDown</kbd></td><td>Pans right in left to right locales.  Pans left in right to left locales.</td></tr>
 *   <tr><td><kbd>LeftArrow</kbd></td><td>Move focus and selection to nearest base map region or marker to the left in same data layer</td></tr>
 *   <tr><td><kbd>RightArrow</kbd></td><td>Move focus and selection to nearest base map region or marker to the right in same data layer</td></tr>
 *   <tr><td><kbd>UpArrow</kbd></td><td>Move focus and selection to nearest base map region or marker above in same data layer</td></tr>
 *   <tr><td><kbd>DownArrow</kbd></td><td>Move focus and selection to nearest base map region or marker below in same data layer</td></tr>
 *   <tr><td><kbd>Shift+LeftArrow</kbd></td><td>Move focus and multi-select nearest base map region or marker to the left in same data layer</td></tr>
 *   <tr><td><kbd>Shift+RightArrow</kbd></td><td>Move focus and multi-select nearest base map region or marker to the right in same data layer</td></tr>
 *   <tr><td><kbd>Shift+UpArrow</kbd></td><td>Move focus and multi-select nearest base map region or marker above in same data layer</td></tr>
 *   <tr><td><kbd>Shift+DownArrow</kbd></td><td>Move focus and multi-select nearest base map region or marker below in same data layer</td></tr>
 *   <tr><td><kbd>Ctrl+LeftArrow</kbd></td><td>Move focus to nearest base map region or marker to the left in same data layer, without changing the current selection</td></tr>
 *   <tr><td><kbd>Ctrl+RightArrow</kbd></td><td>Move focus to nearest base map region or marker to the right in same data layer, without changing the current selection</td></tr>
 *   <tr><td><kbd>Ctrl+UpArrow</kbd></td><td>Move focus to nearest base map region or marker above in same data layer, without changing the current selection</td></tr>
 *   <tr><td><kbd>Ctrl+DownArrow</kbd></td><td>Move focus to nearest base map region or marker below in same data layer, without changing the current selection</td></tr>
 *   <tr><td><kbd>]</kbd></td><td>Move focus and selection to nearest marker in the next data layer above</td></tr>
 *   <tr><td><kbd>[</kbd></td><td>Move focus and selection to nearest base map region or marker in the next data layer below</td></tr>
 *   <tr><td><kbd>Shift+]</kbd></td><td>Move focus to nearest marker in the next data layer above and multi-select</td></tr>
 *   <tr><td><kbd>Shift+[</kbd></td><td>Move focus to nearest base map region or marker in the next data layer below and multi-select</td></tr>
 *   <tr><td><kbd>Ctrl+]</kbd></td><td>Move focus to nearest marker in the next data layer above, without changing the current selection</td></tr>
 *   <tr><td><kbd>Ctrl+[</kbd></td><td>Move focus to nearest base map region or marker in the next data layer below, without changing the current selection</td></tr>
 *   <tr><td><kbd>Ctrl+Spacebar</kbd></td><td>Multi-select base map region or marker with focus</td></tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Thematic Map.
 * @example <caption>Initialize the Thematic Map with no options specified:</caption>
 * $(".selector").ojThematicMap();
 * 
 * @example <caption>Initialize the Thematic Map with some options:</caption>
 * $(".selector").ojThematicMap({basemap: 'usa'});
 * 
 * @example <caption>Initialize the Thematic Map via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojThematicMap'}">
 */
oj.__registerWidget('oj.ojThematicMap', $['oj']['dvtBaseComponent'],
  {
    version: "1.0.0",
    widgetEventPrefix: "oj",
    options: {
      /**
       * Triggered after data items are selected or de-selected.
       * 
       * @property {Object} ui event payload
       * @property {Array} ui.items an array containing objects describing the selected data items
       * @property {string} ui.items.dataLayerId the id of the data layer to which the data item belongs
       * @property {string} ui.items.id the id of the data item
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
       * $(".selector").ojThematicMap({
       *   "select": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
       * $(".selector").on("ojselect", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojThematicMap
       * @instance
       */
      select: null,
      /**
       * Triggered after thematic map resources are loaded and the component has rendered.
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
       * $(".selector").ojThematicMap({
       *   "load": function(){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
       * $(".selector").on("ojload", function(){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojThematicMap
       * @instance
       */
      load: null
    },
    
    _selectedItems: {},
    _loadedBasemaps: [],
    _checkBasemaps: [],
    _supportedLocales: ['ar', 'cs', 'da', 'de', 'el', 'es', 'fi', 'fr', 'hu', 'it', 'iw', 'ja', 'ko', 'nl', 'no', 'pl', 'pt', 'pt_BR', 'ro', 'ru', 'sk', 'sv', 'th', 'tr', 'zh_CN', 'zh_TW'],
    
    /**
     * @override
     * @memberof! oj.ojThematicMap
     * @instance
     * @protected
     */
    _CreateDvtComponent: function(context, callback, callbackObj) {
      return DvtThematicMap.newInstance(context, callback, callbackObj);
    },
    
    /**
     * @override
     * @memberof! oj.ojThematicMap
     * @instance
     * @protected
     */
    _GetComponentStyleClasses: function() {
      var styleClasses = this._super();
      styleClasses.push('oj-thematicmap');
      return styleClasses;
    },
    
    /**
     * @override
     * @memberof! oj.ojThematicMap
     * @instance
     * @protected
     */
    _GetChildStyleClasses: function() {
      var styleClasses = this._super();
      styleClasses['oj-dvtbase oj-thematicmap'] = {'path': 'animationDuration', 'property': 'animation-duration'};
      styleClasses['oj-thematicmap-arealayer'] = [
        {'path': 'styleDefaults/areaStyle', 'property': 'CSS_BACKGROUND_PROPERTIES'},
        {'path': 'styleDefaults/labelStyle', 'property': 'CSS_TEXT_PROPERTIES'}
      ];
      styleClasses['oj-thematicmap-area'] = {'path': 'styleDefaults/dataAreaDefaults/borderColor', 'property': 'border-top-color'};
      styleClasses['oj-thematicmap-area oj-hover'] = {'path': 'styleDefaults/dataAreaDefaults/hoverColor', 'property': 'border-top-color'};
      styleClasses['oj-thematicmap-area oj-selected'] = [
        {'path': 'styleDefaults/dataAreaDefaults/selectedInnerColor', 'property': 'border-top-color'},
        {'path': 'styleDefaults/dataAreaDefaults/selectedOuterColor', 'property': 'border-bottom-color'}];
      styleClasses['oj-thematicmap-marker'] = [
        {'path': 'styleDefaults/dataMarkerDefaults/labelStyle', 'property': 'CSS_TEXT_PROPERTIES'},
        {'path': 'styleDefaults/dataMarkerDefaults/color', 'property': 'background-color'},
        {'path': 'styleDefaults/dataMarkerDefaults/opacity', 'property': 'opacity'},
        {'path': 'styleDefaults/dataMarkerDefaults/borderStyle', 'property': 'border-style'},
        {'path': 'styleDefaults/dataMarkerDefaults/borderColor', 'property': 'border-top-color'},
        {'path': 'styleDefaults/dataMarkerDefaults/borderWidth', 'property': 'border-width'}
      ];
      return styleClasses;
    },
    
    /**
     * @override
     * @memberof! oj.ojThematicMap
     * @instance
     * @protected
     */
    _GetEventTypes : function() {
      return ['load', 'select'];
    },
    
    /**
     * @override
     * @memberof! oj.ojThematicMap
     * @instance
     * @protected
     */
    _Render: function() {
      // For thematic map, we must ensure that all basemaps are loaded before rendering.  If basemaps are still loading,
      // return and wait for the load listener to call _Render again.
      this._loadBasemap();
      for (var i = 0; i < this._checkBasemaps.length; i++) {
        if (!this._loadedBasemaps[this._checkBasemaps[i]])
          return;
      }
      this._checkBasemaps = [];
      
      // Delegate to the super to call the shared JS component for actual rendering.
      this._super();
      
      // Send event once basemaps have been loaded and rendering is complete
      this._trigger('load', null, null);
    },
    
    /**
     * Loads the basemaps and resource bundles.
     * @private
     */
    _loadBasemap: function() {
      var basemap = this.options['basemap'];
      if (basemap) {
        var locale = oj.Config.getLocale();

        // Track basemaps that need to be loaded before rendering
        basemap = basemap.charAt(0).toUpperCase() + basemap.slice(1);

        var areaLayers = this.options['areaLayers'];
        // load area layer basemaps
        if (areaLayers) {
          for (var i = 0; i < areaLayers.length; i++) {
            var layer = areaLayers[i]['layer'];
            if (layer) {
              layer = layer.charAt(0).toUpperCase() + layer.slice(1);
              this._loadBasemapHelper(basemap, layer, locale);
            }
          }
        }

        // load city basemap
        var pointDataLayers = this.options['pointDataLayers'];
        if (pointDataLayers && pointDataLayers.length > 0)
          this._loadBasemapHelper(basemap, 'Cities', locale);
      }
    },
    
    /**
     * Utility function for loading resource bundles by url.
     * @param {string} url The url of the resource to load
     * @private
     */
    _loadResourceByUrl: function(url) {
      // resource is already loaded or function tried to load this resource but failed
      if (this._loadedBasemaps[url])
        return;

      var resolvedUrl = oj.Config.getResourceUrl(url);
      var thisRef = this;
      var loadedBundles = this._loadedBasemaps;
      $.getScript(resolvedUrl, function(data, textStatus, jqxhr) {
        loadedBundles[url] = true;
        thisRef._Render();
      });
    },
    
    _loadBasemapHelper: function(basemap, layer, locale) {
      var relativeUrl = 'resources/internal-deps/dvt/thematicMap/basemaps/DvtBaseMap' + basemap + layer + '.js';
      this._checkBasemaps.push(relativeUrl);

      if (locale.indexOf('en') === -1) {
        // split locale by subtags and try to load resource bundle that satisfies
        var splitLocale = locale.split('_');
        var localeList = [];
        for (var j = 0; j < splitLocale.length; j++) {
          var tempLocale = '';
          for (var k = 0; k < (j + 1); k++) {
            if (k != 0)
              tempLocale += '_';
            tempLocale += splitLocale[k];
          }
          localeList.push(tempLocale)
        }

        var bundleName = 'resources/internal-deps/dvt/thematicMap/resourceBundles/' + basemap + layer + 'Bundle';
        // Go thru list of supported DVT languages
        for (var i = localeList.length - 1; i >= 0; i++) {
          if (this._supportedLocales.indexOf(localeList[i]) !== -1) {
            var bundleUrl = bundleName + "_" + localeList[i] + ".js";
            this._checkBasemaps.push(bundleUrl);
            this._loadResourceByUrl(bundleUrl);
            break;
          }
        }
      }

      this._loadResourceByUrl(relativeUrl);
    },
    
    /**
     * @override
     * @memberof! oj.ojThematicMap
     * @instance
     * @protected
     */
    _HandleEvent: function(event) {
      var type = event && event.getType ? event.getType() : null, selectedItems, selection, i, selectedItem;
      if (type === DvtSelectionEvent.TYPE) {
        selectedItems = [];
        selection = event.getSelection();
        var dataLayerId = event.getParamValue('clientId');
        for (i = 0; i < selection.length; i++) {
          selectedItem = {'id': selection[i], 'dataLayerId': dataLayerId};
          selectedItems.push(selectedItem);
          this._selectedItems[dataLayerId] = selection;
        }
        this._updateSelectionItems();
        // TODO selectedItems need to be all the selected items for all the data layers
        this._trigger('select', null, {'items': selectedItems});
      }
      else {
        this._super(event);
      }
    },
    
    /**
     * Updates the options object with the current data layer selection states 
     * @private
     */
    _updateSelectionItems: function() {
      var pdls = this.options['pointDataLayers'];
      if (pdls) {
        for (var i = 0; i < pdls.length; i++) {
          if (this._selectedItems[pdls[i]['id']])
            pdls[i]['selectedItems'] = this._selectedItems[pdls[i]['id']];
        }
      }
   
      var als = this.options['areaLayers'];
      for (var i = 0; i < als.length; i++) {
        // JET Thematic Map does not support nesting of point data layers within an area layer
        var adl = als[i]['areaDataLayer'];
        if (this._selectedItems[adl['id']])
          adl['selectedItems'] = this._selectedItems[adl['id']];
      }
    },
    
    /**
     * Returns the subcomponent node represented by the documented locator attribute values.
     * Test authors should target thematic map sub elements using the following names:
     * <ul>
     *   <li>dataLayerId:area[id] - An area indexed by the given id in a data layer with id dataLayerId</li>
     *   <li>dataLayerId:marker[id] - A marker indexed by the given id in a data layer with id dataLayerId</li>
     * </ul>
     * @override
     * @memberof! oj.ojThematicMap
     * @instance
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator) {
      return this._super(locator);
    },
    
    /**
     * Returns the subId string for the given child DOM node. Valid thematic map subIds include:
     * <ul>
     *   <li>dataLayerId:area[id] - An area indexed by the given id in a data layer with id dataLayerId</li>
     *   <li>dataLayerId:marker[id] - A marker indexed by the given id in a data layer with id dataLayerId</li>
     * </ul>
     * @override
     * @expose
     * @memberof! oj.ojThematicMap
     * @instance
     * @param {Element} node The subcomponent node used by the component to lookup the subId string
     * @return {string|null} - the subId for the DOM node or null when none is found
     */
    getSubIdByNode: function(node) {
      return this._super(node);
    },
    
    /**
     * Returns a ThematicMapArea object for automation testing verification.
     * @param {String} dataLayerId The dataLayer id
     * @param {String} id The area id 
     * @return {Object} The thematic map area with the given id 
     *                             within the given data layer or null if none exists
     * @expose
     * @instance
     * @memberof! oj.ojThematicMap
     */
    getArea : function(dataLayerId, id) {
      var auto = this._component.getAutomation();
      return new oj.ThematicMapArea(auto.getData(dataLayerId, 'area', id));
    },
    
    /**
     * Returns a ThematicMapMarker object for automation testing verification.
     * @param {String} dataLayerId The dataLayer id
     * @param {String} id The marker id 
     * @return {Object} The thematic map marker with the given id 
     *                             within the given data layer or null if none exists
     * @expose
     * @instance
     * @memberof! oj.ojThematicMap
     */
    getMarker : function(dataLayerId, id) {
      var auto = this._component.getAutomation();
      return new oj.ThematicMapMarker(auto.getData(dataLayerId, 'marker', id));
    }
});
/**
 * An object used for automation verification of thematic map markers.
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ThematicMapMarker = function(data) {
  this._data = data;
};

/**
 * Returns the color of a thematic map marker
 * @return {String} The marker color
 * @export
 */
oj.ThematicMapMarker.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the label of a thematic map marker
 * @return {String} The marker tooltip
 * @export
 */
oj.ThematicMapMarker.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns the tooltip of a thematic map marker
 * @return {String} The marker tooltip
 * @export
 */
oj.ThematicMapMarker.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};

/**
 * Returns whether a thematic map marker is selected
 * @return {boolean} Whether the marker is selected
 * @export
 */
oj.ThematicMapMarker.prototype.isSelected = function() {
  return this._data ? this._data['isSelected'] : false;
};
/**
 * An object used for automation verification of thematic map areas.
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ThematicMapArea = function(data) {
  this._data = data;
};

/**
 * Returns the color of a thematic map area
 * @returns {String} The area color
 * @export
 */
oj.ThematicMapArea.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the tooltip of a thematic map area
 * @returns {String} The area tooltip
 * @export
 */
oj.ThematicMapArea.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns the label of a thematic map area
 * @returns {String} The area label
 * @export
 */
oj.ThematicMapArea.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};

/**
 * Returns whether a thematic map area is selected
 * @return {boolean} Whether the area is selected
 * @export
 */
oj.ThematicMapArea.prototype.isSelected = function() {
  return this._data ? this._data['isSelected'] : false;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

// lory retrieved from https://raw.github.com/jquery/jquery-ui/1-10-stable/ui/jquery.ui.resizable.js on 04/09/2014, and then modified


/*
*
*   - This widget is NOT EXPOSED.
*     ojResizable is made available only to dialog and other components that need to call resize functionality.
*   Changes:
*    - Options minWidth, minHeight, maxWidth, and maxHeight have been deleted
*    - Removed zIndex option
*    - Removed css write of zIndex (this is supported in style sheets)
*
*/

(function() {

    "use strict";

    var mouseHandled = false;
    $( document ).mouseup( function() {
	mouseHandled = false;
    });


    oj.__registerWidget("oj.ojResizable", $['oj']['baseComponent'], {
	version: "1.0.0",
        widgetEventPrefix : "oj", 

	options: {

	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Mouse Options (copied)
	//
	/////////////////////////////////////////////////////////////////////////////////////

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    cancel: "input,textarea,button,select,option",

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    distance: 1,

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    delay: 0,

	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Resize Options
	//
	/////////////////////////////////////////////////////////////////////////////////////


	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    maxHeight: null,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    maxWidth: null,

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    minHeight: 10,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    minWidth: 10,

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    alsoResize: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    animate: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    animateDuration: "slow",
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    animateEasing: "swing",

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    containment: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    ghost: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    grid: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    handles: "e,s,se",
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    helper: false,

	    // See #7960
	    // zIndex: 90,

	    /////////////////
	    // callbacks
	    /////////////////


            /**
              * Triggered when the ojResizable is resized.
              *
              * @private
              * @expose
              * @event 
              * @name resize
              * @memberof! oj.ojResizable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Empty object included for consistency with other events
              * 
              * @example <caption>Initialize the resizable with the <code class="prettyprint">resize</code> callback specified:</caption>
              * $( ".selector" ).ojResizable({
              *     "resize": function( event, ui ) {}
              * });
              * 
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojresize</code> event:</caption>
              * $( ".selector" ).on( "ojresize", function( event, ui ) {} );
              */
	    resize: null,

            /**
              * Triggered on the start of a resize operation.
              *
              * @private
              * @expose
              * @event 
              * @name start
              * @memberof! oj.ojResizable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Empty object included for consistency with other events
              * 
              * @example <caption>Initialize the resizable with the <code class="prettyprint">start</code> callback specified:</caption>
              * $( ".selector" ).ojResizable({
              *     "start": function( event, ui ) {}
              * });
              * 
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojstart</code> event:</caption>
              * $( ".selector" ).on( "ojstart", function( event, ui ) {} );
              */
	    // note - jqui doc has .on("resizestart" 
	    start: null,


            /**
              * Triggered on the end of a resize operation.
              *
              * @private
              * @expose
              * @event 
              * @name stop
              * @memberof! oj.ojResizable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Empty object included for consistency with other events
              * 
              * @example <caption>Initialize the resizable with the <code class="prettyprint">stop</code> callback specified:</caption>
              * $( ".selector" ).ojResizable({
              *     "stop": function( event, ui ) {}
              * });
              * 
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojstop</code> event:</caption>
              * $( ".selector" ).on( "ojstop", function( event, ui ) {} );
              */
	    // note - jqui doc has .on("resizestop" 
	    stop: null
	},

	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Mouse Functions (copied)
	//
	/////////////////////////////////////////////////////////////////////////////////////

	_mouseInit: function() {
	    var that = this;

	    this.element
		.bind("mousedown." + this.widgetName, function(event) {
		    return that._mouseDown(event);
		})
		.bind("click." + this.widgetName, function(event) {
		    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, that.widgetName + ".preventClickEvent");
			event.stopImmediatePropagation();
			return false;
		    }
		});

	    this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
	    this.element.unbind("." + this.widgetName);
	    if ( this._mouseMoveDelegate ) {
		this.document
		    .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
		    .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
	    }
	},

	_mouseDown: function(event) {
	    // don't let more than one widget handle mouseStart
	    if ( mouseHandled ) {
		return;
	    }

	    // we may have missed mouseup (out of window)
	    (this._mouseStarted && this._mouseUp(event));

	    this._mouseDownEvent = event;

	    var that = this,
	    btnIsLeft = (event.which === 1),
	    // event.target.nodeName works around a bug in IE 8 with
	    // disabled inputs (#7620)
	    elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
	    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
		return true;
	    }

	    this.mouseDelayMet = !this.options.delay;
	    if (!this.mouseDelayMet) {
		this._mouseDelayTimer = setTimeout(function() {
		    that.mouseDelayMet = true;
		}, this.options.delay);
	    }

	    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
		this._mouseStarted = (this._mouseStart(event) !== false);
		if (!this._mouseStarted) {
		    event.preventDefault();
		    return true;
		}
	    }

	    // Click event may never have fired (Gecko & Opera)
	    if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
		$.removeData(event.target, this.widgetName + ".preventClickEvent");
	    }

	    // these delegates are required to keep context
	    this._mouseMoveDelegate = function(event) {
		return that._mouseMove(event);
	    };
	    this._mouseUpDelegate = function(event) {
		return that._mouseUp(event);
	    };

	    this.document
		.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
		.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

	    event.preventDefault();

	    mouseHandled = true;
	    return true;
	},

	_mouseMove: function(event) {
	    // IE mouseup check - mouseup happened when mouse was out of window
	    if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
		return this._mouseUp(event);

		// Iframe mouseup check - mouseup occurred in another document
	    } else if ( !event.which ) {
		return this._mouseUp( event );
	    }

	    if (this._mouseStarted) {
		this._mouseDrag(event);
		return event.preventDefault();
	    }

	    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
		this._mouseStarted =
		    (this._mouseStart(this._mouseDownEvent, event) !== false);
		(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
	    }

	    return !this._mouseStarted;
	},

	_mouseUp: function(event) {
	    this.document
		.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
		.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

	    if (this._mouseStarted) {
		this._mouseStarted = false;

		if (event.target === this._mouseDownEvent.target) {
		    $.data(event.target, this.widgetName + ".preventClickEvent", true);
		}

		this._mouseStop(event);
	    }

	    mouseHandled = false;
	    return false;
	},

	_mouseDistanceMet: function(event) {
	    return (Math.max(
		Math.abs(this._mouseDownEvent.pageX - event.pageX),
		Math.abs(this._mouseDownEvent.pageY - event.pageY)
	    ) >= this.options.distance
		   );
	},

	_mouseDelayMet: function(/* event */) {
	    return this.mouseDelayMet;
	},


	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Original Resize Functions
	//
	/////////////////////////////////////////////////////////////////////////////////////


	_num: function( value ) {
	    return parseInt( value, 10 ) || 0;
	},

	_isNumber: function( value ) {
	    return !isNaN( parseInt( value , 10 ) );
	},

	_hasScroll: function( el, a ) {

	    if ( $( el ).css( "overflow" ) === "hidden") {
		return false;
	    }

	    var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
	    has = false;

	    if ( el[ scroll ] > 0 ) {
		return true;
	    }

	    // TODO: determine which cases actually cause this to happen
	    // if the element doesn't have the scroll set, see if it's possible to
	    // set the scroll
	    el[ scroll ] = 1;
	    has = ( el[ scroll ] > 0 );
	    el[ scroll ] = 0;
	    return has;
	},

        /**
         * Triggered when the ojResizable is created.
         *
         * @private
         * @expose
         * @event 
         * @name create
         * @memberof! oj.ojResizable
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the resizable with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojResizable({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
	// note - jqui has on("resizecreate", ... need to verify if we need some form of "ojcreate".
	_ComponentCreate : function ()
	{
            this._super();

	    // _create: function() {

	    var n, i, handle, axis, hname,
	    that = this,
	    o = this.options;
	    this.element.addClass("oj-resizable");

	    $.extend(this, {
		originalElement: this.element,
		_proportionallyResizeElements: [],
		// _helper: o.helper || o.ghost || o.animate ? o.helper || "oj-resizable-helper" : null
		_helper: null
	    });

	    this._initialResize = true;
/*


	    // Wrap the element if it cannot hold child nodes
	    if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

		this.element.wrap(
		    $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
			position: this.element.css("position"),
			width: this.element.outerWidth(),
			height: this.element.outerHeight(),
			top: this.element.css("top"),
			left: this.element.css("left")
		    })
		);

		this.element = this.element.parent().data(
		    "oj-resizable", this.element.resizable( "instance" )
		);

		this.elementIsWrapper = true;

		this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
		this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});
		// support: Safari
		// Prevent Safari textarea resize
		this.originalResizeStyle = this.originalElement.css("resize");
		this.originalElement.css("resize", "none");

		this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

		// support: IE9
		// avoid IE jump (hard set the margin)
		this.originalElement.css({ margin: this.originalElement.css("margin") });

		this._proportionallyResize();
	    }
*/


	    this.handles = o.handles || (!$(".oj-resizable-handle", this.element).length ? "e,s,se" : { n: ".oj-resizable-n", e: ".oj-resizable-e", s: ".oj-resizable-s", w: ".oj-resizable-w", se: ".oj-resizable-se", sw: ".oj-resizable-sw", ne: ".oj-resizable-ne", nw: ".oj-resizable-nw" });
	    if(this.handles.constructor === String) {

		if ( this.handles === "all") {
		    this.handles = "n,e,s,w,se,sw,ne,nw";
		}

		n = this.handles.split(",");
		this.handles = {};

		for(i = 0; i < n.length; i++) {

		    handle = $.trim(n[i]);
		    hname = "oj-resizable-"+handle;
		    axis = $("<div class='oj-resizable-handle " + hname + "'></div>");

		    // axis.css({ zIndex: o.zIndex });

		    // Todo: refine for alta styles
		    // 
		    // if ("se" === handle) {
		    // axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
		    //}

		    this.handles[handle] = ".oj-resizable-"+handle;
		    this.element.append(axis);
		}
	    }

	    this._renderAxis = function(target) {

		var i, axis, padPos, padWrapper;

		target = target || this.element;

		for(i in this.handles) {

		    if(this.handles[i].constructor === String) {
			this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
		    }

		}
	    };

	    // TODO: make renderAxis a prototype function
	    this._renderAxis(this.element);

	    // removed 
	    // this._handles = $(".oj-resizable-handle", this.element).disableSelection();
	    this._handles = $(".oj-resizable-handle", this.element);

	    this._handles.mouseover(function() {
		if (!that.resizing) {
		    if (this.className) {
			axis = this.className.match(/oj-resizable-(se|sw|ne|nw|n|e|s|w)/i);
		    }
		    that.axis = axis && axis[1] ? axis[1] : "se";
		}
	    });

	    this._mouseInit();

	},

	/**
	 * Remove the ojResizable functionality completely. 
	 * This will return the element back to its pre-init state.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
         * @private
         * @expose
	 * @method
	 * @name oj.ojResizable#destroy
	 * @memberof! oj.ojResizable
	 * @instance
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
	 * var destroy = $( ".selector" ).ojResizable( "destroy" );
	 */

	_destroy: function() {

	    this._mouseDestroy();

	    var wrapper,
	    _destroy = function(exp) {
		$(exp).removeClass("oj-resizable oj-resizable-disabled oj-resizable-resizing")
		    .removeData("resizable").removeData("oj-resizable").unbind(".resizable").find(".oj-resizable-handle").remove();
	    };

/*

	    if (this.elementIsWrapper) {
		_destroy(this.element);
		wrapper = this.element;
		this.originalElement.css({
		    position: wrapper.css("position"),
		    width: wrapper.outerWidth(),
		    height: wrapper.outerHeight(),
		    top: wrapper.css("top"),
		    left: wrapper.css("left")
		}).insertAfter( wrapper );
		wrapper.remove();
	    }

*/

	    // this.originalElement.css("resize", this.originalResizeStyle);
	    _destroy(this.originalElement);

	    return this;
	},

	_mouseCapture: function(event) {
	    var i, handle,
	    capture = false;

	    for (i in this.handles) {
		handle = $(this.handles[i])[0];
		if (handle === event.target || $.contains(handle, event.target)) {
		    capture = true;
		}
	    }

	    return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

	    var curleft, curtop, cursor,
	    o = this.options,
	    iniPos = this.element.position(),
	    el = this.element;

	    this.resizing = true;

	    // Bugfix for http://bugs.jqueryui.com/ticket/1749
	    if ( (/absolute/).test( el.css("position") ) ) {
		el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
	    } else if (el.is(".ui-draggable")) {
		el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
	    }

	    this._renderProxy();

	    curleft = this._num(this.helper.css("left"));
	    curtop = this._num(this.helper.css("top"));

	    if (o.containment) {
		curleft += $(o.containment).scrollLeft() || 0;
		curtop += $(o.containment).scrollTop() || 0;
	    }

	    this.offset = this.helper.offset();
	    this.position = { left: curleft, top: curtop };
	    this.size = { width: el.width(), height: el.height() };
	    this.originalSize = { width: el.width(), height: el.height() };
	    this.originalPosition = { left: curleft, top: curtop };
	    this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
	    this.originalMousePosition = { left: event.pageX, top: event.pageY };

	    this.aspectRatio =  (this.originalSize.width / this.originalSize.height) || 1;

	    // cursor = $(".oj-resizable-" + this.axis).css("cursor");
	    cursor = /** @type string */ ($(".oj-resizable-" + this.axis).css("cursor"));
	    $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

	    el.addClass("oj-resizable-resizing");

	    this._propagate("start", event);

	    this._alsoresize_start(event);
	    this._containment_start(event);

	    return true;
	},

	_mouseDrag: function(event) {

	    var data,
	    el = this.helper, props = {},
	    smp = this.originalMousePosition,
	    a = this.axis,
	    dx = (event.pageX-smp.left)||0,
	    dy = (event.pageY-smp.top)||0,
	    trigger = this._change[a];

	    this.prevPosition = {
		top: this.position.top,
		left: this.position.left
	    };
	    this.prevSize = {
		width: this.size.width,
		height: this.size.height
	    };

	    if (!trigger) {
		return false;
	    }

	    data = trigger.apply(this, [event, dx, dy]);

	    this._updateVirtualBoundaries(event.shiftKey);
	    if (event.shiftKey) {
		data = this._updateRatio(data, event);
	    }

	    data = this._respectSize(data, event);

	    this._updateCache(data);

	    this._propagate("resize", event);

	    this._alsoresize_resize(event, this.ui());
	    this._containment_resize(event, this.ui());

	    if ( this.position.top !== this.prevPosition.top ) {
		props.top = this.position.top + "px";
	    }
	    if ( this.position.left !== this.prevPosition.left ) {
		props.left = this.position.left + "px";
	    }
	    if ( this.size.width !== this.prevSize.width ) {
		props.width = this.size.width + "px";
	    }
	    if ( this.size.height !== this.prevSize.height ) {
		props.height = this.size.height + "px";
	    }
	    el.css( props );

	    if ( !this._helper && this._proportionallyResizeElements.length ) {
		this._proportionallyResize();
	    }

	    if ( !$.isEmptyObject( props ) ) {
		this._trigger( "resize", event, this.ui() );
	    }

	    return false;
	},

	_mouseStop: function(event) {

	    this.resizing = false;
	    var pr, ista, soffseth, soffsetw, s, left, top,
	    o = this.options, that = this;

	    $("body").css("cursor", "auto");

	    this.element.removeClass("oj-resizable-resizing");

	    this._propagate("stop", event);

	    this._alsoresize_stop(event);
	    this._containment_stop(event);

	    return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
	    var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
	    o = this.options;

	    b = {
		minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
		maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
		minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
		maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity

		/*
		minWidth: 0,
		maxWidth: Infinity,
		minHeight: 0,
		maxHeight: Infinity
*/

	    };

	    if(forceAspectRatio) {
		pMinWidth = b.minHeight * this.aspectRatio;
		pMinHeight = b.minWidth / this.aspectRatio;
		pMaxWidth = b.maxHeight * this.aspectRatio;
		pMaxHeight = b.maxWidth / this.aspectRatio;

		if(pMinWidth > b.minWidth) {
		    b.minWidth = pMinWidth;
		}
		if(pMinHeight > b.minHeight) {
		    b.minHeight = pMinHeight;
		}
		if(pMaxWidth < b.maxWidth) {
		    b.maxWidth = pMaxWidth;
		}
		if(pMaxHeight < b.maxHeight) {
		    b.maxHeight = pMaxHeight;
		}
	    }
	    this._vBoundaries = b;
	},

	_updateCache: function(data) {
	    this.offset = this.helper.offset();
	    if (this._isNumber(data.left)) {
		this.position.left = data.left;
	    }
	    if (this._isNumber(data.top)) {
		this.position.top = data.top;
	    }
	    if (this._isNumber(data.height)) {
		this.size.height = data.height;
	    }
	    if (this._isNumber(data.width)) {
		this.size.width = data.width;
	    }
	},

	_updateRatio: function( data ) {

	    var cpos = this.position,
	    csize = this.size,
	    a = this.axis;

	    if (this._isNumber(data.height)) {
		data.width = (data.height * this.aspectRatio);
	    } else if (this._isNumber(data.width)) {
		data.height = (data.width / this.aspectRatio);
	    }

	    if (a === "sw") {
		data.left = cpos.left + (csize.width - data.width);
		data.top = null;
	    }
	    if (a === "nw") {
		data.top = cpos.top + (csize.height - data.height);
		data.left = cpos.left + (csize.width - data.width);
	    }

	    return data;
	},

	_respectSize: function( data ) {

	    var o = this._vBoundaries,
	    a = this.axis,
	    ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
	    isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
	    dw = this.originalPosition.left + this.originalSize.width,
	    dh = this.position.top + this.size.height,
	    cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
	    if (isminw) {
		data.width = o.minWidth;
	    }
	    if (isminh) {
		data.height = o.minHeight;
	    }
	    if (ismaxw) {
		data.width = o.maxWidth;
	    }
	    if (ismaxh) {
		data.height = o.maxHeight;
	    }

	    if (isminw && cw) {
		data.left = dw - o.minWidth;
	    }
	    if (ismaxw && cw) {
		data.left = dw - o.maxWidth;
	    }
	    if (isminh && ch) {
		data.top = dh - o.minHeight;
	    }
	    if (ismaxh && ch) {
		data.top = dh - o.maxHeight;
	    }

	    // Fixing jump error on top/left - bug #2330
	    if (!data.width && !data.height && !data.left && data.top) {
		data.top = null;
	    } else if (!data.width && !data.height && !data.top && data.left) {
		data.left = null;
	    }

	    return data;
	},

	_proportionallyResize: function() {

	    if (!this._proportionallyResizeElements.length) {
		return;
	    }

	    var i, j, borders, paddings, prel,
	    element = this.helper || this.element;

	    for ( i=0; i < this._proportionallyResizeElements.length; i++) {

		prel = this._proportionallyResizeElements[i];

		if (!this.borderDif) {
		    this.borderDif = [];
		    borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
		    paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

		    for ( j = 0; j < borders.length; j++ ) {
			this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
		    }
		}

		prel.css({
		    height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
		    width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
		});

	    }

	},

	_renderProxy: function() {

	    var el = this.element, o = this.options;
	    this.elementOffset = el.offset();

	    this.helper = this.element;

	},

	_change: {
	    "e": function(event, dx) {
		return { width: this.originalSize.width + dx };
	    },
	    "w": function(event, dx) {
		var cs = this.originalSize, sp = this.originalPosition;
		return { left: sp.left + dx, width: cs.width - dx };
	    },
	    "n": function(event, dx, dy) {
		var cs = this.originalSize, sp = this.originalPosition;
		return { top: sp.top + dy, height: cs.height - dy };
	    },
	    "s": function(event, dx, dy) {
		return { height: this.originalSize.height + dy };
	    },
	    "se": function(event, dx, dy) {
		return $.extend(this._change["s"].apply(this, arguments), this._change["e"].apply(this, [event, dx, dy]));
	    },
	    "sw": function(event, dx, dy) {
		return $.extend(this._change["s"].apply(this, arguments), this._change["w"].apply(this, [event, dx, dy]));
	    },
	    "ne": function(event, dx, dy) {
		return $.extend(this._change["n"].apply(this, arguments), this._change["e"].apply(this, [event, dx, dy]));
	    },
	    "nw": function(event, dx, dy) {
		return $.extend(this._change["n"].apply(this, arguments), this._change["w"].apply(this, [event, dx, dy]));
	    }
	},

	_propagate: function(n, event) {

	    // 
	    // Propage resizeStart and resizeStop events.
	    // (resize is propagated internally by drag)
	    // 

	    // $.ui.plugin.call(this, n, [event, this.ui()]);
	    (n !== "resize" && this._trigger(n, event, this.ui()));
	},

	//////////////////////////////////////////////////////////////////////////////////
	//
	// Code block that implements functionality formerly in defined as a plugin.
	// (note: plugin code is deprecated)
	//
	// The alsoResize functionality "also resizes" the dialog body.
	// This approach allows the footer area to remain at a fixed height
	// the dialog is resized.
	//
	// $.ui.plugin.add("resizable", "alsoResize", {
	// 
	/////////////////////////////////////////////////////////////////////////////////

	_alsoresize_start: function () {

	    //var that = $(this).resizable( "instance" ),
	    // var that = $(this).data("oj-resizable"), // w
	    var that = this;
	    var o = that.options;
	    // var initialR = that._initialResize;

	    var _store = function (exp) {
		$(exp).each(function() {
		    var el = $(this);

		    el.data("oj-resizable-alsoresize", {
			width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
			left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
		    });
		});
	    };

	    if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
		if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
		else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
	    }else{
		_store(o.alsoResize);
	    }
	},

	_alsoresize_resize: function (event, ui) {

	    // var that = $(this).resizable( "instance" ),
	    // var that = $(this).data("oj-resizable"), // v
	    var that = this;

	    var o = that.options;
	    var os = that.originalSize;
	    var op = that.originalPosition;

	    var delta = {
		height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
		top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
	    },

	    _alsoResize = function (exp, c) {
		$(exp).each(function() {
		    var el = $(this), start = $(this).data("oj-resizable-alsoresize"), style = {},
		    css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

		    $.each(css, function (i, prop) {
			var sum = (start[prop]||0) + (delta[prop]||0);
			if (sum && sum >= 0) {
			    style[prop] = sum || null;
			}
		    });

		    el.css(style);
		});
	    };

	    if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
		$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
	    }else{
		_alsoResize(o.alsoResize, null);
	    }
	},

	_alsoresize_stop: function () {
	    // $(this).removeData("resizable-alsoresize");
	    $(this).removeData("oj-resizable-alsoresize");
	},


	/////////////////////////////////////////////////////////////////////////////////
	// 
	// Code block for containment functionality (formerly defined as a plugin)
	// 
	// $.ui.plugin.add( "resizable", "containment", {
	// 
	/////////////////////////////////////////////////////////////////////////////////

	_containment_start: function() {

	    var element, p, co, ch, cw, width, height;

	    // var that = $(this).data("oj-resizable");
	    var that = this;

	    var o = that.options,
	    el = that.element,
	    oc = o.containment,
	    ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

	    if ( !ce ) {
		return;
	    }

	    that.containerElement = $( ce );

	    if ( /document/.test( oc ) || oc === document ) {
		that.containerOffset = {
		    left: 0,
		    top: 0
		};
		that.containerPosition = {
		    left: 0,
		    top: 0
		};

		that.parentData = {
		    element: $( document ),
		    left: 0,
		    top: 0,
		    width: $( document ).width(),
		    height: $( document ).height() || document.body.parentNode.scrollHeight
		};
	    } else {
		element = $( ce );
		p = [];
		$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
		    p[ i ] = that._num( element.css( "padding" + name ) );
		});

		that.containerOffset = element.offset();
		that.containerPosition = element.position();
		that.containerSize = {
		    height: ( element.innerHeight() - p[ 3 ] ),
		    width: ( element.innerWidth() - p[ 1 ] )
		};

		co = that.containerOffset;
		ch = that.containerSize.height;
		cw = that.containerSize.width;
		width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
		height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

		that.parentData = {
		    element: ce,
		    left: co.left,
		    top: co.top,
		    width: width,
		    height: height
		};
	    }
	},

	_containment_resize: function( event, ui ) {
	    var woset, hoset, isParent, isOffsetRelative;

	    // var that = $(this).data("oj-resizable");
	    var that = this;

	    var o = that.options,
	    co = that.containerOffset,
	    cp = that.position,
	    pRatio = event.shiftKey,
	    cop = {
		top: 0,
		left: 0
	    },
	    ce = that.containerElement,
	    continueResize = true;

	    if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
		cop = co;
	    }

	    if ( cp.left < ( that._helper ? co.left : 0 ) ) {
		that.size.width = that.size.width + ( that._helper ? ( that.position.left - co.left ) : ( that.position.left - cop.left ) );
		if ( pRatio ) {
		    that.size.height = that.size.width / that.aspectRatio;
		    continueResize = false;
		}
		that.position.left = o.helper ? co.left : 0;
	    }

	    if ( cp.top < ( that._helper ? co.top : 0 ) ) {
		that.size.height = that.size.height + ( that._helper ? ( that.position.top - co.top ) : that.position.top );
		if ( pRatio ) {
		    that.size.width = that.size.height * that.aspectRatio;
		    continueResize = false;
		}
		that.position.top = that._helper ? co.top : 0;
	    }

	    that.offset.left = that.parentData.left + that.position.left;
	    that.offset.top = that.parentData.top + that.position.top;

	    woset = Math.abs( ( that._helper ? that.offset.left - cop.left : ( that.offset.left - co.left ) ) + that.sizeDiff.width );
	    hoset = Math.abs( ( that._helper ? that.offset.top - cop.top : ( that.offset.top - co.top ) ) + that.sizeDiff.height );

	    isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
	    isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

	    if ( isParent && isOffsetRelative ) {
		woset -= Math.abs( that.parentData.left );
	    }

	    if ( woset + that.size.width >= that.parentData.width ) {
		that.size.width = that.parentData.width - woset;
		if ( pRatio ) {
		    that.size.height = that.size.width / that.aspectRatio;
		    continueResize = false;
		}
	    }

	    if ( hoset + that.size.height >= that.parentData.height ) {
		that.size.height = that.parentData.height - hoset;
		if ( pRatio ) {
		    that.size.width = that.size.height * that.aspectRatio;
		    continueResize = false;
		}
	    }

	    if ( !continueResize ){
		that.position.left = ui.prevPosition.left;
		that.position.top = ui.prevPosition.top;
		that.size.width = ui.prevSize.width;
		that.size.height = ui.prevSize.height;
	    }
	},

	_containment_stop: function(){

	    // var that = $(this).data("oj-resizable"),
	    var that = this,

	    o = that.options,
	    co = that.containerOffset,
	    cop = that.containerPosition,
	    ce = that.containerElement,
	    helper = $( that.helper ),
	    ho = helper.offset(),
	    w = helper.outerWidth() - that.sizeDiff.width,
	    h = helper.outerHeight() - that.sizeDiff.height;

	    if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
		$( this ).css({
		    left: ho.left - cop.left - co.left,
		    width: w,
		    height: h
		});
	    }

	    if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
		$( this ).css({
		    left: ho.left - cop.left - co.left,
		    width: w,
		    height: h
		});
	    }
	},

	ui: function() {
	    return {
		originalElement: this.originalElement,
		element: this.element,
		helper: this.helper,
		position: this.position,
		size: this.size,
		originalSize: this.originalSize,
		originalPosition: this.originalPosition,
		prevSize: this.prevSize,
		prevPosition: this.prevPosition
	    };
	}


    });


}() );

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

// lory retrieved from https://raw.github.com/jquery/jquery-ui/1-10-stable/ui/jquery.ui.dialog.js on 09/03/2013, and then modified

//
// Note that one of the main differences between JET Dialog and the jQueryUI dialog 
// is the reparenting approach:
//
//   - JET Dialog reparents to the body on OPEN
//   - jQueryUI dialog reparents to the appendTo() container on CREATE
//

// Notes:
//  - $.uiBackCompat has been deprecated
//

/*!
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 */


(function() {
"use strict";

    var /** @const */ _placeHolderPrefix = "ojDialogPlaceHolder-";
    var /** @const */ _placeHolderFooterPrefix = "ojDialogPlaceHolderFooter-";
    var /** @const */ _placeHolderHeaderPrefix = "ojDialogPlaceHolderHeader-";
    var /** @const */ _wrapperPrefix = "ojDialogWrapper-";
    var /** @const */ _putback = true;
    var /** @const */ _padYDelta = 2;   // add a small amount of padding so that the scrollbar does not inadvertantly show up.

    var /** @const */ _resizeDelay = 50;   // delay between body refresh during resize

    /**
    * @class
    * @name oj.ojDialog
    * @augments oj.baseComponent
    * @since 0.6
    *
    * @classdesc
    * <h3 id="dialogOverview-section">
    *   JET Dialog Component
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialogOverview-section"></a>
    * </h3>
    * <p>Description: Themeable, WAI-ARIA-compliant dialog component.
    * A dialog is a floating window that typically contains a title bar and a content area. 
    * The dialog window can be moved by dragging on the title area, and closed with the 'x' icon (by default). Dialogs can also be resized by dragging on edges or corners of the dialog component. </p>
    *
    *<p>If the content length exceeds the maximum height, a scrollbar will automatically appear.</p>
    *
    *<p>A bottom button bar and semi-transparent modal overlay layer are common options that can be added.</p>
    *
    * <h3 id="markup-section">
    *   HTML Markup and Style Classes
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#markup-section"></a>
    * </h3>
    *
    * <p>Three main formatting classes are provided:
    *
    *<ul>
    *  <li> <b> oj-dialog-header </b> </li>
    *  Optional. If oj-dialog-header is omitted, a header will automatically be created. 
    *  <li> <b> oj-dialog-body </b> </li>
    *  Expected. Formats the body of the dialog.
    *  <li> <b> oj-dialog-footer </b> </li>
    *  Optional. Formats the footer of the dialog. Omit if the dialog has no footer. 
    *</ul>
    *
    * <p>For automically created headers (when <code class="prettyprint"> oj-dialog-header </code> 
    * is not part of the user's markup), the title of the header is the dialog title, and a close button is created.
    *
    *<p>A separator between the dialog body and the dialog footer can be added by using a second style class ( <code class="prettyprint"> oj-dialog-footer-separator </code>) in the footer:
    *
    *<ul>
    *  <li> <b> oj-dialog-footer oj-dialog-footer-separator </b> </li>
    *  Add a footer separator to the dialog.
    *</ul>
    *
    * See the demo section for a live example of the footer separator.
    *
    * Note that the dialog component wraps additional divs around the user's content and also performs other DOM manipulations.
    * Thus, the user should be careful if they wish to engage in advanced coding approaches. 
    * In general, it is better to target DOM elements by id or class name 
    * (e.g., developers should not rely on relative positioning of dialog DOM elements).
    *
    * <p> In addition to the three main formatting classes, another class is provided for formatting embedded progress bars.
    *
    *<ul>
    *  <li> <b> oj-dialog-body-header </b> </li>
    *  Optional. Used to format a progress bar embedded in the dialog header.
    *</ul>
    *
    * <h3 id="focus-section">
    *   Focus
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#focus-section"></a>
    * </h3>
    *
    *<p>Upon opening a dialog, focus is automatically moved to the first item that matches the following:</p>
    *<ol>
    *  <li>The first element within the dialog with the <code>autofocus</code> attribute</li>
    *  <li>The first <code>:tabbable</code> element within the dialog body</li>
    *  <li>The first <code>:tabbable</code> element within the dialog footer</li>
    *  <li>The dialog's close button</li>
    *  <li>The dialog itself</li>
    *</ol>
    *<p>While open, the dialog widget ensures that tabbing cycles focus between elements within the dialog itself, not elements outside of it. Modal dialogs additionally prevent mouse users fro  clicking on elements outside of the dialog.</p>
    *
    *<p>Upon closing a dialog, focus is automatically returned to the element that had focus when the dialog was opened.</p>
    *
    * <h3 id="keyboard-section">
    *   Keyboard End User Information
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
    * </h3>
    * 
    * <p>For the close icon:
    * 
    * <table class="keyboard-table">
    *   <thead>
    *     <tr>
    *       <th>Key</th>
    *       <th>Use</th>
    *     </tr>
    *   </thead>
    *   <tbody>
    *     <tr>
    *       <td><kbd>Esc</kbd></td>
    *       <td>Closes the dialog.</td>
    *     </tr>
    *   </tbody>
    * </table>
    *
    * <p>Also for the close icon, with focus on the close icon:
    * 
    * <table class="keyboard-table">
    *   <thead>
    *     <tr>
    *       <th>Key</th>
    *       <th>Use</th>
    *     </tr>
    *   </thead>
    *   <tbody>
    *     <tr>
    *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
    *       <td>Closes the dialog.</td>
    *     </tr>
    *     <tr>
    *     </tr>
    *   </tbody>
    * </table>
    * 
    *<h3>Sizing</h3>
    *
    * <p> Dialog dimensions, including <code class="prettyprint"> height, width, min-width, max-width, min-height</code> and <code class="prettyprint">max-height</code> are defined with css variables. The default dialog dimensions are the following:
    *
    *<ul>
    *  <li> <code class="prettyprint">height: auto</code> </li>
    *  <li> <code class="prettyprint">width: 300px</code> </li>
    *  <li> <code class="prettyprint">min-width: 200px</code> </li>
    *</ul>
    * 
    * In most cases, you will want to use the default <code class="prettyprint">height:auto</code>, since this will automatically adjust the height based on the content.
    * 
    * <p> Dialog dimensions can be set using rootAttributes:
    *
    * <pre class="prettyprint">
    * <code>
    *  &lt;div id="wideDialog" title="Wide Dialog" style="" 
    *       data-bind="ojComponent:{component: 'ojDialog', initialVisibility: 'show',
    *		  rootAttributes: { style: 'width: 400px; min-width: 100px; max-width 500px;'}}"&gt;
    *       &lt;div class="oj-dialog-body"&gt;
    *         &lt;p&gt; Dialog Text
    *       &lt;/div&gt;
    *  &lt;/div&gt;
    * </code></pre>
    *
    *
    * To dynamically change a dialog dimension (e.g., change a dimension after the dialog has been created), the 'widget' syntax is required:
    * <pre class="prettyprint">
    * <code>
    * $("#wideDialog").ojDialog('widget').css{'width', '400px'}
    * </code></pre>
    *
    * <h3 id="accessibility-section">
    *   Accessibility
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
    * </h3>
    * <h4> role </h4>
    * By default, the role will be set to dialog.
    * This can be observed by inspecting the DOM: 
    *
    * <pre class="prettyprint">
    * <code>
    *  &lt;div class="ojdialog ..." role="dialog"&gt;
    * </code></pre>
    *
    * This can be changed using the role option. WAI-ARIA recommends that role="dialog" be used if the dialog expects input (such as text input),
    * otherwise, use the role option to assign role="alertdialog".
    *
    * <h4> labeled-by </h4>
    *
    * For default headers, the dialog component takes care of labeled-by for you. User-defined headers require additional work on the user's part:
    *<ul>
    *  <li> <b> Default Headers </b> </li>
    *   For default headers, the labeled-by attribute will be generated automatically (and set to the id of the title).
    *  <li> <b> User-defined Headers </b> </li>
    *   For user-defined headers, the the labeled-by attribute should be defined in the user's markup. Please refer to the demos for examples.
    *</ul>
    *
    * <h3 id="rtl-section">
    *   Reading direction
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
    * </h3>
    * 
    * <p> Setting the reading direction (LTR or RTL) is supported by setting the <code class="prettyprint">"dir"</code> attribute on the 
    * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
    * is changed post-init, the dialog must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded. 
    * 
    * <h3 id="pseudos-section">
    *   Pseudo-selectors
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
    * </h3>
    * 
    * <p>The <code class="prettyprint">:oj-dialog</code> pseudo-selector can be used in jQuery expressions to select JET Dialogs.  For example:
    * 
    * <pre class="prettyprint">
    * <code>$( ":oj-dialog" ) // selects all JET Dialogs on the page
    * $myEventTarget.closest( ":oj-dialog" ) // selects the closest ancestor that is a JET Dialog
    * </code></pre>
    * 
    *<h3>Additional Examples</h3>
    *
    * <p> The following defines a basic dialog, with a cancel and an ok button in the footer:
    *
    * <pre class="prettyprint">
    * <code>
    *
    * &lt;div id="dialog" class="ojDialog" title="ojDialog Title"&gt;
    *     &lt;div class="oj-dialog-body"&gt;
    *         &lt;p&gt;Dialog Text&lt;/p&gt;
    *     &lt;/div&gt;
    *     &lt;div class="oj-dialog-footer"&gt;
    *        &lt;button id="buttonCancel" data-bind="ojComponent: 
    *              { component: 'ojButton', label: 'OK'}"&gt; &lt;/button&gt;
    *        &lt;button data-bind="ojComponent: 
    *              { component: 'ojButton', label: 'Cancel'}"&gt; &lt;/button&gt;
    *     &lt;/div&gt;
    * &lt;/div&gt;
    *
    * </code></pre>
    *
    * Note that you will need to define your own event handlers for the ok and close buttons (see the demos for examples of this).
    *
    * <p> A dialog with user-defined header is shown next. Arbitrary header content can be defined using a user-defined header.
    *
    * <pre class="prettyprint">
    * <code>
    *
    * &lt;div id="dialog" class="ojDialog" title="ojDialog Title"&gt;
    *   &lt;div class="oj-dialog-header" aria-labelledby="dialog-title-id"&gt;
    *     &lt;span id="dialog-title-id" class="oj-dialog-title"&gt; User Defined Header&lt;/span&gt;
    *    &lt;/div&gt;
    *    &lt;div class="oj-dialog-body"&gt;
    *        &lt;p&gt;Dialog Text&lt;/p&gt;
    *        &lt;br&gt;
    *    &lt;/div&gt;
    *    &lt;div class="oj-dialog-footer"&gt;
    *       &lt;button data-bind="ojComponent: 
    *           { component: 'ojButton', label: 'OK'}"&gt; &lt;/button&gt;
    *       &lt;button id="buttonCancel" class="" data-bind="ojComponent: 
    *           { component: 'ojButton', label: 'Cancel'}"&gt; &lt;/button&gt;
    *    &lt;/div&gt;
    * &lt;/div&gt;
    * 
    * </code></pre>
    *
    * <h3 id="jqui2jet-section">
    *   JET for jQuery UI developers
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
    * </h3>
    * 
    * This section summarizes the major differences between the JQueryUI dialog and the JET dialog API.
    * 
    * <h4> Options added to JET Dialog </h4>
    * 
    * <p>
    * One additional option has been added to the JET dialog:
    *
    * <p>
    * <table class="keyboard-table">
    *   <thead>
    *     <tr>
    *       <th>JQueryUI Dialog Option</th>
    *       <th>JET Dialog Option </th>
    *     </tr>
    *   </thead>
    *   <tbody>
    *     <tr>
    *       <td></td>
    *       <td><code class="prettyprint">role</code></td>
    *     </tr>
    *   </tbody>
    * </table>
    *
    * The JET Dialog option allows the developer to set the WAI-ARIA role. The <td><code class="prettyprint">role </code></td> option is not part of the JQueryUI dialog.
    *
    * <h4> Options Renamed between JQueryUI Dialog and JET Dialog </h4>
    *
    * <p>
    * The following options have been renamed between the JQueryUI dialog and the JET dialog.
    *
    * <p>
    * <table class="keyboard-table">
    *   <thead>
    *     <tr>
    *       <th>JQueryUI Dialog Option</th>
    *       <th>JET Dialog Option </th>
    *     </tr>
    *   </thead>
    *   <tbody>
    *     <tr>
    *       <td><code class="prettyprint">autoOpen </code></td>
    *       <td><code class="prettyprint">initialVisibility</code></td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">closeOnEscape </code></td>
    *       <td><code class="prettyprint">cancelBehavior</code></td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">draggable</code></td>
    *       <td><code class="prettyprint">dragAffordance</code></td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">modal</code></td>
    *       <td><code class="prettyprint">modality</code></td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">resizable</code></td>
    *       <td><code class="prettyprint">resizeBehavior</code></td>
    *     </tr>
    *   </tbody>
    * </table>
    *
    * <p>Also note that the JQueryUI dialog defines these options as booleans, while the JET dialog defines these options as strings.
    * <h4> Options in JQueryUI Dialog but not In JET Dialog </h4>
    * 
    * <p>
    * The following options are part of the JQueryUI dialog but are not options in JET Dialog:
    *
    * <p>
    * <table class="keyboard-table">
    *   <thead>
    *     <tr>
    *       <th>JQueryUI Dialog Option</th>
    *       <th>JET Dialog Approach </th>
    *     </tr>
    *   </thead>
    *   <tbody>
    *     <tr>
    *       <td><code class="prettyprint">appendTo</code></td>
    *       <td>Use the jquery <code class="prettyprint">appendTo()</code> instead</td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">button</code></td>
    *       <td>Buttons are added directly to HTML markup</td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">width</code>, <code class="prettyprint">height</code></td>
    *       <td>Use css variables <code class="prettyprint">width</code>, <code class="prettyprint">height</code></td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">minWidth</code>, <code class="prettyprint">maxWidth</code>, <code class="prettyprint">minHeight</code>, <code class="prettyprint">maxHeight</code></td>
    *       <td>Use css variables <code class="prettyprint">min-width</code>, <code class="prettyprint">max-width</code>, <code class="prettyprint">min-height</code>, <code class="prettyprint">max-height</code></td>
    *     </tr>
    *     <tr>
    *       <td><code class="prettyprint">show</code>, <code class="prettyprint">hide</code></td>
    *       <td>Use css classes instead, e.g., <code class="prettyprint">display: none</code> to hide an element</td>
    *     </tr>
    *   </tbody>
    * </table>
    *
    *
    * <h4> Event Names </h4>
    *
    * <p>Event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "dialog".
    * E.g. the JQUI <code class="prettyprint">dialogcreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
    *
    *
    * <!-- - - - - Above this point, the tags are for the class.
    *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
    * 
    * 
    * @desc Creates a JET Dialog.
    * @param {Object=} options a map of option-value pairs to set on the component
    * @example <caption>Initialize a (modal) dialog with no options specified:</caption>
    * $( ".selector" ).ojDialog();
    * @example <caption>Create a modeless dialog: </caption>
    * $("#dialog").ojDialog(modality: "modeless"});
    */

    oj.__registerWidget("oj.ojDialog", $['oj']['baseComponent'], {
	version: "1.0.0",
        widgetEventPrefix : "oj", 
	options: 
	{
	    // Specify the appendTo container of the dialog. 
            // If the appendTo container is null, then dialogs will be appended inline.
            // Setting to "body" would append all dialogs to the end of the body.
	    /** 
             *
             * @expose 
             * @memberof oj.ojDialog
	     * @instance
             * @type {string|null}
             * @deprecated 
             *
             */
	    // appendTo: null,


	    // 
            // <p> Specifies the location of open dialogs.
            // The default is "auto". 
            // "body" will append dialog content (for open dialogs) to the end of the HTML body.
            // The alternative is "inline", which will position dialog content in the same DOM hierarchy as the user's dialog markup.
            //
            // @expose 
            // @memberof oj.ojDialog
            // @instance
            // @type {string}
            // @default <code class="prettyprint">"body"</code>
            //
            // @example <caption>Initialize the dialog with the <code class="prettyprint">location</code> option specified:</caption>
            // $(".selector" ).ojDialog( {location: "show" } );
            // 
            // @example <caption>Get or set the <code class="prettyprint">location</code> option, after initialization:</caption>
            // // getter
            // var location = $(".selector" ).ojDialog( "option", "location" );
            // 
            // // setter
            // $(".selector" ).ojDialog( "option", "location", "inline");
            // 
	    // location: "auto",

	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated Replaced by initialVisibility.
             //
	    // autoOpen: true,

	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated Replaced by html markup.
             //
	    // buttons: [],
	    //
             //
             // @expose 
             // @memberof oj.ojDialog
             // @instance
             // @deprecated (replaced by cancelBehavior)
            //
	    // escapeBehavior: "close",

	    /**
	     * Specifies the cancel behavior of the dialog. The following are valid values:
             *
             * <ul>
             * <li> 
	     * <code class="prettyprint">"icon"</code> - (the default) (a) a close icon will automatically be created, and (b) the dialog will close when it has focus and user presses the escape (ESC) key.
             * </li> 
             * <li> 
	     * <code class="prettyprint">"none"</code> - no actions will be associated with the escape key.
             * </li> 
             * <li> 
	     * <code class="prettyprint">"escape"</code> -  the dialog will close when it has focus and user presses the escape (ESC) key. A close icon will not automatically be created.
             * </li> 
             * </ul>
             *
             * Note that the cancelBehavior applies to both automatic and user-defined headers. So by default, a user-defined header will have a system generated close icon.
             * @expose 
             * @memberof oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"icon"</code>
             *
             * @example <caption>Initialize the dialog to disable the default <code class="prettyprint">cancelBehavior</code></caption>
             * $(".selector" ).ojDialog( {cancelBehavior: "none" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">cancelBehavior</code> option, after initialization:</caption>
             * // getter
             * var cancelBehavior = $(".selector" ).ojDialog( "option", "cancelBehavior" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "cancelBehavior", "none");
             */
	    cancelBehavior: "icon",

	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (replaced by escapeBehavior)
             //
	    // closeOnEscape: true,

	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated
             //
	    // closeText: "",

	    //
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated
             //
             // dialogClass: "",

	    /**
	     * Specifies the drag affordance.
	     * If set to <code class="prettyprint">"title-bar"</code> (the default) the dialog will be draggable by the title bar.
	     * If <code class="prettyprint">"none"</code>, the dialog will not be draggable.
             *
             * @expose 
             * @memberof oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"title-bar"</code>
             *
             * @example <caption>Initialize the dialog to disable dragging <code class="prettyprint">dragAffordance</code></caption>
             * $(".selector" ).ojDialog( {dragAffordance: "none" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">dragAffordance</code> option, after initialization:</caption>
             * // getter
             * var dragAffordance = $(".selector" ).ojDialog( "option", "dragAffordance" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "dragAffordance", "none");
             */
	    dragAffordance: "title-bar",

	    //
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (renamed to dragAffordance)
             //
	    // draggable: true,

	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (use css classes instead)
	    // 
	    // hide: null,

	    //
	     // The height of the dialog. <br>
	     // <strong>Multiple types are supported:</strong><ul>
	     // <li>
	     // <strong>Number</strong>: The height in pixels.</li>
	     // <li>
	     // <strong>String</strong>: The only supported string value is <code>"auto"</code> which will allow the dialog height to adjust based on its content.</li>
	     // </ul>
             //
             // @expose 
             // @memberof oj.ojDialog
             // @type {string|number} 
             //
             // @example <caption>Initialize the dialog to a fixed height <code class="prettyprint">height</code></caption>
             // $(".selector" ).ojDialog( {height: 300 } );
             // 
             // @example <caption>Get or set the <code class="prettyprint">height</code> option, after initialization:</caption>
             // // getter
             // var height = $(".selector" ).ojDialog( "option", "height" );
             // 
             // // setter
             // $(".selector" ).ojDialog( "option", "height", 300);
            //
	    // height: "auto",

	    /**
             * <p> Set the initial visibility of the dialog. 
	     * If set to <code class="prettyprint">"show"</code>, the dialog will automatically open upon initialization. 
	     * If <code class="prettyprint">"hide"</code>, the dialog will stay hidden until the <a href="#method-open"><code class="prettyprint">open()</code></a> method is called.
             *
             * @expose 
             * @memberof oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"hide"</code>
             *
             * @example <caption>Initialize the dialog with the <code class="prettyprint">initialVisibility</code> option specified:</caption>
             * $(".selector" ).ojDialog( {initialVisibility: "show" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">initialVisibility</code> option, after initialization:</caption>
             * // getter
             * var initialVisibility = $(".selector" ).ojDialog( "option", "initialVisibility" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "initialVisibility", "show");
             */
	    // initialVisibility: "show",
	    initialVisibility: "hide",

	    // createTitlebar: true,

	    //
            // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (use css variables max-height instead)
             //
	    // maxHeight: null,
	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (use css variables max-width instead)
             //
	    // maxWidth: null,
	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (use css variables min-height instead)
             //
	    // minHeight: 150,
	    // 
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (use css variables min-width instead)
            //
	    // minWidth: 150,

	    //
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @deprecated (replaced by modality)
             //
	    // modal: false,

	    /**
	     *
	     * The modality of the dialog. Valid values are:
             * <ul>
             * <li> 
	     * <code class="prettyprint">"modal"</code> - (the default) The dialog is modal. Interactions with other page elements are disabled. Modal dialogs overlay other page elements.
             * </li> 
             * <li> 
	     * <code class="prettyprint">"modeless"</code> - defines a modeless dialog.
             * </li> 
             * </ul>
             *
             * @expose 
             * @memberof oj.ojDialog
             * @instance
             * @default <code class="prettyprint">"modal"</code>
             * @type {string}
             *
             * @example <caption>Initialize the dialog to a specific modality <code class="prettyprint">modality</code></caption>
             * $(".selector" ).ojDialog( {modality: "modal" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">modality</code> option, after initialization:</caption>
             * // getter
             * var modality = $(".selector" ).ojDialog( "option", "modality" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "modality", "modal");
             */
	    modality: "modal",

	    // todo: link to position utility?
	    // JQUi doc had { ..., of: button}} - what does this mean?

           /**
            * <p>Position object is defined by the jquery position API and is used to establish the location the
            * dialog will appear relative to another element.  The postion object contains the following properties:
            * "my", "at", "of", "colision", "using" and "within".</p>
            *
            * <p>The "my" and "at" properties defines aligment points relative to the dialog and other element.  The
            * "my" property represents the dialogs alignment where the "at" property represents the other element
            * that can be identified by "of" or defauts to the launcher when the dialog opens.  The values of these
            * properties describe a "horizontal vertical" location.</p>
            *
            * <p>Acceptable "horizontal" alignments values are: "right", "center", "left", "start", "end".  Note: Jet has
            * added "start" and "end" options to be more RTL friendly.  The Jet values of "start" and "end" normalize
            * to "right" or "left" depending on the direction of the document.</p>
            *
            * <p>Acceptable "vertical" alignment values are: "top", "center" and "bottom".</p>
            *
            * The following is a short summary of the most interesting positon properties:
            * <ul>
            *   <li><code class="prettyprint">my</code> - A "vertical horizontal" rule that defines the location of the dialog
            *       used for alignment.</li>
            *   <li><code class="prettyprint">at</code> - A "vertical horizontal" rule that defines the location of the
            *       other element for used alignment. The other element is defined by "of" or defaults to the open launcher
            *       argument if not specified.</li>
            * </ul>
            *
            * @expose
            * @memberof oj.ojDialog
            * @instance
            * @type {Object}
            * @default <code class="prettyprint">{my: "center", at: "center", collision: "fit"}</code>
            *
            * @example <caption>Initialize the dialog with <code class="prettyprint">position</code> option specified:</caption>
            * $( ".selector" ).ojDialog( { "position": {"my": "left top", "at": "right top"} } );
            *
            * @example <caption>Get or set the <code class="prettyprint">position</code> option, after initialization:</caption>
            * // getter
            * var position = $( ".selector" ).ojDialog( "option", "position" );
            *
            * // setter
            * $( ".selector" ).ojDialog( "option", "position", {"my": "start bottom", "at": "end+14 top" } );
            */
     	    position: {
                /**
                 *
                 * @expose 
                 * @alias position.my
                 * @memberof! oj.ojDialog
                 * @instance
     		 * @type {string}
                 * @default <code class="prettyprint">"center"</code>
                 *
                 */
		my: "center",
                /**
                 *
                 * @expose 
                 * @alias position.at
                 * @memberof! oj.ojDialog
                 * @instance
		 * @type {string}
                 * @default <code class="prettyprint">"center"</code>
                 *
                 */
		at: "center",
                /**
                 *
                 * @expose 
                 * @alias position.of
                 * @memberof! oj.ojDialog
                 * @instance
		 * @type {Object}
                 * @default <code class="prettyprint">"window"</code>
                 *
                 */
		of: window,
                /**
                 *
                 * @expose 
                 * @alias position.collision
                 * @memberof! oj.ojDialog
                 * @instance
		 * @type {string}
                 * @default <code class="prettyprint">"fit"</code>
                 *
                 */
		collision: "fit",
		// Ensure the titlebar is always visible
		using: function( pos ) {
		    var topOffset = $( this ).css( pos ).offset().top;
		    if ( topOffset < 0 ) {
			$( this ).css( "top", pos.top - topOffset );
		    }
		}
	    },

	    /**
	     *
	     * The resizeBehavior of the dialog. "resizable" (default) makes the dialog resizable.
             * "none" disables dialog resizability.
             *
             * @expose 
             * @memberof oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"resizable"</code>
             *
             * @example <caption>Initialize the dialog to a specific resizeBehavior <code class="prettyprint">resizeBehavior</code></caption>
             * $(".selector" ).ojDialog( {resizeBehavior: "none" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">resizeBehavior</code> option, after initialization:</caption>
             * // getter
             * var resizeBehavior = $(".selector" ).ojDialog( "option", "resizeBehavior" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "resizeBehavior", "none");
             */
	    resizeBehavior: "resizable",

	    //
             // @expose 
	     // @memberof oj.ojDialog
	     // @instance
             // @deprecated Replaced by resizeBehavior.
             //
	    // resizable: true,


	    /**
	     *
	     * The WAI-ARIA role of the dialog. By default, role="dialog" is added to the generated HTML markup that surrounds the dialog.
             * When used as an alert dialog, the user should set role to "alertdialog".
             *
             * @expose 
             * @memberof oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"dialog"</code>
             *
             * @example <caption>Initialize the dialog with the <code class="prettyprint">role</code></caption> option specified:</caption>
             * $(".selector" ).ojDialog( {role: "alertdialog" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">role</code> option, after initialization:</caption>
             * // getter
             * var role = $(".selector" ).ojDialog( "option", "role" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "role", "alertdialog");
             */
	    role: "dialog",

	    //
            // @expose 
	    // @memberof oj.ojDialog
	    // @instance
            // @deprecated (use css classes instead)
            //
	    // show: null,

	    /**
	     *
	     * Specify the title of the dialog. null is the default. 
             *
             * @expose 
             * @memberof oj.ojDialog
	     * @instance
             * @type {string|null}
             *
             * @example <caption>Initialize the dialog to a specific title <code class="prettyprint">title</code></caption>
             * $(".selector" ).ojDialog( {title: "Title of Dialog" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">title</code> option, after initialization:</caption>
             * // getter
             * var title = $(".selector" ).ojDialog( "option", "title" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "title", "Title of Dialog");
             */
	    title: null,

	    //
	     // The width of the dialog, in pixels <br>
	     // <strong>Multiple types are supported:</strong><ul>
	     // <li>
	     // <strong>Number</strong>: The width in pixels.</li>
	     // <li>
	     // <strong>String</strong>: The only supported string value is <code>"auto"</code> which will allow the dialog width to adjust based on its content.</li>
	     // </ul>
             //
             //
             // @expose 
             // @memberof oj.ojDialog
	     // @instance
             // @type {string|number} 
             // @default <code class="prettyprint">300</code>
             //
             // @example <caption>Initialize the dialog to a fixed width <code class="prettyprint">width</code></caption>
             // $(".selector" ).ojDialog( {width: 400 } );
             // 
             // @example <caption>Get or set the <code class="prettyprint">width</code> option, after initialization:</caption>
             // // getter
             // var width = $(".selector" ).ojDialog("option", "width" );
             // 
             // // setter
             // $(".selector" ).ojDialog("option", "width", 400);
            //

	    // width: "auto",
	    // width: "300",

	    ///////////////////////////////////////////////////////
	    // events
	    ///////////////////////////////////////////////////////

            /**
             * Triggered when a dialog is about to close. If cancelled, the dialog will not close.
             *
	     * @expose
             * @event 
             * @name beforeClose
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">beforeClose</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "beforeClose": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeClose</code> event:</caption>
             * $( ".selector" ).on( "ojbeforeclose", function( event, ui ) {} );
             */

	    beforeClose: null,

            /**
             * Triggered when the dialog is about to to open.
             *
	     * @expose
             * @event 
             * @name beforeOpen
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">beforeOpen</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "beforeOpen": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeOpen</code> event:</caption>
             * $( ".selector" ).on( "ojbeforeopen", function( event, ui ) {} );
             */

	    beforeOpen: null,


		// * @name close
            /**
             * Triggered when the dialog is closed.
             *
	     * @expose
             * @event 
             * @name oj.ojDialog#close
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">close</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "close": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">close</code> event:</caption>
             * $( ".selector" ).on( "close", function( event, ui ) {} );
             */

	    close : null,

	    //
             // @expose 
	     // @memberof oj.ojDialog
	     // @instance
             // @deprecated (In the future, this functionality will be supported in HTML 5)
             //
	    // drag: null,

	    //
             // @expose 
	     // @memberof oj.ojDialog
	     // @instance
             // @deprecated (In the future, this functionality will be supported in HTML 5)
             //
	    //dragStart: null,

	    //
             // @expose 
	     // @memberof oj.ojDialog
	     // @instance
             // @deprecated (In the future, this functionality will be supported in HTML 5)
             //
	    // dragStop: null,

            /**
             * Triggered when the dialog gains focus.
             *
	     * @expose
             * @event 
             * @name focus
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">focus</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "focus": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojfocus</code> event:</caption>
             * $( ".selector" ).on( "ojfocus", function( event, ui ) {} );
             */

	    focus: null,
            /**
             * Triggered when the dialog is opened.
             *
	     * @expose
             * @event oj.ojDialog#open
             * @name open
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">open</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "open": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojopen</code> event:</caption>
             * $( ".selector" ).on( "ojopen", function( event, ui ) {} );
             */
	    open: null,

            /**
             * Triggered when the dialog is being resized.
             *
	     * @expose
             * @event 
             * @name resize
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
	     * <ul>
	     * <li>
	     * <div><strong>event</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Event">Event</a>
	     * </div>
	     * <div></div>
	     * </li>
	     * <li>
	     * <div><strong>ui</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div></div>
	     * <ul>
	     * <li>
	     * <div><strong>originalPosition</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The CSS position of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>position</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current CSS position of the dialog.</div>
	     * </li>
	     * <li>
	     * <div><strong>originalSize</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The size of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>size</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current size of the dialog.</div>
	     * </li>
	     * </ul>
	     * </li>
	     * </ul>
	     * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">resize</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "resize": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojresize</code> event:</caption>
             * $( ".selector" ).on( "ojresize", function( event, ui ) {} );
             */
	    resize: null,

            /**
             * Triggered when the user starts resizing the dialog.
             *
	     * @expose
             * @event 
             * @name resizeStart
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
	     * <ul>
	     * <li>
	     * <div><strong>event</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Event">Event</a>
	     * </div>
	     * <div></div>
	     * </li>
	     * <li>
	     * <div><strong>ui</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div></div>
	     * <ul>
	     * <li>
	     * <div><strong>originalPosition</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The CSS position of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>position</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current CSS position of the dialog.</div>
	     * </li>
	     * <li>
	     * <div><strong>originalSize</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The size of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>size</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current size of the dialog.</div>
	     * </li>
	     * </ul>
	     * </li>
	     * </ul>
	     * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">resizeStart</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "resizeStart": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojresizeStart</code> event:</caption>
             * $( ".selector" ).on( "ojresizestart", function( event, ui ) {} );
             */
	    resizeStart: null,

            /**
             * Triggered when the user stops resizing the dialog.
             *
	     * @expose
             * @event 
             * @name resizeStop
             * @memberof oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Currently empty
             * 
	     * <ul>
	     * <li>
	     * <div><strong>event</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Event">Event</a>
	     * </div>
	     * <div></div>
	     * </li>
	     * <li>
	     * <div><strong>ui</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div></div>
	     * <ul>
	     * <li>
	     * <div><strong>originalPosition</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The CSS position of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>position</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current CSS position of the dialog.</div>
	     * </li>
	     * <li>
	     * <div><strong>originalSize</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The size of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>size</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current size of the dialog.</div>
	     * </li>
	     * </ul>
	     * </li>
	     * </ul>
	     * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">resizeStop</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "resizeStop": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojresizeStop</code> event:</caption>
             * $( ".selector" ).on( "ojresizestop", function( event, ui ) {} );
             */
	    resizeStop: null
	},

        
        /**
         * Triggered when the dialog is created.
         *
         * @expose
         * @override
         * @event 
         * @name create
         * @memberof oj.ojDialog
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Currently empty
         * 
         * @example <caption>Initialize the dialog with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojDialog({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */

	_ComponentCreate : function ()
	{
            this._super();
	    // _create: function() {
	    this.originalCss = {
		display: this.element[0].style.display,
		width: this.element[0].style.width,
		// minHeight: this.element[0].style.minHeight,
		// maxHeight: this.element[0].style.maxHeight,
		height: this.element[0].style.height
	    };
	    this.originalPosition = {
		parent: this.element.parent(),
		index: this.element.parent().children().index( this.element )
	    };
	    this.originalTitle = this.element.attr("title");
	    this.options.title = this.options.title || this.originalTitle;

	    this._createWrapper();

	    this.element
		.show()
		.removeAttr("title")
		// .addClass("oj-dialog-content oj-component-content")
		.addClass("oj-dialog-content oj-dialog-default-content")
		.appendTo( this.uiDialog );

	    this.userDefinedDialogHeader = false;

	    // 
	    // If there is not nested content,
	    // simply find the first oj-dialog-header
	    // 
	    var nestedContent = this.element.find(".oj-dialog");

	    if (!nestedContent.length) {

		this._userDefinedHeader = this.element.find(".oj-dialog-header");
		if (this._userDefinedHeader.length) {
		    this.userDefinedDialogHeader = true;
		}
	    }
	    else {

		//
		// For nested content,
		// look for a header that is NOT contained with an oj-dialog-body
		//

		var allDialogHeaders = this.element.find('.oj-dialog-header');

		var that = this;

		//this.element('.oj-dialog-header').each(function(index, li) {
		allDialogHeaders.each(function(index, li) {

		    var dialogHeader = $(li);
		    var isNestedDialog = dialogHeader.closest('.oj-dialog-body');

		    //
		    // If the header is not nested within an .oj-dialog-body,
		    // then it IS a user-defined header.
		    //
		    if (!isNestedDialog.length) {
			// this._userDefinedHeader = dialogHeader;
			that._userDefinedHeader = dialogHeader;
			// this.userDefinedDialogHeader = true;
			that.userDefinedDialogHeader = true;
			return false;
		    }
		    
		});

	    }

	    if (this.userDefinedDialogHeader) {

		this._createPlaceHolderHeader(this._userDefinedHeader);
		this._userDefinedHeader.prependTo(this.uiDialog);

		if (this.options.cancelBehavior === "icon") {

		    this._createCloseButton(this._userDefinedHeader);

		    // 
		    // Insert oj-dialog-title between oj-dialog-header and oj-dialog-header-close-wrapper
		    // 
		    this._userDefinedTitle = this._userDefinedHeader.find(".oj-dialog-title");
		    if (this._userDefinedTitle.length)
		    	this._userDefinedTitle.insertAfter(this.uiDialogTitlebarCloseWrapper);

		}

	    }
	    else {
		this._createTitlebar(); 
	    }

	    this.uiDialogFooter = this.element.find(".oj-dialog-footer");
	    this._createPlaceHolderFooter(this.uiDialogFooter);

	    if (this.uiDialogFooter) {
		this.uiDialogFooter.addClass("oj-helper-clearfix")
		this.uiDialogFooter.appendTo(this.uiDialog);
	    }

	    if ( this.options.dragAffordance === "title-bar" && $.fn.draggable ) {
		this._makeDraggable();
	    }

	    // 
	    // Set up the resize delay.
	    // 
	    this._delayedResizeFcn = this._resizeBody.bind(this);
	    this._delayId = window.setTimeout(this._delayedResizeFcn, _resizeDelay);

	    // 
	    // Create the resize listener.
	    // 

	    //
	    // use this for testing (this would bypass the timeout code path).
	    // this._handleResizeFcn = this._resizeBody.bind(this);
	    //
	    this._handleResizeFcn = this._handleResize.bind(this);
            oj.DomUtils.addResizeListener(this.uiDialog[0], this._handleResizeFcn);

            this._hasResizeListener = true;

	    this['_isOpen'] = false;

	    this._trackFocus();

            this._super();
	},

	_init: function() {

	    if (this.options.initialVisibility === "show" ) {
		this.open();
	    }

	    // if ( this.options.autoOpen ) {
	    // this.open();
    	    // }

	},

	// 
	// Return the location to append to.
	// (Always returns "body" element)
	// 
	_appendTo: function() {

	    // var element = this.options.appendTo;
	    // if ( element && (element.jquery || element.nodeType) ) return $( element );
	    // return this.document.find( element || "body" ).eq( 0 );
	    return this.document.find("body").eq( 0 );
	},

	/**
	 * Remove the dialog functionality completely. 
	 * This will return the element back to its pre-init state.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @method
	 * @name oj.ojDialog#destroy
	 * @memberof oj.ojDialog
	 * @instance
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
	 * var destroy = $( ".selector" ).ojDialog( "destroy" );
	 */

	_destroy: function() {

	    var next,
	    originalPosition = this.originalPosition;

	    if (this['_isOpen']) this.close();

	    if (this._hasResizeListener)
	    {
		oj.DomUtils.removeResizeListener(this.uiDialog[0], this._handleResizeFcn);
		this._hasResizeListener = false;
	    }

	    // this._destroyOverlay();

	    if (this._resizableComponent) {
		this._resizableComponent("destroy");
		this._resizableComponent = null;
	    }

	    // var footer = this.uiDialog.find(".oj-dialog-footer");

	    if (this.uiDialogFooter) {
		this.uiDialogFooter.removeClass("oj-helper-clearfix")
		$('#' + this._placeHolderFooterId).replaceWith(this.uiDialogFooter);
	    }

	    this._desroyCloseButton();

	    if (this.userDefinedDialogHeader) {

		var header = this.uiDialog.find(".oj-dialog-header");
		if (header) 
		    $('#' + this._placeHolderHeaderId).replaceWith(header);
	    }




	    if (this.uiDialogTitle) {
		this.uiDialogTitle.remove();
		this.uiDialogTitle = null;
	    }

	    // causes testing problems.

/*

	    if (this.uiDialogTitlebar) {
		this.uiDialogTitlebar.remove();
		this.uiDialogTitlebar = null;
	    }

*/


	    this.element
		.removeUniqueId()
		.removeClass( "oj-dialog-content oj-dialog-default-content" )
		.css( this.originalCss );

	    this.uiDialog.stop( true, true );
	    this.element.unwrap();

	    if ( this.originalTitle ) {
		this.element.attr( "title", this.originalTitle );
	    }



	    // if (_putback) {
	    // $('#' + this._placeHolderId).replaceWith(this.element);
	    // this._destroyPutback();
	    // }

            this._super();
	},

	/* resize handler */
	_handleResize: function(width, height)
	{

	    if (this._delayId == null)
		this._delayId = window.setTimeout(this._delayedResizeFcn, _resizeDelay);
	},

	/**
         * Refreshes the dialog. JET components require a <code class="prettyprint">refresh()</code> after a supported DOM change is made 
         * that affects the component, of which the component would otherwise be unaware.  
         * 
         * <p>This method calls <code class="prettyprint">baseComponent.refresh()</code>, but doesn't currently do anything dialog-specific.
         * Note that anything having a JS API, such as the Dialog's title or modality, must be set via the API, not 
         * by mutating the DOM and calling <code class="prettyprint">refresh()</code>. 
         * 
         * @expose 
         * @name oj.ojDialog#refresh
	 * @memberof oj.ojDialog
	 * @method 
	 * @instance
         * 
         * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
         * $( ".selector" ).ojDialog( "refresh" );
         */
	refresh: function() // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
	{
            this._super();
	    // this._measureDiv();
	},

	/**
	 * Returns a <code class="prettyprint">jQuery</code> object containing the generated wrapper.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @expose
	 * @name oj.ojDialog#widget
	 * @memberof oj.ojDialog
	 * @instance
	 * @return {jQuery} the dialog
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
	 * var widget = $( ".selector" ).ojDialog( "widget" );
	 */
	widget: function() {
	    return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	
        // * @variation 2
	    // @name oj.ojDialog#close

	/**
	 * Closes the dialog.
	 * 
         * @name oj.ojDialog#close
	 * @method 
	 * @memberof oj.ojDialog
	 * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @return {void}
         * @fires oj.ojDialog#beforeClose
         * @fires oj.ojDialog#close
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
	 * var close = $( ".selector" ).ojDialog( "close" );
	 */
	close: function( event ) {
	    var that = this;

	    if ( !this['_isOpen'] || this._trigger( "beforeClose", event ) === false ) {
		return;
	    }

	    // manage resizable notifications
            oj.Components.subtreeHidden(this.uiDialog[0]);

	    this['_isOpen'] = false;
	    this._focusedElement = null;
	    this._destroyOverlay();
	    this._untrackInstance();

	    if ( !this.opener.filter(":focusable").focus().length ) {
		// Hiding a focused element doesn't trigger blur in WebKit
		// so in case we have nothing to focus on, explicitly blur the active element
		// https://bugs.webkit.org/show_bug.cgi?id=47182
		$( this.document[0].activeElement ).blur();
	    }

	    // this._hide( this.uiDialog, this.options.hide, function() {
	    this._hide( this.uiDialog, null, function() {
		that._trigger( "close", event );
	    });

	    if (_putback) {

		// Put the dialog back to its original location.
		// Old - this would put the unwrapped code back
		// $('#' + this._placeHolderId).replaceWith($('#' + this._elementId));

		// Remove the old wrapper.
		//$('#' + this._wrapperId).remove();

		//
		// Put contents and wrapper back to inline location.
		//
		$('#' + this._placeHolderId).replaceWith($('#' + this._wrapperId));

	    }
	},

	/**
	 * Returns true if the dialog is currently open.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @method
	 * @name oj.ojDialog#isOpen
	 * @memberof oj.ojDialog
	 * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">isOpen</code> method:</caption>
	 * var isOpen = $( ".selector" ).ojDialog( "isOpen" );
	 */
	isOpen: function() {
	    return this['_isOpen'];
	},

	// 
	// Moves the dialog to the top of the dialog stack.
	// 
	// <p>This method does not accept any arguments.
	// 
	// @method
	// @name oj.ojDialog#moveToTop
	// @memberof oj.ojDialog
	// @instance
	// 
	// @example <caption>Invoke the <code class="prettyprint">moveToTop</code> method:</caption>
	// var moveToTop = $( ".selector" ).ojDialog( "moveToTop" );
	// 
	// moveToTop: function() {
	// this._moveToTop();
        // },

	// 
	// For the opened dialog and focus managment,
	// _moveToTop moves the dialog to the top of the visibility stack.
	// 
	_moveToTop: function( event, silent ) {

	    var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
	    if ( moved && !silent ) {
		this._trigger( "focus", event );
	    }
	    return moved;

	},


   // * @memberof oj.ojDialog

	/**
	 * Opens the dialog.
	 * 
	 * @method
	 * @name oj.ojDialog#open
	 * @memberof oj.ojDialog
	 * @instance
         * @return {void}
         * @fires oj.ojDialog#beforeOpen
         * @fires oj.ojDialog#open
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
	 * var open = $( ".selector" ).ojDialog( "open" );
	 */
	open: function( event ) {

            // this.$element.on('click.ojDialog', $.proxy(this.uiDialog.hide, this));

	    if (this._trigger( "beforeOpen", event ) === false ) {
		return;
	    }

	    var that = this;

	    if ( this['_isOpen'] ) {

		// orig
		// if ( this._moveToTop() ) {
		// this._focusTabbable();
		// }

		if ( this._moveToTop() ) {
		    this._focusTabbable();
		}

		return;
	    }

	    this['_isOpen'] = true;
	    this.opener = $( this.document[0].activeElement );

	    this._size();
	     if (this.options.resizeBehavior === "resizable") {
	        this._makeResizable();
	     }

	    //
	    // Reparent dialog to body on OPEN (NOT Create, as JQueryUI Dialog does).
	    //

	    this._relocateWithPutback();
	    this._createOverlay();

	    // new code - this._position() was BEFORE relocateWithPutback()
	    this._position();

	    this._moveToTop( null, true ); // orig

	    // 
	    // Reduced functonality from jqueryUI since we now encourage
	    // the use of css classes for animation instead of the jQueryUI effects package
	    // exposed via jquery show()
	    // 
	    // this._show( this.uiDialog, this.options.show, function() {
	    this._show( this.uiDialog, null, function() {
		that._focusTabbable();
		that._trigger("focus");
	    });

	    // manage resizable notifications
            oj.Components.subtreeShown(this.uiDialog[0]);

	    // Track the dialog immediately upon openening in case a focus event
	    // somehow occurs outside of the dialog before an element inside the
	    // dialog is focused (#10152)
	    this._makeFocusTarget();

	    this._trigger("open");
	},

	_focusTabbable: function() {
	    // Set focus to the first match:
	    // 1. First element inside the dialog matching [autofocus]
	    // 2. Tabbable element inside the content element
	    // 3. Tabbable element inside the footer
	    // 4. The close button
	    // 5. The dialog itself

	    // var hasFocus = this.element.find("[autofocus]");
	    var hasFocus = this._focusedElement;
	    if ( !hasFocus ) {
		hasFocus = this.element.find( "[autofocus]" );
	    }

	    if ( !hasFocus.length ) {
		hasFocus = this.element.find(":tabbable");
	    }
	    if ( !hasFocus.length ) {
		if (this.uiDialogFooter) 
		    // hasFocus = this.uiDialogFooter.filter(":tabbable");
		    hasFocus = this.uiDialogFooter.find(":tabbable");
	    }
	    if ( !hasFocus.length ) {
		// todo: this may not exist when a user-defined header is used.
		// We may want to provide an api for the focusable element, or
		// check the oj-dialog-header markup
		if (this.uiDialogTitlebarClose)
		    hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
	    }
	    if ( !hasFocus.length ) {
		hasFocus = this.uiDialog;
	    }
	    hasFocus.eq( 0 ).focus();
	},

	'_keepFocus': function( event ) {
	    function checkFocus() {
		var activeElement = this.document[0].activeElement,
		isActive = this.uiDialog[0] === activeElement ||
		    $.contains( this.uiDialog[0], activeElement );
		if ( !isActive ) {
		    this._focusTabbable();
		}
	    }
	    event.preventDefault();
	    checkFocus.call( this );
	},


	_trackFocus: function() {
		this._on( this.widget(), {
			focusin: function( event ) {
				this._makeFocusTarget();
				this._focusedElement = $( event.target );
			}
		});
	},

	_makeFocusTarget: function() {
		this._untrackInstance();
		this._trackingInstances().unshift( this );
	},

	_untrackInstance: function() {
		var instances = this._trackingInstances(),
			exists = $.inArray( this, instances );
		if ( exists !== -1 ) {
			instances.splice( exists, 1 );
		}
	},

	_trackingInstances: function() {
		var instances = this.document.data( "ui-dialog-instances" );
		if ( !instances ) {
			instances = [];
			this.document.data( "ui-dialog-instances", instances );
		}
		return instances;
	},


	_isNumber: function( value ) {
	    return !isNaN( parseInt( value , 10 ) );
	},

	_createWrapper: function() {

	    // make sure that the element has a unique id.
	    this.element.uniqueId();
	    this._elementId = this.element.attr('id');
	    this._wrapperId = _wrapperPrefix + this._elementId;

	    this.uiDialog = $("<div>")
		// .addClass( "oj-dialog oj-component oj-component-content oj-corner-all oj-front " +
		// .addClass( "oj-dialog oj-helper-reset-inheritable oj-component oj-dialog-front " +
	    // this.options.dialogClass )
		.addClass( "oj-dialog oj-component oj-dialog-front ")
		.hide()
		.attr({
		    // Setting tabIndex makes the div focusable
		    'tabIndex': -1,
		    'role': this.options.role,
		    'id' : this._wrapperId
		});

	    this.uiDialog.insertBefore(this.element);   // position inline

	    this._on( this.uiDialog, {
		keyup: function( event ) {

		    // if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
		    // if (this.options.escapeBehavior === "close" && !event.isDefaultPrevented() && event.keyCode &&
		    if (this.options.cancelBehavior != "none" && !event.isDefaultPrevented() && event.keyCode &&
			event.keyCode === $.ui.keyCode.ESCAPE ) {
			event.preventDefault();
			event.stopImmediatePropagation();
			this.close( event );
			return;
		    }

		    // prevent tabbing out of dialogs
		    if ( event.keyCode !== $.ui.keyCode.TAB ) {
			return;
		    }
		    var tabbables = this.uiDialog.find(":tabbable"),
		    first = tabbables.filter(":first"),
		    last  = tabbables.filter(":last");

		    if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
			first.focus( 1 );
			event.preventDefault();
		    } else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
			last.focus( 1 );
			event.preventDefault();
		    }
		},
		mousedown: function( event ) {
		    // if ( this._moveToTop( event ) ) {
		    // this._focusTabbable();
		    // }
		    if ( this._moveToTop( event ) ) {
			this._focusTabbable();
		    }
		}
	    });

	    // We assume that any existing aria-describedby attribute means
	    // that the dialog content is marked up properly
	    // otherwise we brute force the content as the description
	    if ( !this.element.find("[aria-describedby]").length ) {
		this.uiDialog.attr({
		    "aria-describedby": this.element.uniqueId().attr("id")
		});
	    }

	},


	_desroyCloseButton: function() {

	    if (this.uiDialogTitlebarCloseWrapper) {
		this.uiDialogTitlebarCloseWrapper.remove();
		this.uiDialogTitlebarCloseWrapper = null;
		this.uiDialogTitlebarClose = null;
	    }
	},


	// 
	// Create a close button.
	// 
	_createCloseButton: function(domDestination) {

	    this.uiDialogTitlebarCloseWrapper = $("<div>")
		.addClass("oj-dialog-header-close-wrapper")
		.attr("tabindex", "1")
		.attr("aria-label", "close")
		.attr("role", "button")
		.appendTo(domDestination);

	    this.uiDialogTitlebarClose = $("<span>")
		.addClass("oj-component-icon oj-clickable-icon oj-dialog-close-icon")
		.attr("alt", "close icon" )
		.prependTo( this.uiDialogTitlebarCloseWrapper);

	    this._on( this.uiDialogTitlebarCloseWrapper, {
		click: function( event ) {
		    event.preventDefault();
		    event.stopImmediatePropagation();
		    this.close( event );
		},
		mousedown: function( event ) {
		    var currTarget = event.currentTarget;
		    $(currTarget).addClass("oj-active");
		},
		mouseup: function( event ) {
		    var currTarget = event.currentTarget;
		    $(currTarget).removeClass("oj-active");
		},
		mouseenter: function( event ) {
		    var currTarget = event.currentTarget;
		    $(currTarget).addClass("oj-hover");
		},
		mouseleave: function( event ) {
		    var currTarget = event.currentTarget;
		    $(currTarget).removeClass("oj-hover");
		    $(currTarget).removeClass("oj-active");
		},

		//
		// Close dialog when close icon has focus and SPACE is entered.
		//
		keyup: function( event ) {

                    if (event.keyCode && event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
			event.preventDefault();
			event.stopImmediatePropagation();
			this.close( event );
			return;
		    }
		}

	    });

	},

	_createTitlebar: function() {
	    var uiDialogTitle;
	    var headerClasses;

	    headerClasses = "oj-dialog-header oj-helper-clearfix";

	    this.uiDialogTitlebar = $("<div>")
		.addClass(headerClasses)
		.prependTo( this.uiDialog );

	    this._on( this.uiDialogTitlebar, {
		mousedown: function( event ) {
		    // Don't prevent click on close button (#8838)
		    // Focusing a dialog that is partially scrolled out of view
		    // causes the browser to scroll it into view, preventing the click event
		    // if ( !$( event.target ).closest(".oj-fwk-icon-close") ) {
		    if ( !$( event.target ).closest(".oj-dialog-close-icon") ) {
			// Dialog isn't getting focus when dragging (#8063)
			this.uiDialog.focus();
		    }
		}
	    });


	    if (this.options.cancelBehavior === "icon")
		this._createCloseButton(this.uiDialogTitlebar);


	    uiDialogTitle = $("<span>")
		.uniqueId()
		.addClass("oj-dialog-title")
		// .prependTo( this.uiDialogTitlebar );
		.appendTo( this.uiDialogTitlebar );
	    this._title( uiDialogTitle );

	    this.uiDialog.attr({
		"aria-labelledby": uiDialogTitle.attr("id")
	    });
	},

	_title: function( title ) {
	    if ( !this.options.title ) {
		title.html("&#160;");
	    }
	    title.text( this.options.title );
	},


	_makeDraggable: function() {
	    var that = this,
	    options = this.options;

	    function filteredUi( ui ) {
		return {
		    position: ui.position,
		    offset: ui.offset
		};
	    }

	    this.uiDialog.draggable({
		// cancel: ".oj-dialog-content, .oj-dialog-titlebar-close",
		// handle: ".oj-dialog-titlebar",
		cancel: ".oj-dialog-content, .oj-dialog-header-close",
		handle: ".oj-dialog-header",
		containment: "document",
		start: function( event, ui ) {
		    $( this ).addClass("oj-dialog-dragging");
		    that._blockFrames();
		    that._trigger( "dragStart", event, filteredUi( ui ) );
		},
		'drag': function( event, ui ) {
		    that._trigger( "drag", event, filteredUi( ui ) );
		},
		stop: function( event, ui ) {
		    options.position = [
			ui.position.left - that.document.scrollLeft(),
			ui.position.top - that.document.scrollTop()
		    ];
		    $( this ).removeClass("oj-dialog-dragging");
		    that._unblockFrames();
		    that._trigger( "dragStop", event, filteredUi( ui ) );
		}
	    });
	},

	_makeResizable: function() {
	    var that = this,

	    options = this.options,

	    // handles = options.resizable,
	    position = this.uiDialog.css("position"),
	    // resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";

	    resizeHandles = "n,e,s,w,se,sw,ne,nw";

	    function filteredUi( ui ) {
		return {
		    'originalPosition': ui.originalPosition,
		    'originalSize': ui.originalSize,
		    position: ui.position,
		    size: ui.size
		};
	    }

	    this._resizableComponent = this.uiDialog['ojResizable'].bind(this.uiDialog);

	    // this.uiDialog.['ojResizable']({
	    // this.uiDialog.resizable({

	    this._resizableComponent({
		cancel: ".oj-dialog-content",
		containment: "document",

		handles: resizeHandles,
		start: function( event, ui ) {
		    $( this ).addClass("oj-dialog-resizing");
		    that._blockFrames();
		    // fire resizestart
		    that._trigger( "resizeStart", event, filteredUi( ui ) );
		},
		resize: function( event, ui ) {
		    that._trigger( "resize", event, filteredUi( ui ) );
		},
		stop: function( event, ui ) {

		    $( this ).removeClass("oj-dialog-resizing");
		    that._unblockFrames();
		    that._trigger( "resizeStop", event, filteredUi( ui ) );
		}
	    })
		    .css( "position", position );

	},

	_position: function() {

	    // Need to show the dialog to get the actual offset in the position plugin
	    var isVisible = this.uiDialog.is(":visible");
	    if ( !isVisible ) {
		this.uiDialog.show();
	    }

	    var pos = this.options.position;

	    // 
	    // Extended position objects with better names to support RTL.
	    // 
	    var isRtl = this._GetReadingDirection() === "rtl";
	    this.uiDialog.position(oj.PositionUtils.normalizeHorizontalAlignment(pos, isRtl));

	    // this.uiDialog.position(pos);
	    // this.uiDialog.position( this.options.position );

	    if ( !isVisible ) {
		this.uiDialog.hide();
	    }
	},

	_setOption: function( key, value, flags ) {
	    /*jshint maxcomplexity:15*/
	    var isDraggable, isResizable,
	    uiDialog = this.uiDialog;

	    if ( key === "disabled" ) {
		return;
	    }

	    this._super( key, value, flags );

            switch (key) 
            {
	    case "dragAffordance":

		isDraggable = uiDialog.is(":data(ui-draggable)");

		if ( isDraggable && value === "none") {
		    uiDialog.draggable("destroy");
		}

		if ( !isDraggable && value === "title-bar" ) {
		    this._makeDraggable();
		}

		break;

	    case "position":
		this._position();
		break;

	    case "resizeBehavior":

		isResizable = false;
		if (this._resizableComponent) isResizable = true;

		// currently resizable, becoming non-resizable
		if ( isResizable && value != "resizable" ) {
		    // uiDialog._resizableComponent("destroy");
		    this._resizableComponent("destroy");
		    this._resizableComponent = null;
		}

		// currently resizable, changing handles
		// if ( isResizable && typeof value === "string" ) {
		// this._resizableComponent( "option", "handles", value );
		//}

		// currently non-resizable, becoming resizable
		// if ( !isResizable && value !== false ) {
		if ( !isResizable && value === "resizable" ) {
		    this._makeResizable();
		}

		break;

	    case "title":
		this._title( this.uiDialogTitlebar.find(".oj-dialog-title") );
		break;

	    case "role":
		uiDialog.attr("role", value);
		break;

	    case "modality":

		if (value === "modal") {
		    this._createOverlay();
		}
		else if (value === "modeless")
		    this._destroyOverlay();

		break;

	    case "cancelBehavior":

		if (value === "none" || value === "escape") {

		    // we may need additional code here
		    // if (this.userDefinedDialogHeader) {   }

		    this._desroyCloseButton();

		}
		else if (value === "icon") {

		    if (this.userDefinedDialogHeader) {

			this._createCloseButton(this._userDefinedHeader);

			// 
			// Insert oj-dialog-title between oj-dialog-header and oj-dialog-header-close-wrapper
			// 
			this._userDefinedTitle = this._userDefinedHeader.find(".oj-dialog-title");
			if (this._userDefinedTitle.length)
		    	    this._userDefinedTitle.insertAfter(this.uiDialogTitlebarCloseWrapper);

		    } else 
			this._createCloseButton(this.uiDialogTitlebar);

		}

		break;

	    }
	},

	// 
	// Set the height of the body based on the dialog, header, and footer height.
	// bodyHeight = dialogHeight - headerHeight - footerHeight;
	// Called to implement interactive resize.
	// 
	_resizeBody: function() {

	    // clearTimeout(this._delayId);

	    var bodyHeight = this._getBodyHeight();

	    this.element.css({height: bodyHeight});

	},

	_getBodyHeight: function() {

	    var header;

	    this._delayId = null;

	    if (this.userDefinedDialogHeader)
		header = this._userDefinedHeader;
	    else header = this.uiDialogTitlebar;

	    var headerHeight = header.outerHeight();

	    var footerHeight = 0;
	    if (this.uiDialogFooter) {
		footerHeight = this.uiDialogFooter.outerHeight();
	    }

	    var bodyHeight =  this.uiDialog.height() - headerHeight - footerHeight;

	    return bodyHeight;
	},

	_measureDialogHeight: function() {

	    // 
	    // Convert the .css width and height variables to numerical values.
	    // This is done in order to be compatible with the ojResizable API.
	    // The numberical value conversion is done by rendering to an off-document div.
	    // 

	    // create a temporary element
	    var tempE = $("<div></div>");

	    // 
	    // Note: we use Math.ceil() for width and height.
	    // 
	    this._cssHeight = this.uiDialog.css('height');
	    if (this._cssHeight != "auto") {
		tempE.height(this._cssHeight);
		this._cssHeightNumeric = tempE.height();
		if (this._isNumber(this._cssHeightNumeric))
		    this._cssHeightNumeric = Math.ceil(this._cssHeightNumeric);
	    } 
	    else this._cssHeightNumeric = "auto";

	    tempE.remove();

	},

	//
	// Calculate the initial height of the dialog content, this is passed into ojResizable.
	//
	_size: function() {

	    this._measureDialogHeight();

	    // 
	    // Save the original dimensions
	    // 
	    var heightValue = this.uiDialog[0].style.height;
	    var widthValue = this.uiDialog[0].style.width;

	    // 
	    // Save the min/max heights, since we temporarily step on them.
	    // 
	    var minHeightValue = this.uiDialog[0].style.minHeight;
	    var maxHeightValue = this.uiDialog[0].style.maxHeight;

	    // Set element height to 0 in order to determine the height of the non-content elements.
	    this.element.css({
		width: "auto",
		minHeight: 0,
		maxHeight: "none",
		height: 0
	    });

	    var nonContentHeight;

	    // 
	    // determine the height of all the non-content elements
	    // Note: height: 'auto' is needed for accurate scrolling calculations.
	    //

	    nonContentHeight = this.uiDialog.css({
		minHeight: 0,
		maxHeight: "none",
		height: "auto"
	    }).outerHeight();

	    // 
	    // Restore the element height
	    //
	    this.element.css({
		width: '',
		minHeight: '',
		maxHeight: '',
		height: ''
	    });

	    //
	    // Restore the height back to its original.
	    // This is necessary to support browser resize of %height and % width
	    //
	    this.uiDialog.css({width: widthValue});
	    this.uiDialog.css({height: heightValue});
	    // 
	    // Restore the min and max heights.
	    // 
	    this.uiDialog.css({minHeight: minHeightValue});
	    this.uiDialog.css({maxHeight: maxHeightValue});

	    //
	    // Set the height of the inner element
	    // This is needed in order to see the overflow scrollbar
	    // if overflow occurs on the initial, unresized dialog
	    // 
	    if (heightValue != "auto" ) {
		this.element.height(Math.max( 0, this._cssHeightNumeric + _padYDelta - nonContentHeight));
	    }

	},

	_blockFrames: function() {
	    this.iframeBlocks = this.document.find( "iframe" ).map(function() {
		var iframe = $( this );

		var offset = /** @type {{left: number, top: number}}  */ (iframe.offset());

		return $( "<div>" )
		    .css({
			position: "absolute",
			width: iframe.outerWidth(),
			height: iframe.outerHeight()
		    })
		    .appendTo( iframe.parent() )
		    .offset( offset )[0];
	    });
	},

	_unblockFrames: function() {
	    if ( this.iframeBlocks ) {
		this.iframeBlocks.remove();
		delete this.iframeBlocks;
	    }
	},

	_allowInteraction: function( event ) {
	    if ( $( event.target ).closest(".oj-dialog").length ) {
		return true;
	    }

	    // TODO: Remove hack when datepicker implements
	    // the .oj-front logic (#8989)
	    return !!$( event.target ).closest(".oj-datepicker").length;
	},

	//
	// Place a system generated div in the DOM spot where the dialog is defined.
	// This is used later to return the dialog to its original relocated position.
	// Relocate the dialog to the end of the body.
	//
	_relocateWithPutback: function() {

	    if (_putback) {

		this._placeHolderId = _placeHolderPrefix + this._elementId;

		this._placeHolder = $("<div>")
		    .hide()
		    .attr({'id' : this._placeHolderId});

		this._placeHolder.insertBefore($('#' + this._wrapperId));  // position placeHolder at original in-line DOM location, before the wrapper id
	    }

		// Since the dialog is reparented to the body, it looses associate in the dom.
		// Establish linkage between the dialog and its placeholder.
		this.uiDialog.attr(oj.DomUtils.SURROGATE_ID, this._placeHolder.attr("id"));

	    this.uiDialog.appendTo( this._appendTo() ); 
	},

	_createPlaceHolderFooter: function(domElement) {

	    this._placeHolderFooterId = _placeHolderFooterPrefix + this._elementId;

	    this._placeHolderFooter = $("<div>")
		.hide()
		.attr({'id' : this._placeHolderFooterId});

	    this._placeHolderFooter.insertBefore(domElement);  

	},

	_createPlaceHolderHeader: function(domElement) {

	    this._placeHolderHeaderId = _placeHolderHeaderPrefix + this._elementId;

	    this._placeHolderHeader = $("<div>")
		.hide()
		.attr({'id' : this._placeHolderHeaderId});

	    this._placeHolderHeader.insertBefore(domElement);  

	},

	_destroyPutback: function() {

	    if (_putback) {

		if ( this.placeHolder) {

		    this.placeHolder.remove();
		    this.placeHolder = null;
		}
	    }
	},

	_createOverlay: function() {

	    if (this.options.modality === "modeless" ) {
		return;
	    }

	    if ( this.overlay ) return;

	    // We use a delay in case the overlay is created from an
	    // event that we're going to be cancelling (#2804)
	    var isOpening = true;
	    this._delay(function() {
		isOpening = false;
	    });

	    if ( !this.document.data( "oj-dialog-overlays" ) ) {

		// Prevent use of anchors and inputs
		// Using _on() for an event handler shared across many instances is
		// safe because the dialogs stack and must be closed in reverse order
		this._on( this.document, {
		    focusin: function( event ) {
			if ( isOpening ) {
			    return;
			}

			if ( !this._allowInteraction( event ) ) {
			    event.preventDefault();
			    this._trackingInstances()[ 0 ]._focusTabbable();
			}
		    }
		});
	    }

	    
	    //
	    // create an overlay that will disable anything except the dialog.
	    //
	    this.overlay = $("<div>")
		.addClass("oj-component-overlay oj-dialog-front");

	    // this.overlay.appendTo( this._appendTo() );
	    // This insertion point works better for dynamic option changes (modality option)
	    var bod = this.document.find("body").eq( 0 );
	    this.overlay.insertBefore(bod.find(".oj-dialog").eq(-0));

	    this._on( this.overlay, {
		mousedown: "_keepFocus"
	    });

	    this.document.data( "oj-dialog-overlays",
				(this.document.data( "oj-dialog-overlays" ) || 0) + 1 );
	},

	_destroyOverlay: function() {

	    // if (this.options.modality === "modeless" ) { return; }

	    if ( this.overlay ) {
		var overlays = this.document.data( "oj-dialog-overlays" ) - 1;

		if ( !overlays ) {
		    this.document
			.unbind( "focusin" )
			.removeData( "oj-dialog-overlays" );
		} else {
		    this.document.data( "oj-dialog-overlays", overlays );
		}

		this.overlay.remove();
		this.overlay = null;
	    }
	},

	/**
   * Return the subcomponent node represented by the documented locator 
   * attribute values.
   * Test authors should target sub elements using the following names:
   * <ul>
   * <li><b>oj-dialog-header</b>: dialog header div </li>
   * <li><b>oj-dialog-body</b>: dialog body div </li>
   * <li><b>oj-dialog-footer</b>: dialog footer div </li>
   * <li><b>oj-dialog-content</b>: dialog content div </li>
   * <li><b>oj-dialog-header-close-wrapper</b>: dialog header-close wrapper </li>
   * <li><b>oj-dialog-header-close-icon</b>: dialog header-close icon </li>
   * <li><b>oj-resizable-n</b>: North resizable handle </li>
   * <li><b>oj-resizable-e</b>: East resizable handle </li>
   * <li><b>oj-resizable-s</b>: South resizable handle </li>
   * <li><b>oj-resizable-w</b>: West resizable handle </li>
   * <li><b>oj-resizable-se</b>: Southeast resizable handle </li>
   * <li><b>oj-resizable-sw</b>: Southwest resizable handle </li>
   * <li><b>oj-resizable-ne</b>: Northeast resizable handle </li>
   * <li><b>oj-resizable-nw</b>: Northwest resizable handle </li>
   * </ul>
   * @expose
   * @memberof oj.ojDialog
   * @instance
   * @override
   * @param {Object} locator An Object containing at a minimum a subId property 
   *        whose value is a string, documented by the component, that allows 
   *        the component to look up the subcomponent associated with that 
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one 
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component 
   *        expects in getNodeBySubId to locate a particular subcomponent
    * @example <caption>Return the locator for the dialog footer: </caption>
    * var node = $( ".selector" ).ojDialog("getNodeBySubId", {'subId', '.oj-dialog-footer'});
   * @returns {Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
	getNodeBySubId: function(locator)
	{
	    if (locator == null)
	    {
		return this.element ? this.element[0] : null;
	    }
	    
	    var subId = locator['subId'];

	    switch (subId) {

	    case "oj-dialog":
	    case "oj-dialog-header":
	    case "oj-dialog-body":
	    case "oj-dialog-footer":
	    case "oj-dialog-content":
	    case "oj-dialog-header-close-wrapper":
	    case "oj-dialog-header-close-icon":
	    case "oj-resizable-n":
	    case "oj-resizable-e":
	    case "oj-resizable-s":
	    case "oj-resizable-w":
	    case "oj-resizable-se":
	    case "oj-resizable-sw":
	    case "oj-resizable-ne":
	    case "oj-resizable-nw":

		var dotSubId = "." + subId;
		return (this.widget().find(dotSubId)[0]);
		break;

	    }

	    // Non-null locators have to be handled by the component subclasses
	    return null;
	}


    });


}() );


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/* This component is based on origional code from:
   jsTree 1.0-rc3   http://jstree.com/
   "Copyright (c) 2010 Ivan Bozhanov (vakata.com)
    Licensed same as jquery - under the terms of either the MIT License or
    the GPL Version 2 License
    http://www.opensource.org/licenses/mit-license.php
    http://www.gnu.org/licenses/gpl.html"
*/


/*---------------------------------------------------------
   ojTree     Displays a Hierarchical Tree
   Depends:   jquery.ui.core.js
              jquery.ui.widget.js
----------------------------------------------------------*/

(function () 
{
  /*
  function debugObj(o)  {
    var s ;
    try { s = JSON.stringify(o) ; }
    catch (e) { s = "ERROR";}
    return s ;
  };
  */

  //  ojTree class names  
  var  /** @const */   OJT_NODE          = "oj-tree-node",            // a tree node (parent or leaf)
       /** @const */   OJT_LEAF          = "oj-tree-leaf",            // leaf node
       /** @const */   OJT_ICON          = "oj-tree-icon",            // <ins> generic icon
       /** @const */   OJT_NICON         = "oj-tree-node-icon",       // <ins> node icon
       /** @const */   OJT_DISC          = "oj-tree-disclosure-icon", // <ins> disclosure icon
       /** @const */   OJT_LAST          = "oj-tree-last",            // last <li> in a <ul>
       /** @const */   OJT_LOADING       = "oj-tree-loading",
       /** @const */   OJT_LAST_SELECTED = "oj-tree-last-selected",
       /** @const */   OJT_TITLE         = "oj-tree-title",
       /** @const */   OJT_INACTIVE      = "oj-tree-inactive" ;

  // Jet class names
  var  /** @const */   OJ_EXPANDED       = "oj-expanded",
       /** @const */   OJ_COLLAPSED      = "oj-collapsed",
       /** @const */   OJ_HOVER          = "oj-hover",
       /** @const */   OJ_SELECTED       = "oj-selected",        // i.e clicked
       /** @const */   OJ_DISABLED       = "oj-disabled",
       /** @const */   OJ_DEFAULT        = "oj-default";


  // ojTree disclosure class names
  var  /** @const */   OJ_DISC           = "oj-tree-icon oj-tree-disclosure-icon oj-component-icon oj-clickable-icon oj-default";

  //  ojTree DnD reorder class names  

  var  /** @const */   OJ_DRAGGABLE      = "oj-draggable",     // node is draggable
       /** @const */   OJ_DRAG           = "oj-drag",          // node that is being dragged
       /** @const */   OJ_ACTIVE_DROP    = "oj-active-drop",   // over node in process of being dropped on
       /** @const */   OJ_VALID_DROP     = "oj-valid-drop",    // over node that could be dropped on
       /** @const */   OJ_INVALID_DROP   = "oj-invalid-drop",  // over node that could be dropped on
       /** @const */   OJ_DROP           = "oj-drop" ;         // ?


  var  /** @const */   OJT_DROP_OK       = "oj-tree-drop-ok",
       /** @const */   OJT_DROP_INVALID  = "oj-tree-drop-invalid",
       /** @const */   OJT_MARKER        = "oj-tree-marker",
       /** @const */   OJT_MARKER_LINE   = "oj-tree-marker-line";

  //  WAI-ARIA  
  var  /** @const */   WA_ROLE              = "role",
       /** @const */   WA_TREE              = "tree",
       /** @const */   WA_TREEITEM          = "treeitem",
       /** @const */   WA_GROUP             = "group",
       /** @const */   WA_SELECTED          = "aria-selected",
       /** @const */   WA_EXPANDED          = "aria-expanded",
       /** @const */   WA_ACTIVEDESCENDANT  = "aria-activedescendant",
       /** @const */   WA_MULTISELECTABLE   = "aria-multiselectable";

  //  Data names
  var  /** @const */   OJT_CHILDREN         = "oj-tree-children";

  //  Data source in use
  var  /** @const */   DS_TREE        =  1,
       /** @const */   DS_COLLECTION  =  2,
       /** @const */   DS_JSON        =  3,
       /** @const */   DS_HTML        =  4,
       /** @const */   DS_NONE        =  0,
       /** @const */   DS_ERROR       = -1;

  // Context Menu item id's
  var  /** @const */  _arMenuCmdMap = { "cut"    : "ojtreecut",
                                        "copy"   : "ojtreecopy",
                                        "paste"  : "ojtreepaste",
                                        "remove" : "ojtreeremove",
                                        "rename" : "ojtreerename"
                                      } ;

  var  /** @const */  USER_UL_ID_PREFIX = "oj-tree-existing-markup-" ;

  /**
    *  Public event names
    *  @const
    */
  var  _aEvNames = ["optionChange", "select", "deselect", "hover", "dehover", "expand", "collapse", "loaded",
                    "move", "remove", "deselectAll", "rename", "refresh", "expandAll", "collapseAll", "destroy",
                    "create", "before", "remove", "cut", "copy", "paste"] ;

  /**
    *  Return sanitized selector
    *  @private
    */
  function  _sanitizeSelector(hash) {
       return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
  };

  /**
    *  Return sanitized html fragment for security
    *  @private
    */
  function  _escapeHtml(s) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(s)) ;
    return div.innerHTML;
  };

  /**
    *  Return true if event name is public. 
    *  @private
    */
  function _isPublicEvent(s) {
     var  b = ($.inArray(s, _aEvNames) >= 0) ;
     if ((! b) && (s == "create_node")) {
       b = true ;
     }
     return b ;
  };

  /**
    *  Convert event names to ojTree style.
    *  @private
    */
  function _convertEventName(s) {
    // jsTree uses the same event names as its methods.  This behavior is changed for ojTree

    if      (s === "rename_node") {s = "rename";}
    else if (s === "set_focus")   {s = "focus";}
    else if (s === "unset_focus") {s = "unfocus";}
    else if (s === "delete_node") {s = "remove";}
    else if (s === "move_node")   {s = "move";}
    else if (s === "create_node") {s = "create";}

    return s ;
  };


  var scrollbar_width, e1, e2;
  $(function() {
     if (/msie/.test(navigator.userAgent.toLowerCase())) {
       e1 = $('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
       e2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
       scrollbar_width = e1.width() - e2.width();
       e1.add(e2).remove();
     }
     else {
       e1 = $('<div />').css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: 0 })
                        .prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
       scrollbar_width = 100 - e1.width();
       e1.parent().remove();
     }
  });


  /**
    *  Adds a style sheet.
    *  @param {Object=}  opts  The css data.
    *  @param {boolean=} bLink  True if opts.url is to be ignored.
    *  @private
    */
  function  _addSheet(opts, bLink)
  {
    var tmp    = false,
        isNew  = true;

    if (opts.str)  {
      if (opts.title)  {
        tmp = $("style[id='" + opts.title + "-stylesheet']")[0];
      }
      if (tmp)  {
        isNew = false;
      }
      else   {
        tmp = document.createElement("style");
        tmp.setAttribute('type',"text/css");
        if (opts.title) {
          tmp.setAttribute("id", opts.title + "-stylesheet");
        }
      }

      if (tmp.styleSheet)  {
        if (isNew)  {
          document.getElementsByTagName("head")[0].appendChild(tmp); 
          tmp.styleSheet.cssText = opts.str; 
        }
        else  {
          tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str;
        }
      }
      else   {
        tmp.appendChild(document.createTextNode(opts.str));
        document.getElementsByTagName("head")[0].appendChild(tmp);
      }

      return tmp.sheet || tmp.styleSheet;
    }

    if (opts.url) {
      if (bLink) {
        if (document.createStyleSheet)  {
          try  {
                 tmp = document.createStyleSheet(opts.url);    // IE
          }
          catch (e) { }

        }
        else  {
          tmp        = document.createElement('link');
          tmp.rel    = 'stylesheet';
          tmp.type   = 'text/css';
          tmp.media  = "all";
          tmp.href   = opts.url;

          document.getElementsByTagName("head")[0].appendChild(tmp);
          return tmp.styleSheet;
        }
      }
    }
  };

  /**
    *  Removes a style sheet.
    *  @param {string} title  The "title" member used in _addSheet() opts data.
    *  @private
    */
  function  _removeSheet(title) {
     title = "#" + title + "-stylesheet" ;
     $(title).remove() ;
  };


  /**
    * Stack of key handler objects for all trees
    * @private
    */
  var  _aKeyHandlerStack = [] ;

  /**
    * Add key combination handler to stack, and add listener 
    * @private
    */
  function  _addKeyFilter(obj)
  {
    _aKeyHandlerStack.push(obj) ;
    $(obj._selector).keydown(_KeyFilterHandler) ;
  };  

  /**
    * Handle keystroke from _KeyFilter and dispatch to the 
    * relevent accessibility key combination handler.
    * @private
    */
  function  _KeyFilterHandler(e)
  {
    var s = "" ;
  
    if (oj.DomUtils.isMetaKeyPressed(e)) {           
      s += "ctrl+" ;
    }
    else if (e.shiftKey) {
      s += "shift+" ;
    }

    var key = e.which ;
    switch(key) {
      case 32:                      // Space
                s += "space"
                break;
      case 37:                      // Left arrow
                s += "left"
                break;
      case 38:                      // Up arrow
                s += "up"
                break;
      case 39:                      // Right arrow
                s += "right"
                break;
      case 40:                      // Down arrow
                s += "down"
                break;
      case 46:                      // Delete
                s += "del"
                break;
      case 33:                      // Page Up
                s += "pgup"
                break;
      case 34:                      // Page Down
                s += "pgdn"
                break;
      case 35:                      // End
                s += "end"
                break;
      case 36:                      // Home
                s += "home"
                break;
      case 56:                      // asterisk
                s = "*"             // remove the shift required to get *
                break;
//    case 112:                     // F1
      case 113:                     // F2
/*
      case 114:                     // F3
      case 115:                     // F4
      case 116:                     // F5
      case 117:                     // F6
      case 118:                     // F7
      case 119:                     // F8
      case 120:                     // F9
      case 121:                     // F10
      case 122:                     // F11
      case 123:                     // F12
*/
                s += ("f" + ('1' - (112 - key))) ;
                break;
    }

    if (s.length === 0) {
      return ;
    }

    // If we can find a handler from a tree with focus, dispatch
    // the keystroke event to it.
    var retHandler = undefined ;
    $.each(_aKeyHandlerStack, function(i, obj) {
        if (obj._this._data.ui.focused) {         // does associated tree have focus
          if (obj._handler[s]) {                  // yes, does it have a matching handler function
            e.preventDefault() ;
            retHandler = obj._handler[s].call(obj._this, e) ;
            return false ;          // break out of $.each
          }
        }
    });
    return retHandler;

  };

  /**
    * Remove key combination handler from stack and remove listener 
    * @private
    */
  function  _removeKeyFilter(selector)
  {
    $.each(_aKeyHandlerStack, function(i) {
       if (_aKeyHandlerStack[i]._selector === selector) {
         $(selector).off("keydown") ;
         _aKeyHandlerStack[i] = null ;
         _aKeyHandlerStack.splice(i, 1) ;
         return false ;
       }
    }) ;
  };


  /**
    * @private
    */
  var _instance   = -1 ;      // current Tree instance id
  var _aInstances = [] ;


/**
  * @class
  * @name oj.ojTree
  * @augments oj.baseComponent
  * @since 0.6
  *
  * @classdesc
  * <h3 id="treeOverview-section">
  *   JET Tree Component
  *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#treeOverview-section"></a>
  * </h3>
  *
  * The ojTree component allows a user to display the hierarchical relationship between the nodes of a tree.<p>
  * The tree contents can be specified in JSON format, or by prepopulating the tree's containing &lt;div&gt; with
  * HTML &lt;ul&gt; list markup.
  * </p></br>
  * 
  * <h4 id="treeJSON-section"> JSON Node Format</h4>
  * </br>
  * Each node object typically has a <code class="prettyprint">title</code> and an
  * <code class="prettyprint">attr</code> property. Any node can be defined as a parent by supplying
  * a <code class="prettyprint">children</code> property, which is an array of more node definitions.
  * (Note that if a node has a <code class="prettyprint">children</code> property defined, but no children
  * are actually specified, then ojTree will perform lazy-loading by requesting child node data only
  * when a node is expanded for the first time - refer to <code class="prettyprint">option</code> property
  * <code class="prettyprint">data</code>.
  * <p>Example: Basic JSON Tree definition
  * <pre class="prettyprint">
  * <code>
  *[
  *   {                                    
  *     "title": "Home",
  *     "attr": {"id": "home"},
  *   },
  *   { 
  *     "title": "News",
  *     "attr": {"id": "news"}
  *   },
  *   { 
  *      "title": "Blogs",
  *      "attr": {"id": "blogs"},
  *      "children": [ {
  *                       "title": "Today",
  *                       "attr": {"id": "today"}
  *                    },
  *                    {
  *                       "title": "Yesterday",
  *                       "attr": {"id": "yesterday"}
  *                    }
  *                  ]
  *   }
  *] 
  *</code></pre>
  *</p></br>
  * Whatever attributes are defined for the <code class="prettyprint">attr</code> property are transferred
  * to the associated DOM &lt;li&gt; element. A <code class="prettyprint">metadata</code> attribute can also be
  * defined for arbitrary user-defined data that is to be associated with a node. (This metadata is
  * maintained within the ojTree instance, and is not represented in the DOM.)  A node's metadata can be retrieved
  * using the jQuery .data() method.
  * </p></br>Example: Expanded use of the <code class="prettyprint">attr</code> property
  * <pre class="prettyprint">
  * <code>
  *[
  *  { 
  *    "title": "Home",
  *    "attr": {
  *               "id": "home",
  *               "myattr1": "Hello",         &lt;-- additional user-defined attributes
  *               "myattr2": "World"          &lt;-- additional user-defined attributes 
  *            },
  *    "metadata": {                          &lt;-- node metadata
  *                  "type": "T123",
  *                  "val": 42,
  *                  "active": true
  *                }
  *  },
  *
  *  . . .
  *]
  *</code></pre>
  *
  * </p></br>Example: Retrieving node attributes and data
  * <pre class="prettyprint">
  * <code>
  *$("#mytree).on("ojtreehover", function (ev, ui){
  *
  *  // ui.item = node
  *  // ui.item.attr("id")         -  retrieve a node attribute
  *  // ui.item.attr("myattr1")    -    ..
  *  // ui.item.data("active")     -  retrieve the "active" meta-data value from previous example
  *
  *});
  *</code></pre>
  *</p></br>
  * For flexibility, attributes can also be applied to the node's &lt;a&gt; element if required, by specifying
  * the node <code class="prettyprint">data</code> property as an object.
  * </p>Example: Using the data property
  * <pre class="prettyprint">
  * <code>
  *{
  *   "attr" : { "id" : "myid" },                    &lt;-- this is set on the &lt;li&gt;
  *   "data" : {
  *              "attr" : {
  *                         "flags"   : "A-B",       &lt;-- this is set on the &lt;a&gt;
  *                         "title" : "This is a tooltip"
  *                       }
  *             }
  *}
  *</code></pre>
  *</p></br>
  * <h4 id="treeHTML-section"> HTML Node Format</h4>
  * </br>
  * A Tree can be populated via standard HTML markup using a &lt;ul&gt; list structure - refer to
  * <code class="prettyprint">option</code> property <code class="prettyprint">"data"</code>.  In
  * the case where the <code class="prettyprint">"data"</code> option has not been defined, ojTree
  * will use any HTML markup defined in the Tree's containing &lt;div&gt;, and on startup the &lt;ul&gt;
  * the markup will be detached from the containing &lt;div&gt;, saved, and used as a template to create a new
  * tree structure in its place.  When the tree is destroyed, the original markup is restored.  Lazy loading of 
  * a node's children (when expanded) is performed if any node indicates that it has children,  
  * but its child &lt;ul&gt; list is left empty.
  * </p></br>Example: Using HTML markup to populate a Tree.
  * <pre class="prettyprint">
  * <code>
  * &lt;div id="mytree"&gt;
  *    &lt;ul&gt;
  *       &lt;li id="home"&gt;
  *          &lt;a href="#"&lt;Home&gt;/a&gt;
  *       &lt;/li&gt;
  *       &lt;li id="news"&gt;
  *          &lt;a href="#"&gt;News&lt;/a&gt;
  *       &lt;/li&gt;
  *       &lt;li id="blogs"&gt;
  *            &lt;a href="#"&gt;Blogs&lt;/a&gt;
  *            &lt;ul&gt;
  *              &lt;li id="today"&gt;
  *                 &lt;a href="#"&gt;Today&lt;/a&gt;
  *              &lt;/li>
  *              &lt;li id="yesterday"&gt;
  *                 &lt;a href="#"&gt;Yesterday&lt;/a&gt;
  *              &lt;/li&gt;
  *            &lt;/ul&gt;
  *       &lt;/li&gt;
  * &lt;/div&gt;
  </code></pre>
  * </p></br>
  * <h3 id="keyboard-section">
  *   Keyboard End User Information<a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a></h3>
  * <table class="keyboard-table">
  *   <thead>
  *     <tr>
  *       <th>Key</th>
  *       <th>Use</th>
  *     </tr>
  *   </thead>
  *   <tbody>
  *     <tr>
  *       <td><kbd>Up/down arrow</kbd></td>
  *       <td>Moves between visible nodes.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Left-arrow</kbd></td>
  *       <td>On an expanded node, collapses the node.<br>On a collapsed or leaf node, moves focus to the node's parent.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Right-arrow</kbd></td>
  *       <td>On a collapsed node, expands the node.<br>On an expanded node, moves to the first first child of the node.<br>On an end node, does nothing.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Space bar</kbd></td>
  *       <td>Toggles the select status of the node.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Home</kbd></td>
  *       <td>Moves to the top node of the tree.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>End</kbd></td>
  *       <td>Moves to the last visible node of the tree.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift-Up arrow</kbd></td>
  *       <td>Extends selection up one node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift-Down arrow</kbd></td>
  *       <td>Extends selection down one node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift-Home</kbd></td>
  *       <td>Extends selection up to the top-most node.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift+pgDn</kbd></td>
  *       <td>Extends selection to the last node.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Ctrl+Space bar</kbd></td>
  *       <td>Toggles the selection state of the current node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift+Space bar</kbd></td>
  *       <td>Extends selection to the current node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>* (asterisk)</kbd></td>
  *       <td>Expands all nodes.</td>
  *     </tr>
  * </tbody></table>
  *
  *
  * @desc Creates a JET Tree.
  * @param {Object=} options a map of option-value pairs to set on the component
  * 
  * @example <caption>Initialize the Tree with options:</caption>
  * $( ".selector" ).ojTree( {"animDuration": 0, "selectionMode": "single"} );
  * 
  */
  oj.__registerWidget("oj.ojTree", $['oj']['baseComponent'], 
  {
     widgetEventPrefix : "oj", 
     defaultElement    : "<div>", 

     options: {
                /** Disables the tree if set to <code class="prettyprint">true</code>.
                  * 
                  * @member
                  * @name disabled
                  * @memberof! oj.ojTree
                  * @instance
                  * @type {boolean}
                  * @default <code class="prettyprint">false</code>
                  * 
                  * @example <caption>Initialize the tree with the <code class="prettyprint">disabled</code> option specified:</caption>
                  * $( ".selector" ).ojTree( { "disabled": true } );
                  * 
                  * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
                  * // getter
                  * var disabled = $( ".selector" ).ojTree( "option", "disabled" );
                  * 
                  * // setter
                  * $( ".selector" ).ojTree( "option", "disabled", true );
                  */
                  // disabled option declared in superclass, but we still want the above API doc

                /**
                  * Identifies the JET Menu that the component should launch as a context menu on right-click or
                  * <kbd>Shift-F10</kbd>. If specified, the browser's native context menu will be replaced by the
                  * specified JET Menu.
                  * 
                  * <p>To specify a JET context menu on a DOM element that is not a JET component, see the
                  * <code class="prettyprint">ojContextMenu</code> binding.  
                  * 
                  * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the
                  * context menu via the standard HTML5 syntax shown in the below example.  When the component is
                  * initialized, the context menu thus specified will be set on the component.
                  *
                  * <p>When defining a contextMenu, ojTree will provide built-in behavior for "edit" style functionality
                  *  (e.g. cut/copy/paste) if the following format for menu &lt;li&gt; item's is used (no &lt;a&gt; 
                  *  elements are required):
                  * <ul><li> &lt;li data-oj-command="oj-tree-cut" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-copy" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-paste" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-remove" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-rename" /&gt;</li>
                  * </ul>
                  * The available translated text will be applied to menu items defined this way.
                  *
                  * <p>The JET Menu should be initialized before any component using it as a context menu.
                  * 
                  * @member
                  * @name contextMenu
                  * @memberof! oj.ojTree
                  * @instance
                  * @type {string | null}
                  * @default <code class="prettyprint">null</code>
                  * 
                  * @example <caption>Initialize a JET Tree with a context menu:</caption>
                  * // via recommended HTML5 syntax:
                  * &lt;div id="myTree" contextmenu="myMenu" data-bind="ojComponent: { ... }>
                  * 
                  * // via JET initializer (less preferred) :
                  * $( ".selector" ).ojTree({ "contextMenu": "#myContextMenu"  ... } });
                  * 
                  * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option for
                  *      an ojTree after initialization:</caption>
                  * // getter
                  * var menu = $( ".selector" ).ojTree( "option", "contextMenu" );
                  * 
                  * // setter
                  * $( ".selector" ).ojTree( "option", "contextMenu", "#myContextMenu"} );
                  */

                /**
                  * Specifies an animation duration in milliseconds for expanding or collapsing a node.
                  * Specify zero to inhibit animation.
                  * @type {number}
                  * @default <code class="prettyprint">500</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                animDuration  : 500,

                /**
                  * Specifies whether the user is permitted to reorder the nodes within the same tree using drag and drop.</br></br>
                  * Specify an object with the property "reorder" set to <code class="prettyprint">"enable"</code> to enable
                  * reordering.  Setting the <code class="prettyprint">"reorder"</code> property to <code class="prettyprint">"disable"</code>,
                  * or omitting the <code class="prettyprint">"reorder"</code> property disables reordering support. 
                  * 
                  * @example <caption>Example: Enable drag and drop for tree node reordering</caption>
                  * dnd : (
                  *         "reorder" : "enable"
                  *       }
                  *
                  * @type {Object}
                  * @default <code class="prettyprint">{reorder:'disable'}</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                dnd : {reorder:'disable'},             

                /**
                  * Specify <span class="code-caption">true</span> if expanding a node programatically should
                  * also expand its parents (i.e all parent nodes down to this node will be expanded).
                  * @type {boolean}
                  * @default <code class="prettyprint">false</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                expandParents : false,

                /**
                  * Specifies whether any nodes should be initially expanded on start-up.   Specify an array
                  * of node id's, or the string <span class="code-caption">"all"</span> if all parent nodes
                  * should be expanded.  The value may optionally be specified as an empty array.
                  * @type {Array | null}
                  * @default <code class="prettyprint">null</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                initExpanded  : null,

                initLoaded    : [],                  // suppressed per design review

                /** An array of node elements that are currently selected. If the array is modified
                  * by an application, the selected node status of the tree is modified to match the array
                  * (nodes may be defined as elements, jQuery wrapped nodes, or selectors pointing to the
                  * elements that should be selected).
                  * @type {Array}
                  * @default <code class="prettyprint">Array</code>
                  * @expose 
                  * @instance
                  * @memberof! oj.ojTree 
                  */
                selection : [],

                /**
                  * Specifies whether selection is permitted, and whether more than one node
                  * can be selected at a time.  Values are <span class="code-caption">"single"</span>
                  * for single selection, <span class="code-caption">"multiple"</span> to allow multiple
                  * concurrent selections, and <span class="code-caption">"none"</span> to inhibit selection.
                  * @type {string}
                  * @default <code class="prettyprint">"single"</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectionMode  :  "single" ,

                /**
                  *  Specifies what action is to be taken when a selected node's parent is collapsed.  Specify
                  *  false if nothing is to be done. Specify <span class="code-caption">"selectParent"</span>
                  *  if the node's closed parent is to be selected, or specify <span class="code-caption">"deselect"</span>
                  *  if the node is to be deselected.
                  * @type {boolean | string}
                  * @default <code class="prettyprint">false</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectedParentCollapse  :  false ,

                /**
                  *  Specifies what action is to be taken when a node is programmatically expanded.  Specify
                  *  <span class="code-caption">true</span> if all of the node's closed parents should be opened
                  *  automatically.  If <span class="code-caption">false</span> is specified, the node is selected but will
                  *  remain invisible if its parents are currently collapsed.
                  * @type {boolean}
                  * @default <code class="prettyprint">true</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectedParentExpand   :  true ,

                /**
                  * Specifies the action to take when a selected node is deleted.  If set to 
                  * <span class="code-caption">true</span>, its previous sibling (or parent, if no previous siblings)
                  * is selected.  If <span class="code-caption">false</span> is specified, no action is taken.
                  * @type {boolean}
                  * @default <code class="prettyprint">false</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectPrevOnDelete     :  false ,

                /**
                  * Specifies the data source used to populate the tree. Currently supported data sources are a <code class="prettyprint">JsonTreeDataSource</code>,
                  * or json, or html.</br></br> 
                  * The general format of the <code class="prettyprint">data</code> option is one of the following:
                  *</br></br>
                  *<ul>
                  *   <li>data : oj.JsonTreeDataSource</br></br></li>
                  *   <li>data : null    (or omit) - ojTree will look at the containing &lt;div&gt;
                  *                       and use any existing html &lt;ul&gt; markup found</br></br></li>
                  *   <li>data : "  json string  "</br></br></li>
                  *   <li>data : [ array of json objects ]</br></br></li>
                  *   <li>data : "&lt;ul&gt;&lt;li&gt; ...  html markup string  &lt;/ul&gt;"</br></br></li>
                  *   <li>data : { "data" : &nbsp; &nbsp; ... or &nbsp; &nbsp; "ajax" : &nbsp; &nbsp; . . . &nbsp; &nbsp;}  &nbsp; &nbsp; &nbsp; // retrieve json or html</li>
                  * </ul>
                  *</br>
                  * Use of the <code class="prettyprint">"data"</code> property of the <code class="prettyprint">data</code> option,
                  * specifies that the tree is to be populated from JSON or HTML (local or remote).
                  * The <code class="prettyprint">"data"</code> object contains one of two properties:
                  * <ul>
                  *  <li>"data"</li>
                  *  <li>"ajax"</li>
                  * </ul>
                  *  An optional <code class="prettyprint">"dataType"</code> property may also be specified, which can take the
                  *  value <code class="prettyprint">"json"</code> or <code class="prettyprint">"html"</code>, and indicates
                  *  what kind of data is being returned in the <code class="prettyprint">"data"</code> or
                  *  <code class="prettyprint">"ajax"</code> method (default is "json").
                  * </ul>
                  *
                  * When <span class="code-caption">"data"</span> is specified as an object, its <span class="code-caption">"data"</span> property may be specified as a function which
                  * receives two arguments: <span class="code-caption">node</span>, and <span class="code-caption">fn</span>.
                  * </p></br>
                  * Example: Skeleton outline of a <code class="prettyprint">"data"</code> function:
                  *</br>
                  *<pre class="prettyprint">
                  *<code>
                  *data : {
                  *          "data" : function(node, fn) {
                  *                    // node  -  the jQuery wrapped node to be expanded for a lazy load,
                  *                    //          or -1 if it is the initial call to load the tree.
                  *                    // fn    -  a function to call with the JSON to be applied.
                  *
                  *                    fn( new_json_node_data ) ;   // return the JSON
                  *                   }
                  *        }
                  *</code></pre>
                  * </br>
                  * The <code class="prettyprint">"ajax"</code> property of the <code class="prettyprint">"data"</code> option
                  * allows remote JSON to be retrieved. It may be specified as an object (refer to the
                  * jQuery .ajax() settings object). If may also be specified as <code class="prettyprint">false</code> or
                  * omitted, if no AJAX operations are performed.</br></br>
                  * When specified as an object, it should contain the following two properties:
                  * <ul>
                  *  <li>type</li>
                  *  <li>url</li>
                  * </ul>
                  *<pre class="prettyprint">
                  *<code>
                  *"ajax" : {
                  *           "type": "GET",
                  *           "url":   "my_url"      // some url to the content
                  *          }
                  *</code></pre>
                  * <code class="prettyprint">"url"</code> may also be specified as a function which should return
                  * a url string:
                  *</br>
                  *<pre class="prettyprint">
                  *<code>
                  *"ajax" : {
                  *           "type" : "GET",
                  *           "url":   function (node) {
                  *                         ... return a url string ...
                  *                     }
                  *          )
                  *</code></pre>
                  * </br>
                  *  where  <span class="code-caption">node</span> is a parent node (can be used for lazy loading), or -1 to
                  *  indicate the initial tree load.
                  * </br></br>
                  *  Optionally, <span class="code-caption">success</span> and <span class="code-caption">error</span>
                  *  functions may be defined. If the <span class="code-caption">success</span> function returns a
                  *  value, it will be used to populate the tree; this can be useful if there is a need to transform
                  *  the data returned by a server at the client before it is displayed in the tree.
                  * </br></br></br>
                  *
                  * Note: to enable lazy loading of a parent node, specify that it has children but do not define them.
                  * When it is opened, data() or ajax() will be called with the node whose JSON is to be returned.</br></br>
                  *@example <caption>Example 1: Skeleton outline of success and error functions</caption>
                  *<code>
                  *"ajax": {
                  *          "type":"GET",
                  *          "url": myurl    &lt;-- url to full tree JSON
                  *          "success" : function(data, status, obj) {
                  *                        // data   = the JSON data
                  *                        // status = "success"
                  *                        // obj    = the AJAX object.
                  *                        trace("Ajax " + status) ;
                  *                        // return the data, can transform it first if required.
                  *                        // if no return value, the data is used untransformed.
                  *          },
                  *          "error" : function(reason, feedback, obj) {
                  *                        // reason e.g. "parsererror"
                  *                        // feedback.message  e.g. "unexpected string"
                  *                        // obj    = the AJAX object.
                  *                        trace("Ajax error " + reason + " feedback=" + feedback.message) ;
                  *          },
                  * </code>
                  *
                  *@example <caption>Example 2:  Load the complete tree from locally defined JSON.</caption>
                  *<code>
                  *"data" :  [
                  *            { 
                  *             "title": "Home",
                  *             "attr": {"id": "home"},
                  *            },
                  *            { 
                  *              "title": "News",
                  *              "attr": {"id": "news"}
                  *            },
                  *            { 
                  *              "title": "Blogs",
                  *              "attr": {"id": "blogs"},
                  *              "children": [ { 
                  *                             "title": "Today",
                  *                             "attr": {"id": "today"}
                  *                            },
                  *                            { 
                  *                              "title": "Yesterday",
                  *                              "attr": {"id": "yesterday"}
                  *                            }
                  *                          ]
                  *            }
                  *          ]
                  *</code>
                  *
                  *@example <caption>Example 3:  Load the complete tree with remotely served JSON.</caption>
                  *<code>
                  *"data" : {
                  *            "ajax": {
                  *                     "type":"GET",
                  *                     "url": myurl    <-- url to full tree JSON
                  *                    }
                  *           
                  *          }  
                  *</code>
                  *
                  *@example <caption>Example 4:  Load the complete tree with remotely served JSON via a function.</caption>
                  *<code>
                  *"data" : {
                  *           
                  *           "ajax": {
                  *                     "type":"GET",
                  *                     "url": function() {
                  *                               return (a url) ;
                  *                            }
                  *                   }
                  *           
                  *          }  
                  * </code>
                  *
                  *@example <caption>Example 5:  Load a partial tree, and retrieve node data when a parent node is expanded and needs to be populated.</caption>
                  *<code>
                  *"data" : {
                  *           "ajax": {
                  *                     "type":"GET",
                  *                     "url": function(node) {
                  *                             if (node === -1) {                       // -1 indicates initial load
                  *                               return (url for for  partial json) ;   // the tree outline with parent nodes empty.
                  *                             }
                  *                             else {
                  *                               var id = node.attr("id") ;
                  *
                  *                               return (a url based on the node id to retrieve just the node children) ; 
                  *                             }
                  *                           }
                  *                   }
                  *           
                  *          }
                  *</code>
                  *
                  *@example <caption>Example 6:  Transform data received from server before passing to ojTree.</caption>
                  *<code>
                  *"data" : {
                  *           "ajax": {
                  *                     "type":"GET",
                  *                     "url": function(node) {
                  *                              . . .
                  *                            },
                  *                      "success" : function (data)  {
                  *                                    . . .    // transform the received data into node JSON format
                  *
                  *                                    return (transformed data) ;
                  *                                  },
                  *                      "error" : function () {
                  *                                   // ajax call failed.
                  *                                }
                  *                   } 
                  *           
                  *          }
                  *</code>
                  *
                  * @example <caption>Example 7:  Use own mechanism to load a partial tree and retrieve node data when a parent is expanded.</caption>
                  * <code>
                  * // Sample outline of a tree.  Note that the parent nodes "Node2" and "Node3" have
                  * // their "children" property specifed, but no children are actually defined.
                  *
                  *{
                  *  "title" : Node1",
                  *  "attr" : {"id" : "n1"}
                  *},
                  *{
                  *  "title" : Node2",
                  *  "attr" : {"id" : "n2"},
                  *  "children" : []
                  *},
                  *{
                  *  "title" : Node3",
                  *  "attr" : {"id" : "n3"},
                  *  "children" : []
                  *},
                  *
                  *
                  *"data" : {
                  *           "data": function(node, fn) {
                  *                     // node  =  the node whose children are to be retrieved
                  *                     // fn    =  the function to call with the retrieved node json 
                  *
                  *                     if (node === -1) {             // initial tree load
                  *                       fn( acquired node json for the tree) ;
                  *                     }
                  *                     else {                         // node lazy load
                  *                       var id = node.attr("id") ;   // get the node id, will be "n2" 
                  *                                                    // or "n3", in this example.  
                  *                       fn( acquired node json for the expanded node ) ;
                  *                     }
                  *                  }
                  *           
                  *          }
                  *}
                  * </code>
                  * When an <span class="code-caption">option</span> call is made to reset the <span class="code-caption">data</span> property
                  * of a tree, the application does not need to call <span class="code-caption">refresh</span>.
                  * @type {Object | Array | string | null}
                  * @default <code class="prettyprint">null</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                data : null,

                /**
                 * The text to display when there are no data in the Tree. If not specified, 
                 * default text is extracted from the resource bundle.  Specify an empty string if
                 * this default behavior is not required.
                 * 
                 * @expose 
                 * @memberof! oj.ojTree
                 * @instance
                 * @type {string|null}
                 * @default <code class="prettyprint">"No data"</code>
                 * 
                 * @example <caption>Initialize the tree with text set to 'no data':</caption>
                 * $( ".selector" ).ojTree({ "data":data, "emptyText": "no data" });
                 */
                emptyText: null,

                //  Themes

                /**
                  * Specifies whether node icons are to be displayed.  Specify <span class="code-caption">true</span>
                  * to display icons, or <span class="code-caption">false </span> to suppress node icons.
                  * @type {boolean}
                  * @default <code class="prettyprint">true</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                icons : true,

                /*
                 *  Specifies whether hierarchy lines between nodes are displayed.
                 *  // not exposed in V1
                 */
                //dots" : false,


                /**
                  * The <span class="code-caption">'types'</span> option allow nodes to be classified and their appearance
                  * and behavior modified.</br></br>
                  * Typical uses are to define a specific icon for a particular node, or to inhibit certain
                  * operations on a particular type of folder (e.g. the root node cannot be deleted or moved).
                  * <p>
                  * A node <span class="code-caption">type</span> has the following properties:
                  * <ul>
                  *   <li><span class="code-caption">"image"</span> -  specifies the location of the icon to be used
                  *         (optional). May also be specified as <span class="code-caption">false</span> to suppress
                  *         the image.</br></br></li>
                  *   <li><span class="code-caption">"position"</span> - position of sprite in the image in the format 
                  *        <span class="code-caption">"left top"</span>, e.g. "-36px -16px".</br>
                  *        Optional - omit if icon is not contained within a multi-sprite image.</br></br></li>
                  *   <li><span class="code-caption">method name</span> - specify a function or a
                  *         boolean. Optional.</br>  Any node operation method (that
                  *         is, takes a node as its first argument) can be redefined (e.g. <span class="code-caption">select</span>,
                  *         <span class="code-caption">expand</span>, <span class="code-caption">collapse</span>, etc). 
                  *         Alternatively, the method can be defined as <span class="code-caption">true</span> or 
                  *         <span class="code-caption">false</span> to permit or inhibit the operation, or a
                  *         function that returns a boolean value. The default value
                  *         if omitted is <span class="code-caption">true</span> (i.e. the operation is permitted).</li>
                  * </ul>
                  * In the following example, three node types have been defined: <span class="code-caption">"myroot"</span>,
                  * <span class="code-caption">"myfolder"</span>, and <span class="code-caption">"myleaf"</span>.
                  * Any node that does not have one of these types defaults its behavior to the default type
                  * (whose properties can also be redefined).  The default <span class="code-caption">"default"</span>
                  * node type has no restrictions on the operations that can be performed on the node. In the following
                  * example, a modification to the default type properties have been made.  Also, for the
                  * <span class="code-caption">"myroot"</span> node type, the standard <span class="code-caption">select</span>,
                  * <span class="code-caption">remove</span> and <span class="code-caption">move</span> operations return false
                  * which inhibts those operations.
                  * been redefined to be no-ops.
                  * @example <caption>Example 1:  Add custom appearance and node behavior.</caption>
                  * <code>
                  *"types": {
                  *            "myroot" :   {
                  *                            "image"  : baseurl + "/img/root.png",
                  *                            "select" : function() { return false; },
                  *                            "remove" : function() { return false; },
                  *                            "move" :   function() { return false; },
                  *                         },
                  *            "myfolder" : {
                  *                            "image" : baseurl + "/img/folder.png"
                  *                         },
                  *            "myleaf" :   {
                  *                           "image" : "baseurl + "/img/leaf.png"
                  *                         },
                  *            "default" : {   <-- optional redefinition of the default behavior
                  *                           "image" : "baseurl + "/img/leaf.png",
                  *                           "remove" : function() { return false; }
                  *                        }
                  *
                  *          }
                  *}
                  *</code>
                  * User-defined types are specified as an attribute of the node.  The default
                  * node type attribute is <span class="code-caption">"type"</span>, but this could be changed if desired using
                  * the <span class="code-caption">"attr"</span> property. Thus, for the node types in example 1 above, the node
                  * type attribute values in the node definitions could be set as in example 2:
                  * @example <caption>Example 2:  Using node types in the tree JSON.</caption>
                  * <code>
                  *[
                  *   {                                    
                  *     "title": "Root",
                  *     "attr": {
                  *               "id": "root",                       
                  *               "type": "myroot"                      &lt;--- node type 
                  *             },
                  *     "children": [
                  *                   {
                  *                     "title": "Home",
                  *                     "attr": {"id": "home",
                  *                              "type": "myleaf"}      &lt;--- node type
                  *                   },
                  *                   { 
                  *                     "title": "News",
                  *                     "attr": {
                  *                               "id": "news",
                  *                               "type": "myleaf"      &lt;--- node type
                  *                             }
                  *                   },
                  *                   { 
                  *                     "title": "Blogs",
                  *                     "attr": {
                  *                               "id": "blogs",
                  *                               "type": "myfolder"    &lt;--- node type
                  *                             },
                  *                     "children": [ {
                  *                                     "title": "Today",
                  *                                     "attr": {
                  *                                               "id": "today",
                  *                                               "type": "myleaf"
                  *                                             }
                  *                                   },
                  *                                   {                 &lt;--- default node type
                  *                                     "title": "Yesterday",
                  *                                     "attr": {"id": "yesterday"}
                  *                                   }
                  *                                 ]
                  *                   }
                  *                 ] 
                  *  }
                  *]
                  *</code>
                  * As described above, the node type attribute used on the corresponding tree
                  * &lt;li&gt; element defaults to <span class="code-caption">"type"</span>, but this can be redefined using the <span class="code-caption">attr</span>
                  * property as in the following example:
                  * @example <caption>Example 2:  Using node types in the tree JSON.</caption>
                  * <code>
                  *"types": {
                  *           "attr" : "mytype",    &lt;--- node type attribute is now "mytype"
                  *           "types": {
                  *                      "myroot" : {
                  *                                   "image" : . . .
                  *                                    . . .
                  *                                 }
                  *          }
                  *</code>
                  * @type {Object | null}
                  * @default <code class="prettyprint">true</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                types: null,


                //---------------------------//
                //   Option Event callbacks  //
                //---------------------------//

				/**
				  * Triggered prior to an event.<p>
                  * The following events can be vetoed during <code class="prettyprint">before</code> event processing by returning
                  * </code>false</code> from the <code class="prettyprint">before</code> event handler (omitting a return value or 
                  * returning <code class="prettyprint">true</code> permits the event processing to continue): 
                  * <code class="prettyprint">collapse</code>, <code class="prettyprint">expand</code>, 
                  * <code class="prettyprint">hover</code>, <code class="prettyprint">select</code>, 
                  * <code class="prettyprint">remove</code>, <code class="prettyprint">rename</code>.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {string} ui.func the event causing this <code class="prettyprint">before</code> event to be triggered.
				  * @property {Object} ui.item the node that is the subject of the event
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">before</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "before": function(event, ui)  {
				  *                                       console.log("Before event " + ui.func);
				  *               }
				  * });
			      *
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojbefore</code> event:</caption>
				  * $( ".selector" ).on( "ojbefore", function( event, ui ) {
				  *                                       console.log("Before event " + ui.func);
				  *                                  });
				  */
				before : null,

				/**
				  * Triggered when a tree node is collapsed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been collapsed
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">collapse</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "collapse": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapse</code> event:</caption>
				  * $( ".selector" ).on( "ojcollapse", function(event, ui) {. . .}
				  *                    );
				  */
				collapse : null,

				/**
				  * Triggered when a tree node has been created and added to the tree.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been created
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">create</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "create": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
				  * $( ".selector" ).on( "ojcreate", function(event, ui) {. . .}
				  *                    );
				  */
				create : null,

				/**
				  * Triggered when all nodes of a parent node, or the complete tree, have been collapsed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node(s) that were collapsed.
				  * @property {Object} ui.targ the node that was targeted for collapseAll, or -1 if the complete tree is collapsed.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">collapseAll</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "collapseAll": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapseall</code> event:</caption>
				  * $( ".selector" ).on( "ojcollapseall", function( event, ui ) {. . .} );
				  */
				collapseAll : null,

				/**
				  * Triggered when a tree node has been cut from the tree via the context menu.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that was cut
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">cut</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "cut": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcut</code> event:</caption>
				  * $( ".selector" ).on( "ojcut", function( event, ui ) {. . .} );
				  */
				cut : null,

				/**
				  * Triggered when a tree node is no longer hovered over.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that is no longer hovered over
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">dehover</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "dehover": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdehover</code> event:</caption>
				  * $( ".selector" ).on( "ojdehover", function( event, ui ) {. . .} );
				  */
				dehover : null,

				/**
				  * Triggered when a tree node has been removed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been removed.
				  * @property {Object} ui.parent the parent of the node that was removed.
				  * @property {Object} ui.prev the previous sibling, or if ui.item is the first child of
				  *                    its parent, the parent node.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">remove</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "remove": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojremove</code> event:</caption>
				  * $( ".selector" ).on( "ojremove", function( event, ui ) {. . .} );
				  */
				remove : null,

				/**
				  * Triggered when a tree node is deselected.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has become de-selected.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">deselect</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "deselect": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdeselect</code> event:</caption>
				  * $( ".selector" ).on( "ojdeselect", function( event, ui ) {. . .} );
				  */
				deselect : null,

				/**
				  * Triggered when all nodes of a parent node, or the complete tree, have been de-selected.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node(s) that have become de-selected.
				  * @property {Object} ui.targ the context node that was targeted for deselectAll, or -1 if the complete tree is deselected.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">deselectAll</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "deselectAll": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdeselectall</code> event:</caption>
				  * $( ".selector" ).on( "ojdeselectall", function( event, ui ) {. . .} );
				  */
				deselectAll : null,

				/**
				  * Triggered when a tree is destroyed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">destroy</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "destroy": function( event, ui ) {}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdestroy</code> event:</caption>
				  * $( ".selector" ).on( "ojdestroy", function( event, ui ) {} );
				  */
				destroy : null,

				/**
				  * Triggered when a tree node is expanded.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been expanded
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">expand</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "expand": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
				  * $( ".selector" ).on( "ojexpand", function( event, ui ) {. . .} );
				  */
				expand : null,

				/**
				  * Triggered when all nodes of a parent node, or the complete tree, have been expanded.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node(s) that were expanded.
				  * @property {Object} ui.targ the node that was targeted for expandAll, or -1 if the complete tree is collapsed.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">expandAll</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "expandAll": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpandall</code> event:</caption>
				  * $( ".selector" ).on( "ojexpandall", function( event, ui ) {. . .} );
				  */
				expandAll : null,

				/**
				  * Triggered when a tree node is hovered over.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that is hovered over
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">hover</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "hover": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojhover</code> event:</caption>
				  * $( ".selector" ).on( "ojhover", function( event, ui ) {. . .} );
				  */
				hover : null,

				/**
				  * Triggered when a tree has been loaded and the node data has been applied.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">loaded</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "loaded": function( event, ui ) {}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojloaded</code> event:</caption>
				  * $( ".selector" ).on( "ojloaded", function( event, ui ) {} );
				  */
				loaded : null,

				/**
				  * Triggered when a tree node has been moved within the tree.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that was moved
				  * @property {string} ui.position the moved node's new position relative to the reference node.
				  *                    Can be "before", "after", or "inside".
				  * @property {Object} ui.reference the reference node that ui.position refers to.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">move</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "move": function(event, ui) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojmove</code> event:</caption>
				  * $( ".selector" ).on( "ojmove", function(event, ui) {. . .} );
				  */
				move : null,

                /**
                  * Fired whenever a supported component option changes, whether due to user interaction
                  * or programmatic intervention.  If the new value is the same as the previous value, no
                  * event will be fired.
                  *
                 * Currently there is one supported option, <code class="prettyprint">"selection"</code>.  Additional
                  * options may be supported in the future, so listeners should verify which option is changing
                  * before taking any action.
                  *
                  * @expose
                  * @event
				  * @memberof! oj.ojTree
                  * @instance
                  * @property {Event} event <code class="prettyprint">jQuery</code> event object
                  * @property {Object} ui Parameters
                  * @property {string} ui.option the name of the option that is changing
                  * @property {Object} ui.previousValue the previous value of the option
                  * @property {Object} ui.value the current value of the option
                  * @property {Object} ui.optionMetadata information about the option that is changing
                  * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
                  *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
                  *
                  */
                 optionChange: null,

				/**
				  * Triggered when a tree node has been pasted into the tree via the context menu.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that was pasted
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">paste</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "paste": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojpaste</code> event:</caption>
				  * $( ".selector" ).on( "ojpaste", function( event, ui ) {. . .} );
				  */
				paste : null,

				/**
				  * Triggered when a tree node, or the complete tree, has been refreshed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been refreshed, or -1 if the whole tree has been refreshed.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">refresh</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "refresh": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojrefresh</code> event:</caption>
				  * $( ".selector" ).on( "ojrefresh", function( event, ui ) {. . .} );
				  */
				refresh : null,

				/**
				  * Triggered when a tree node has been renamed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been renamed
				  * @property {string} ui.title the new node text title.
				  * @property {string} ui.prevTitle the node title prior to the rename.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">rename</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "rename": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojrename</code> event:</caption>
				  * $( ".selector" ).on( "ojrename", function( event, ui ) {. . .} );
				  */
				rename : null,

				/**
				  * Triggered when a tree node is selected.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been selected.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">select</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "select": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
				  * $( ".selector" ).on( "ojselect", function( event, ui ) {. . .} );
				  */
				select : null

     },   // end options


     /*---------------*/
     /* Public API's  */
     /*---------------*/

     /** Collapses an expanded node, so that its children are not visible.  Triggers a "collapse" event.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, or a selector
       *                        pointing to the element to be collapsed.
       * @param {boolean=} skipAnim - Set to true to suppress node collapse animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     collapse : function(node, skipAnim)
     {
        var t    = this,
            dur  = skipAnim? 0 : (this.options["animDuration"] || 0);

        node = this._getNode(node);

        if (!node.length || node === -1 || !node.hasClass(OJ_EXPANDED) ||
                            this._data.core.locked || node.hasClass(OJ_DISABLED))  {
          return false;
        }

        var rslt = this._emitEvent({"obj" : node, "func" : "collapse"}, "before") ;
        if (typeof rslt == "boolean" && (!rslt)) {
          return ;
        }

        if (skipAnim || dur)  {
          node.children("ul").attr("style","display:block !important");
        }
        node.removeClass(OJ_EXPANDED).addClass(OJ_COLLAPSED).attr(WA_EXPANDED, "false");
        $(node.children()[0]).removeClass(OJ_SELECTED).addClass("oj-default") ;

        if (skipAnim || dur ) {
          node.children("ul").stop(true, true)
                             .slideUp(dur, function ()
                                           {
                                             this.style.display = "";
                                             t["after_close"](node);
                                           });
        }
        else   {
          t["after_close"](node);
        }
        this._emitEvent({ "obj" : node }, "collapse");
     },


     /** Collapses a node and all its descendants.  Triggers a "collapseall" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, or a
       *                       selector pointing to the element whose descendants are to be collapsed. 
       *                       If omitted , or set to -1, all nodes in the tree are collapsed.
       * @param {boolean=} anim - Set to true (or omit) if all nodes are to collapsed with animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is true.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
     */
     collapseAll : function(node, anim)
     {
        var origTarg = node? node : -1 ;
        var _this = this;

        if (this._data.core.locked) {
          return ;
        }

        node = node ? this._getNode(node) : this._$container;
        if (node && origTarg !== -1) {
          origTarg = node ;
        }
        if (!node || origTarg === -1)  {
          node = this._$container_ul;
        }

        if (node.hasClass(OJ_DISABLED)) {
          return ;
        }

        var subject ;
        if (origTarg !== -1 && this["isExpanded"](node)) {
          subject = node[0] ;
        }

        var objs  =  node.find("li.oj-expanded") ;     // find child nodes that are open
        if (objs.length)  {
          objs.each(function ()  {
                        _this["collapse"](this, !anim);
                    });
        }

        if (subject) {                               // if subject node is also expanded
          this["collapse"](subject, !anim) ;         // include it in the list
          objs.splice(0, 0, subject) ;
        }

        if (objs.length) {
          this._emitEvent({ "obj" : objs, "targ" : origTarg }, "collapseAll");
        }
     },


     /** Expands a collapsed parent node, so that its children are visible. Triggers an "expand" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be expanded.
       * @param {boolean=} skipAnim - Set to true to suppress node expansion animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     expand : function(node, skipAnim)
     {
        this._expand(node, false, skipAnim) ;
     },

     /** May be used as a getter of setter.  If no argument is supplied, the method returns an
       * array of nodes currently expanded. (An empty array implies that no nodes are expanded.)  
       * If an array of nodes is supplied as an argument, the specified nodes are expanded.
       * @param {Array=} nodes - Omit to use as a getter, or specify an array of nodes to be
       *                 expanded.  Nodes may be defined as elements, id strings, jQuery wrapped nodes, or
       *                 selectors pointing to the elements to be expanded.
       * @param {boolean=} skipAnim - Set to true to suppress node expansion animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is false.
       * @return {Object | null} A jQuery wrapped array of nodes if used as a getter, else null
       *                        if used as a setter.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     expanded : function(nodes, skipAnim)
     {
        var exlr,
            exlen,
            _this = this;

        if (nodes && $.type(nodes) === "array")  {    // setter

          if (this._data.core.locked) {
            return null ;
          }

          exlen = nodes.length ;
          $.each(nodes, function (i, val) {
                          _this._expand(val, false, skipAnim); 
          });
          return null ;
        }
        else  {     // getter

          nodes = this._$container_ul.find("li.oj-expanded");
          exlen  = nodes.length ;
          exlr   = [] ;
          for (var n = 0; n < exlen; n++)  {
            exlr.push(nodes[n]);
          };
          return $(exlr) ;
        }
     },


     /** Expands a node and all its descendants.  Triggers an "expandall" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node,
       *                        or a selector pointing to the element whose descendants are to be expanded.
       *                        If omitted , or set to -1, all nodes in the tree are expanded.
       * @param {boolean=} anim - Set to true (or omit) if all nodes are to expanded with animation (assuming
       *                        option property "animDuration" is greater than zero). Default is true.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     expandAll : function(node, anim)
     {
        this._expandAll(node, anim) ;
     },

     /** Expands a node if collapsed, or collapses a node if expanded. Triggers an "expand" or "collapse" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be expanded/collapsed.
       * @param {boolean=} skipAnim - Set to true to suppress node expand/collapse animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     toggleExpand : function (node, skipAnim)
     {
        node = this._getNode(node);
        if (node === -1) {
          return ;
        }
        if (node.hasClass(OJ_DISABLED) || this._data.core.locked) {
          return ;
        }

        if (node.hasClass(OJ_COLLAPSED))  {
          return this["expand"](node, skipAnim);
        }
        if (node.hasClass(OJ_EXPANDED))  {
          return this["collapse"](node, skipAnim);
        }
     },


     /** Deselects a node. Triggers a "deselect" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be deselected.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     deselect : function (node)
     {
       node = this._getNode(node);
       if (!node.length)  {
         return false;
       }
       if (node.hasClass(OJ_DISABLED) || this._data.core.locked) {
         return ;
       }

       if (this["isSelected"](node))  {
         node.children("a").removeClass(OJ_SELECTED);
         node.removeAttr(WA_SELECTED);
         this._data.ui.selected = this._data.ui.selected.not(node);

         if (this._data.ui.last_selected.get(0) === node.get(0))  {
            this._data.ui.last_selected = this._data.ui.selected.eq(0);
         }

         this._emitEvent({ "obj" : node }, "deselect");
       }
       this._maintainSelected(node, false) ;      // ensure options list of selections is correct

     },


     /** Deselects all selected nodes. If optional argument "context" is specified, only the selected
       * nodes within that context will be selected. Triggers a "deselectall" event.
       * @param {HTMLElement | Object | string=} context - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to an element within the tree.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     deselectAll : function(context)
     {
       if (this._data.core.locked) {
         return ;
       }

       this._deselectAll(context, false) ;
     },

     /** Selects a node. Triggers a "select" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                       or a selector pointing to the element to be selected.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     select : function (node)
     {
        this._select(node) ;
     },


     /** Selects a node if deselected, or deselects a node if selected. Triggers a "select" or "deselect" event.
       * 
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be expanded/collapsed.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     toggleSelect : function (node)
     {
        node = this._getNode(node) ;
        if (!node.length)  {
           return false;
        }

        if (node.hasClass(OJ_DISABLED) || this._data.core.locked) {
          return ;
        }

        if (this["isSelected"](node))  {
          this["deselect"](node);
        }
        else  {
          this._select(node, true);
        }
     },

     /** Returns true if the node is collapsed, else false.
       *
	   * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
	   *                        or a selector pointing to the element.
       * @return {boolean} true if the node is collapsed, else false.
       * @expose 
       * @public
       * @instance
 	   * @memberof! oj.ojTree 
       */
     isCollapsed : function(node)
     {
       node = this._getNode(node);
       return node && node !== -1 && node.hasClass(OJ_COLLAPSED);
     },

     /** Returns true if the node is expanded, else false.
       *
	   * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
	   *                        or a selector pointing to the element.
       * @return {boolean} true if the node is expanded,  else false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     isExpanded : function(node)
     {
       node = this._getNode(node);
       return node && node !== -1 && node.hasClass(OJ_EXPANDED);
     },

     /** Returns true if the node is a leaf node (that is, it has no children), else false.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @return {boolean} true if the node is a leaf node, else false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     isLeaf : function(node)
     {
       return this._isLeaf(node) ;
     },

     /** Returns true if the node is selected, else false.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @return {boolean} true if the node is selected,  else false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     isSelected : function(node)
     {
       return this._data.ui.selected.index(this._getNode(node)) >= 0;
     },


     /** Creates a new node and adds it to the tree.  Triggers a createnode" event.
       *
       * @param {HTMLElement | Object | string} refnode - specifies the node that the new node will be
       *                       placed in, or next to, depending on the "position" argument. Can be a
       *                       DOM element, a jQuery wrapped node, or a selector pointing to the element.
       * @param {string | number} position - specifies the position of the newly created node in relation
       *                       to the "refnode" specified by the first argument.  Can be a string : "before",
       *                       "after", "inside", "first",, "last", or a zero-based index to position the
       *                       new node at a specific point among the childfren of "refnode".
       * @param {Object} data - An object literal containing data to create the new node.  The object properties
       *                       are:<br>
       *                       "attr" - an object of attribute name/value pairs (at least an "id" property should
       *                       be defined).<br>
       *                       "title" - a string used for the visible text of the node.<br><br>
       * <code>
       * var new Node = { "title" : "My Title", "attr" : { "id": "myid" } };
       * </code>
       * @return {Object} Returns the jQuery wrapped node created from the 'data' parameter.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     create : function(refnode, position, data)
     {
        return this._create_node(refnode, position, data);
     },

     /**  Removes a node. Triggers a "remove" event.
       *
       *  @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       *  @return {Object | boolean}   The jQuery wrapped node used as an argument.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */ 
     remove : function(node)
     {
       node = this._getNode(node);
       if (!node.length) {
         return false;
       }

       if (node.hasClass(OJ_DISABLED) || this._data.core.locked) {
         return false;
       }

       var rslt = this._emitEvent({"obj" : node, "func" : "remove"}, "before") ;
       if (typeof rslt == "boolean" && (!rslt)) {
         return false ;
       }

       this.__rollback();
       var p    = this._getParent(node),
           prev = $([]),
           t = this,
           sib = this._getPrev(node) ;

       node.each(function () {
           prev = prev.add(t._getPrev(this));
       });

       node = node.detach();

       if (p !== -1 && p.find("> ul > li").length === 0)  {
         p.removeClass("oj-expanded oj-collapsed")
          .addClass(OJT_LEAF)
          .removeAttr(WA_EXPANDED);
       }

       this._clean_node(p);
       this._emitEvent({ "obj" : node, "prev" : sib, "parent" : p }, "remove");
       return node ;
     },


     /** Returns the title of the specified node
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                       or a selector pointing to the element.
       * @return {string | boolean} The text string title of the node.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getText : function(node)
     {
       node = this._getNode(node) ;
       if (!node.length) {
          return false;
       }

       var ht = this._data.core.htmlTitles;
       node = node.children("a:eq(0)");

       if (ht)  {
          node = node.clone();
          node.children("INS").remove();
          return node.html();
       }
       else  {
//       node = node.contents().filter(function()
//                             {
//                               return this.nodeType == 3;
//                             })[0];
//       return node.nodeValue;
         node = node.find("span:eq(0)") ;
         return node[0].textContent;
       }

     },

     /** Renames a node title.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @param {string=} text - The new text string.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     rename : function(node, text)
     {
       this._rename_node(node, text) ;
     },

     /** Sets the specifed node as the current node of interest (e.g. a mouse-over).  Triggers a "hover" event.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     hover : function(node)
     {
       node = this._getNode(node);
       if (! node.length)  {
         return false;
       }

       if (node.hasClass(OJ_DISABLED) || this._data.core.locked) {
         return ;
       }

       var rslt = this._emitEvent({"obj" : node, "func" : "hover"}, "before") ;
       if (typeof rslt == "boolean" && (!rslt)) {
         return ;
       }

       this._data.core.initFocus = true ;              // if mouse-over, no default first focus required

       //if(this.data.ui.hovered && node.get(0) === this.data.ui.hovered.get(0)) { return; }
       if (! node.hasClass(OJ_HOVER))  {
          this["dehover"]();
       }

       this._data.ui.hovered = node.children("a").addClass(OJ_HOVER).parent();
       this._$container_ul.attr(WA_ACTIVEDESCENDANT, this._data.ui.hovered.attr("id")) ;
       this._fix_scroll(node);
       this._emitEvent({ "obj" : node }, "hover");
     },


     /** Removes the "hover" state of the currently hovered node.  Triggers a "dehover" event.
       *
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     dehover : function()
     {
       var obj = this._data.ui.hovered,
            p;
       if (!obj || !obj.length) {
         return false;
       }

       if (obj.hasClass(OJ_DISABLED) || this._data.core.locked) {
         return ;
       }

       p = obj.children("a").removeClass(OJ_HOVER).parent();
       this._$container_ul.removeAttr(WA_ACTIVEDESCENDANT) ;

       if(this._data.ui.hovered[0] === p[0]) { 
           this._data.ui.hovered = null;
       }
       this._emitEvent({ "obj" : obj }, "dehover");
     },

     /** Returns the full path to a node, either as an array of ID's or node names, depending on
       * the value of the "idMode" argument.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                       or a selector pointing to the element.
       * @param {boolean=} idMode - Set to true (or omit) to return ID's from the node attribute
       *                       "id"), or false to return the names (i.e. text titles).  Default is true.
       *
       * @return {Array | boolean} An array of node ID's or names.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getPath : function(node, idMode)
     {
        var p     = [],
            _this = this;

        node = this._getNode(node);
        if (node === -1 || !node || !node.length)  {
          return false;
        }

        node.parentsUntil(".oj-tree", "li").each(function () {
               p.push( idMode ? this.id : _this["getText"](this) );
        });

        p.reverse();
        p.push( idMode ? node.attr("id") : this["getText"](node) );

        return p;
      },

     /** Returns the jQuery wrapped top outer &lt;ul&gt; element of the tree.
       *
       * @return {Object} The jQuery wrapped &lt;ul&gt; element of the tree.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getRoot : function()
     {
        return this._$container.children("ul:eq(0)");    // return the top <ul>
     },

     /**  Refreshes the tree or a node.
       *
       *  @param {HTMLElement | Object | string | number=} node - If -1 is specified (or the argument is omitted),
       *                   the whole tree is refreshed.  Alternatively, a specific node to be refreshed can be
       *                   supplied. Can be a DOM element, a jQuery wrapped node, or a selector pointing to the element.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     refresh : function(node)
     {
       this._super() ;

        if (this._data.core.locked) {
          return ;
        }

       this._refresh(node) ;
     },


     /**  Moves a tree node.
       *
       *  @param {HTMLElement | Object | string | number} node  The node to be moved. Can be a DOM element,
       *            a jQuery wrapped node, or a selector pointing to the element.
       *  @param {HTMLElement | Object | string | number} refnode  The reference node for the move. Can be
       *            a DOM element, a jQuery wrapped node, or a selector pointing to the element. If -1 is 
       *            specified, the container element is used.
       *  @param {string | number} position  The position of the moved node relative to the reference node refnode.
       *            Can be "before", "after", "inside", "first", "last", or the zero-based index to position the node at a
       *            specific point among the reference node's current children.
       *  @param {boolean=} iscopy  Specify false for a move operation, or true for a copy.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     move : function(node, refnode, position, iscopy)
     {
        this._move_node(node, refnode, position, iscopy);
     },

     /**
       *  Returns the user classified node type applied to the node in the
       *  <span class="code-caption">"types"</span> option. 
       *  @return {string |boolean}  The node's type. If no types have been defined in the tree options,
       *                             false is returned.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     getType : function(node)
     {
         return this._getType(node) ;
     },

     /**
       *  Sets the "type" attribute of the node.
       *  @return {boolean}  true if the change was successful, else false. 
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     setType : function(node, str)
     {
         return this._setType(node, str) ;
     },

     /**
       * Returns the subcomponent node element represented by the locator object subId property.</br>
       * 
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       * @param {Object} locator An Object containing at minimum a "subId" property whose value is a string.<p>
       * The general format of a subId string is: &nbsp; &nbsp; &nbsp; <span class="code-caption">"oj-tree-node['node id']['request']"</span> 
       * <table style="border-collapse:collapse;border:1px solid"><tr style="background-color:#eee"><th>Request</th><th>Description</th></tr>
       *  <tr><td><em>"icon"</em></td><td>Returns the &lt;ins&gt; element for the node icon.</td></tr>
       *  <tr><td><em>"disclosure"</em></td><td>Returns the &lt;ins&gt; element for the disclosure (expand/collapse)
       *                                           icon of a parent node.</td></tr>
       *  <tr><td><em>"link"</em></td><td>Returns the &lt;a&gt; element for the node. </td></tr>
       *  <tr><td><em>"title"</em></td><td>Returns the &lt;span&gt; element for the node's title text. </td></tr>
       * </table>
       * @return {Element|null} the subcomponent element located by the subId string passed in locator, or null if not found.<p>
       */
     getNodeBySubId: function(locator)
     {
        if (! locator)  {
          return this.element ? this.element[0] : null;
        }

        return this._processSubId(locator)
     },


     /**
       * Returns the parent node of the node specified.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @return {Object | null}   The jQuery wrapped parent node, or null if <span class="code-caption">node</span>
                                   is a top level node.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getParent : function (node)
     {
        var l = this._getParent(node) ;
        return (l && l.length > 0)? l : null ;
     },

     /**
       * Returns the previous sibling of the node specified.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @return {Object | null}   The jQuery wrapped sibling node, or null if there is no previous sibling.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getPrevSibling : function (node)
     {
        var l = this._getPrev(node, true) ;
        return  (l && l.length > 0)? l : null ;
     },

     /**
       * Returns the next sibling of the node specified.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @return {Object | null}   The jQuery wrapped sibling node, or null if there is no next sibling.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getNextSibling : function (node)
     {
        var l = this._getNext(node, true) ;
        return (l && l.length>  0)? l : null ;
     },

     /**
       * Returns the children of the node specified.
       * @param {HTMLElement | Object | string | number} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element. May also be specified as -1 or omitted to
       *                        indicate the tree, in which case the top level children of the tree are returned.
       * @return {Object | null}   The jQuery wrapped array of child nodes, or null if there are no children.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getChildren : function (node)
     {
        node = node? node : -1 ;
        var l = this._getChildren(node) ;
        return (l && l.length > 0)? l : null ;
     },

     /**
       *  Removes the Tree from the DOM.  If the tree was constructed from
       *  original user &lt;ul&gt;  markup defined in the Tree's containing &lt;div&gt;, this
       *  markup is reinstated.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     destroy : function ()
     {
        this._emitEvent({ "obj" : -1}, "destroy"); 
        this._super() ;
     },


     //-----------------------------------------//
     //     Internal API's and data             //
     //-----------------------------------------//


     /**
       *  Called the first time the widget is called on an element.
       *  @private
       */
     _ComponentCreate: function ()
     {
        this._super() ;

        this._index         = this._newIndex() ;                    // index for this instance
        _aInstances.push(this) ;
        this._elemId        = this.element.attr("id") ;             // tree element id
        if (this._elemId === undefined) {
          this._elemId = "oj-tree-" + this._getIndex() ;
          this.element.attr("id", this._elemId) ;
        }
        this._elemId        = "#" + this._elemId ;

        this._$container    = $(_sanitizeSelector(this._elemId)) ;  // the containing <div>
        this._$container_ul = null ;                                // the containing <ul>
        this._data          = {} ;                                  // working data
        this._tds           = null ;                                // Tree DataSource
        this._isRtl         = this._GetReadingDirection() === "rtl";
        this._initTree() ;
     },

     /**
       *  Widget is being destroyed.
       *  @private
       */
     _destroy : function()
     {
        this._clearTree() ;    // Clean out the DOM.  After this, the tree markup has
                               // been removed from the div, and all event handlers
                               // removed.

        // If the tree was constructed from existing user markup found in the div,
        // reinstate that markup to reset the div to its original state pre tree create.
        if (this._data.html.markup_ul) {
          this._$container.append(this._data.html.markup_ul) ;
          this._data.html.markup_div.remove() ;
          this._data.html.markup_div        = false ;
          this._data.html.useExistingMarkup = false ;
        }

        this._data.ds.type = DS_NONE ;
        this._super() ;
     },


     /**
       *  Handle an option change.
       *  Called by $(selector).ojtree("options", "prop", value)
       *  @private
       */
     _setOption: function (key, newval, flags)
     {
        var _this = this ;
        var prev  = this.options[key] ;
        var val ;

        if (key === "selection") {
          this._super(key, newval, flags);
          this._handleSelectionOptionChange() ;
          this._fireOptionChange(key, prev, newval, null) ;
          return ;
        }
        else if (key === "selectionMode") {
          if (newval === "none") {
            val = 0 ;
          }
          else if (newval === "single") {
            val = 1;
          }
          else if (newval === "multiple") {
            val = -1 ;
          }
          else {
            val = 0 ;
            newval = "none"
          }
          if (val != _this._data.core.selectMode) {
            _this._data.core.selectMode = val ;
          }
        }
        else if (key === "icons") {
           if ($.type(newval) == "boolean") {
             if (newval != _this._data.themes.icons) {
               _this._data.themes.icons = newval ;
               newval? _this._showIcons() : _this._hideIcons() ;
             }
           }
        }                                // end "core/ui" options
        else if (key === "contextMenu") {
           this._clearMenu() ;
           if (newval) {  
             this._initMenuOpts() ;
             this._initMenu(newval) ;
           }
        }                                // end "contextMenu"
        else if (key === "disabled")  {
           this._handleDisabledChanged(newval) ;
        }                            // end "disabled"
        else if (key === "data") {    //TDO
          this._super(key, newval, flags);
          this._initDSOpts() ;
          this._initDataSource();
          this._initExpandedOpts() ;    // reset the nodes to be initially expanded
          this._loadNodes() ;           // start node loading from the datasource
          return ;                      // super has already been called
        }
        else if (key === "dnd") {
          this._super(key, newval, flags);
          this._initDnDOpts();
          return ;                     // super has already been called
        }
        this._super(key, newval, flags);
     },

     /**
       *  Clears out the tree dom
       *  @private
       */
     _clearTree : function()
     {
        var  n = this._getIndex();

        this._$container
            .unbind(".oj-tree")
            .undelegate(".oj-tree")
            .removeData("oj-tree-instance-id")
            .find("[class^='oj-tree']")
            .addBack()
            .attr("class", function ()
                    {
                      return this["className"].replace(/oj-tree[^ ]*|$/ig,'');
                    });

        var cl = this._$container.attr("class") ;      // if jQuery has left us with a
        cl = cl.trim();                                // class of blanks, remove it.
        if (cl.length === 0) {
          this._$container.removeAttr("class") ;
        }

        _removeKeyFilter(this._$container_ul) ;        // remove keyboard listener because
                                                       // _$container_ul will be removed
        $(document)
            .unbind(".oj-tree-" + n)
            .undelegate(".oj-tree-" + n);

        // Remove the constructed tree from the DOM.
        this._$container_ul.remove() ;
        this._$container_ul = null ;
     },

     /*
       *  Returns a jQuery wrapped tree node.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If -1 is used
       *  (indicating the whole tree), -1 is returned.
       *  @private
       */
/*                                           Not used in V1
     _getNodeCore : function(obj) 
     {
         var $obj = $(obj, this._$container); 

         if ($obj.is(".oj-tree") || obj == -1)  {
            return -1;
         } 
         $obj = $obj.closest("li", this._$container);
         return $obj.length ? $obj : false; 
     },
*/


     /**
       *  Returns a jQuery wrapped tree node.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If obj is -1
       *  (indicating the whole tree), -1 is returned.
       *  @private
       */
     _getNode :  function (obj, allow_multiple)
     {
       if (typeof obj === "undefined" || obj === null) {
         return allow_multiple ? this._data.ui.selected : this._data.ui.last_selected;
       }

       var $obj = $(obj, this._getContainer()); 

       if ($obj.is(".oj-tree") || obj === -1) {
          return -1;
       } 

       $obj = $obj.closest("li", this._getContainer()); 
       return $obj.length ? $obj : false; 
     },

     /**
       *  Returns the node previous to the supplied obj.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If -1 is used
       *  (indicating the whole tree), -1 is returned.  If arg strict is true, only immediate
       *  siblings are considered, else if the obj has no previous siblings (i.e is the first
       *  child of its parent), the parent is returned.
       *  @private
       */
     _getPrev  : function (obj, strict)
     {
        obj = this._getNode(obj);
        if (obj === -1) {
          return this._$container.find("> ul > li:last-child");
        }
        if (!obj.length) {
          return false;
        }
        if (strict) {
         return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false;
        }

        if (obj.prev("li").length) {
            obj = obj.prev("li").eq(0);
            while (obj.hasClass(OJ_EXPANDED)) {
               obj = obj.children("ul:eq(0)").children("li:last");
            }
           return obj;
        }
        else {
           var o = obj.parentsUntil(".oj-tree","li:eq(0)");
           return o.length ? o : false;
        }
     },

     /**  Returns the node after the supplied obj.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If -1 is used
       *  (indicating the whole tree), -1 is returned.  If arg strict is true, only immediate
       *  siblings are considered, else if the obj has no more siblings (i.e is the last
       *  child of its parent), the parent's next sibling is returned.
       *  @private
       */
     _getNext  : function (obj, strict)
     {
        obj = this._getNode(obj);
        if (obj === -1)  {
          return this._$container.find("> ul > li:first-child");
        }
        if (!obj.length) {
           return false;
         }
        if (strict)  {
           return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false;
        }
        
        if (obj.hasClass(OJ_EXPANDED))  {
          return obj.find("li:eq(0)");
        }
        else if(obj.nextAll("li").size() > 0)  {
          return obj.nextAll("li:eq(0)");
        }
        else  {
           return obj.parentsUntil(".oj-tree","li").next("li").eq(0);
        }
     },


     /**
       *  Returns the parent node of the supplied obj.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.
       *  child of its parent), the parent is returned.
       *  @private
       */
     _getParent  : function (obj)
     {
        obj = this._getNode(obj);
        if (obj == -1 || !obj.length)  {
          return false;
        }
        var o = obj.parentsUntil(".oj-tree", "li:eq(0)");
        return o.length ? o : -1;
     },

     /**
       *  Returns the child nodes of the supplied obj, or false if no children or failure.
       *  obj can be a selector pointing to an element within the tree, a DOM node, or a
       *  jQuery wrapped node.  obj can be -1 to indicate the whole tree.
       *  @private
       */
     _getChildren   : function (obj)
     {
        obj = this._getNode(obj);
        if (obj === -1) {
          return this._$container.children("ul:eq(0)").children("li");
        }
        if (!obj.length) {
          return false;
        }
        return obj.children("ul:eq(0)").children("li");
     },

     _isLeaf : function(node)
     {
       node = this._getNode(node) ;
       return node && node !== -1 && node.hasClass(OJT_LEAF);
     },

     /**
       *  Returns the widget instance for the supplied node.  Not currently used.  TDO
       *  @private
       */
     _reference : function(node)
     {
        var div  = node.parents("div").eq(0) ;

        return this ;
     },

     /**
       *  Add default values to options, unless already defined in options.
       *  @private
       */
     _applyDefaults :  function(to, from)
     {
        if (to != undefined && from != undefined)  {
          $.each(from, function(prop, val) {
                                             if (to[prop] == undefined) {
                                               to[prop] = val ;
                                             }  
                                            });
        }
     },

     /**
          Handle change of the disabled option
       *  @private
       */
     _handleDisabledChanged  : function(newval)
     {
        var curState  = this._$container_ul.hasClass(OJ_DISABLED) ;
        if (! curState) {
          curState = false ;      // in case undefined
        }

        if (typeof newval === "undefined")  {
          return ;
        }

        if (curState != newval) {
          if (newval) {
            this._$container_ul.addClass(OJ_DISABLED) ;
            this._$container_ul.prop("disabled", "disabled");
          }
          else {
            this._$container_ul.removeClass(OJ_DISABLED) ;
            this._$container_ul.removeAttr("disabled");
          }
//          this._lock(newval) ;
          this._treeDisable(newval) ;
        }
     },

     /**
       *  @private
       */
     _treeDisable : function (lstate) {

        lstate = lstate || false ;
        if (lstate) {
          this._data.core.locked = true;
          this._data.ui.opacity  = this._$container.children("ul").css("opacity") ;
          this._$container_ul.addClass(OJ_DISABLED).css("opacity","0.9");
        }
        else {
          this._data.core.locked = false;
          this._$container_ul.removeClass(OJ_DISABLED).css("opacity", this._data.ui.opacity);
        }
//      this._emitEvent({});
     },


     /**
       *  Handles a change to the selected option array. Nodes currently selected that are not
       *  in the new array are deselected.  Nodes in the new array become (or stay) selected.
       */
     _handleSelectionOptionChange : function()
     {
        var newval = this.options["selection"] ;
        var cur    = [] ;
        var _this  = this ;

        // Convert the new array to the same format (i.e. node id's) as the
        // maintained "selection" option array.
        $.each(newval, function(i, node) {
                          node = _this._getNode(node) ;
                          if (node && node.length === 1) {
                            cur.push("#" + node.attr("id")) ;
                          }
                      });         // note: any invalid node specifications are dropped

        //  Deselect any currently selected nodes that are not in the new array.
        var aSelected = this._getSelected() ;
        $.each(aSelected, function(i, node) {
                            if ($.inArray($(node).attr("id"), cur) < 0)  {
                              _this["deselect"](node) ;        // this will also downdate the
                            }                                  // options "selection" array
                          }) ;

        //  Select all nodes in the new selection array and update the options "selection" array.
        this._setSelected(cur) ;
     },


     /**
       *  Creates a "move" object containing details of the impending move, and
       *  stores it in this._data.core.prepared_move
       *
       *  The object contains :
       *     .o   the node being moved
       *     .r   the reference node
       *     .p   the destination position relative to the reference node
       *     .np  the new parent
       *     .oc  the original node if there was a copy
       *     .cy  boolean indicating if the move was a copy
       *     .op  the former parent
       *     .or  the node that was previously in the position of the moved node
       *     .ot  the original tree instance
       *     .rt  the reference tree instance
       *     .cr  same as .np but if a root node is created this is -1
       *
       *   @private
       */
     _prepare_move :  function (o, r, pos, cb, is_cb)
     {
       var p = {};
             
       p.ot =  this;
       p.o  = p.ot._getNode(o);
       p.r  = r === - 1 ? -1 : this._getNode(r);
       p.p = (typeof pos === "undefined" || pos === false) ? "last" : pos; // TODO: move to a setting

       if (!is_cb && this._data.core.prepared_move.o && this._data.core.prepared_move.o[0] === p.o[0] 
                                                     && this._data.core.prepared_move.r[0] === p.r[0]
                                                     && this._data.core.prepared_move.p    === p.p)  {
          this._emitEvent(this._data.core.prepared_move);
          if (cb)  {
            cb.call(this, this._data.core.prepared_move);
          }
          return;
       }

       p.ot = this;
       p.rt = this; // r === -1 ? p.ot : $.jstree._reference(p.r) || this
 
       if (p.r === -1 || !p.r)  {
         p.cr = -1;

         switch(p.p)
         {
            case "first":
            case "before":
            case "inside":
                           p.cp = 0; 
                           break;
            case "after":
            case "last":
                           p.cp = p.rt._$container.find(" > ul > li").length; 
                           break;
            default:
                           p.cp = p.p;
                           break;
         }
       }
       else {
         if (!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
           return this._load_node(p.r, function ()
                                                    {
                                                      this._prepare_move(o, r, pos, cb, true);
                                                    });
         }
          switch(p.p)
          {
             case "before":  p.cp = p.r.index();
                             p.cr = p.rt._getParent(p.r);
                             break;
             case "after":   p.cp = p.r.index() + 1;
                             p.cr = p.rt._getParent(p.r);
                             break;
             case "inside":
             case "first":
                             p.cp = 0;
                             p.cr = p.r;
                             break;
             case "last":
                             p.cp = p.r.find(" > ul > li").length; 
                             p.cr = p.r;
                             break;
             default: 
                             p.cp = p.p;
                             p.cr = p.r;
                             break;
          }
       }

       p.np  = p.cr == -1 ? p.rt._getContainer() : p.cr;
       p.op  = p.ot._getParent(p.o);
       p.cop = p.o.index();

       if (p.op === -1)  {
         p.op = p.ot ? p.ot._$container : this._$container;
       }
       if (!/^(before|after)$/.test(p.p) && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp)
       {
         p.cp++;
       }

       //if(p.p === "before" && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp--; }
       p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
       this._data.core.prepared_move = p;
       this._emitEvent(this._data.core.prepared_move, "prepare_move");
       if (cb) {
         cb.call(this, this._data.core.prepared_move, "prepare_move");
       }
     },


     "check_move" : function ()
     {
       var obj  = this._data.core.prepared_move,
           ret  = true,
           r ;

       r = obj.r === -1 ? this._$container : obj.r;

       if ((!obj) || (!obj.o) || obj.or[0] === obj.o[0]) {
         return false;
       }
       if (!obj.r) {        // tdo, why is r is false when we use jquery simulate drag
         return false ;
       }

       if (!obj.cy) {
         if (obj.op && obj.np && obj.op[0] === obj.np[0] && obj.cp - 1 === obj.o.index())  { 
           return false;
         }
         obj.o.each(function ()
                    { 
                      if (r.parentsUntil(".oj-tree", "li").addBack().index(this) !== -1)  {
                        ret = false; return false;
                      }
                    });
       }

       return ret;
     },

     /**
       *  Changes the text title of a node
       *  @private
       */
     _rename_node : function(node, text)
     {
       var  t ;

       node = this._getNode(node);
       this.__rollback();
       t  = this["getText"](node) ;

       if (node && node.length) {
          var rslt = this._emitEvent({"obj"  : node,
                                      "func" : "rename",
                                      "title" : text,
                                      "prevTitle": t}, "before") ;
          if (typeof rslt == "boolean" && (!rslt)) {
            return ;
          }
       }

       if (node && node.length && this._set_text.apply(this, Array.prototype.slice.call(arguments)))  {
         this._emitEvent({ "obj" : node, "title" : text, "prevTitle" : t}, "rename");
       }
     },

     /**
       *   Moves a node within the tree
       *   @private
       */ 
     _move_node : function (obj, ref, position, is_copy, is_prepared, skip_check)
     {
        if ((obj.hasClass && obj.hasClass(OJ_DISABLED)) || this._data.core.locked) {
          return ;
        }

        if (!is_prepared)  { 
          return this._prepare_move(obj, ref, position, function (p)
                                                        {
                                                          this._move_node(p, false, false,
                                                                          is_copy, true, skip_check);
                                                        });
        }
        if (is_copy) { 
          this._data.core.prepared_move.cy = true;
        }
        if (!skip_check && !this["check_move"]())  {
          return false;
        }

        this.__rollback();
        var o = false;

        if (is_copy)  {
           o = obj.o.clone(true);
           o.find("*[id]").addBack().each(function () {
                                             if (this.id) {
                                               this.id = "copy_" + this.id;
                                             }
                                         });
        }
        else   {
          o = obj.o;
        }

        if (obj.or.length)  {
          obj.or.before(o);
        }
        else   { 
           if (!obj.np.children("ul").length)  {
             $("<ul />").appendTo(obj.np);
           }
           obj.np.children("ul:eq(0)").append(o); 
        }

        try { 
               obj.ot._clean_node(obj.op);
               obj.rt._clean_node(obj.np);
               if (!obj.op.find("> ul > li").length)  {
                obj.op.removeClass("oj-expanded oj-collapsed")
                      .removeAttr(WA_EXPANDED)
                      .addClass(OJT_LEAF)
                      .children("ul")
                      .remove();
               }
        } catch (e) { }

        if (is_copy)  { 
           this._data.core.prepared_move.cy = true;
           this._data.core.prepared_move.oc = o; 
        }
        var d = $.extend(true, {}, this._data.core.prepared_move) ;
        d["obj"] = obj.o ;  
//Fri28 this._emitEvent(this._data.core.prepared_move, "move");
        this._emitEvent(d, "move");
        return this._data.core.prepared_move;
     },


      /**
        *  Returns the "move" object created by a previous _prepare_move()
        *
        *  The object contains :
        *     .o   the node being moved
        *     .r   the reference node
        *     .p   the destination position relative to the reference node
        *     .np  the new parent
        *     .oc  the original node if there was a copy
        *     .cy  boolean indicating if the move was a copy
        *     .op  the former parent
        *     .or  the node that was previously in the position of the moved node
        *     .ot  the original tree instance
        *     .rt  the reference tree instance
        *     .cr  same as .np but if a root node is created this is -1
        *
        *  @private
        */
      _getMove  : function ()
      {
         return this._data.crrm.prepared_move;
      },


      /**
        *  Returns the "type" attribute of the node.  If not found, returns "default"
        *  @private
        */
      _getType : function (node)
      {
        var n = null ;
        var t = this.options["types"];             // are types defined?

        if (t) {
          n = this._getNode(node);
        }
        return (!n || !n.length) ? false : n.attr(this.options["types"]["attr"]) || "default";
      },

      /**
        *  Sets the "type" attribute of the node.
        *  @return {boolean}  true if the change was successful, else false. 
        *  @private
        */
      _setType : function (str, node)
      {
         var  s   = this.options["types"], 
              ret = false ;

         node = this._getNode(node);

         if (s) {
           ret = (!node.length || !str) ? false : node.attr(this.options["types"]["attr"], str);
         }
         else {
           ret = false ;
         }

         if (ret)  {
           this._emitEvent({ "obj" : node, "type" : str}, "settype"); 
         }
         return ret;
      },


      /**
        *  @private
        */
      _check : function (rule, obj, opts)
      {
         obj = this._getNode(obj);

         var v     = false,
             ty    = this._getType(obj),
             d     = 0,
             _this = this,
             s     = this._getOptions()["types"],
             data  = false;

             if (obj === -1) { 
               if (!!s[rule])  {
                 v = s[rule];
                }
               else  {
                 return;
               }
             }
             else   {
               if (ty === false)  {
                 return;
               }

               data = this._data.types.defaults["useData"] ? obj.data("oj-tree") : false;
               if (data && data["types"] && typeof data["types"][rule] !== "undefined")  {
                 v = data["types"][rule];
               }
               else if(!!s["types"][ty] && typeof s["types"][ty][rule] !== "undefined") {
                   v = s["types"][ty][rule];
               }
               else if(!!s["types"]["default"] && typeof s["types"]["default"][rule] !== "undefined")  {
                   v = s["types"]["default"][rule]; }
               }

               if ($.isFunction(v))  {
                   v = v.call(this, obj);
               }

               var md = this._data.types.defaults["maxDepth"] ;

               if (rule === "maxDepth" && obj !== -1 && opts !== false && this._data.types.defaults["maxDepth"] !== -2 && v !== 0)  {
                 // also include the node itself - otherwise if root node it is not checked
                 obj.children("a:eq(0)").parentsUntil(".oj-tree","li").each(function (i)
                        {
                           // check if current depth already exceeds global tree depth
                           if ((md !== -1) && (md - (i + 1) <= 0))  {
                             v = 0;
                             return false;
                           }

                           d = (i === 0) ? v : _this._check(rule, this, false);

                           // Check if current node max depth is already matched or exceeded
                           if (d !== -1 && d - (i + 1) <= 0)  {
                             v = 0; return false;
                           }

                           // otherwise - set the max depth to the current value minus current depth
                           if (d >= 0 && (d - (i + 1) < v || v < 0) )  {
                             v = d - (i + 1);
                           }

                           // If the global tree depth exists and it minus the nodes calculated
                           // so far is less than `v` or `v` is unlimited
                           if ((md >= 0) && (md - (i + 1) < v || v < 0) )  {
                             v = md - (i + 1);
                           }
                        });
               }

               return v;
     },


      /**
        * Applies all necessary classes to the node and its desendants.
        * obj can be a node, or -1 to clean the whole tree.
        * @private
        */
      _clean_node  : function (obj)
      {
         obj = obj && obj != -1 ? $(obj) : this._$container_ul;
         obj = obj.is("li") ? obj.find("li").addBack() : obj.find("li");

         obj.removeClass(OJT_LAST)
            .addClass(OJT_NODE)
            .addClass(OJ_DRAGGABLE)
            .filter("li:last-child")
            .addClass(OJT_LAST)
            .end()
            .filter(":has(li)")
            .not(".oj-expanded")
            .removeClass(OJT_LEAF)
            .addClass(OJ_COLLAPSED)
            .attr(WA_EXPANDED, "false");

         obj.not(".oj-expanded, .oj-collapsed")     // clean leaf nodes
            .addClass(OJT_LEAF)
            .children("ul")
            .remove();

         var nodes = obj.find("li"),         // clean the node and disclosure icon <ins> 's
             disc,
             t ;
         $.each(obj, function (i, val) {
                 t = $(this) ;
                 disc = t.find("> ins") ;
                 if (disc.length > 1) {
                   disc = $(disc[0]) ;
                 }
                 if (t.hasClass(OJT_LEAF)) {
                   disc.removeClass(OJ_DISC);
                   disc.addClass(OJT_ICON);
                 }
                 else {
                   disc.addClass(OJ_DISC);
                   disc.removeClass(OJT_NICON);
                 }
         }) ;

         this._emitEvent({ "obj" : obj }, "clean_node");
      },


      /**
        *  Creates a new node
        *  @private
        */
      _create_node :  function (obj, position, js, callback, is_loaded)
      {
         obj = this._getNode(obj);
         if (obj !== -1 && !obj.length) {
           return false;
         }

         var ht   = this._data.core.htmlTitles ;
         position = (typeof position === "undefined") ? "last" : position;

         var d = $("<li />"),
             s = this.options,
             tmp;

         if (!is_loaded && !this._is_loaded(obj)) {
           this._load_node(obj, function () 
                               {
                                 this._create_node(obj, position, js, callback, true);
                               });
           return false;
         }
           
         this.__rollback();
           
         if (typeof js === "string") {
            js = { "data" : js };
         }
         if (!js) {
            js = {};
         }
         if (js["attr"])  {
           d.attr(js["attr"]);
         }
         if (js["metadata"]) {
           d.data(js["metadata"]);
         }
         if (js["state"]) {
           d.addClass("oj-tree-" + ((js["state"] === "expanded")? "open" : "closed"));
         }
         if (!js["data"]) {
           js["data"] = (js["title"] !== undefined)? js["title"] :
                                                     this.getTranslatedString("m_newnode");
         }
           
         if (!$.isArray(js["data"]))  {
           tmp = js["data"];
           js["data"] = [];
           js["data"].push(tmp);
         }

         var _this = this ;
         var sp ;
         $.each(js["data"], function (i, m) {
             tmp = $("<a tabindex='-1' />");
             if ($.isFunction(m)) {
                m = m.call(this, js);
             }
             sp = $("<span class='" + OJT_TITLE + "'>") ;
             if (typeof m == "string")  {
               sp[ht? "html" : "text"](m) ;
               tmp.attr("href", "#");
             }
             else  {
               if (! m["attr"])  {
                  m["attr"] = {};
               }
               if (! m["attr"]["href"])  {
                  m["attr"]["href"] = '#';
               }
               sp[ht? "html" : "text"](m["title"]) ;
               if (m["language"]) {
                 tmp.addClass(m["language"]);
               }
             }
             tmp.append(sp) ;
             tmp.prepend("<ins class='oj-tree-icon oj-tree-node-icon'>&#160;</ins>");

             if (!m["icon"] && js["icon"]) {
               m["icon"] = js["icon"];
             }
             if (m["icon"]) { 
               if (m["icon"].indexOf("/") === -1)  {
                  tmp.children("ins").addClass(m["icon"]);
               }
               else  {
                  tmp.children("ins").css("background","url('" + m["icon"] + "') center center no-repeat");
               }
             }
             d.append(tmp);
         });

         d.prepend("<ins class='" + OJ_DISC + "'>&#160;</ins>");
         if (obj === -1) {
           obj = this._$container;
           if (position === "before")  {
             position = "first";
           }
           if (position === "after") {
             position = "last";
           }
         }

         switch(position)
         {
           case "before":  obj.before(d);
                           tmp = this._getParent(obj);
                           break;
           case "after" :  obj.after(d);
                           tmp = this._getParent(obj);
                           break;
           case "inside":
           case "first" :  if (!obj.children("ul").length) {
                            obj.append("<ul />");
                           }
                           obj.children("ul").prepend(d);
                           tmp = obj;
                           break;
           case "last":    if (!obj.children("ul").length) {
                             obj.append("<ul />");
                           }
                           obj.children("ul").append(d);
                           tmp = obj;
                           break;
           default:        if (!obj.children("ul").length) {
                             obj.append("<ul />");
                           }
                           if (!position) {
                             position = 0;
                           }
                           tmp = obj.children("ul").children("li").eq(position);
                           if (tmp.length)  {
                             tmp.before(d);
                           }
                           else  {
                             obj.children("ul").append(d);
                           }
                           tmp = obj;
                           break;
         }

         if (tmp === -1 || tmp.get(0) === this._$container.get(0)) {
           tmp = -1;
         }
         this._clean_node(tmp);
         this._emitEvent({ "obj" : d, "parent" : tmp }, "create_node");

         if (callback) {
           callback.call(this, d);
         }

         return d;
      },


      /**
        *  Expands a collapsed node
        *  @private
        */
      _expand   : function (obj, callback, skipAnim)
      {
         obj = this._getNode(obj);
         if (! obj.length) {
           return false;
         }

         if (obj.hasClass(OJ_DISABLED) || this._data.core.locked) {
           return ;
         }

         if (! obj.hasClass(OJ_COLLAPSED))  {
           if (callback)  {
             callback.call();
           }
           return false;
         }

         var rslt = this._emitEvent({"obj" : obj, "func" : "expand"}, "before") ;
         if (typeof rslt == "boolean" && (!rslt)) {
           return ;
         }

         var dur  = skipAnim? 0 : (this.options["animDuration"] || 0),
             t    = this;

         if (! this._is_loaded(obj))  {
           obj.children("a").addClass("oj-tree-loading");
           this._load_node(obj, function () {
                                   t["expand"](obj, callback, skipAnim);
                                }, callback) ;
         }
         else    {
           if (this.options["expandParents"])  {
             obj.parentsUntil(".oj-tree", ".oj-collapsed").each(function ()
                                   {
                                     t["expand"](this, false, true);
                                    });
           }

           if (skipAnim || dur)  {
             obj.children("ul").css("display","none");
           }
           obj.removeClass(OJ_COLLAPSED).addClass(OJ_EXPANDED)
                                      .attr(WA_EXPANDED, "true")
                                      .children("a")
                                      .removeClass("oj-tree-loading");
           $(obj.children()[0]).removeClass(OJ_SELECTED).addClass("oj-default") ;

           if (skipAnim || dur)  {
             obj.children("ul").stop(true, true)
                               .slideDown(dur, function ()
                                              {
                                                this.style.display = ""; 
                                                t["after_open"](obj);
                                              });
           }
           else  {
              t["after_open"](obj);
           }

           this._emitEvent({"obj" : obj}, "expand");
           if (callback)  {
             callback.call();
           }
         }
    },


    /**
      *  Expands all collapsed nodes
      *  @private
      */
    _expandAll  : function (obj, do_animation, original_obj)
    {
      var origTarg = obj? obj : -1 ;

      obj = obj ? this._getNode(obj) : -1;
      if (!obj || obj === -1) {
        obj = this._$container_ul;
      }
      else {
        origTarg = obj ;
      }

      if (original_obj)  { 
        obj = obj.find("li.oj-collapsed");
      }
      else   {
        original_obj = obj;
        if (obj.is(".oj-collapsed"))
        {
          obj = obj.find("li.oj-collapsed").addBack();
        }
        else  {
          obj = obj.find("li.oj-collapsed");
        }
      }

      var _this = this;
      obj.each(function ()
           { 
             var __this = this; 

             if (!_this._is_loaded(this))   {
               _this["expand"](this, function()
                                     {
                                       _this._expandAll(__this, do_animation, original_obj);
                                     }, !do_animation);
             }
             else  {
               _this._expand(this, false, !do_animation);
             }
           });

      // so that callback is fired AFTER all nodes are open
      if (original_obj.find('li.oj-collapsed').length === 0)  {
        this._emitEvent({ "obj" : obj, "targ" : origTarg }, "expandAll");
      }
   },


    /**
      *  Selects a node. If "e" is not defined, the selection originated from an
      *  app API call and not via mouse action.
      *  @private
      */
    _select : function (node, check, e)
    {
       if (this._data.core.selectMode == 0) {
         return false ;
       }

       node = this._getNode(node);

       if (node == -1 || !node || !node.length)  {
         return false;
       }

       if (node.hasClass(OJ_DISABLED) || this._data.core.locked) {
         return ;
       }

       this._data.core.initFocus = true ;              // if click caused first focus, no default action
       var isSelected  = this["isSelected"](node) ;

       if (! isSelected) {
         var rslt = this._emitEvent({"obj" : node, "func":"select"}, "before") ;
         if (typeof rslt == "boolean" && (!rslt)) {
           return ;
         }
       }

       //  Establish whether the select should happen, and deselect where necessary.

       var s              = this.options ;
       var selMultMod     = this._data.ui.defaults["selectMultipleModifier"] ;   // to remove - not published
       var selRangeMod    = this._data.ui.defaults["selectRangeModifier"] ;      // not yet published
       var disSelChildren = this._data.ui.defaults["disableSelectingChildren"] ; // not yet published 
       var isMultiple     = (selMultMod == "on" || (selMultMod !== false && e && oj.DomUtils.isMetaKeyPressed(e))),           
           isRange        = ((selRangeMod !== false) && (e &&  (e[selRangeMod + "Key"]))  &&
                            this._data.ui.last_selected && this._data.ui.last_selected[0] !== node[0] &&
                            (this._data.ui.last_selected.parent()[0] === node.parent()[0])),
           proceed        = true,
           t              = this;

       if (check) {
          if (disSelChildren && isMultiple && 
              ((node.parentsUntil(".oj-tree","li").children("a.oj-selected").length) ||
               (node.children("ul").find("a.oj-selected:eq(0)").length)))  {
             return false;
          }
          proceed = false;
          switch(!0)  {
             case (isRange):
                 this._data.ui.last_selected.addClass("oj-tree-last-selected");
                 node = node[ node.index() < this._data.ui.last_selected.index() ? "nextUntil" : "prevUntil" ](".oj-tree-last-selected").addBack();

                 if (this._data.core.selectMode == -1 || node.length < this._data.core.selectMode)  {
                   this._data.ui.last_selected.removeClass("oj-tree-last-selected");
                   this._data.ui.selected.each(function ()
                                           {
                                              if (this !== t._data.ui.last_selected[0])  {
                                                t["deselect"](this);
                                              }
                                         });
                   isSelected = false;
                   proceed    = true;
                 }
                 else {
                   proceed = false;
                 }
                 break;

             case (isSelected && !isMultiple): 
                 if (! e) {                      // if via api, nothing to do - node is
                   break ;                       // already selected.
                 }
                 this["deselectAll"]();
                 if (!this._data.ui.spacebar) {  // only kbd toggles selected status
                   isSelected = false;
                 }
                 proceed = true;
                 break;

             case (! isSelected && !isMultiple): 
                 if (e) {                                         // if mouse click
                   if (this._data.ui.selected && (this._data.ui.selected.length == 1)) {
                     this["deselect"](this._data.ui.selected) ;  // clear the selection
                   }
                   else {
                     this["deselectAll"](this._data.ui.selected) ;  // clear all selections
                   }
                 }
                 else  //if (this._data.core.selectMode == -1 || this._data.core.selectMode > 0)  {
                       if (this._data.core.selectMode === 1)  {
                   this["deselect"](this._data.ui.selected) ;
                 }
                 else if (this._data.core.selectMode > 1)  {  // TDO check if the selected count will exceed the
                   this["deselectAll"]();                     // the selectMode count. Do we veto this select?
                 }
                 proceed = true;
                 break;

             case (isSelected && isMultiple): 
                 this["deselect"](node);
                 break;

             case (! isSelected && isMultiple): 
                 if ((this._data.core.selectMode == -1) ||
                     (this._data.ui.selected.length + 1 <= this._data.core.selectMode))  { 
                   proceed = true;
                 }
                 break;
          }
       }

       // Proceed with the selection

       if (proceed && !isSelected)  {
          if (!isRange)  {
            this._data.ui.last_selected = node;
          }
          node.children("a").addClass(OJ_SELECTED);
          node.attr(WA_SELECTED, "true");

          if (s["selectedParentExpand"])  {
             node.parents(".oj-collapsed").each(function () {
                                                   t["expand"](this, false, true);
                                            });
          }
          this._data.ui.selected = this._data.ui.selected.add(node);
          this._fix_scroll(node.eq(0));
          this._maintainSelected(node, true) ;                    // maintain the options list of selections
          this._emitEvent({ "obj" : node, "e" : e }, "select");
        }
     },


      /**
        *  Deselect all nodes.  Nodes can be deselected all together with a "deselectAll" event,
        *  or separately with "deselect" events.
        *  @private
        */
     _deselectAll : function(context, bSeparate)
     {
       if (this._data.core.locked) {
         return ;
       }

       if (! bSeparate) {
         var a ;
         var origTarg = context? context : -1 ;
         var ret = context ? $(context).find("a.oj-selected").parent() :
                             this._$container.find("a.oj-selected").parent();

         ret.not(".oj-disabled") ;
         if (ret.length === 0) {
           if (origTarg === -1) {
             a = this.options["selection"] ;     // bullet proofing
             while (a.length) {                  // ensure that selections
               a.pop() ;                         // really is empty.
             }
           }
           return ;                // nothing selected
         }

         ret.children("a.oj-selected").removeClass(OJ_SELECTED);
         ret.removeAttr(WA_SELECTED);

         var _this = this ;
         $.each(ret, function(i, n) {
                        _this._maintainSelected($(n), false) ;
                     }) ;
         this._data.ui.selected      = $([]);
         this._data.ui.last_selected = false;

         if (ret.length) {
           this._emitEvent({ "obj" : ret, "targ": origTarg}, "deselectAll");
         }
       }
       else {
         var origTarg = context? context : -1 ;
         var ret = context ? $(context).find("a.oj-selected").parent() :
                             this._$container.find("a.oj-selected").parent();

         ret.not(".oj-disabled") ;
         if (ret.length === 0) {
           return ;                // nothing selected
         }

         var _this = this ;
         $.each(ret, function() {
            _this["deselect"](this) ;     // deselect (also downdates the option selection array)
         }) ;
       }
     },


     /** Selects all nodes specified in array.
       * @param {Array}  nodes - an array of nodes to be selected.  Nodes may be defined as elements,
       *                         jQuery wrapped nodes, or selectors pointing to the elements to be selected.
       * @private
       */
     _setSelected : function(nodes)
     {
        if (this._data.core.locked) {
          return null ;
        }

        if (nodes && nodes.length > 0)  {
          var _this = this;
          $.each(nodes, function (i, val) {
            if (val)  {
              _this._select(val, true);
            }
          });
        }
     },


     /**  Maintain the options list of selections 
       *  @param {Object} node jQuery wrapped node ref
       *  @private
       */
     _maintainSelected : function (node, bAdd)
     {
         var  ar, i, id ;

         if (node) {
           ar = this.options["selection"] ;
           id = "#" + node.attr("id") ;

           if (bAdd) {
              //  Ensure node is in the list
              if ($.inArray(id, ar) < 0) {
                ar.push(id) ;
              }
           }
           else {
             //  Ensure node is not in the list
             i = $.inArray(id, ar) ;
             if (i >= 0) {
               ar.splice(i, 1) ;
             }
           }
        }
     },


     /**
       *  Handle hover over a disclosure icon-font
       *  @private
       */
     _disclosureHover : function(elem, bHover)
     {
        elem = $(elem) ;
        if (elem.hasClass(OJ_DISABLED) || this._data.core.locked) {
          return ;
        }

        var par     = elem.parent() ;
        var bOpen   = par.hasClass(OJ_EXPANDED) ;
        var bClosed = par.hasClass(OJ_COLLAPSED) ;
        if (bOpen || bClosed) {                    // only care about disclosure
          if (bHover) {                            // <ins>'s of a disclosable
            elem.addClass(OJ_HOVER) ;              // parent node.
            elem.removeClass("oj-default") ;
            elem.removeClass(OJ_SELECTED) ;
          }
          else {
            elem.removeClass(OJ_HOVER) ;
            elem.addClass("oj-default") ;
          }
       }
     },

     /**
       *  Placeholder for a more specific refresh action. It is replaced
       *  by refresh_json() for json_data, or _refresh_ui() for html_data.
       *
       *  Refreshes the tree - notes all open nodes, reloads them in the tree
       *  and then reopens the noted open nodes.
       *  @private
       */
     _refresh : function(node) {
        this._refresh_core(node) ;
     },


     /**
       *  Base _refresh action
       *  @private
       */
     _refresh_core : function(node)
     {
       var origTarg = node? node : -1 ;
       var _this    = this;
       
       this._save_opened();
       if (!node) {
          node = -1;
       }
       node = this._getNode(node);
       if (!node)  {
         node = -1;
       }
       else {
         origTarg = node
       }

       if (node !== -1)  {
         node.children("UL").remove();
       }
       else  {
         this._$container_ul.empty();
         this._processExistingMarkup() ;    // if existing markup, reprocess in case it changed
       }
       this._load_node(node, function ()
                           {
                             _this._emitEvent({ "obj" : origTarg}, "refresh");
                             _this._reload_nodes();
                            }
                      );
     },


     /**
       *  Ui _refresh action 
       *  @private
       */
     _refresh_ui : function (obj)
     {
        this["saveSelected"]();
//wed5  return this.__call_old();
        this._refresh_core(obj) ;
     },


    /**
      *  Emits an "after_open" event for internal use only.
      *  @private
      */
    "after_open"  : function (obj)
    { 
       this._emitEvent({ "obj" : obj }, "after_open");
    },


    /**
      *  Emits an internal "after_close" event for internal use only.
      *  @private
      */
    "after_close" : function (obj)
    { 
       this._emitEvent({ "obj" : obj }, "after_close");
    },


    /**
      *  Expand any nodes that have been specified to be expanded.
      *  Emits an internal "reopen" event.
      *  @private
      */
    _reopen : function ()
    {
       var _this = this;

       if (this._data.core.toExpand.length) {
         $.each(this._data.core.toExpand, function (i, val)
                                          {
                                             _this._expand(val, false, true); 
                                          });
       }
       this._emitEvent({}, "reopen");
     },


     /**
       *  Returns an array of currently selected nodes.
       *  @private
       */
     _getSelected : function (context)
     { 
         return context ? $(context).find("a.oj-selected").parent() : this._data.ui.selected ; 
     },


     /**
       *  Changes the text title of the node's <a>
       *  @private
       */
     _set_text  : function (obj, val)
     {
        obj = this._getNode(obj);
        if (!obj.length)  {
          return false;
        }

        obj = obj.children("a:eq(0)");
        if (this._data.core.htmlTitles)  {
           var tmp = obj.children("INS").clone();
           obj.html(val).prepend(tmp);
           this._emitEvent({ "obj" : obj, "name" : val }, "set_text");
           return true;
        }
        else
        {
//         obj = obj.contents().filter(function() {
//                                 return this.nodeType == 3;
//                              })[0];

           obj = obj.find("span:eq(0)") ;
           this._emitEvent({ "obj" : obj, "name" : val }, "set_text");
           return (obj[0].textContent = val);
        }
     },

     /**
       *  @private
       */ 
     _loadNodes : function()
     {              
        if (this._data.ds.type !== DS_NONE && this._data.ds.type !== DS_ERROR) {
          this._load_node(-1, function ()  {                  //  Construct and add the nodes
                                this._loaded();
                                this._reload_nodes();
                              });
        }
        else {
           this._applyEmptyText() ;     //  Use emptyText option if defined.
           this._loaded() ;
          }
      },


     /**
       *  @private
       */ 
     _load_node : function(obj, success_callback, error_callback)     // Dummy function overriden by data methods
     {
        this._emitEvent({ "obj" : obj }, "load_node");
     },


     /**
       *  Returns whether a node is current loaded. This is a dummy function
       *  overriden by data methods (such as_load_node_J()).
       *  @private
       */
     _is_loaded  : function (obj)                 // Dummy function overriden by data methods
     {
       return true;
     },


     /**
       *  TreeDataSource's _load_node
       *  @private
       */
     _load_node_DS : function (obj, s_call, e_call)
     {
        var _this = this;
        this._load_node_tree(obj, function ()  {
                                      _this._emitEvent({ "obj" : _this._getNode(obj) }, "load_node");
                                      s_call.call(this);
                                  }, e_call);
     },


     /**
       *   JsonTreeDataSource's _is_loaded()
       *   @return {boolean}
       *   @private
       */
     _is_loaded_DS : function (obj)
     { 
//     var s = this.options["data"]["json"];

       obj = this._getNode(obj); 

//     return (obj === -1 || !obj ) || (!s["ajax"] && !this._data.ds.progressiveRender && !$.isFunction(s["data"]))
       return (obj === -1 || !obj ) || obj.is(".oj-expanded, .oj-tree-leaf")
                                    || obj.children("ul").children("li").length > 0;
     },


     /**
       *   JsonTreeDataSource's _refreshDS
       *  @private
       */
     _refresh_DS  : function (obj)
     {
        obj = this._getNode(obj);

//      var s = this.options["data"]["json"];
//      if (obj && obj !== -1 && this._data.ds.progressiveUnload && ($.isFunction(s["data"]) || !!s["ajax"]))  {
        if (obj && obj !== -1)  {
          obj.removeData(OJT_CHILDREN);
        }
//Wed5  return this.__call_old();
        return this._refresh_ui(obj);
     },


     /**
       *  json_data's _load_node
       *  @private
       */
     _load_node_J : function (obj, s_call, e_call)
     {
        var _this = this;
        this._load_node_json(obj, function ()  {
                                      _this._emitEvent({ "obj" : _this._getNode(obj) }, "load_node");
                                      s_call.call(this);
                                  }, e_call);
     },

     /**
       *   json_data's _is_loaded()
       *   @private
       */
     _is_loaded_J : function (obj)
     { 
       var s = this.options["data"];

       obj = this._getNode(obj); 
       return obj == -1 || !obj || (!s["ajax"] && !this._data.ds.progressiveRender && !$.isFunction(s["data"]))
                        || obj.is(".oj-expanded, .oj-tree-leaf")
                        || obj.children("ul").children("li").length > 0;
     },


     /**
       *   html_data's _load_node
       *   @private
       */
     _load_node_H : function (obj, s_call, e_call)
     {
       var _this = this;
       this._load_node_html(obj, function ()  {
                                   _this._emitEvent({ "obj" : _this._getNode(obj)}, "load_node") ;
                                   s_call.call(this);
                                 }, e_call);
     },

     /**
       *  html_data's _is_loaded()
       *  @private
       */
     _is_loaded_H : function (obj)
     { 
       var s    = this.options["data"],
           data = null,
           ajax = null ;

      if (s) {
        data  = s["data"] || null ;
        ajax  = s["ajax"] || null ;
      }

       obj = this._getNode(obj); 

       return obj == -1 || !obj || (!ajax && !$.isFunction(data)) ||
                           obj.is(".oj-expanded, .oj-tree-leaf") || obj.children("ul").children("li").size() > 0;
     },

       
     //  Rselect nodes as of last savedSelected()
     "reselect" : function ()
     {
        var _this = this,
            s      = this._data.ui.to_select;

        s = $.map($.makeArray(s), function (n) {
                           return "#" + n.toString().replace(/^#/,"")
                                                    .replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
        // this.deselect_all(); WHY deselect, breaks plugin state notifier?
        $.each(s, function (i, val)
                   {
                      if (val && val !== "#")  {
                        _this["select"](val);
                      }
                   });

        this._data.ui.selected = this._data.ui.selected.filter(function ()
                                           {
                                             return this["parentNode"];
                                           });
        this._emitEvent(null, "reselect");
     },

     // Save selection state - see also reselect()
     "saveSelected" : function ()
     {
        var _this = this;

        this._data.ui.to_select = [];
        this._data.ui.selected.each(function ()
                  {
                    if (this.id) {
                      _this._data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); 
                     }
                  });
        this._emitEvent(this._data.ui.to_select, "savedselected");
     },


     /*
      *      Not documented
      */
     "rollback" : function (rb)
     {
        if (rb)  {
          if (!$.isArray(rb))  {
            rb = [ rb ];
          }
          $.each(rb, function (i, val)
                     {
//                       instances[val.i]["set_rollback"](val.h, val.d);     //TDO
                     });
        }
    },


    "get_rollback" : function ()
    { 
       this._emitEvent(null, "get_rollback");
       return {
                i : this._getIndex(),
                h : this._$container.children("ul").clone(true),
                d : this["data"]                    // TDO ???
              }; 
    },
           
    "set_rollback" : function (html, data)
    {
       if (this._$container && this._$container_ul)   {
         this._$container_ul.empty().append(html);
       }

       this["data"] = data;                       // TDO ???
       this._emitEvent(null, "set_rollback");
    },


    /*
     *  Load json for a particular node (or the whole tree)
     *  @private
     */
    _load_node_tree : function (obj, s_call, e_call)
    {
       var rslt = this._JsonDSToJson(obj) ;

       if (! rslt.success) {
         return ; // TDO
       }

       if (! rslt.js) {
         return ;       // TDO
       }

       var  bTree = ((! obj) || (obj === -1)) ;
       var  s     = this.options["data"] ;
       var  d ;

       if ((!!s["data"] && !s["ajax"]) || (!!s["data"] && !!s["ajax"] && bTree))  {
         if (bTree)  {
           d = this._parseJson(rslt.js, obj) ;
           if (d)  {
             this._$container_ul.empty().append(d.children());
             this._clean_node();
           }
           else  { 
              if (this._data.ds.correctState) {
                  this._$container_ul.empty();
               }
           }
         }
         if (s_call) {
            s_call.call(this);
         }
       }
       else if  ((!s["data"] && !!s["ajax"]) || (!!s["data"] && !!s["ajax"] && (! bTree))) {
          d = this._parseJson(rslt.js, obj);
          if (d)  {
            if (bTree)  {
              var $u =  this._$container_ul;
              $u.empty().append(d.children());
              $u.attr(WA_ROLE, WA_TREE).attr("tabindex", "0").css("outline", "none") ;
              if (this._data.core.selectMode === -1)  {
                $u.attr("aria-multiselectable", true) ;
              }
            }
            else  {
              obj.append(d).children("a.oj-tree-loading").removeClass("oj-tree-loading");
              obj.removeData("oj-tree-is-loading");
            }
   
            this._clean_node(obj);
            if (s_call)  {
              s_call.call(this);
            }
          }
          else  {
            if (bTree) {
              if (this._data.ds.correctState)  { 
                this._$container_ul.empty(); 
                if (s_call) {
                  s_call.call(this);
                }
              }
            }
            else  {
               obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
               obj.removeData("oj-tree-is-loading");
               if (s["correct_state"]) { 
                 this._correct_state(obj);
                 if (s_call)  {
                   s_call.call(this);
                 } 
               }
            }
          }
       }

     },


    /**
      * Process a JsonTreeDataSource to a Json array ready for parsing.
      * This is temporary - it assumes that all nodes are available in the Json;
      * that is, there is no lazy-loading.   TDO
      * @private
      * @return {Object} contains "success" (boolean) and "js" (the json nodes)
      */
     _JsonDSToJson : function (parentKey, node)
     {
        var arJson = [],
            ds     = this._tds,
            cc,
            range  = {},
            rslt   = {success : false, js : null} ;

        if (parentKey == -1) {
          parentKey = null ;
          range["start"] = 0 ;
        }
        else {
          // TDO
        }

        cc = ds.getChildCount(parentKey) ;   
        if (cc > 0) {
          range["count"] = cc ;
          ds.fetchChildren(parentKey, range,              // get the JsonNodeSet 
              {
                "success" : $.proxy(function(jns) {
                     var c = jns.getCount(),
                         attr,
                         n ;

                     for (var i = 0; i < c; i++) {
                        node = {} ;
                        attr = jns.getData(i) ;           // get the attribute list to be applied 
                        if (attr) {
                          node["attr"] = attr ;
                        }
                       node["title"] = jns.m_nodes[i]["title"] ;         // hack, wait for chadwick
                       if (attr.metadata) {
                         node["metadata"] = jns.m_nodes[i]["metadata"] ; // hack, wait for chadwick
                       }

                       var key  = node["attr"]["id"] ;

                       n = ds.getChildCount(key) ;
                       if (n > 0) {
                          var r = this._JsonDSToJson(key, node) ;
                          node["children"] = r.js ;
                       }

                       arJson.push(node) ;
                     }
  
                     rslt.success = true ;
                     rslt.js      = arJson ;
                   }, this),

                "error" :  function(status) {
                              rslt.success = false ;
                           }
              }) ;
        }
        return rslt ;
     },


     /**
       *  @private
       */
     _refresh_json  : function (obj)
     {
        obj = this._getNode(obj);

        if (this._data.core.locked) {
          return ;
        }

        var bTree = (!obj || obj !== -1 || !obj.length) ;
        if (!bTree && obj.hasClass(OJ_DISABLED)) {
          return ;
        }

        var s = this.options["data"]["json"];

        if (! bTree && this._data.ds.progressiveUnload && ($.isFunction(s["data"]) || !!s["ajax"]))  {
          obj.removeData(OJT_CHILDREN);
        }
//Wed5  return this.__call_old();
        return this._refresh_ui(obj);
     },


     /*
      *  Load json for a particular node (or the whole tree)
      *  @private
      */
     _load_node_json : function (obj, s_call, e_call)
     {
       var s = this._getOptions()["data"],        // work on a copy of the options to avoid
           d,                                     // endless loop in calling success/error funcs
           error_func   = function () {},
           success_func = function () {},
           data         = (s && s["data"]) || null,
           ajax         = (s && s["ajax"]) || null;

       if (s && !data && !ajax) {
         data = s ;                               // we just have data, no data() ajax() methods defined
       }

       obj = this._getNode(obj);

       if (obj && obj !== -1 && (this._data.ds.progressiveRender || this._data.ds.progressiveUnload)
                             && !obj.is(".oj-expanded, .oj-tree-leaf")
                             && obj.children("ul").children("li").length === 0 && obj.data(OJT_CHILDREN)) {
          d = this._parseJson(obj.data(OJT_CHILDREN), obj);
          if (d)  {
            obj.append(d);
            if (! this._data.ds.progressiveUnload) {
              obj.removeData(OJT_CHILDREN);
            }
          }

          this._clean_node(obj);
          if (s_call)  {
            s_call.call(this);
          }
          return;
       }

       if (obj && obj !== -1) {
         if (obj.data("oj-tree-is-loading"))  {
            return;
         }
         else  {
            obj.data("oj-tree-is-loading",true);
         }
       }

       switch (!0)
       {
          case (!data && !ajax) : throw "ojTree - neither data nor ajax settings supplied.";

          // function option added here for easier model integration (also supporting async - see callback)

          case ($.isFunction(data)):
                       data.call(this, obj, $.proxy(function (d) {
                           d = this._parseJson(d, obj);
                           if (!d) { 
                              if (obj === -1 || !obj)  {
                                if (this._data.ds.correctState)  {
                                  this._$container_ul.empty();
                                }
                              }
                              else  {
                                 obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                                 obj.removeData("oj-tree-is-loading");

                                 if (this._data.ds.correctState) {
                                   this._correct_state(obj);
                                 }
                              }
                              if (e_call) {
                                e_call.call(this);
                              }
                           }
                           else  {
                              if (obj === -1 || !obj)  {
                                 this._$container_ul.empty().append(d.children());
                              }
                              else  {
                                 obj.append(d).children("a.oj-tree-loading").removeClass("oj-tree-loading");
                                 obj.removeData("oj-tree-is-loading");
                              }
                              this._clean_node(obj);
                              if (s_call)  {
                                s_call.call(this);
                              }
                           }
                       }, this));
                       break;

          case (!!data && !ajax) || (!!data && !!ajax && (!obj || obj === -1)):

                       if (!obj || obj == -1)  {
                         d = this._parseJson(data, obj) ;
                         if (d)  {
                           this._$container_ul.empty().append(d.children());
                           this._clean_node();
                         }
                         else  { 
                            if (this._data.ds.correctState) {
                              this._$container_ul.empty();
                             }
                         }
                       }
                       if (s_call) {
                          s_call.call(this);
                       }
                       break;

          case (!data && !!ajax) || (!!data && !!ajax && obj && obj !== -1):

                       error_func = function (x, t, e)
                       {
                         var ef = this._getOptions()["data"]["ajax"]["error"];  // reget the options       
                         if (ef) {                                              // without our updated ajax
                           ef.call(this, t, e, x);                              // changes to avoid forever loop
                         }
                         if (obj != -1 && obj.length)  {
                            obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                            obj.removeData("oj-tree-is-loading");
                            if (t === "success" && this._data.ds.correctState)  {
                              this._correct_state(obj);
                            }
                         }
                         else   {
                           if (t === "success" && this._data.ds.correctState)  {
                             this._$container_ul.empty();
                           }
                         }
                         if (e_call)  {
                           e_call.call(this);
                         }
                       };

                       success_func = function (d, t, x)
                       {
                         var sf = this._getOptions()["data"]["ajax"]["success"];  // reget the options
                         if (sf) {                                                // without our updated ajax
                           d = sf.call(this, d, t, x) || d;                       // changes to avoid forever loop
                         }

                         if (d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "") || (!$.isArray(d) && !$.isPlainObject(d)))  {
                           return error_func.call(this, x, t, "");
                         }

                         d = this._parseJson(d, obj);
                         if (d)  {
                            if (obj === -1 || !obj)  {
                               var $u =  this._$container_ul;
                               $u.empty().append(d.children());
                               $u.attr(WA_ROLE, WA_TREE).attr("tabindex", "0").css("outline", "none") ;
                               if (this._data.core.selectMode === -1)  {
                                 $u.attr("aria-multiselectable", true) ;
                               }
                             }
                             else   {
                                obj.append(d).children("a.oj-tree-loading").removeClass("oj-tree-loading");
                                obj.removeData("oj-tree-is-loading");
                             }

                             this._clean_node(obj);
                             if (s_call)  {
                               s_call.call(this);
                             }
                         }
                         else  {
                           if (obj === -1 || !obj) {
                              if (this._data.ds.correctState)  { 
                                 this._$container_ul.empty(); 
                                 if (s_call) {
                                   s_call.call(this);
                                 }
                              }
                           }
                           else  {
                              obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                              obj.removeData("oj-tree-is-loading");
                              if (this._data.ds.correctState) { 
                                this._correct_state(obj);
                                if (s_call)  {
                                  s_call.call(this);
                                } 
                              }
                           }
                         }
                       };

                       //  Prepare for an ajax op. (note: we are updating a copy of the options)
                       s["ajax"]["context"] = this;
                       s["ajax"]["error"]   = error_func;
                       s["ajax"]["success"] = success_func;

                       if (! s["dataType"])  {
                         s["ajax"]["dataType"] = "json";
                       }
                       if ($.isFunction(s["ajax"]["url"]))  {
                         s["ajax"]["url"] = s["ajax"]["url"].call(this, obj);
                       }
                       if ($.isFunction(s["ajax"]["data"]))  {
                         s["ajax"]["data"] = s["ajax"]["data"].call(this, obj);
                       }
                       $.ajax(s["ajax"]);
                       break;
               }                       // end switch

     },


     /**
       *  Parse a JSON representation of the tree into a jQuery wrapped <ul> structure
       *  @private
       */
     _parseJson : function (js, obj, isRecurse)
     {
        var d = false, 
            tmp, i, j, ul1, ul2, title;

        if (!js) {
          return d;
        }

        if (this._data.ds.progressiveUnload && obj && obj !== -1)  { 
          obj.data(OJT_CHILDREN, d);
        }

        if (typeof js == "string")  {
          try {
                js = $.parseJSON(js) ;
              } catch(err) {js = [];}     // have nothing useful to display
        }

        if ($.isArray(js))  {             // array of ojects ?
          d = $('<ul>');
          if (! js.length)  {
            return false;
          }

          for (i = 0, j = js.length; i < j; i++)  {       // recurse until we have an individual node obj 
             tmp = this._parseJson(js[i], obj, true);
             if (tmp.length)  {
               d = d.append(tmp);
             }
          }

          d = d.children();
        }
        else  {
           //  We have an individual node object

           if (typeof js == "string")  {
             js = { "data" : js };
           }

//JRM      if(!js.data && js.data !== "") { return d; }

           title = (typeof js["title"] == "string")?  js["title"] : " " ;

           d = $("<li role='" + WA_TREEITEM + "' />");                  // start a node

           if (js["attr"])  {
             if (this._data.types.defType && (! js["attr"]["type"])) {  // if no type and "default" type
               js["attr"]["type"] = "oj-tree-deftype" ;                 // defined, add default type
             }
             d.attr(js["attr"]);       // apply attr's to the <li>
           }
           if (js["metadata"])  {      // and any user defined arbitrary data
             d.data(js["metadata"]);
           }

           // js.state     // not published - per Design Review

           if (js["state"] || (js["children"] && js["children"].length === 0)) {    // length zero means lazy load
             d.addClass("oj-tree-" + ((js["state"] === "expanded")? "open" : "closed"));
           }

//         if (!$.isArray(js["data"])) {
//           tmp = js["data"];
//           js["data"] = [];
//           js["data"].push(tmp);
//         }
           
           if (! js["data"]) {
             js["data"] = {"dummy": 0} ;
           }

           var ht   = this._data.core.htmlTitles,
               bIns = false,
               sp ;


           tmp = $("<a tabindex='-1' />");
           $.each(js["data"], function (i, m)   {
//                    tmp = $("<a role=presentation tabindex=-1 />");
                      if ($.isFunction(m)) {
                        m = m.call(this, js);
                      }
                      if (typeof m == "string")  {
//                      tmp.attr('href','#')[ ht? "html" : "text" ](title);
                      }
                      else  {
//                      if (!m["attr"]) {
//                        m["attr"] = {};
//                      }

//                      for (var x in m) {
//                         if (x !== "attr") {
//                           m["attr"][x] = m[x] ;
//                         }
//                      }

//                        if (!m["attr"]["href"]) {
//                          m["attr"]["href"] = '#';
//                        }

//                       tmp.attr(m["attr"]);                // apply attr's to the <a>
                       if (i == "attr") {
                         tmp.attr(m) ;
                       }
                       else if (i == "style") {
                         tmp.css(m) ;
                       }
                        if (i == "language") {
                          tmp.addClass(m);
                        }
                      }

                      if (! bIns) {
                        sp = $("<span class='" + OJT_TITLE + "'>") ;
                        sp[ht? "html" : "text"](title) ;
                        tmp.prepend("<ins class='oj-tree-icon " + OJT_NICON + "'>&#160;</ins>", sp);    // node icon
                        bIns = true ;
                      }
                      if (!m["icon"] && js["icon"])  {
                        m["icon"] = js["icon"];
                      }
                      if (m["icon"])  { 
                        if (m["icon"].indexOf("/") === -1)  {
                          tmp.children("ins").addClass(m["icon"]);
                        }
                        else  {
                          tmp.children("ins").css("background","url('" + m["icon"] + "') center center no-repeat");
                        }
                      }
           });

           d.append(tmp);

           d.prepend("<ins class='" + OJ_DISC + "'>&#160;</ins>");      // potential disclosure icon

           if (js["children"])  { 
             if (this._data.ds.progressiveRender && js["state"] !== "expanded")  {
               d.addClass(OJ_COLLAPSED).attr(WA_EXPANDED, "false")
                                       .data(OJT_CHILDREN, js["children"]);
             }
             else  {
               if (this._data.ds.progressiveUnload)  {
                 d.data(OJT_CHILDREN, js["children"]);
               }
               if ($.isArray(js["children"]) && js["children"].length) {
                 tmp = this._parseJson(js["children"], obj, true);
                 if (tmp.length)  {
                   ul2 = $("<ul role='" + WA_GROUP + "' />");
                   ul2.append(tmp);
                   d.append(ul2);
                 }
               }
             }
           }
        }  // end else

        if (! isRecurse)  {
          ul1 = $("<ul />");
          ul1.append(d);
          d = ul1;
        }

        return d;
     },

     /*
      *   Returns a Json representation of a node
      *   @private
      */
//    ---  Currently not used in V1  ---

//     _getJson : function (obj, li_attr, a_attr, is_callback)
//     {
//       var result = [], 
//           s      = this.options, 
//           _this  = this,
//           tmp1,
//           tmp2,
//           li,
//           a,
//           t,
//           lang;
//
//       obj = this._getNode(obj);
//
//       if (!obj || obj === -1)  {
//         obj = this._$container.find("> ul > li");
//       }
//       li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
//
//       if (!is_callback && s["types"])  {
//         li_attr.push(s["types"]["attr"]);
//       }
//       a_attr = $.isArray(a_attr) ? a_attr : [ ];
//
//       obj.each(function () {
//                  li = $(this);
//                  tmp1 = { data : [] };
//
//                  if (li_attr.length)  {
//                    tmp1.attr = { };
//                  }
//                  $.each(li_attr, function (i, v)  { 
//                                    tmp2 = li.attr(v); 
//                                    if (tmp2 && tmp2.length && tmp2.replace(/oj-tree[^ ]*/ig,'').length)  {
//                                      tmp1.attr[v] = (" " + tmp2).replace(/ oj-tree[^ ]*/ig,'')
//                                                                 .replace(/\s+$/ig," ")
//                                                                 .replace(/^ /,"").replace(/ $/,""); 
//                                    }
//                  });
//
//                  if (li.hasClass(OJT_OPEN))  {
//                    tmp1.state = "open";
//                  }
//                  if (li.hasClass(OJT_CLOSED))  {
//                    tmp1.state = "closed";
//                  }
//                  if (li.data())  {
//                    tmp1.metadata = li.data();
//                  }
//                  a = li.children("a");
//                  a.each(function ()  {
//                          t = $(this);
//
//                          if ( a_attr.length || $.inArray("languages", s["plugins"]) !== -1 || 
////wed3                         t.children("ins").get(0).style.backgroundImage.length || 
//                               t.children("ins").get(0)["style"]["backgroundImage"].length || 
////wed3                        (t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/oj-tree[^ ]*|$/ig,'').length))
//                              (t.children("ins").get(0)["className"] && t.children("ins").get(0)["className"].replace(/oj-tree[^ ]*|$/ig,'').length))
//                          { 
//                            lang = false;
//                            if ($.inArray("languages", s["plugins"]) !== -1 && $.isArray(s["languages"]) && s["languages"].length)  {
////                            $.each(s.languages, function (l, lv)   {
//                              $.each(s["languages"], function (l, lv)   {
//
//                                                     if (t.hasClass(lv))  {
//                                                       lang = lv;
//                                                       return false;
//                                                     }
//                              });
//                            }
//
//                            tmp2 = { "attr" : { }, "title" : _this.getText(t, lang) }; 
//                            $.each(a_attr, function (k, z) {
//                                tmp2.attr[z] = (" " + (t.attr(z) || "")).replace(/ oj-tree[^ ]*/ig,'')
//                                                                        .replace(/\s+$/ig," ")
//                                                                        .replace(/^ /,"")
//                                                                        .replace(/ $/,"");
//                            });
//                            if ($.inArray("languages", s["plugins"]) !== -1 && $.isArray(s["languages"]) && s["languages"].length) {
//                               $.each(s["languages"], function (k, z)  {
//                                  if (t.hasClass(z))  {
//                                    tmp2.language = z;
//                                    return true;
//                                  }
//                               });
//                            }
//
//                            if (t.children("ins").get(0)["className"].replace(/oj-tree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length)
//                            {
//                              tmp2.icon = t.children("ins").get(0)["className"].replace(/oj-tree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
//                            }
//                            if (t.children("ins").get(0)["style"]["backgroundImage"].length)
//                            {
//                              tmp2.icon = t.children("ins").get(0)["style"]["backgroundImage"].replace("url(","").replace(")","");
//                            }
//                          }
//                          else   {
//                             tmp2 = _this["getText"](t);
//                          }
//
//                          if (a.length > 1)  {
//                            tmp1.data.push(tmp2);
//                          }
//                          else   {
//                            tmp1.data = tmp2;
//                         }
//                  });
//
//                  li = li.find("> ul > li");
//                  if (li.length)  {
//                     tmp1.children = _this._getJson(li, li_attr, a_attr, true);
//                  }
//                  result.push(tmp1);
//       });
//
//       return result;
//     },

     /**
       *  Corrects nodes by setting closed nodes to leaf nodes if no children found. 
       *  @private
       */
     _correct_state   : function (obj)
     {
         obj = this._getNode(obj);
         if (!obj || obj === -1) {
           return false;
         }
         obj.removeClass("oj-collapsed oj-expanded")
            .removeAttr(WA_EXPANDED)
            .addClass(OJT_LEAF)
            .children("ul")
            .remove();

         obj.find("ins:first-child").removeClass(OJ_DISC).addClass(OJT_ICON) ;
         this._emitEvent({ "obj" : obj }, "correct_state");
     },


     /*
       *  @private
       */
/*                                           // not used in V1
     _core_notify : function (n, data)
     {
        if (data.opened)  {
          this._expand(n, false, true);
        }
     },
*/

     /*
      *  Dummy function to fire after the first load (so that there is a loaded event)
      *  @private
      */
     _loaded  : function ()
     { 
        this._emitEvent(null, "loaded"); 
      },


     /**
       *   Process the user tree <ul> list placed in the tree div, or loaded via ajax.
       *   @private
       */
     _load_node_html : function (obj, s_call, e_call)
     {
       var s = this._getOptions()["data"],        // work on a copy of the options to avoid
           d,                                     // endless loop in calling success/error funcs
           error_func   = function () {},
           success_func = function () {},
           data         = (s && s["data"]) || null,
           ajax         = (s && s["ajax"]) || null;

       obj = this._getNode(obj);
       if (obj && obj !== -1)  {
         if (obj.data("oj-tree-is-loading")) {
           return;
         }
         else  {
           obj.data("oj-tree-is-loading", true);
         }
       }

       switch(!0)
       {
          case ((!data && !ajax) && (s && (typeof s === "string"))) :
                    this._loadHtmlString(s, obj, s_call, e_call) ;
                    break ;

          case $.isFunction(data):
                    data.call(this, obj, $.proxy(function (d)
                              {
                                 this._loadHtmlString(d, obj, s_call, e_call) ;
                              }, this));
                    break;

          case (!data && !ajax):
                    if (!obj || obj == -1 )  {
                      this._$container_ul
                              .empty()
                              .append(this._data.html.cloneMarkup)
                              .find("li, a")
                              .filter(function () {
                                               return (!this.firstChild || !this.firstChild.tagName ||
                                                       this.firstChild.tagName !== "INS");
                                                   })
                              .prepend("<ins class='oj-tree-icon' >&#160;</ins>").end()
                              .filter("a").children("ins:first-child")
                              .not(".oj-tree-node-icon")
                              .addClass(OJT_NICON)
                              .addClass(OJT_ICON);

                      this._$container_ul.find("li").children("ins:first-child")
                                                    .addClass(OJ_DISC);

                      //  No point in checking for empty parent <ul> because we don't have a
                      //  "data" option in the first place, so no lazy loading posssible.

                      //  Add the <a> text <span> for hover/click styling
                      this._insertHtmlTextSpan(this._$container_ul) ;

                      if (this._data.types.defType) {             // if "default" type defined
                        this._addDefType(this._$container_ul) ;   // apply to nodes with no asooc type
                      }

                      this._clean_node();
                      this._$container_ul.find("ul").attr(WA_ROLE, WA_GROUP) ;
                      this._$container_ul.find("li").attr(WA_ROLE, WA_TREEITEM) ;
                      this._$container_ul.find("a").attr("tabindex", -1) ;
                    }
                    if (s_call)  {
                      s_call.call(this);
                    }
                    break;

          case (!!data && !ajax) || (!!data && !!ajax && (!obj || obj === -1)):
                    if (!obj || obj == -1) {
                           d = $(data);
                           if (!d.is("ul")) {
                             d = $("<ul />").append(d);
                           }
                           this._$container_ul
                               .empty()
                               .append(d
                               .children())
                               .find("li, a")
                               .filter(function ()
                                           {
                                              return (!this.firstChild || !this.firstChild.tagName ||
                                                      this.firstChild.tagName !== "INS");
                                           })
                               .prepend("<ins class='oj-tree-icon'>&#160;</ins>").end()
                               .filter("a")
                               .children("ins:first-child")
                               .not(".oj-tree-node-icon")
                               .addClass(OJT_NICON)
                               .addClass(OJT_ICON);

                           this._$container_ul.find("li.oj-tree-leaf ins:first-child").removeClass(OJ_DISC)
                                                                                      .removeClass(OJT_NICON)
                                                                                      .addClass(OJT_ICON);

                           //  Add the <a> text <span> for hover/click styling
                           this._insertHtmlTextSpan(this._$container_ul) ;

                           if (this._data.types.defType) {             // if "default" type defined
                             this._addDefType(this._$container_ul) ;   // apply to nodes with no asooc type
                           }

                           this._clean_node();
                           this._$container_ul.find("ul").attr(WA_ROLE, WA_GROUP) ;
                           this._$container_ul.find("li").attr(WA_ROLE, WA_TREEITEM) ;
                           this._$container_ul.find("a").attr("tabindex", "-1") ;
                    }
                    if (s_call)  {
                         s_call.call(this);
                    }
                    break;

          case (!data && !!ajax) || (!!data && !!ajax && obj && obj !== -1):
                    obj = this._getNode(obj);
                    error_func = function (x, t, e)
                         {
                           var ef = this._getOptions()["data"]["ajax"]["error"];  // reget the options
                           if (ef) {                                              // without our updated ajax
                             ef.call(this, x, t, e);                              // changes to avoid forever loop
                           }

                           if (obj != -1 && obj.length)  {
                             obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                             obj.removeData("oj-tree-is-loading");
                             if (t === "success" && this._data.ds.correctState) {
                                this._correct_state(obj);
                             }
                           }
                           else  {
                             if (t === "success" && this._data.ds.correctState) {
                               this._$container_ul.empty();
                             }
                           }
                           if (e_call)  {
                             e_call.call(this);
                           }
                        };
                    success_func = function (d, t, x)
                        {
                          var parent, lazy ;
                          var sf = this._getOptions()["data"]["ajax"]["success"];  // reget the options
                          if (sf) {                                                // without our updated ajax
                            d = sf.call(this, d, t, x) || d;                       // changes to avoid forever loop
                          }

                          if (d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
                            return error_func.call(this, x, t, "");
                          }

                          if (d)  {
                            d = $(d);
                            if (!d.is("ul")) {
                              d = $("<ul />").append(d);
                            }
                            if (obj == -1 || !obj) {
                              this._$container_ul.empty()
                                                 .append(d.children())
                                                 .find("li, a")
                                                 .filter(function ()
                                                    {
                                                      return !this.firstChild || !this.firstChild.tagName ||
                                                                                 this.firstChild.tagName !== "INS";
                                                    })
                                                 .prepend("<ins class='oj-tree-icon'>&#160;</ins>")
                                                 .end()
                                                 .filter("a")
                                                 .children("ins:first-child")
                                                 .not(".oj-tree-node-icon")
                                                 .addClass(OJT_NICON)
                                                 .addClass(OJT_ICON);

                              this._$container_ul.find("li.oj-tree-leaf ins:first-child").removeClass(OJ_DISC)
                                                                                         .removeClass(OJT_NICON)
                                                                                         .addClass(OJT_ICON);
                              parent = this._$container_ul ;
                            }
                            else  {
                               obj.children("a.oj-tree-loading")
                                  .removeClass("oj-tree-loading");

                               this._removeEmptyUL(obj) ;

                               obj.append(d)
                                  .children("ul")
                                  .find("li, a")
                                  .filter(function () {
                                             return (!this.firstChild || !this.firstChild.tagName ||
                                                                         this.firstChild.tagName !== "INS");
                                          })
                                  .prepend("<ins class='oj-tree-icon'>&#160;</ins>")
                                  .end()
                                  .filter("a")
                                  .children("ins:first-child")
                                  .not(".oj-tree-node-icon")
                                  .addClass(OJT_NICON)
                                  .addClass(OJT_ICON);
                               obj.removeData("oj-tree-is-loading");

                               obj.find("li.oj-tree-leaf ins:first-child").removeClass(OJ_DISC)
                                                                          .removeClass(OJT_NICON)
                                                                          .addClass(OJT_ICON);

                               parent = obj ;
                            }

                            //  Look for parents with empty children <ul> list (lazy loading),
                            //  and add the closed class to make it a parent.
                            this._handleHtmlParentNoChildren(parent) ;

                            //  Add the <a> text <span> for hover/click styling
                            this._insertHtmlTextSpan(parent) ;

                            // If "default" type defined, apply to nodes with no assoc type
                            if (this._data.types.defType && parent)  {
                              this._addDefType(this._$container_ul) ;
                            }

                            this._clean_node(obj);
                            if (s_call)  {
                              s_call.call(this);
                            }
                          }
                          else  {
                            if (obj && obj !== -1)  {
                               obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                               obj.removeData("oj-tree-is-loading");
                               if (this._data.ds.correctState)  { 
                                  this._correct_state(obj);
                                  if (s_call) {
                                    s_call.call(this);
                                  } 
                               }
                              }
                              else  {
                                if (this._data.ds.correctState)  { 
                                   this._$container_ul.empty();
                                   if (s_call) {
                                     s_call.call(this);
                                   } 
                                }
                              }
                              this._$container_ul.find("ul").attr(WA_ROLE, WA_GROUP) ;
                              this._$container_ul.find("li").attr(WA_ROLE, WA_TREEITEM) ;
                          }
                        };

                        //  Prepare for an ajax op. (note: we are updating a copy of the options)
                        s["ajax"]["context"] = this;
                        s["ajax"]["error"]   = error_func;
                        s["ajax"]["success"] = success_func;

                        if (!s["ajax"]["dataType"]) {
                          s["ajax"]["dataType"] = "html";
                        }
                        if ($.isFunction(s["ajax"]["url"])) {
                          s["ajax"]["url"] = s["ajax"]["url"].call(this, obj);
                        }
                        if ($.isFunction(s["ajax"]["data"])) {
                          s["ajax"]["data"] = s["ajax"]["data"].call(this, obj);
                        }
                        $.ajax(s["ajax"]);
                        break;
       }
     },


     /**
       *   Look for parents with empty children <ul> list (lazy loading), and add the closed
       *   class to make it a parent.
       *   @private
       */
     _handleHtmlParentNoChildren : function (parent)
     {
        var lazy = parent
                     .find(parent.is("ul")?  "li ul" : "ul")
                     .filter(function () {
                                return (!this.firstChild ||
                                        this.childNodes.length == 0 ||
                                        (this.childNodes.length == 1 && this.firstChild.nodeType ==3));
                                       }) ;
        $.each(lazy, function() {
                                  $(this).closest("li")
                                         .addClass(OJ_COLLAPSED) ;
                                }) ;
     },


     /**
       *   Remove an empty <ul> in a node (lazy loading).
       *   @private
       */
     _removeEmptyUL : function(parent)
     {
        var l = parent.find("ul")
                     .filter(function () {
                                return (!this.firstChild ||
                                        this.childNodes.length == 0 ||
                                        (this.childNodes.length == 1 && this.firstChild.nodeType ==3));
                                       }) ;
       if (l.length > 0) {
         l.remove() ;
       }
     },




     /**
       *   Load an HTML <ul><li>...</ul> markup string
       *   @private
       */
     _loadHtmlString : function (s, obj, s_call, e_call)
     {
        var parent ;

        if (s && s !== "" && s.toString && s.toString().replace(/^[\s\n]+$/,"") !== "") {
          s = $(s);
          if (! s.is("ul")) {
            s = $("<ul />").append(s);
          }

          if (obj == -1 || !obj) {
            this._$container_ul.empty()
                               .append(s.children())
                               .find("li, a")
                               .filter(function () {
                                         return (!this.firstChild || !this.firstChild.tagName ||
                                                 this.firstChild.tagName !== "INS");
                                       })
                               .prepend("<ins class='oj-tree-icon oj-tree-disclosure-icon'>&#160;</ins>")
                               .end().filter("a")
                               .children("ins:first-child")
                               .not(".oj-tree-node-icon")
                               .addClass(OJT_NICON)
                               .addClass(OJT_ICON);

            this._$container_ul.find("li.oj-tree-leaf ins:first-child").removeClass(OJ_DISC)
                                                                       .removeClass(OJT_NICON)
                                                                       .addClass(OJT_ICON);

            parent = this._$container_ul ;

            //  No point in checking for empty parent <ul> because we don't have a
            //  "data" option in the first place, so no lazy loading posssible.

            //  If the "default" node type has been defined, add the def type to any nodes
            //  that have not been given an explicit type
            this._addDefType(this._$container_ul) ;
          }
          else  {
            obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
            obj.append(s)
               .children("ul")
               .find("li, a")
               .filter(function ()
                          {
                             return !this.firstChild || !this.firstChild.tagName ||
                                                         this.firstChild.tagName !== "INS";
                          })
               .prepend("<ins class='oj-tree-icon'>&#160;</ins>")
               .end().filter("a")
               .children("ins:first-child")
               .not(".oj-tree-node-icon")
               .addClass("oj-tree-node-icon")
               .addClass("oj-tree-icon");
            obj.removeData("oj-tree-is-loading");

            parent = obj ;

            //  If the "default" node type has been defined, add the def type to
            //  any nodes that have not been given an explicit type
            this._addDefType(this.obj) ;
          }

            //  Add the <a> text <span> for hover/click styling
          if (parent) {
            this._insertHtmlTextSpan(parent) ;
          }

          this._clean_node(obj);
          if (s_call)  {
            s_call.call(this);
          }
        }
        else  {
          if (obj && obj !== -1)  {
            obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
            obj.removeData("oj-tree-is-loading");
            if (this._data.ds.correctState) { 
              this._correct_state(obj);
              if (s_call) {
                s_call.call(this);
              } 
            }
          }
          else  {
            if (this._data.ds.correctState)
            { 
              this._$container_ul.empty();
              if (s_call) {
                s_call.call(this);
              } 
            }
          }
        }
     },

     /**
       *  Insert the <a> text <span> for hover/click styling
       *  @private
       */
     _insertHtmlTextSpan : function(elem)
     {
        $.each(elem.find("li a"), function (i, val) {
        	 var ih = val.innerHTML ;
             ih = ih.replace("ins>", "ins><span class='" + OJT_TITLE + "'>") ;
             ih += "</span>" ;
        	 val.innerHTML = ih ;
        });
     },

     /**
       *  Add the "default" type attr to all nodes that do not have an explicit type defined.
       *  @private
       */
     _addDefType : function(obj)
     {
        var s, typeAttr ;
        if (this._data.types.defType) {
          s = this.options["types"];
          typeAttr = s? s["attr"] : this._data.types.defaults["attr"];

          $.each(obj.find("li"), function (i, val) {
                  val = $(val)
                  if (! val.attr(typeAttr)) {
                    val.attr(typeAttr, "oj-tree-deftype") ;
                  }
          });
        }
     },


     /*
      *
      *   @private
      */
     _dnd_prepare : function ()
     {
       var  vars = this._data.dnd.vars ;

       if (! vars.r || ! vars.r.length) {
         return;
       }
       this._data.dnd.off = vars.r.offset();   // get pos of dragged node relative to doc

       if (this._isRtl) {
         // arrow icon is the right of the marker line
         this._data.dnd.off.right  = this._data.dnd.off.left + vars.r.width() - vars.r.find(">a").width() -14 ;
       }
       this._data.dnd.targ_ml_width = vars.r.find("a").width();
//   this._data.dnd.targ_ml_width = this._data.dnd.targ_ml_width > 100? 100 : this._data.dnd.targ_ml_width ;
//   this._data.dnd.targ_ml_width = this._data.dnd.targ_ml_width < 25? 25   : this._data.dnd.targ_ml_width ;

       if (this._data.dnd.foreign)  {

         var a = this.options["dnd"]["drag_check"].call(this, { "o" : vars.o,
                                                                "r" : vars.r });
         this._data.dnd["after"]   = a["after"];
         this._data.dnd["before"]  = a["before"];
         this._data.dnd["inside"]  = a["inside"];
         this._data.dnd.prepared   = true;
         return this._dnd_show();
       }

       this._prepare_move(vars.o, vars.r, "before");
       this._data.dnd["before"] = this["check_move"]();
       this._prepare_move(vars.o, vars.r, "after");
       this._data.dnd["after"]  = this["check_move"]();

       if (this._is_loaded(vars.r)) {
         this._prepare_move(vars.o, vars.r, "inside");
         this._data.dnd["inside"] = this["check_move"]();
       }
       else  {
         this._data.dnd["inside"] = false;
       }

       this._data.dnd.prepared = true;
       return this._dnd_show();
     },


     /*
      *  Positions and shows (or hides) the drag insert position marker and line.
      *  @private
      */
     _dnd_show : function ()
     {
        var  dnd      = this._data.dnd,
             isParent = false,
             mLeft,                // pos of marker rel to document
             mlLeft ;              // position of marker line rel to doc

        if (! dnd.prepared)  {
          return;
        }

        var o     =  ["before","inside","after"],
            r     =  false,
            pos,
            ctl   =  dnd.ctl,
            vars  =  dnd.vars ;

        if (dnd.w < this._data.core.li_height/3)  {
           o = ["before","inside","after"];
        }
        else if (dnd.w <= this._data.core.li_height * 2/3)  {
          o = dnd.w < this._data.core.li_height/2 ? ["inside","before","after"] :
                                                    ["inside","after","before"] ;
        }
        else {
          o = ["after","inside","before"];
        }
 
        $.each(o, $.proxy(function (i, val)
           { 
             if (this._data.dnd[val])  {
               ctl.helper.children("ins")
                         .removeClass(OJT_DROP_INVALID)
                         .addClass(OJT_DROP_OK);
               $("body").removeClass("oj-tree-invalid-drop") ;      // set cursor
               r = val;
               return false;
             }
        }, this));

        if (r === false)  {
          ctl.helper.children("ins")
                    .removeClass(OJT_DROP_OK)
                    .addClass(OJT_DROP_INVALID);
          $("body").addClass("oj-tree-invalid-drop") ;       // set cursor
        }
        
        pos       = this._isRtl ? (this._data.dnd.off.right - 18) : (this._data.dnd.off.left + 5);

        isParent  = ! this["isLeaf"](vars.r);
        mLeft     = this._isRtl? (pos + this._data.dnd.targ_ml_width + 18) : pos ;  // pos of marker rel to doc
        mlLeft    = this._isRtl? (mLeft - this._data.dnd.ml_width) : (pos + 8)      // pos of marker line rel to doc
        
        switch(r)
        {
            case "before":
                vars.m.css({ "left" : mLeft + "px",
                             "top"  : (this._data.dnd.off.top - this._data.core.li_height/2) + "px" 
                           }).show();
                if (vars.ml) {
                    vars.ml.css({ "left" : mlLeft + "px",
                                  "top"  : (this._data.dnd.off.top - 3) + "px" 
                                }).show();
                }
                break;

            case "after":
                vars.m.css({ "left" : mLeft + "px",
                             "top"  : (this._data.dnd.off.top +
                                       this._data.core.li_height - 3 - 6) + "px" 
                           }).show();
                if (vars.ml) {
                   vars.ml.css({ "left" : mlLeft + "px",
                                 "top" : (this._data.dnd.off.top +
                                          this._data.core.li_height - 3 + 2) + "px" 
                               }).show();
                }
                break;

            case "inside":
                vars.m.css({ "left" : mLeft + (this._isRtl? (isParent? -4 : 0) : 4) + "px",
                             "top" : (this._data.dnd.off.top + this._data.core.li_height/2 - 10) + "px"
                            }).show();
                if (vars.ml)  {
                  vars.ml.hide();
                }
                break;

            default:
                vars.m.hide();
                if (vars.ml) {
                  vars.ml.hide();
                }
                break;
        }

        vars.last_pos = r;
        return  r;
     },



     /*
      *
      *   @private
      */
     _dnd_enter : function (obj)
     {
        var dnd  = this._data.dnd,
            vars = dnd.vars ;

        if (dnd.mto)  { 
          clearTimeout(dnd.mto);
          dnd.mto = false;
        }

        dnd.prepared = false;
        vars.r = this._getNode(obj);

        var s             = this.options["dnd"];
        var checkTimeout  = s["check_timeout"] ;

        if (checkTimeout)  { 

           // do the calculations after a minimal timeout (users tend to drag quickly to the desired location)

           if (dnd.to1)  {
             clearTimeout(dnd.to1);
           }
           dnd.to1 = setTimeout($.proxy(this._dnd_prepare, this), checkTimeout); 
        }
        else { 
            this._dnd_prepare(); 
        }

        var openTimeout  = s["open_timeout"] ;
        if (openTimeout)  { 
          if (dnd.to2)  {
            clearTimeout(dnd.to2);
          }
          if (vars.r && vars.r.length && vars.r.hasClass(OJ_COLLAPSED))  { 
            // if the node is closed - open it, then recalculate
            dnd.to2 = setTimeout($.proxy(this._dnd_open, this), openTimeout);
          }
        }
        else   {
          if (vars.r && vars.r.length && vars.r.hasClass(OJ_COLLAPSED))  { 
             this._dnd_open();
          }
        }
  
     },


     /*
      *
      *   @private
      */
     _dnd_leave : function (e)
     {
        var dnd  = this._data.dnd,
            vars = this._data.dnd.vars ;

        dnd["after"]   = false;
        dnd["before"]  = false;
        dnd["inside"]  = false;

        this._data.dnd.ctl.helper.children("ins")
                                 .removeClass(OJT_DROP_OK)
                                 .addClass(OJT_DROP_INVALID);
        $("body").addClass("oj-tree-invalid-drop") ;      // set cursor

        if (vars.r) {
          vars.r.removeClass(OJ_VALID_DROP).removeClass(OJ_INVALID_DROP) ;
        }

        vars.m.hide();

        if (vars.ml) {
          vars.ml.hide();
        }
        if (vars.r && vars.r[0] === e.target.parentNode)
        {
          if (dnd.to1) {
            clearTimeout(dnd.to1);
            dnd.to1 = false;
          }
          if (dnd.to2)  {
            clearTimeout(dnd.to2);
            dnd.to2 = false;
          }
        }

     },


     /**
       *  Expand the node hovered over while dragging so the user can drop inside a folder.
       *  @private
       */
     _dnd_open : function ()
     {
        var  vars = this._data.dnd.vars ;

        this._data.dnd.to2 = false;
        this["expand"](vars.r, $.proxy(this._dnd_prepare, this), true);
     },


     /**
       *  Drop is complete - move the node. (Note: drag_stop does not get called)
       *  @private
       */
     _dnd_finish : function (e)
      {
         var dnd  = this._data.dnd,
             vars = this._data.dnd.vars ;

         if (dnd.foreign)   {
           if (dnd["after"] || dnd["before"] || dnd["inside"])  {
              this.options["dnd"]["drag_finish"].call(this, { "o" : vars.o,
                                                              "r" : vars.r,
                                                              "p" : vars.last_pos
                                                             });
           }
         }
         else  {
           this._dnd_prepare();
           this._move_node(vars.o, vars.r, vars.last_pos, e[this.options["dnd"]["copy_modifier"] + "Key"]);
         }

        _removeSheet("oj-tree-drag");      // remove our temporary drag stylesheet
         if (vars.o) {
          vars.o.removeClass("oj-drag") ;  // remove class from dragged node

         }

         vars.o = false;
         vars.r = false;
         vars.m.hide();

         if (vars.ml) {
           vars.ml.hide();
         }
     },


     /**
       *  Mouse is down on an <a>, prepare for drag and drop
       *  @private
       */
     _start_drag : function (obj, e)
     {
        var  dnd  = this._data.dnd,
             vars = this._data.dnd.vars ;

        vars.o = this._getNode(obj);

        if (vars.o.hasClass(OJ_DISABLED) || this._data.core.locked) {
          return ;
        }

        if (this._data.ui && this["isSelected"](vars.o))  {
          vars.o = this._getNode(null, true);
        }

        var dt  = vars.o.length > 1 ? this.getTranslatedString("m_multisel") : this["getText"](vars.o),
            cnt = this._getContainer();

        if (!this._data.core.htmlTitles) {
          dt = dt.replace(/</ig,"&lt;").replace(/>/ig,"&gt;");
        }

        vars.o.addClass("oj-drag") ;       // add class to the dragged node

        // Temporarily add some css for the duration of the drag.
        _addSheet({ str : "body.oj-tree-invalid-drop { cursor: not-allowed ;}", title : "oj-tree-drag" });

        this._drag_start(e, { jstree : true,
                              obj    : vars.o
                            }, "<ins class='oj-tree-icon'></ins>" + dt);

        if (this._data.themes) {
          if (vars.m) {
             vars.m.addClass("oj-tree-" + this._data.themes.theme);
          }
          dnd.ctl.helper.addClass("oj-tree-dnd-helper oj-tree-" + this._data.themes.theme); 
        }

        dnd.cof    = cnt.offset();
        dnd.cw     = parseInt(cnt.width(),10);
        dnd.ch     = parseInt(cnt.height(),10);
        dnd.active = true;
     },


     /**
       *  Start drag/drop process
       *  @private
       */
     _drag_start : function (e, data, html)
     {  
         var ctl = this._data.dnd.ctl ;

         if (ctl.is_drag)  {
           this._drag_stop() ;
         }
         try {
               e.currentTarget.unselectable = "on";
               e.currentTarget.onselectstart = function()  { return false; };
               if (e.currentTarget.style)  {
                 e.currentTarget.style.MozUserSelect = "none";
               }
         } catch(err) { }

         ctl.init_x    = e.pageX;
         ctl.init_y    = e.pageY;
         ctl.user_data = data;
         ctl.is_down   = true;
         ctl.helper    = $("<div class='oj-tree-drag-text' />").html(html); //.fadeTo(10,0.25);

         // Listen for mouse drag and mouse up events
         $(document).bind("mousemove", this._drag.bind(this));
         $(document).bind("mouseup",   this._drag_stop.bind(this));

         return false;
     },


     /**
       *  Mouse is down and we are dragging 
       *  @private
       */
     _drag :  function (e)
     { 
        var ctl  = this._data.dnd.ctl,
            vars = this._data.dnd.vars ;

        if (! ctl.is_down) {
          return;
        }
        if (! ctl.is_drag)  {
          if (Math.abs(e.pageX - ctl.init_x) > 5 || Math.abs(e.pageY - ctl.init_y) > 5)  { 
            ctl.helper.appendTo("body");
            ctl.is_drag = true;
            $(document).triggerHandler("drag_start.ojtreeu", [{
                                                                 "event" : e,
                                                                 "data"  : ctl.user_data
                                                              }]);
          }
          else  {
            return;
          }
        }


        // maybe use a scrolling parent element instead of document?
        if (e.type === "mousemove")
        {   // thought of adding scroll in order to move the helper, but mouse position is n/a
           var d = $(document),
               t = d.scrollTop(),
               l = d.scrollLeft();

           if (e.pageY - t < 20)  { 
             if (vars.sti && vars.dir1 === "down") {
                clearInterval(vars.sti);
                vars.sti = undefined;
             }
             if (! vars.sti)  {
               vars.dir1 = "up";
               vars.sti = setInterval(function ()
                            {
                              $(document).scrollTop( $(document).scrollTop() - ctl.scroll_spd );
                            }, 150);
             }
           }
           else  { 
              if (vars.sti && vars.dir1 === "up")   {
                clearInterval(vars.sti);
                vars.sti = undefined;
              }
           }

           if ($(window).height() - (e.pageY - t) < 20)   {
             if (vars.sti && vars.dir1 === "up")  {
                clearInterval(vars.sti);
                vars.sti = undefined;
             }
             if (! vars.sti)  {
               vars.dir1 = "down";
               vars.sti = setInterval(function ()
                         {
                           $(document).scrollTop( Number($(document).scrollTop()) + ctl.scroll_spd );
                           // above Number() is for the closure compiler!!
                         }, 150);
             }
           }
           else   { 
              if (vars.sti && vars.dir1 === "down")  {
                clearInterval(vars.sti);
                vars.sti = undefined;
              }
           }

           if (e.pageX - l < 20)   {
             if (vars.sli && vars.dir2 === "right")  {
                clearInterval(vars.sli);
                vars.sli = undefined;
             }
             if (! vars.sli)  {
                vars.dir2 = "left";
                vars.sli = setInterval(function ()
                       {
                         $(document).scrollLeft( $(document).scrollLeft() - ctl.scroll_spd );
                       }, 150);
             }
           }
           else   { 
             if (vars.sli && vars.dir2 === "left")   {
               clearInterval(vars.sli);
               vars.sli = undefined;
             }
           }

           if ($(window).width() - (e.pageX - l) < 20)   {
             if (vars.sli && vars.dir2 === "left")  {
                clearInterval(vars.sli);
                vars.sli = undefined;
             }
             if (! vars.sli)   {
               vars.dir2 = "right";
               vars.sli = setInterval(function ()
                        {
//                        Number() is for the closure compiler!!
                          $(document).scrollLeft(Number($(document).scrollLeft()) + ctl.scroll_spd);
                        }, 150);
             }
           }
           else  { 
             if (vars.sli && vars.dir2 === "right")  {
               clearInterval(vars.sli);
               vars.sli = undefined;
             }
           }
        }

        ctl.helper.css({ left : (e.pageX + ctl.helper_left) + "px", top : (e.pageY + ctl.helper_top) + "px" });
        $(document).triggerHandler("drag.ojtreeu", [{
                                                      "event" : e,
                                                      "data"  : ctl.user_data
                                                    }]);
     },


     /**
       *  @private
       */
     _drag_stop  : function (e)
     {
        var vars = this._data.dnd.vars,
            ctl  = this._data.dnd.ctl ;

        if (vars.sli)  {
          clearInterval(vars.sli);
        }
        if (vars.sti)   {
          clearInterval(vars.sti);
        }

        if (vars.o) {
          vars.o.removeClass("oj-drag") ;  // remove class from dragged node
        }
        _removeSheet("oj-tree-drag");     // remove our temporary drag stylesheet


        $(document).unbind("mousemove", this._drag.bind(this));
        $(document).unbind("mouseup",   this._drag_stop.bind(this));
        $(document).triggerHandler("drag_stop.ojtreeu", [{
                                                           "event" : e? e: {},
                                                           "data"  : ctl.user_data
                                                         }]);
        ctl.helper.remove();
        ctl.init_x    = 0;
        ctl.init_y    = 0;
        ctl.user_data = {};
        ctl.is_down   = false;
        ctl.is_drag   = false;

        $("body").removeClass("oj-tree-invalid-drop") ;       // set cursor


    },


     /**
       *  @private
       */
     _save_opened : function ()
     {
        var _this = this;
        this._data.core.toExpand = [];
        this._$container_ul.find("li.oj-expanded").each(function () { 
            if (this.id)  { 
              _this._data.core.toExpand.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"));
            }
        });

        this._emitEvent(_this._data.core.toExpand, "save_opened");
     },


     /*
      *   Reload tree nodes
      *   @private
      */
      _reload_nodes : function (is_callback)
      {
         var _this     = this,
             done      = true,
             current   = [],
             remaining = [],
             ea,
             bExpandAll ;
     
         if (!is_callback)  { 
            this._data.core.reopen     = false; 
            this._data.core.refreshing = true; 

            bExpandAll = (this._data.core.toExpand === "all") ;
            if (bExpandAll) {
              this._data.core.toExpand  = [];
            }
            else  if (($.type(this._data.core.toExpand) === "array") && (this._data.core.toExpand.length > 0) &&
                                                                        (this._data.core.toExpand[0] === "all")) {
              this._data.core.toExpand.length = 0 ;
              bExpandAll = true ;
            }

            if (bExpandAll) {
              ea = this._$container_ul.find("li.oj-collapsed").each(function() {
                     var id = $(this).attr("id") ;
                     _this._data.core.toExpand.push('#' + $(this).attr("id")) ;
                   }) ;
            }
     
            this._data.core.toExpand = 
                     $.map(
                            $.makeArray(this._data.core.toExpand),
                                function (n) {
                                   return "#" + n.toString().replace(/^#/, "")
                                                            .replace(/\\\//g, "/")
                                                            .replace(/\//g, "\\\/")
                                                            .replace(/\\\./g, ".")
                                                            .replace(/\./g, "\\.")
                                                            .replace(/\:/g, "\\:");
                                }
                          );
     
            this._data.core.toLoad = 
                       $.map(
                              $.makeArray(this._data.core.toLoad),
                                  function (n)  {
                                     return "#" + n.toString().replace(/^#/,"")
                                                              .replace(/\\\//g,"/")
                                                              .replace(/\//g,"\\\/")
                                                              .replace(/\\\./g,".")
                                                              .replace(/\./g,"\\.")
                                                              .replace(/\:/g,"\\:");
                            }
                       );
     
            if (this._data.core.toExpand.length)  {
              this._data.core.toLoad  = this._data.core.toLoad.concat(this._data.core.toExpand);
            }
         }
     
         if (this._data.core.toLoad.length) {
            $.each(this._data.core.toLoad, function (i, val) {
                if (val == "#") {
                  return true;
                }
                if ($(val).length) {
                  current.push(val);
                }
                else {
                  remaining.push(val);
                }
            });
     
            if (current.length) {
               this._data.core.toLoad  =  remaining;
               $.each(current, function (i, val) { 
                   if (! _this._is_loaded(val))  {
                      _this._load_node(val, function ()  {
                                               _this._reload_nodes(true);
                                             }, function ()  {
                                                 _this._reload_nodes(true);
                                                }
                                      );
                      done = false;
                   }
               });
            }
         }

         if (this._data.core.toExpand.length)
         {
            $.each(this._data.core.toExpand, function (i, val) {
                 _this["expand"](val, false, true); 
            });
         }

         if (done)  { 
            // TODO: find a more elegant approach to syncronizing returning requests

            if (this._data.core.reopen)  {
              clearTimeout(this._data.core.reopen);
            }
            this._data.core.reopen = setTimeout(function ()  {
                                                   _this._emitEvent({}, "reload_nodes");
                                               }, 50);

            this._data.core.refreshing = false;
            this._reopen();
         }
    },


     /*
      *   TDO   replace with Jet theming.
      *   @private
      */
    "set_theme" : function (theme_name, theme_url)
    {
       if (! theme_name)  {
         return false;
       }

       if (! theme_url)  {
          theme_url = this._data.themes._themes + theme_name + '/style.css';
       }

       if ($.inArray(theme_url, this._data.themes.themes_loaded) == -1)  {
         _addSheet({ url : theme_url });
         this._data.themes.themes_loaded.push(theme_url);
       }

       if (this._data.themes.theme != theme_name)  {
         this._$container.removeClass('oj-tree-' + this._data.themes.theme);
         this._data.themes.theme = theme_name;
       }

       this._$container.addClass('oj-tree-' + theme_name);

       if (! this._data.themes.dots) {
         this._hideDots();
       }
       else  {
          this._showDots();
       }

       if (! this._data.themes.icons)  {
         this._hideIcons();
       }
       else  {
         this._showIcons();
       }
 
       this._emitEvent(null, "set_theme");

    },


    /*
     *   Shows the hierarchy lines.  Not used in V1
     *   @private
     */
/*
    "show_dots"  : function ()
    {
      this._showDots() ;
    },
*/
    /*
     *   Hides the hierarchy lines.  Not used in V1
     *   @private
     */
/*
    "hide_dots"   : function ()
    {
      this._hideDots() ;
    },
*/
    /*
     *   Toggles the current hierarchy line state.  Not used in V1
     *   @private
     */
/*
    "toggle_dots" : function ()
    {
       if (this._data.themes.dots) {
         this._hideDots();
       }
       else  {
         this._showDots"]();
       }
    },
*/
    /*
     *   Returns true if node icons are currently displayed.  Users can find this state from options.
     *   @private
     */
    "isIcons"  : function ()
    {
       return this._data.themes.icons ;
    },


    /**
     *   Displays node icons. Users can set this state from options.
     *   @private
     */
    _showIcons  : function ()
    {
       this._data.themes.icons = true;
       this._$container.children("ul").removeClass("oj-tree-no-icons");
    },

    /**
     *   Hides node icons. Users can set this state from options.
     *   @private
     */
    _hideIcons  : function ()
    {
       this._data.themes.icons = false;
       this._$container.children("ul").addClass("oj-tree-no-icons");
    },

    /**
     *   Toggles the display state of node icons. User can set this state from options.
     *   @private
     */
    "toggleIcons" : function ()
    {
/*                                      Not used in V1
       if (this.data.themes.icons) {
         this._hideIcons();
       }
       else  {
         this._showIcons();
       }
*/
    },

    /**
      *   Enables keyboard support
      *   @private
      */
    _enableKeys : function ()
    {
       this._data.keys.enabled = true;
    },

    /**
      *   Disables keyboard support
      *   @private
      */
/*           Not used in V1
    _disableKeys : function ()
    {
       this._data.keys.enabled = false;
    },
*/

    /**
      *   Initializes the widget, examining options and setting up
      *   internal data structures.
      *   @private
      */
     _initTree : function()
     {
        this._initData() ;
        this._initCoreOpts() ;
        this._initUIOpts() ;
        this._initCrrmOpts() ;
        this._initThemeOpts()
        this._initDSOpts(true) ;
        this._initTypeOpts()
        this._initDnDOpts() ;
        this._initMenuOpts() ;

        this._initCore() ;
        this._initUI() ;
        this._initThemes() ;
        this._initDataSource() ;
//        this._initCrrm() ;
        this._initTypes() ;
        this._initDnD() ;
        this._initKeys() ;
        this._initMenu() ;

        this._start() ;
     },


     /**
       *   Emit events
       *   @param {Object} data an object containing details about the event.
       *   @param {string} eventname the raw event name (e.g. "select", or "expandAll".
       *                             When the event is fired, it is "ojselect" and "ojexpandall",
       *                             but also the options "select" and "expandAll" are called.
       *   @private
       */
     _emitEvent : function (data, eventname) 
     { 
        if ((! eventname) || $.type(eventname) !== "string"){
          return ;
        } 

        var rslt,
            func,
            args     = Array.prototype.slice.call(arguments),
            rlbk     = false,
            evname   = eventname,
            inst     = this._$container,
            isBefore = (eventname === "before"),
            isPublic = false,
            item ;

        if ((this._data.core.locked === true) && (eventname !== "unlock")
                                              && (eventname !== "isLocked")
                                              && (eventname !== "lock")) {
          return;
        }

        evname   =  _convertEventName(eventname) ;
        isPublic = _isPublicEvent(evname) ;
        if (! isPublic)  {
          evname = "tree" + evname ;        // internal event
        }

        item = (data? data["obj"] : undefined) ;
        if (evname === "loaded" || evname == "optionChange") {
          item = -1 ;
        }

        //  Trigger the event

        var eventdata = {} ;                       // build the "ui" argument
        eventdata["item"] = item ;
        eventdata["inst"] = inst ;

        if (isBefore) {
          func               = data["func"] ;      // target method
          eventdata["func"]  = func ;
          eventdata["args"]  = args ;
          if (func === "rename") {
            eventdata["title"]     = data["title"] ;
            eventdata["prevTitle"] = data["prevTitle"] ;
          }
        }
        else  if (isPublic) {
          if (evname == "move") {
            eventdata["position"]  = data.p ;      // position relative to the reference node
            eventdata["reference"] = data.r ;      // the reference node
            eventdata["data"]      = data ;        // (req'd internally)
          }
          else if (evname == "rename") {
            eventdata["title"]     = data["title"] ;      // the new node title to be
            eventdata["prevTitle"] = data["prevTitle"] ;  // the current title
          }
          else if (evname == "remove") {            // node was deleted via context menu
            eventdata["parent"]  = data["parent"] ; // parent node
            eventdata["prev"]    = data["prev"] ;   // the "previous" node
          }
          else if (evname == "delete") {            // node was deleted via context menu
            eventdata["prev"]   = data["prev"] ;    // (req'd internally) - the "previous" node
            eventdata["parent"] = data["parent"] ;  // parent node
          }
          else if (evname === "expandAll" || evname === "collapseAll" || evname === "deselectAll") {         
            eventdata["targ"]   = data["targ"] ;    // the target of the op (node or -1)
          }
          else if (evname == "optionChange") {
            eventdata["option"]         = data["option"] ;
            eventdata["previousValue"]  = data["previousValue"] ;
            eventdata["value"]          = data["value"] ;
            eventdata["optionMetadata"] = data["optionMetadata"] ;
          }
        }

        // console.log("Event (" + eventname + ")  " + evname + " isPublic=" + isPublic +
        //                            (isBefore? (" isBefore=true - " + eventdata["func"]) : ""));

        if (isPublic) {
          rslt = this._trigger(evname, new $.Event("oj" + evname), eventdata) ;

          if (isBefore) {
            //  console.log("Event (" + eventname + ") " + eventdata["func"] + " returned " + rslt);
            if (typeof rslt != "undefined") {
              rslt = rslt? true : false ;         // returns true/false/undefined
            }
            return rslt ;
          }
        }
        else {
          this._$container.trigger(evname, eventdata) ;    // internal event
        }
        
     },


     /**
       *  fire optionChange event
       *  @param {string}  key             the option key whose property value has been changed.
       *  @param {Object}  prevVal         the previous value prior to the change 
       *  @param {Object}  newVal          the new value after the change
       *  @param {Event | null} origEvent  false if option change is not due to user interaction.
       *  @private
       */
     _fireOptionChange : function(key, prevVal, newVal, origEvent)
     {
       this._emitEvent({ "option"         : key,
                         "previousValue"  : prevVal,
                         "value"          : newVal,
                         "optionMetadata" : {"writeback" : (origEvent? "shouldWrite" : "shouldNotWrite")}
                       }, "optionChange");
     },


     /**
       *  TDO _not currently used in V1
       *  @private
       */
     __rollback : function ()
     { 
         var
         rlbk = this["get_rollback"]();
         return rlbk;
     },


     /**
       *   To Be Removed  TDO 
       *   @private
       */
     __call_old : function (replace_arguments)
     {
//       return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
     },


     /*
      *  Tree initialization is complete.  Build and render the tree.
      *  @private
      */
     _start : function()
     {
       this.set_focus(); 

       if (this._isRtl) {
         this._$container.addClass("oj-tree-rtl").css("direction", "rtl");
       }

       //  Create the outer <ul> with a temporary <li> saying "Loading..."

       this._$container.html("<ul role='tree' tabindex='0' class='oj-tree-list' style='outline:none'" + 
                    ((this._data.core.selectMode === -1)? " aria-multiselectable='true'" : "") +
                    "><li class='oj-tree-last oj-tree-leaf'><ins class='oj-tree-icon'>&#160;</ins><a class='oj-tree-loading' href='#'><ins class='oj-tree-icon'>&#160;</ins>" + this.getTranslatedString("m_loading") + "</a></li></ul>");

       this._$container_ul = this._$container.children("ul:eq(0)");
       this._$container.data("oj-tree-instance-id", this._getIndex());

       this._data.core.li_height = this._$container_ul.find("li.oj-collapsed, li.oj-tree-leaf")
                                                      .eq(0)
                                                      .height() || 18;

       this._$container
              .delegate(".oj-tree-list ins.oj-tree-disclosure-icon", "click.ojtree", $.proxy(function (event)  {
                     var trgt = $(event.target);
                     // if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
                     this["toggleExpand"](trgt);
                }, this))

              .delegate(".oj-tree-list ins.oj-tree-disclosure-icon", "mousedown", $.proxy(function (event)  {
                     var trgt = $(event.target);
                     trgt.removeClass("oj-default").removeClass(OJ_HOVER).addClass(OJ_SELECTED) ;
                }, this))

              .delegate(".oj-tree-list ins.oj-tree-disclosure-icon", "mouseup", $.proxy(function (event)  {
                     var trgt = $(event.target);
                     trgt.removeClass("oj-selected").addClass("oj-default") ;
                }, this))

              .bind("mousedown.ojtree", $.proxy(function ()  { 
                     this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
                }, this))
              .bind("dblclick.ojtree", function (event)  { 
                     var sel;
                     if (document.selection && document.selection.empty) {
                       document.selection.empty();
                     }
                     else  {
                       if (window.getSelection)  {
                         sel = window.getSelection();
                         try { 
                               sel.removeAllRanges();
                               sel["collapse"](document.getElementsByTagName("body")[0], 0);
                             } catch (err) { }
                       }
                     }
                });

       this._$container_ul
               .focus($.proxy(function(e) {
                        this._data.ui.focused = true ;
                        if (! this._data.core.initFocus) {                       // if first focus
                          this._data.core.initFocus = true ;                     // make top node active
                          var first  = this._$container_ul.find("li:first");
                          this["hover"](first);
                        }
                        else {
                          if (this._data.ui.lastHovered) {
                            this._data.ui.hovered =  this._data.ui.lastHovered ;
                            this["hover"](this._data.ui.hovered);
                            this._data.ui.lastHovered = null ;
                          }
                        // want color change for selected inactive to selected
                        this._$container_ul.find("a.oj-selected").removeClass(OJT_INACTIVE) ;
                        }
                      }, this)
               )
               .blur($.proxy(function(e) {
                        this._data.ui.focused = false ;
                        this._data.ui.lastHovered = this._data.ui.hovered ;
                        if (this._data.ui.lastHovered) {
                          this["dehover"](this._data.ui.hovered) ;
                        }
                        // want color change for selected active to selected inactive
                        this._$container_ul.find("a.oj-selected").addClass(OJT_INACTIVE) ;
                     }, this)
               );

//     Not currently used in V1
//       if (this._data.core.notify_plugins)  {   // TDO is this jstree code needed anymore
//         this._$container
//             .bind("treeload_node", $.proxy(function (e, ui)  { 
//                  var o = this._getNode(ui["item"]),
//                      t = this;
//                  if (o === -1)  {
//                    o = this._$container_ul;
//                  }
//                  if ((!o) || (! o.length))  {
//                    return;
//                  }
//
//                  o.find("li").each(function ()  {
//                       var th = $(this);
//                       if (th.data("oj-tree"))
//                       {
//                         $.each(/** @type {Array} */(th.data("oj-tree")), function (plugin, values)
//                         $.each(th.data("oj-tree"), function (plugin, values)
//                            {
//                               if (t.data[plugin] && $.isFunction(t["_" + plugin + "_notify"]))
//                               if (t["data"][plugin] && $.isFunction(t["_" + plugin + "_notify"]))
//                               if (th["data"][plugin] && $.isFunction(t["_" + plugin + "_notify"])) {
//                                 t["_" + plugin + "_notify"].call(t, th, values);
//                               }
//                            });
//                       }
//                  });
//
//             }, this));
//       }

       if (this._data.core.load_open)   {

         this._$container
            .bind("treeload_node", $.proxy(function (e, ui)  { 
                 var o = this._getNode(ui["item"]),
                     t = this;
                 if (o === -1)  {
                   o = this._$container_ul;
                 }
                 if (!o.length)  {
                   return;
                 }
                 o.find("li.oj-expanded:not(:has(ul))").each(function ()
                     {
                        this._load_node(this, $.noop, $.noop);
                 });
            }, this));
       }

       this._emitEvent({}, "init");    // Tree is now init'd (but nodes have not yet been added)

       this._loadNodes() ;             // start node loading from the datasource

       //  Tree div is now constructed, note if context menu has been set.
       if (this._data.menu.usermenu) {
         this._applyMenu() ;
       }

       // Add this tree's keyboard combination handler
       _addKeyFilter( {
                        _handler : this._keyHandler,
                        _selector: this._$container_ul,
                        _this    : this
                      }) ;
       this._enableKeys();

       this._$container_ul.focus() ;        // set first node as the active element
     },


     /*
      *  Initialize the Core section
      *  @private
      */ 
     _initCore : function()
     {
       this._data.core.locked   = false;

       this._$container.addClass("oj-tree oj-tree-" + this._getIndex()) ;     //TDO TDO

       this._$container.css("outline", "none");
       this._$container.css("MozUserSelect", "none");
       this._$container.css("WebkitTouchCallout", "none");
       this._$container.css("WebkitUserSelect", "none");
       this._$container.css("WebkitTapHighlightColor", "rgba(0,0,0,0)");
     },


    /*
     *  Initialize the UI section
     *  @private
     */
     _initUI : function() 
     {
         this._data.ui.selected      = $(); 
         this._data.ui.last_selected = false; 
         this._data.ui.hovered       = null;
         var a = this.options["selection"] ;
         if (a && ($.type(a) === "array") && a.length > 0) {
           this._data.ui.to_select  = a ;
           this.options["selection"] = [] ;  // will be updated when the selections are performed
         }

        // Bind to events
        this._$container
             .delegate(".oj-tree-list a", "click.ojtree", $.proxy(function (event)
                {
                  event.preventDefault();
                  event.currentTarget.blur();
                  if (!$(event.currentTarget).hasClass("oj-tree-loading"))  {
                    this.set_focus();
                    this._select(event.currentTarget, true, event);
                    this._$container_ul.focus() ;
                  }
                }, this))
             .delegate(".oj-tree-list a", "mouseenter.ojtree", $.proxy(function (event)
                {
                  if (! $(event.currentTarget).hasClass("oj-tree-loading"))  {
                     this["hover"](event.target);
                  }
                }, this))
             .delegate(".oj-tree-list a", "mouseleave.ojtree", $.proxy(function (event)
               {
                  if (! $(event.currentTarget).hasClass("oj-tree-loading"))  {
                    this["dehover"](event.target);
                  }
               }, this))
             .delegate(".oj-tree-list .oj-tree-disclosure-icon", "mouseenter.ojtree", $.proxy(function (event)
                {
                  if (! $(event.currentTarget).hasClass("oj-tree-loading"))  {
                     this._disclosureHover(event.target, true);
                  }
                }, this)) 
             .delegate(".oj-tree-list .oj-tree-disclosure-icon", "mouseleave.ojtree", $.proxy(function (event)
                {
                  if (! $(event.currentTarget).hasClass("oj-tree-loading"))  {
                     this._disclosureHover(event.target, false);
                  }
                }, this))
             .bind("treereopen", $.proxy(function ()
               { 
                 this["reselect"]();
               }, this))
             .bind("treeget_rollback", $.proxy(function ()
               { 
                  this["dehover"]();
                  this["saveSelected"]();
               }, this))
             .bind("treeset_rollback", $.proxy(function ()
               { 
                  this["reselect"]();
               }, this))
             .bind("ojcollapse", $.proxy(function (event, ui)
              { 
                var obj   = this._getNode(ui["item"]),
                    clk   = (obj && obj.length) ? obj.children("ul").find("a.oj-selected") : $(),
                    _this = this;
                if (this.options["selectedParentCollapse"] === false || (! clk.length))  {
                  return;
                }
                clk.each(function ()  { 
                               this["deselect"](this);
                               if (this.options["selectedParentCollapse"] === "selectParent")  {
                                  this["select"](obj);
                               }
                         });
                 }, this))
             .bind("ojremove", $.proxy(function (event, ui)         // node delete 
                { 
                   var s     = this.options["selectPrevOnDelete"],
                       obj   = this._getNode(ui["item"]),
                       clk   = (obj && obj.length) ? obj.find("a.oj-selected") : [],
                       _this = this;

                     clk.each(function ()
                                {
                                   _this["deselect"](this);
                                });
                     if (s && clk.length)
                     { 
                       ui["prev"].each(function ()
                          { 
//Wed3                      if(this.parentNode)
                            if (this["parentNode"])
                            {
                              _this["select"](this);
                              return false;   // if return false is removed all prev nodes will be selected 
                            }
                         });
                     }
                 }, this))
             .bind("ojmove", $.proxy(function (event, ui)
                { 
                   var data = ui["data"] ;
                   if (data["cy"])  { 
                     data["oc"].find("a.oj-selected").removeClass(OJ_SELECTED);
                     data["oc"].removeAttr(WA_SELECTED);
                   }
                 }, this));

     },

     /*
      *  Initialize the data source
      *  @private
      */
     _initDataSource : function()
     {
        this._initTreeData() ;
        this._initJsonData() ;
        this._initHtmlData() ;
     },

     /*
      *  Initialize the tree data source
      *  @private
      */
     _initTreeData : function()
     {
        if (this._data.ds.type === DS_TREE) {
          this._tds        = (this.options["data"] || null) ;     // the tree data source
          this._load_node  = this._load_node_DS ;
          this._is_loaded  = this._is_loaded_DS ;
          this._refresh    = this._refresh_DS ;
       }
     },

     /*
      *  Initialize the json_data section if requested
      *  @private
      */
     _initJsonData : function()
     {
        if (this._data.ds.type === DS_JSON) {
          if (this._data.ds.progressiveUnload)  {
            this._$container.bind("treeafter_close", function (e, ui)  {
                                     ui["item"].children("ul").remove();
                                   });
          }

          this._load_node  = this._load_node_J ;
          this._is_loaded  = this._is_loaded_J ;
          this._refresh    = this._refresh_json ;
        }
     },


     /**
       *  Initialize html_data support if requested.
       *  @private
       */
     _initHtmlData : function()
     {
       if (this._data.ds.type !== DS_HTML) {
         return ;
       }

       this._processExistingMarkup() ;         // check for existing markup in the div

       this._load_node = this._load_node_H ;
       this._is_loaded = this._is_loaded_H ;
       this._refresh   = this._refresh_ui ;
     },


     /**
      *  If there is existing html markup in the div, clone it and move it to another div.
      *  @private
      */
     _processExistingMarkup : function ()
     {
       if (! this._data.html.useExistingMarkup) {
         return ;
       }

       if (! this._data.html.markup_ul) {  // first time find the user <ul>
         this._data.html.markup_ul   = this._$container.find(" > ul");          // user's <ul>

         // Move the user <ul> in the tree div to another div so that it is still in the DOM,
         // and can be located by the app, changed, and refresh() called if desired, and so it
         // will not interfere with the <ul> we maintain for the tree in the tree div. If the
         // app wants to change the markup, it must find its <ul> first and then find node id's
         // from it if it needs to, because the <ul> has been cloned and the id's will
         // therefore be duplicated.
         // TDO - we need to have a better way to do this.
         this._data.html.markup_div  = $("<div id='" +
                                       USER_UL_ID_PREFIX + this._getIndex() +
                                       "' style='display:none'>").append(this._data.html.markup_ul) ;
         this._$container.after(this._data.html.markup_div) ;
       }

       this._data.html.markup      = this._data.html.markup_ul.find(" > li");   // user's <li>'s
       this._data.html.cloneMarkup = this._data.html.markup.clone(true);        // our clone of the <li>'s

       // this used to use html() and clean the whitespace, but this way any attached data was lost
       // remove white space from LI node - otherwise nodes appear a bit to the right
       this._data.html.cloneMarkup.find("li").addBack()
                                             .contents()
                                             .filter(function()
                                                {
                                                  return this.nodeType == 3;
                                                 })
                                             .remove();
     },


     /**
       *  Initialize the Themes section   -  TDO replace with Jet functionality
       *  @private
       */
     _initThemes : function()
     {
        // autodetect themes path
        if (this._data.themes._themes === false)  {
           $("script").each(function ()
            { 
              if( this.src.toString().match(/jquery\.oj-tree[^\/]*?\.js(\?.*)?$/))  { 
                 this._data.themes._themes = this.src.toString().replace(/jquery\.oj-tree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
                 return false; 
              }
            });
        }
        if (this._data.themes._themes === false)    {
          this._data.themes._themes = "themes/";
        }

        this._$container
             .bind("treeinit", $.proxy(function ()
                {
                   var s = this.options ;

                   this._data.themes.dots  = s["dots"]; 
                   this._data.themes.icons = s["icons"]; 
                   this["set_theme"](this._data.themes.theme, this._data.themes.url);

                }, this))

             .bind("ojloaded", $.proxy(function ()
                {
                   // bound here too, as simple HTML tree's won't honor dots & icons otherwise
                   if (! this._data.themes.dots)  {
                     this._hideDots();
                   }
                   else  {
                     this._showDots();
                   }
                   if (!this._data.themes.icons)  {
                     this._hideIcons();
                   }
                   else  {
                     this._showIcons();
                   }
                }, this));

     },


     /*
      *  Initialize the icon type functionality
      *  @private
      */
     _initTypes : function()
     {
        var s = this.options["types"];
        if (! s) {
          return ;
        }

        this._$container
               .bind("treeinit", $.proxy(function ()
                  { 
                    var types     = $.extend(true, {}, s["types"]),
                        attr      = s["attr"] || this._data.types.defaults["attr"],
                        icons_css = "", 
                        _this     = this;

                    $.each(types, function (i, tp)
                       {
                         $.each(tp, function (k, v)
                            { 
                              if (!/^(maxDepth|maxChildren|icon|validChildren)$/.test(k))  {
                                _this._data.types.attachTo.push(k);
                              }
                            });

                         // For ojTree we allow image and position props to not
                         // have to be in an icon object like jsTree.
                         var ot = (typeof tp["icon"]) ;
                         if (ot === "undefined") {
                           ot = (typeof tp["image"]) ;
                           if ((ot === "boolean") && (!tp["image"])) {
                             tp["image"] = "ojt$none" ;
                           }
                           else if ((! tp["image"]) && (! tp["position"])) {
                             return true;
                           }

                           tp["icon"] = {} ;
                           if (tp["image"])  {
                             tp["icon"]["image"] = tp["image"]; 
                             delete tp["image"] ;
                           } 

                           if (tp["position"] !== undefined)  {
                             tp["icon"]["position"] = tp["position"] ;
                             delete tp["position"] ;
                           }
                         }    

                         if ( tp["icon"]["image"] || tp["icon"]["position"])  {
                           if (i == "default")  {
                             _this._data.types.defType = true ;     // note that the "default" type has been defined                             icons_css += '.oj-tree-' + _this._getIndex() + ' a > .oj-tree-icon { ';
                             icons_css += '.oj-tree-' + _this._getIndex() + ' .oj-tree-list a > .oj-tree-node-icon { ';
                             icons_css += _this._addTypeCss(tp, icons_css) ;
                             icons_css += '} ';
                             icons_css += '.oj-tree-' + _this._getIndex() + ' .oj-tree-list li[' + attr + '="oj-tree-deftype"] > a .oj-tree-node-icon { ';
                           }
                           else if (tp["icon"]["image"]) {
                             icons_css += '.oj-tree-' + _this._getIndex() + ' .oj-tree-list li[' + attr + '="' + i + '"] > a > ins.oj-tree-node-icon { ';
                           }

                           icons_css += _this._addTypeCss(tp, icons_css) ;
                           icons_css += '} ';
                         }
                    });

                    if (icons_css !== "")  {
                      _addSheet({ str : icons_css, title : "oj-tree-types" });
                    }
                   }, this))
               .bind("ojbefore", $.proxy(function (e, data)
                  { 
                     var s,
                         ty, 
                         func = data["func"],
                         item = data["item"],
                         o = this._data.types.defaults["useData"] ? this._getNode(item) : false, 
                         d = (o && o !== -1 && o.length)? o.data("oj-tree") : false;

                     if (d && d["types"] && d[func] === false)
                     {
                       e.stopImmediatePropagation();
                       return false;
                     }

                     if ($.inArray(func, this._data.types.attachTo) !== -1)  {
                       if (!data["item"] || (!data["item"]["tagName"] && !data["item"]["jquery"]))  {
                         return;
                       }
                       s   = this.options["types"]["types"];
                       ty  = this._getType(item);             // get "type" attr name for node

                       if (( (s[ty] && typeof s[ty][func] !== "undefined") || 
                             (s["default"] && typeof s["default"][func] !== "undefined") 
                            ) && this._check(func, item) === false)  {
                         e.stopImmediatePropagation();
                         return false;
                       }
                     }

                  }, this));
     },

     /**
       *  Add css for the type.
       *  @private
       */
     _addTypeCss : function(tp)
     {
         var css = "" ;

         if (tp["icon"]["image"] !== "ojt$none")  {
           css += ' background-image:url(' + tp["icon"]["image"] + '); ';
         }
         else  {
           css += " background-image:none; ";
         }

         if (tp["icon"]["position"])  {
           css += ' background-position:' + tp["icon"]["position"] + '; ';
         }
         else  {
           css += ' background-position:0 0; ';
         }
         return css ;
     },

     /*
      *  Initialize Drag and Drop functionality.  TDO - this will change to HTML5 drag/drop post V1.0
      *  @private
      */
     _initDnD : function()
     {
        if (! this._data.dnd.reorder) {          // only handling a temporary version
          return ;                               // of Dnd for reorder within the tree.
        }
  
        var vars = this._data.dnd.vars ;
        vars.m =                                 // dnd insertion point marker
         $("<div class='oj-tree-marker'><span class='oj-tree-ptr oj-component-icon'>&#160;</span></div>")              // dnd insertion point marker
            .hide()
            .bind("mouseleave mouseenter", $.proxy(function (e) { 
                var vars = this._data.dnd.vars ;
                vars.m.hide();
                vars.ml.hide();
                e.preventDefault(); 
                e.stopImmediatePropagation(); 
                return false; 
            }, this))
            .appendTo("body");

        vars.ml = $("<div />")                   // dnd insert point marker line
            .addClass(OJT_MARKER_LINE)
            .hide()
            .bind("mouseup", function (e) { 

               var vars = this._data.dnd.vars ;

               if (vars.r && vars.r.length) { 
                  vars.r.children("a").trigger(e); 
                  e.preventDefault(); 
                  e.stopImmediatePropagation(); 
                  return false; 
               } 
            })
            .bind("mouseleave", $.proxy(function (e)  { 

                var vars = this._data.dnd.vars ;
                var rt = $(e.relatedTarget);

                if (rt.is(".oj-tree") || rt.closest(".oj-tree").length === 0) {
                    if (vars.r && vars.r.length) { 
                        vars.r.children("a").trigger(e); 
                        vars.m.hide();
                        vars.ml.hide();
                        e.preventDefault(); 
                        e.stopImmediatePropagation(); 
                        return false; 
                    }
                }
            }, this))
            .appendTo("body");

        this._data.dnd.ml_width = vars.ml.width() ;    // marker line width from style

        $(document).bind("drag_start.ojtreeu", $.proxy(function (e, data)
            {
             var vars = this._data.dnd.vars ;

             if (data.data.jstree)  {
                vars.m.show();
                if (vars.ml)  {
                   vars.ml.show();
                 }
             }
           }, this));

        $(document).bind("drag_stop.ojtreeu", $.proxy(function (e, data)
           {
              var vars = this._data.dnd.vars ;

              if (data.data.jstree)  {
                vars.m.hide();
                if (vars.ml) {
                  vars.ml.hide();
                }
              }
           }, this));

        this._getContainer()
            .bind("mouseenter.ojtree", $.proxy(function (e)
                {
                  var  ctl  = this._data.dnd.ctl,
                       vars = this._data.dnd.vars ;

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    if (this.options["themes"]) {
                      vars.m.addClass("oj-tree-" + this._data.themes.theme); 
                      if (vars.ml) {
                        vars.ml.addClass("oj-tree-" + this._data.themes.theme);
                      }
                      ctl.helper.addClass("oj-tree-dnd-helper oj-tree-" + this._data.themes.theme);
                    }
                      //if($(e.currentTarget).find("> ul > li").length === 0) {
                    if (e.currentTarget === e.target && ctl.user_data.obj &&
                        $(ctl.user_data.obj).length && $(ctl.user_data.obj).parents(".oj-tree:eq(0)")[0] !== e.target)
                    {
                      // node should not be from the same tree
                      var tr = this._reference(e.target),   //TDO
                          dc;

                      if (tr.data.dnd.foreign) {
                        dc = tr.options["dnd"]["drag_check"].call(this, { "o" : vars.o, "r" : tr._getContainer(), "is_root" : true });
                         if (dc === true || dc["inside"] === true || dc["before"] === true || dc["after"] === true)  {
                           ctl.helper.children("ins").removeClass(OJT_DROP_INVALID)
                                                     .addClass(OJT_DROP_OK);
                           $("body").removeClass("oj-tree-invalid-drop") ;       // set cursor
                           if (vars.o) {
                             vars.o.removeClass(OJ_INVALID_DROP)
                                   .addClass(OJ_VALID_DROP) ;
                           }
                         }
                      }
                      else {
                         tr._prepare_move(vars.o, tr._getContainer(), "last");
                         if (tr["check_move"]()) {
                           ctl.helper.children("ins").removeClass(OJT_DROP_INVALID)
                                                     .addClass(OJT_DROP_OK);
                           $("body").removeClass("oj-tree-invalid-drop") ;       // set cursor
                           if (vars.o) {
                             vars.o.removeClass(OJ_INVALID_DROP)
                                   .addClass(OJ_VALID_DROP) ;
                           }
                         }
                      }
                    }
                  }
                 }, this))
            .bind("mouseup.ojtree", $.proxy(function (e)
               {
                  var vars = this._data.dnd.vars,
                      ctl = this._data.dnd.ctl ;       // jsTree helper class

                  if (ctl.is_drag && ctl.user_data.jstree && e.currentTarget === e.target  &&
                                     ctl.user_data.obj    && $(ctl.user_data.obj).length   &&
                                     $(ctl.user_data.obj).parents(".oj-tree:eq(0)")[0] !== e.target)
                  {  // node should not be from the same tree
                      var tr = this._reference(e["currentTarget"]),
                          dc;
                      if (tr["data"]["dnd"]["foreign"])  {
                        dc = tr._getOptions()["dnd"]["drag_check"].call(this, { "o" : vars.o, "r" : tr._getContainer(), "is_root" : true });
                        if (dc === true || dc["inside"] === true || dc["before"] === true || dc["after"] === true)
                        {
                           tr._getOptions()["dnd"]["drag_finish"].call(this, { "o" : vars.o, "r" : tr._getContainer(), "is_root" : true });
                        }
                      }
                      else  {
                         tr._move_node(vars.o, tr._getContainer(), "last", e[tr.options["dnd"]["copy_modifier"] + "Key"]);
                      }
                  }
                 }, this))
            .bind("mouseleave.ojtree", $.proxy(function (e)
               {
                  var ctl = this._data.dnd.ctl ;       // dnd helper object

                  if (e.relatedTarget && $(e.relatedTarget).hasClass(OJT_MARKER_LINE))  {
                    return false; 
                  }
                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    if (this._data.dnd.i1) {
                       clearInterval(this._data.dnd.i1);
                    }
                    if (this._data.dnd.i2) {
                      clearInterval(this._data.dnd.i2);
                    }
                    if (this._data.dnd.to1)  {
                      clearTimeout(this._data.dnd.to1);
                    }
                    if (this._data.dnd.to2) {
                      clearTimeout(this._data.dnd.to2);
                    }
                    if (ctl.helper.children("ins").hasClass(OJT_DROP_OK))  {
                      ctl.helper.children("ins").removeClass(OJT_DROP_OK)
                                                .addClass(OJT_DROP_INVALID);
                      $("body").addClass("oj-tree-invalid-drop") ;              // set cursor

                      if (this._data.dnd.vars.o) {
                        this._data.dnd.vars.o.removeClass(OJ_VALID_DROP)
                                             .addClass(OJ_INVALID_DROP) ;
                      }
                    }
                  }
                }, this))
            .bind("mousemove.ojtree", $.proxy(function (e)
               {
                  var ctl = this._data.dnd.ctl ;       // get the dnd helper object

                  if (ctl.is_drag && ctl.user_data.jstree) {
                    var cnt = this._getContainer()[0];

                    // Horizontal scroll
                    if (e.pageX + 24 > this._data.dnd.cof.left + this._data.dnd.cw) {
                      if (this._data.dnd.i1) {
                        clearInterval(this._data.dnd.i1);
                      }
                      this._data.dnd.i1 = setInterval($.proxy(function () {
                                                   this.scrollLeft += ctl.scroll_spd;
                                                 }, cnt), 100);
                    }
                    else if (e.pageX - 24 < this._data.dnd.cof.left)  {
                      if (this._data.dnd.i1) {
                        clearInterval(this._data.dnd.i1);
                      }
                      this._data.dnd.i1 = setInterval($.proxy(function () {
                                                this.scrollLeft -= ctl.scroll_spd;
                                              }, cnt), 100);
                    }
                    else   {
                      if (this._data.dnd.i1)  {
                        clearInterval(this._data.dnd.i1);
                      }
                    }

                    // Vertical scroll
                    if (e.pageY + 24 > this._data.dnd.cof.top + this._data.dnd.ch)  {
                      if (this._data.dnd.i2)  {
                        clearInterval(this._data.dnd.i2);
                      }
                      this._data.dnd.i2 = setInterval($.proxy(function () {
                                                this.scrollTop += ctl.scroll_spd;
                                             }, cnt), 100);
                    }
                    else if (e.pageY - 24 < this._data.dnd.cof.top) {
                        if (this._data.dnd.i2)  {
                          clearInterval(this._data.dnd.i2);
                        }
                        this._data.dnd.i2 = setInterval($.proxy(function () {
                                                 this.scrollTop -= ctl.scroll_spd;
                                               }, cnt), 100);
                    }
                    else   {
                       if (this._data.dnd.i2) {
                         clearInterval(this._data.dnd.i2);
                       }
                    }

                  }
                }, this))
            .bind("scroll.ojtree", $.proxy(function (e)
               { 
                  var ctl  = this._data.dnd.ctl,        // get the dnd helper object
                      vars = this._data.dnd.vars ; 

                  if (ctl.is_drag && ctl.user_data.jstree && vars.m && vars.ml)  {
                     vars.m.hide();
                     vars.ml.hide();
                  }
                }, this))
            .delegate(".oj-tree-list a", "mousedown.ojtree", $.proxy(function (e)
                { 
                  if (e.which === 1) {
                    this._start_drag(e.currentTarget, e);
                    return false;
                  }
                }, this))
            .delegate(".oj-tree-list a", "mouseenter.ojtree", $.proxy(function (e)
                { 
                  var ctl = this._data.dnd.ctl ;        // get the dnd helper object

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    this._dnd_enter(e.currentTarget);
                  }
                }, this))
            .delegate(".oj-tree-list a", "mousemove.ojtree", $.proxy(function (e)
                { 
                  var  ctl  = this._data.dnd.ctl,       // get the dnd helper object
                       vars = this._data.dnd.vars ;

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                     if (! vars.r || ! vars.r.length || vars.r.children("a")[0] !== e.currentTarget) {
                         this._dnd_enter(e.currentTarget);
                     }
                     if (typeof this._data.dnd.off.top === "undefined") {
                       this._data.dnd.off = $(e.target).offset();
                     }
                     if (typeof this._data.dnd.off.top === "undefined")  {
                       this._data.dnd.off = $(e.target).offset();
                     }

                     this._data.dnd.w = (e.pageY - (this._data.dnd.off.top || 0)) % this._data.core.li_height ;

                     if (this._data.dnd.w < 0)   {
                       this._data.dnd.w += this._data.core.li_height;
                     }
                     this._dnd_show();
                  }
                }, this))
            .delegate(".oj-tree-list a", "mouseleave.ojtree", $.proxy(function (e)
                { 
                  var ctl  = this._data.dnd.ctl,        // get the dnd helper object
                      vars = this._data.dnd.vars ;

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                     if (e.relatedTarget && $(e.relatedTarget).hasClass(OJT_MARKER_LINE))  {
                       return false; 
                     }
                     if (vars.m) {
                        vars.m.hide();
                     }
                     if (vars.ml) {
                       vars.ml.hide();
                     }
                     /*
                     var ec = $(e.currentTarget).closest("li"), 
                         er = $(e.relatedTarget).closest("li");
                     if(er[0] !== ec.prev()[0] && er[0] !== ec.next()[0]) {
                         if(m) { m.hide(); }
                         if(ml) { ml.hide(); }
                     }
                     */

                     this._data.dnd.mto = setTimeout( (function (t) {
                                                         return function () {
                                                                   t._dnd_leave(e);
                                                                };
                                                       })(this), 0);
                  }
                }, this))
            .delegate(".oj-tree-list a", "mouseup.ojtree", $.proxy(function (e)
                { 
                  var ctl = this._data.dnd.ctl ;       // get the dnd helper object

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    this._dnd_finish(e);
                  }
                }, this));

            $(document)
                .bind("drag_stop.ojtreeu", $.proxy(function ()
                   {
                     var dnd  = this._data.dnd,
                         vars = this._data.dnd.vars ;

                     if (dnd.to1) {
                       clearTimeout(dnd.to1);
                     }
                     if (dnd.to2) {
                       clearTimeout(dnd.to2);
                     }
                     if (dnd.i1)  {
                       clearInterval(dnd.i1);
                     }
                     if (dnd.i2)  {
                       clearInterval(dnd.i2);
                     }

                     dnd["after"]   = false;
                     dnd["before"]  = false;
                     dnd["inside"]  = false;
                     dnd.off        = false;
                     dnd.prepared   = false;
                     dnd.w          = false;
                     dnd.to1        = false;
                     dnd.to2        = false;
                     dnd.i1         = false;
                     dnd.i2         = false;
                     dnd.active     = false;
                     dnd.foreign    = false;

                     if (vars.m) {
                       vars.m.css({ "top" : "-2000px" });
                     }
                     if (vars.ml) {
                       vars.ml.css({ "top" : "-2000px" });
                     }
                   }, this))
                .bind("drag_start.ojtreeu", $.proxy(function (e, data)
                   {
                      if (data.data.jstree) { 
                        var et = $(data.event.target);
                        if (et.closest(".jstree").hasClass("oj-tree-" + this._getIndex())) {
                          this._dnd_enter(et);
                        }
                      }
                   }, this));

                /*
                .bind("keydown.jstree-" + this.get_index() + " keyup.jstree-" + this.get_index(), $.proxy(function(e) {
                        if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && !this.data.dnd.foreign) {
                            var h = $.vakata.dnd.helper.children("ins");
                            if(e[this._get_settings().dnd.copy_modifier + "Key"] && h.hasClass("jstree-ok")) {
                                h.parent().html(h.parent().html().replace(/ \(Copy\)$/, "") + " (Copy)");
                            } 
                            else {
                                h.parent().html(h.parent().html().replace(/ \(Copy\)$/, ""));
                            }
                        }
                    }, this)); */



            var s = this.options["dnd"];
            if (s["drag_target"])
            {
               $(document)
                   .delegate(s["drag_target"], "mousedown.ojtree-" + this._getIndex(), $.proxy(function (e) {

                       var ctl  = this._data.dnd.ctl,
                           dnd  = this._data.dnd,
                           vars = this._data.dnd.vars ;

                       vars.o = e.target;

                       this._drag_start(e, { jstree : true,
                                             obj    : e.target
                                           }, "<ins class='oj-tree-icon'></ins>" + $(e.target).text());
                       if (this._data.themes) { 
                         if (vars.m) {
                            vars.m.addClass("oj-tree-" + this._data.themes.theme);
                         }
                         if (vars.ml) {
                           vars.ml.addClass("oj-tree-" + this._data.themes.theme);
                         }
                         ctl.helper.addClass("oj-tree-dnd-helper oj-tree-" + this._data.themes.theme); 
                       }

                       ctl.helper.children("ins").removeClass(OJT_DROP_OK)
                                                 .addClass(OJT_DROP_INVALID);
                       $("body").addClass("oj-tree-invalid-drop") ;            // set cursor

                       if (vars.o) {
                         vars.o.removeClass(OJ_VALID_DROP)
                               .addClass(OJ_INVALID_DROP) ;
                       }

                       var cnt     = this._getContainer();
                       dnd.cof     = cnt.offset();
                       dnd.cw      = parseInt(cnt.width(),10);
                       dnd.ch      = parseInt(cnt.height(),10);
                       dnd.foreign = true;
                       e.preventDefault();
                   }, this));
            }

            if (s["drop_target"])
            {
                $(document)
                    .delegate(s["drop_target"], "mouseenter.ojtreex-" + this._getIndex(), $.proxy(function (e)
                         {
                           var dnd  = this._data.dnd,
                               vars = this._data.dnd.vars ;

                           if (dnd.active && this.options["dnd"]["drop_check"].call(this, { "o" : vars.o, "r" : $(e.target), "e" : e }))  {
                             dnd.ctl.helper.children("ins")
                                           .removeClass(OJT_DROP_INVALID)
                                           .addClass(OJT_DROP_OK);
                             $("body").removeClass("oj-tree-invalid-drop") ;      // set cursor

                             if (vars.o) {
                               vars.o.removeClass(OJ_INVALID_DROP)
                                     .addClass(OJ_VALID_DROP) ;
                             }
                            }
                        }, this))
                    .delegate(s["drop_target"], "mouseleave.ojtree-" + this._getIndex(), $.proxy(function (e)
                        {
                           if (this._data.dnd.active)  {
                             this._data.dnd.ctl.helper.children("ins")
                                                      .removeClass(OJT_DROP_OK)
                                                      .addClass(OJT_DROP_INVALID);
                             $("body").addClass("oj-tree-invalid-drop") ;       // set cursor
                            }
                        }, this))
                    .delegate(s["drop_target"], "mouseup.ojtreex-" + this._getIndex(), $.proxy(function (e)
                       {
                         var vars = this._data.dnd.vars ;

                         if (this._data.dnd.active && this._data.dnd.ctl.helper.children("ins").hasClass(OJT_DROP_OK))  {
                           this.options["dnd"]["drop_finish"].call(this, { "o" : vars.o, "r" : $(e.target), "e" : e });
                         }
                        }, this));
            }

          // TDO

     },


     /**
       *  Process Drag and Drop options.
       *  @private
       */
     _initDnDOpts : function()
     {
        this._data.dnd.reorder = false ;

        var opts = this.options["dnd"],
            ot   = (typeof opts),
            bFixup = true ;

        if (ot === "object") {
          opts = opts["reorder"] ;
          if (typeof opts === "string") {
            if (opts === "enable") {
              this._data.dnd.reorder = true ;
              bFixup = false ;
            }
            else if (opts == "disable") {
              bFixup = false ;
            }
          }
        }

        if (this._data.dnd.reorder) {
          //  Add our default requirements until these are made public and can be
          //  defined in options.
          this.options["dnd"] = {} ;
          this._applyDefaults(this.options["dnd"], this._data.dnd.defaults) ;
          this.options["dnd"]["reorder"] = "enable" ;
        }
        else {
          if (bFixup) {
            this.options["dnd"] = {"reorder" : "disable"} ;
          }
        }
     },


     /*
      *  Initialize the context menu cut/copy/paste/remove/rename support.
      *  @private
      */
/*                                Not currently used in V1
     _initCrrm :  function()
     {
        this._$container
                .bind("ojmove",
                     $.proxy(function (e, data)
                               {
                                 //if (this.options["crrm"]["move"]["openOnMove"])
                                 if (this._data.crrm.defaults["move"]["openOnMove"]) {
                                   var t = this;
//  Tue4
//                                 data.rslt.np.parentsUntil(".oj-tree").addBack()
//                                                                      .filter(".oj-tree-closed")
//                                                                      .each(function ()
//                                                                        {
//                                                                         t["expand"](this, false, true);
//                                                                        });
// Tue4
                                 }
                               }, this));

     },
*/

     /**
       *  Initialize keyboard support
       *  @private
       */
     _initKeys  :  function()
     {
     },


     /**
       *  Initialize the context menu.  This is called on startup, or on option
       *  "contextMenu" change.
       *  @param {Object=} newVal   true if called because of an option change.
       *  @private
       */
     _initMenu : function(newVal)
     {
       var  menu, t, html, $html ;

// Temp code for M6 to clear bug 18712968.  Once the new methods
// are in place via Max and Jim, this whole mechanism will change. 

if ((! newVal) && (! this.options["contextMenu"])) {
 menu = this._$container.attr("contextmenu") ;   // check for attribute
 if (menu) {
   this.options["contextMenu"] = "#" + menu ;
 }
}

       if ((! newVal) && (! this.options["contextMenu"])) {
         return ;
       }

       menu =  newVal || this.options["contextMenu"] ;
       t = $.type(menu) ;
       if (t == "function") {
         try {
            menu = menu() ;             // call user's method to get the context menu
         }
         catch (e) {
            menu = null;
         }
         t = $.type(menu) ;
       }

       if (t !== "string") {
         return ;      // unknown
       }

       var $m = $(menu) ;                    // get the user's <ul> list   
       if ($m) {
         $m.css("display", "none") ;         // ensure it's not visible
         var  dm       = this._data.menu ;
         dm.$container = $m ;
         dm.usermenu   = true ;              // have a context menu
       }
       
       if (this._data.menu.usermenu) {       // if we have a context menu
         if (newVal) {                       // and it is being changed
           this._applyMenu() ;               // complete menu creation/attachnment
         }
       }

       //  If not a new val from options, Menu will be noted at the end of initialization in _start()
     },


     /**
       *  Note the tree node that the menu has just been activated on.  Also note
       *  the associated Tree Id in case the app has multiple Tree's and is
       *  sharing a context menu with all of them.
       *  @private
       */
     _handleContextMenuBeforeShow: function(e, ui)
     {
        var ev = e['originalEvent']['originalEvent'];

        if (ev['type'] === 'keydown') {
          this._data.menu.node   = this._data.ui.hovered ;
        }
        else  {
           this._data.menu.node  = $(e.originalEvent.target.parentNode) ;
        }
        this._data.menu.treeDivId = this._data.menu.node.closest("div").attr("id") ;
        
        // TODO: Should set "of" only for keyboard, like Table/DataGrid do, so that 
        // for right-clicks the menu is positioned at the event.  And for keyboard launch, 
        // horizontal alignment seems too far to the left typically.
        // TODO: Rather than setting "position" in this beforeOpen listener, probably better to 
        // override _OpenContextMenu() and pass "position" in its call to menu.open().  That way, 
        // if the app wants to tweak the position in its beforeOpen listener, its success 
        // doesn't depend on who gets their listeners registered first.
        ui.openOptions.position = {"my" : "start top",
                                   "at" : "start bottom",
                                   "of" : this._data.menu.node[0]};

        // Set menu "Paste" disable state, depending on whether there's been a
        // previous "cut"/"copy"
        if (this._data.menu.usermenu && this._data.menu.$elemPaste) {

          var state         = this._data.menu.$elemPaste.hasClass(OJ_DISABLED) ;
          var disabledState = (! this._data.crrm.ct_nodes && !this._data.crrm.cp_nodes) ;

          if (! state) {
            state = false ;      // in case undefined
          }
          if (state != disabledState) {
            if (disabledState) {
              this._data.menu.$elemPaste.addClass(OJ_DISABLED) ;
            }
            else {
              this._data.menu.$elemPaste.removeClass(OJ_DISABLED) ;
            }
            this._data.menu.$container.ojMenu("refresh") ;
          }
        }

     },

     /**
       *   Check menu selected to see if it one of our predefined remove/cut/copy/paste id's
       *   @private
       */
     _handleContextMenuSelect: function(ev, ui)
     {
        //  Make sure its a menu ojselect and not from ojTree
        if (ui["inst"]) {
          return ;
        }

        // There may be multiple trees sharing (and thereby listening to) the same 
        // context menu.  Check that this tree is the same as the tree on which the
        // menu was invoked.
        if (this._data.menu.treeDivId != this._elemId.substr(1)) {
          return ;
        }

        var  id = ui? ui.item.attr("id") : undefined ;

        if (id === "ojtreecopy") {
          this._crrm_copy(this._data.menu.node);
        }
        else if (id === "ojtreecut") {
          this._crrm_cut(this._data.menu.node);
        }
        else if (id === "ojtreepaste") {
          this._crrm_paste(this._data.menu.node);
        }
        else if (id === "ojtreeremove") {
          if (this["isSelected"](this._data.menu.node)) {
            this._crrm_remove();
          }
          else {
           this._crrm_remove(this._data.menu.node);
          }
        }
        else if (id === "ojtreerename") {
          this._crrm_rename(this._data.menu.node);
        }
        else if (id === "ojtreecreate") {
          this._crrm_create(this._data.menu.node);
        }
     },

    /*
     *  Ensure that focus returns to the tree if the menu is dismissed in
     *  some way via the keyboard.  This is temporary and is awaiting the general
     *  proposal from Pavitra re each component having a .focus() method.
     */
    _OpenContextMenu: function(menu, event)
     {
       menu.open(event, {"launcher": this._$container_ul, "initialFocus": "menu"});
     },


     /**
       *  Process Core options
       *  @private
       */
     _initCoreOpts : function()
     {
        var val = this.options["selectionMode"] ;

        val = (val == undefined)? "single" : val ;
        if (val === "none") {
          val = 0 ;
        }
        else if (val === "single") {
          val = 1;
        }
        else if (val === "multiple") {
          val = -1 ;
        }
        this._data.core.selectMode = val ;

        this._data.themes.icons = this.options["icons"] ;

        this._data.core.toExpand = this._varCopy(this.options, "initExpanded");  
        if (this._data.core.toExpand == null) {
          this._data.core.toExpand = [] ;
        }
        this._data.core.toLoad = this.options["initLoaded"];
/*
        val = this.options["htmlTitles"] ;              // not currently exposed
        if (typeof val == "boolean") {
          this._data.core.htmlTitles = val ;
        }
*/
     },


     /**
       *  Process UI type options
       *  @private
       */
     _initUIOpts : function()
     {
     },

     /**
       *  Process data source options
       *  @private
       */
     _initDSOpts : function(bInit)
     {
        var s = this.options["data"],
            dt,
            ot ;

        this._data.ds.type = DS_NONE ;
        this._data.html.useExistingMarkup  = false ;
        this._data.html.cloneMarkup        = false ;
        //  _data.html.markup_ul, _data.html.markup and  _data.html.markup_div
        // are left intact for destroy.

        if (s) {
          ot = $.type(s) ;
          if (ot === "string") {
           if (this._isHtml(s)) {
             this._data.ds.type = DS_HTML ;          // we have an non-Tree DS html source
           }
           else {
             this._data.ds.type = DS_JSON ;          // we have a non-tree DS json source
             this._initJsonOpts() ;
           }
          }
          else if (ot === "array") {
             //  we have an array of local json objects
             this._data.ds.type = DS_JSON ;          // we have a non-tree DS json source
          }
          else if (ot === "object") { 
             try
             {                                           // don't crash if no ojdatacollection-common
               if (s instanceof oj.JsonTreeDataSource) {
                 this._data.ds.type = DS_TREE ;          // we have a tree DS source
               }
             }
             catch(e)
             {
                this._data.ds.type = DS_ERROR
             } ;
             if (this._data.ds.type !== DS_TREE) {
               try
               {                                           // don't crash if no ojtree-model
                  if (s instanceof oj.CollectionTreeDataSource) {
                    this._data.ds.type = DS_COLLECTION ;   // we have a tree DS source
                  }
               }
               catch(e)
               {
                  this._data.ds.type = DS_ERROR
               } ;
             }
             if ((this._data.ds.type === DS_TREE)   ||
                 (this._data.ds.type === DS_COLLECTION))  {
               this._initTreeDSOpts() ;
             }
             else {
               if (s["data"] || s["ajax"])  {
                 dt = s["dataType"] ;
                 if (dt) {
                   if (dt === "json") {
                     this._data.ds.type = DS_JSON ;    // we have a non-tree DS json source
                     this._initJsonOpts() ;
                   }
                   else if (dt === "html") {
                     this._data.ds.type = DS_HTML ;    // we have a non-tree DS html source
                     this._initHtmlOpts() ;
                   }
                 }
                 else {
                   s["dataType"]      = "json" ;
                   this._data.ds.type = DS_JSON ;      // we have a non-tree DS json source
                   this._initJsonOpts() ;
                 }
               }
             }
          }
        }

        //  If no data defined, see if there is initial user markup in the div
        if (bInit && this._data.ds.type == DS_NONE) {
          if (this._$container.find("ul").length > 0) {
            this._data.ds.type                = DS_HTML ; // note we have an non-Tree DS html source
            this._data.html.useExistingMarkup = true ;
          }
        }
     },

     /**
       *  Process Tree DataSource options
       *  @private
       */
     _initTreeDSOpts : function()
     {
     },

     /**
       *  Process json_data options
       *  @private
       */
     _initJsonOpts : function()
     {
     },


     /**
       *  Process html_data options
       *  @private
       */
     _initHtmlOpts : function()
     {
     },

     /**
       *  Process cut/copy/paste/rename/remove options
       *  @private
       */
     _initCrrmOpts : function()
     {
       //if (this.options["crrm"] == undefined)  {
         //  Will use our defaults until these are made public and can be
         //  defined in options.
         //  this._applyDefaults(this.options["crrm"], this._data.crrm.defaults) ;
       //}

     },

     /**
       *  Process context menu options
       *  @private
       */
     _initMenuOpts : function()
     {
     },

     /**
       *  Process theme options
       *  @private
       */
     _initThemeOpts : function()
     {
       //  Themes support not yet published
     },


     /**
       *  Process node type options
       *  @private
       */
     _initTypeOpts  : function()
     {
       var opts ;
       var o = this.options["types"] ;

//     For V1, there are no default options that we publish
//     if (typeof o === "object") {
//       //  Add our default requirements until these are made public and can be
//       //  defined in options.
//       this._applyDefaults(this["options"]["types"], this._data.types.defaults) ;
//     }
       if (typeof o === "object") {
         this._applyDefaults(o, {"attr" : this._data.types.defaults["attr"]}) ;
       }
     },

     /**
       *  Set/reset the initExpanded opts
       *  @private
       */
     _initExpandedOpts : function()
     {
        this._data.core.toExpand = this._varCopy(this.options, "initExpanded");  
        if (this._data.core.toExpand == null) {
          this._data.core.toExpand = [] ;
        }
     },

     /**
       *  Set up tree instance data
       *  @private
       */
     _initData : function()
     {
        //  Establish working values, and define default values

        var data = this._data ;
         
        //  Core
        data.core  =  {
                        htmlTitles     : false,      // this option not currently exposed
                        initLoaded     : [],
                        selectMode     : 1,          //  0, 1, 2 ... or -1 for unlimited
                        load_open      : false,
                        li_height      : 0,
                        notify_plugins : false,       // TDO
                        toExpand       : false,
                        toLoad         : false,
                        prepared_move  : {},         // for the move_node function
                        initFocus      : false       // On first focus, select top node
                      };

        // UI
        data.ui =  {
                      selected          :  $(),       // selected node jquery list
                      last_selected     :  false,
                      hovered           :  null,      // currently hovered
                      lastHovered       :  null,      // last hovered before blur
                      to_select         :  null,      // initial selection in options:selection
                      opacity           : 1,          // used by disable/_lock()
                      spacebar          : false,      // true if select caused by keybd (toggles)
                      focused           : false       // tree has focus
                   };

        data.ui.defaults = {                          // default values not yet published or suppressed
                                                      // design committee 
                             "selectMultipleModifier"  :  "ctrl" ,      // on, or ctrl, shift, alt
                             "selectRangeModifier"     :  "shift" ,
                             "disableSelectingChildren" :  false
                           } ;


        //  Creating/renaming/removing/moving via context menu

        data.crrm = {} ;
        data.crrm.cp_nodes = false;     // nodes that have been copy'd
        data.crrm.ct_nodes = false;     // node(s) that have been cut
        data.crrm.defaults = {
                               "inputWidthLimit" : 200,
                               "move"            : {
                                                     "alwaysCopy"       : false, // false, true or "multitree"
                                                     "openOnMove"       : true,
                                                     "defaultPosition"  : "last",
                                                     "checkMove"        : function (m) {
                                                                             return true;
                                                                          }
                                                   }
                             };
        data.crrm.prepared_move = {} ;   // for the move node function

        // Data Source

        data.ds = {} ;
        data.ds.progressiveRender = false ;       // options not currently exposed
        data.ds.progressiveUnload = false ;
        data.ds.correctState      = true ;

        data.ds.type              = DS_NONE ;     // type of data source (DS_TREE, DS_JSON, DS_HTML)

        //  json data source

        data.json = {} ;
        data.json.defaults = {
                               "data"  : false,   // `data` can be a function:
                                                  //  accepts two arguments - node being loaded
                                                  //  and a callback to pass the result to,
                                                  //  & ajax won't be supported
                               "ajax"  : false
                             } ;

        // html data source

       data.html = {} ;
       data.html.defaults = {
                              "data"   : false,   // `data` can be a function:
                              "ajax"   : false
                            };

       data.html.useExistingMarkup  = false ;  // true == use existing div markup
       data.html.markup_ul          = false ;  // user's <ul>
       data.html.markup_div         = false ;  // the add dive used to store th user's <ul>
       data.html.markup             = false ;  // the user's markup ( <li>'s )
       data.html.cloneMarkup        = false ;  // our clone of user's orig markup <li's>


        //  Themes

        data.themes       = {} ;
        data.themes.icons = true ;
        data.themes.dots  = false ;
        data.themes.theme = "default" ;
        data.themes.url   = false ;

        data.themes.themes_loaded = [];
        data.themes._themes = false;   //  path to themes folder - if false - it will be autodetected

        //  Types

        data.types           = {} ;
        data.types.attachTo  = [];
        data.types.defType   = false ;                    // true if "default" type defined
        data.types.defaults  = {                                 //  Options not published in V1
                                 "maxChildren"         : -1,     // defines max number of root nodes
                                                                 // (-1 = unlimited, -2 = disable maxChildren checking)
                                 "maxDepth"            : -1,     //  maximum depth of the tree
                                 "validChildren"       : "all",  // defines valid node types for the root nodes
                                 "useData"             : false,  // whether to use $.data     TDO
                                 "attr"                : "type", // attr name in <li> where type is stored
                                 "types" : {                     // a list of types
                                             "default" : {       // the default type
                                                           "maxChildren"   : -1,
                                                           "maxDepth"      : -1,
                                                           "validChildren" : "all"
                                       
                                                           // Bound functions - you can bind any other function here
                                                           // (using boolean or function)
                                                           //"select_node" : true
                                                         }
                                           }
                               } ;

        //  Context menu

        data.menu              = {} ;
        data.menu.usermenu     = false ;   // user has supplied an ojMenu id if true
        data.menu.$container   = false ;   // the menu <ul>
        data.menu.$elemPaste   = false ;   // the menu "Paste" element
        data.menu.node         = false ;   // the tree node the menu was activated on


        //  Keyboard support

        data.keys         = {} ;
        data.keys.enabled = true ;
        data.keys.bound   = [];

        // Drag and Drop

        data.dnd            = {} ;
        data.dnd.reorder    = false ;

        data.dnd.active     = false ;
        data.dnd["after"]   = false ;
        data.dnd["inside"]  = false ;
        data.dnd["before"]  = false ;
        data.dnd.off        = false ;
        data.dnd.prepared   = false ;
        data.dnd.w          = 0,
        data.dnd.to1        = false ;
        data.dnd.to2        = false ;
        data.dnd.cof        = false ;
        data.dnd.cw         = false ;
        data.dnd.ch         = false ;
        data.dnd.i1         = false ;
        data.dnd.i2         = false ;
        data.dnd.mto        = false ;
        data.dnd.ml_width   = 100 ;    // marker line width - updated in _initDnd() from css
        data.dnd.targ_ml_width = 100 ; // marker line width of target node
  
        data.dnd.defaults = {
                              "copy_modifier"  : "ctrl",
                              "check_timeout"  : 100,
                              "open_timeout"   : 500,
                              "drop_target"    : ".oj-tree-drop",
                              "drop_check"     : function (data) { return true; },
                              "drop_finish"    : $.noop,
                              "drag_target"    : ".oj-tree-draggable",
                              "drag_finish"    : $.noop,
                              "drag_check"     : function (data)
                                                  {
                                                     return {
                                                              "after"  : false,
                                                              "before" : false,
                                                              "inside" : true
                                                            };
                                                  }
                            } ;


        data.dnd.vars          = {}          // drag/drop block of vars 
        data.dnd.vars.o        = false ;
        data.dnd.vars.r        = false ;
        data.dnd.vars.m        = false ;     // marker pointer div
        data.dnd.vars.ml       = false ;     // marker line div
        data.dnd.vars.sli      = undefined ;
        data.dnd.vars.sti      = undefined ;
        data.dnd.vars.dir1     = false ;
        data.dnd.vars.dir2     = false ;
        data.dnd.vars.last_pos = false ;

        data.dnd.ctl             = {} ;      //  dnd helper object (port note: this was the old ojtreeu helper)
        data.dnd.ctl.is_down     = false,
        data.dnd.ctl.is_drag     = false,
        data.dnd.ctl.helper      = false,
        data.dnd.ctl.scroll_spd  = 10,
        data.dnd.ctl.init_x      = 0,
        data.dnd.ctl.init_y      = 0,
        data.dnd.ctl.threshold   = 5,
        data.dnd.ctl.helper_left = -15,      // left displacement for dragged div pos
        data.dnd.ctl.helper_top  = 5,        // top displacement for dragged div pos
        data.dnd.ctl.user_data   = {}
     },

     /**
       *  @private
       */
     _fix_scroll : function (obj)
     {
        var c = this._$container[0],
            t;
       
       if (c.scrollHeight > c.offsetHeight)
       {
          obj = this._getNode(obj);
          if (!obj || obj === -1 || !obj.length || !obj.is(":visible"))  {
             return;
          }

          t = obj.offset().top - this._$container.offset().top;

          if (t < 0)  { 
            c.scrollTop = c.scrollTop + t - 1; 
          }

         if (t + this._data.core.li_height + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0) > c.offsetHeight)  { 
           c.scrollTop = c.scrollTop + (t - c.offsetHeight + this._data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0)); 
          }
       }
     },

     /**
       *  @private
       */
     set_focus   : function ()            // undocumented per Design Review
     { 
/*                                        // bug 18857563
       if (this._isFocused()) {
          return;
       }
       var f = this._focused();
       if (f) {
         this.unset_focus();
       }

       this._$container.addClass("oj-tree-focused"); 
       if (this._$container_ul) {
         this._$container_ul.focus() ;
       }
       this._data.ui.focused = true ;
       this._emitEvent(null, "set_focus");
*/
     },

     /**
       *  Return true if this tree has focus.
       *  @private
       */
     _isFocused  : function ()            // undocumented per Design Review
     { 
        return this._data.ui.focused ;
     },

     /**
       *  @private
       */
     unset_focus : function ()            // undocumented per Design Review
     {
/*    See set_focus
        if (this._isFocused()) {
          this._$container.removeClass("oj-tree-focused"); 
          this._data.ui.focused = false ;
          if (this._$container_ul) {
            this._$container_ul.blur() ;
          }
        }
        this._emitEvent(null, "unset_focus");
*/
     },

     /**
       *  Return the "this of the tree that currently has focus, or null.
       *  @private
       */
     _focused : function ()
     {
        var ret = null ;
        $.each(_aInstances, function(i, _this) {
            if (_this._data.ui.focused) {
              ret = _this ;
              return false ;
            }
        });

        return ret ;
     },

     /**
       *  Returns the next instance index to use.
       *  @private
       */
     _newIndex: function()
     {
       return ++_instance
     },

     /**
       *  Returns the current instance index.
       *  @private
       */
     _getIndex : function()
     {
        return this._index ;
     },

     /**
       *  Returns a copy of the options.
       *  @private
       */
     _getOptions : function()
     {
        return ($.extend(true, {}, this.options)) ;
     },

     /**
       *  Returns the tree containig div
       *  @private
       */ 
     _getContainer : function()
     {
        return this._$container ;
     },

     /**
       *   Handle keystroke and combination keystrokes.
       *   The return value is passed to the jQuery keydown handler.
       *   @private
       */
     _keyHandler : {

         "up" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getPrev(o));
            return false; 
         },

         "ctrl+up" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getPrev(o));
            return false; 
         },

         "shift+up" : function (t)
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["select"](this._getPrev(o), (this._data.ui.selectMode !== -1));
            return false; 
         },

         "down" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getNext(o));
            return false;
         },

         "ctrl+down" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getNext(o));
            return false;
         },

         "shift+down" : function ()
         { 
           var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
           this["select"](this._getNext(o), (this._data.ui.selectMode !== -1));
           return false;
         },

         "left" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o) {
              if (o.hasClass(OJ_EXPANDED))  {
                this["collapse"](o);
              }
              else  {
                this["hover"](this._getPrev(o));
              }
            }
            return false;
         },

         "ctrl+left" : function ()
         { 
           var o = this._data.ui.hovered || this._data.ui.last_selected;
           if (o)  {
             if (o.hasClass(OJ_EXPANDED))  {
                this["collapse"](o);
             }
             else  {
               this["hover"](this._getPrev(o));
             }
           }
           return false;
         },

         "shift+left" : function ()
         { 
           var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o) {
              if (o.hasClass(OJ_EXPANDED)) {
                this["collapse"](o);
              }
              else  {
                this["hover"](this._getPrev(o));
              }
            }
            return false;
         },

         "right" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o && o.length) {
               if (o.hasClass(OJ_COLLAPSED))  {
                  this["expand"](o);
               }
               else  {
                  this["hover"](this._getNext(o));
               }
            }
            return false;
         },

         "ctrl+right" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o && o.length) {
               if (o.hasClass(OJ_COLLAPSED)) {
                 this["expand"](o);
               }
               else   {
                 this["hover"](this._getNext(o));
               }
            }
            return false;
         },

         "shift+right" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o && o.length) {
              if (o.hasClass(OJ_COLLAPSED))  {
                this["expand"](o);
              }
              else  {
                this["hover"](this._getNext(o));
              }
            }
            return false;
         },

         "space" : function ()              // toggle hovered node select status
         { 
            if (this._data.ui.hovered)  {
              this._data.ui.spacebar = true ;      // note keyboard - so click will toggle
              this._data.ui.hovered.children("a:eq(0)").click();
              this._data.ui.spacebar = false ;
            } 
            return false; 
         },

         "home" : function ()               // move hover to top node
         { 
           this["hover"](this._$container_ul.find("li:first"));
           return false; 
         },

         "end" : function ()                // move hover to last visible node
         { 
           var a = this._$container_ul.find("li.oj-tree-last:visible");
           if (a && a.length) {
             this["hover"](a[a.length-1]) ;
           }
           return false; 
         },

         "*" : function ()                  // expand all nodes
         { 
           var l = this._$container_ul.find("a") ;
           this._expandAll(-1, false) ;
           return false; 
         },

         "ctrl+space" : function (event)    // toggle the select state
         { 
           if (this._data.ui.hovered)  { 
             var ev = $.Event("click") ;
             ev.ctrlKey = true;
             this._data.ui.hovered.children("a:eq(0)").trigger(ev);
           } 
           return false; 
         },

         "shift+space" : function (event)   // select to the hovered node
         { 
           if (this._data.ui.hovered)  {
             var ev = $.Event("click") ;
             ev.shiftKey = true;
             this._data.ui.hovered.children("a:eq(0)").trigger(ev);
           } 
           return false; 
         },

         "shift+home" : function (event)   // extend selection to top node
         { 
           var hover  = this._data.ui.hovered;

           if (hover)  {
             var bContinue  = true,
                 _this      = this,
                 nodes      = this._$container_ul.find("li:visible");

             hover = hover[0] ;
             $.each(nodes, function(i, node) {         // select from top
                  if (node == hover) {                 // until we find our
                    bContinue = false ;                // starting node
                  }
                  _this._select(node, true) ; 
                  return bContinue ;
             });
           } 
           return false; 
         },

         "shift+pgdn" : function (event)   // extend selection to last node
         { 
           var hover  =  this._data.ui.last_selected || this._data.ui.hovered ;
           if (hover)  {
             var bFound = false,
                 _this  = this,
                 l      = this._$container_ul.find("li:visible");

             hover = hover[0] ;
             $.each(l, function(i, node) {
                if (! bFound) {                        // select to bottom from 
                  bFound = (node == hover) ;           // last selected node
                }
                if (bFound && (! _this["isSelected"](node))) {
                  _this._select(node, true) ; 
                }
                return true ;
             });
           } 
           return false; 
         },

         "f2" : function ()
         {
           this["rename"](this._data.ui.hovered || this._data.ui.last_selected);
           return false ;
         },

         "del" : function ()
         {
           this["remove"](this._data.ui.hovered || this._getNode(null));
           return false ;
         }
     },

     /**
       *   Attach the user menu <ul> list to the tree div, and set up listeners on it.
       *   @private
       */
     _applyMenu : function()
     {
       if (! this._data.menu.usermenu) {
         return ;
       }

       // Add our listeners so that we can handle build-in cut/copy/paste, etc
       var $menuContainer = this._data.menu.$container ;
       var _this          = this ;

       $menuContainer.on("ojselect",     $.proxy(this._handleContextMenuSelect,     this));
       $menuContainer.on("ojbeforeopen", $.proxy(this._handleContextMenuBeforeShow, this));

       // If there are any ojTree built in menu item ids, construct the menu items
       var listItems = $menuContainer.find("[data-oj-command]");
       var bChanged  = false ;

       listItems.each(function()  {
              var cmd;
              if ($(this).children('a').length === 0)  {
                cmd = $(this).attr('data-oj-command').split("-");
                $(this).replaceWith(_this._buildContextMenuItem(cmd[cmd.length-1]));
                if ($(this).hasClass("oj-menu-divider")) {
                  $(this).removeClass("oj-menu-divider")
                         .addClass("oj-menu-item") ;
                }
                bChanged = true ;
              }
          });

       if (bChanged) {
         $menuContainer.ojMenu('refresh');
       }

       //  Note "paste" element for disabling if no prev cut/copy
       this._data.menu.$elemPaste = $menuContainer.find("#ojtreepaste") ;
       
     },

     /**
       *  Clear out any contextMenu data.
       *  @private
       */
     _clearMenu : function() {

       var um = this._data.menu ;

       if (um.usermenu)  {
         um.usermenu   = false ;
         um.$container.off("ojselect") ;
         um.$container.off("ojbeforeopen") ;
         um.$container = null ;
       }
     },

     /**
       * Builds a menu for a command, takes care of submenus where appropriate
       * @param {string} cmd
       * @private	 
       */            
     _buildContextMenuItem : function(cmd)
     {
        return $(this._buildContextMenuListItem(cmd)) ;
     },

     /**
       * Builds a context menu list item from a command
       * @param {string} cmd the string to look up command value for as well as translation
       * @return {string} an HTML string containing a list item and a  
       * @private	 
       */
     _buildContextMenuListItem: function(cmd)
     {
        var id = _arMenuCmdMap[cmd] ;
        return '<li id=' + id + '>' + this._buildContextMenuLabel(cmd) + '</li>';
     },

     /**
       * Builds a context menu anchor element with translated text
       * @param {string} cmd the command string whose label translated label should be used.
       * @return {string} an HTML anchor element string containing the translated label  
       * @private	 
       */
     _buildContextMenuLabel: function(cmd)
     {
         return '<a href="#">' + this.getTranslatedString("m_" + cmd) + '</a>';
     },        


     /**
       *  Menu "cut" functionality
       *  @private
       */
     _crrm_cut : function (obj)
     {
        obj = this._getNode(obj, true);
        if (!obj || !obj.length)  {
          return false;
        }

        this._data.crrm.cp_nodes = false;
        this._data.crrm.ct_nodes = obj;

        this._emitEvent({ "obj" : obj }, "cut");
     },

     /**
       *  Menu "copy" functionality
       *  @private
       */
     _crrm_copy : function (obj)
     {
        obj = this._getNode(obj, true);
        if (!obj || !obj.length)  {
          return false;
        }
        this._data.crrm.ct_nodes = false;
        this._data.crrm.cp_nodes = obj;
        this._emitEvent({ "obj" : obj }, "copy");
     },

     /**
       *  Menu "paste" functionality
       *  @private
       */
     _crrm_paste : function (obj)
     { 
        obj = this._getNode(obj);
        if (!obj || !obj.length) {
          return false;
        }
        var nodes = this._data.crrm.ct_nodes ? this._data.crrm.ct_nodes : this._data.crrm.cp_nodes;

        if (! this._data.crrm.ct_nodes && !this._data.crrm.cp_nodes)  {
           return false;
         }
         if (this._data.crrm.ct_nodes)  {
//         this.move_node(this._data.crrm.ct_nodes, obj);
           this._crrm_move_node(this._data.crrm.ct_nodes, obj);
           this._data.crrm.ct_nodes = false;
         }
         if (this._data.crrm.ct_nodes)
         {
//         this.move_node(this._data.crrm.ct_nodes, obj);
           this._crrm_move_node(this._data.crrm.ct_nodes, obj);
           this._data.crrm.ct_nodes = false;
         }
         if (this._data.crrm.cp_nodes)  {
//         this.move_node(this._data.crrm.cp_nodes, obj, false, true);
           this._crrm_move_node(this._data.crrm.cp_nodes, obj, false, true);
         }
         this._emitEvent({ "obj" : obj, "nodes" : nodes}, "paste");
     },

     /**
       *  Menu move node support for paste
       * @private
       */
     _crrm_move_node : function (obj, ref, position, is_copy, is_prepared, skip_check)
     {
        //var s = this.options["crrm"]["move"];
        var s = this._data.crrm.defaults["move"];
        if (! is_prepared)  { 
          if (typeof position === "undefined")  {
            position = s["defaultPosition"];
          }
          if (position === "inside" && !s["defaultPosition"].match(/^(before|after)$/))  {
            position = s["defaultPosition"];
          }
//Wed5      return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
            return this._move_node(obj, ref, position, is_copy, false, skip_check);
        }

        // if the move is already prepared
        if (s["alwaysCopy"] === true || (s["alwaysCopy"] === "multitree" && obj.rt._getIndex() !== obj.ot._getIndex() ))  { 
          is_copy = true;
        }
//Wed5  this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
        this._move_node(obj, ref, position, is_copy, true, skip_check);
     },

     /**
       *  Menu "remove" (i.e. delete) functionality
       *  @private
       */
     _crrm_remove : function (obj)
     {
        obj = this._getNode(obj, true);

//      var p   = this._getParent(obj),
//          prev = this._getPrev(obj);

         this.__rollback();
         obj = this["remove"](obj);
//         if (obj !== false) {
//           this._emitEvent({ "obj" : obj, "prev" : prev, "parent" : p }, "remove");
//         }
     },

     /**
       *  Menu rename a node functionality
       *  @private
       */
     _crrm_rename  :  function (obj)
     {
        var f = this._emitEvent;

        obj = this._getNode(obj);
        this.__rollback();
        this._crrm_showInput(obj, function (obj, new_name, old_name)
                                  { 
                                    //  Emit rename event
//                                    f.call(this, {
//                                                   "obj"       : obj,
//                                                   "title"     : new_name,
//                                                   "prevTitle" : old_name 
//                                                 },  "rename");
                                  });
     },

     /**
       *  Turn node into an input field to allow the user to rename the node.
       *  @private
       */
     _crrm_showInput : function (obj, callback)
     {
        obj = this._getNode(obj);

        var rtl = this._isRtl,
//          w   = this.options["crrm"]["inputWidthLimit"],       // applyDefaults() not done for V1
            w   = this._data.crrm.defaults["inputWidthLimit"],
            w1  = obj.children("ins").width(),
            w2  = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
            t   = this["getText"](obj),
            _this = this,

            h1  = $("<div />", { css : { "position"   : "absolute",
                                         "top"        : "-200px",
                                         "left"       : (rtl ? "0px" : "-1000px"),
                                         "visibility" : "hidden"
                                       }
                               }).appendTo("body"),

            h2  = obj.css("position", "relative").append(
                $("<input />", { 
                    "value" : t,
                    "class" : "oj-tree-rename-input",
                    // "size" : t.length,
                    "css" : {
                              "padding"  : "0",
                              "border"   : "1px solid silver",
                              "position" : "absolute",
                              "left"     : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
                              "right"    : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
                              "top"      : "0px",
                              "height"   : (this._data.core.li_height - 2) + "px",
                              "lineHeight" : (this._data.core.li_height - 2) + "px",
                              "width"    : "150px" // will be set a bit further down
                             },
                    "blur" : $.proxy(function ()
                      {
                        var i = obj.children(".oj-tree-rename-input"),
                            v = i.val();
                        if (v === "")  {
                          v = t;
                        }
                        h1.remove();
                        i.remove();                    // rollback purposes
                        this._set_text(obj, t);        // rollback purposes
                        this._rename_node(obj, v);
                        callback.call(this, obj, v, t);
                        obj.css("position","");
                    }, this),

                    "keyup" : function (event)
                      {
                        var key = event.keyCode || event.which;
// ignore first enter, it appears to be left
// over from hitting enter on the menu rename item????!!!
if (! _this._done) {
  _this._done=true ;
  return false;
}
                        if(key == 27)  {
_this._done = false ;
                           this.value = t;
                           this.blur();
                           return;
                        }
                        else if(key == 13)  {
_this._done = false ;
                           this.blur();
                           return;
                        }
                        else  {
                           h2.width(Math.min(h1.text("pW" + this.value).width(),w));
                        }
                    },

                    "keypress" : function(event)
                    {
                      var key = event.keyCode || event.which;
                      if (key == 13)  {
                        return false;
                      }
                    }
                })
            ).children(".oj-tree-rename-input"); 
            this._set_text(obj, "");
            h1.css({
                    fontFamily      : h2.css('fontFamily')      || '',
                    fontSize        : h2.css('fontSize')        || '',
                    fontWeight      : h2.css('fontWeight')      || '',
                    fontStyle       : h2.css('fontStyle')       || '',
                    fontStretch     : h2.css('fontStretch')     || '',
                    fontVariant     : h2.css('fontVariant')     || '',
                    letterSpacing   : h2.css('letterSpacing')   || '',
                    wordSpacing     : h2.css('wordSpacing')     || ''
            });
//Fri2      h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
            h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0]["select"]();
     },

     /**
       *  @private
       */
     _crrm_create : function (obj, position, js, callback, skip_rename)
     {
        var t, _this = this;
        obj = this._getNode(obj);
        if (!obj) {
           obj = -1;
        }
        this.__rollback();
        t = this._create_node(obj, position, js, function (t)
             {
                var p = this._getParent(t),
                    pos = $(t).index();

                if (callback)  {
                   callback.call(this, t);
                }
                if (p.length && p.hasClass(OJ_COLLAPSED))  {
                   this["expand"](p, false, true);
                }
                if (!skip_rename)  { 
                  this._crrm_showInput(t, function (obj, new_name, old_name)
                         { 
                            _this._emitEvent({ "obj"      : obj,
                                               "name"     : new_name,
                                               "parent"   : p,
                                               "position" : pos
                                              });
                         });
                }
                else  {
                   _this._emitEvent({ "obj"      : t, 
                                      "name"     : this["getText"](t),
                                      "parent"   : p,
                                      "position" : pos 
                                    });
                }
             });

        return t;
     },

     /**
       *  @private
       */
     _crrm_check_move : function ()
     {
        if (! this.__call_old())  {
          return false;
        }
        //var s = this.options["crrm"]["move"];
        var s = this._data.defaults.crrm["move"];
        if (! s["checkMove"].call(this, this._getMove()))  {
          return false;
        }
        return true;
     },

     /**
       *  @private
       */
     _isHtml : function(s)
     {
        if (!s || s.length < 3) {
          return false ;
        }

        s = s.trim() ;
        return (s.charAt(0) === "<") ;
     },


     /**
       *  Use emptyText option if defined.
       *  @private
       */
     _applyEmptyText : function()
     {
        var txt = this.option.emptyText ;

        if (typeof txt !== "string") {
          txt = this.getTranslatedString("m_emptyText");
        }
        if (txt && txt.length > 0)  {

          var $u =  this._$container_ul;
          var d  = "<li class='oj-tree-empty'>" + txt + "</li>" ;   // no <a>, not interactive 
          $u.empty().append(d);
        }
      },

     /**
       *  Return the HTMLElement based on the locator subid property.
       *  @private
       */
     _processSubId : function(locator)
     {
        // Parent node
        // <li role="treeitem" id="blogs" class="oj-tree-expanded|oj-tree-collapsed">
        //    <ins class="oj-tree-icon oj-tree-disclosure-icon oj-..."> </ins>  <-- disclosure icon
        //    <a tabindex="-1" href="#">
        //       <ins class="oj-tree-icon"> </ins>                              <-- node icon
        //       <span class="oj-tree-title">Blogs</span>                       <-- node title
        //       <ul role="group"> 
        //          <li . . . child nodes . . .
        //       </ul>
        //    </a>
        // </li>
        //
        //  Leaf node
        // <li role="treeitem" id="home" myattr1="Hello" class="oj-tree-leaf">
        //    <ins class="oj-tree-icon"> </ins>                   <-- unused disclosure icon
        //    <a tabindex="-1" href="#">
        //       <ins class="oj-tree-icon oj-tree-node-icon"> </ins>  <-- node icon
        //       <span class="oj-tree-title">Home</span>              <-- node title
        //    </a>
        // </li>

        var subId, node, a, sNode, c, sKey = null, i, ret ;

        if (locator) {
          subId = locator["subId"] ;
        }
        if (! subId) {
          return null ;
        }

        a  = subId.split("[") ;
        if (a.length === 3) {
          a[0] = a[0].trim() ;
          if (a[0] === "oj-tree-node") {
            a[1] = a[1].trim() ;
            c = a[1].charAt(0) ;                  // should be ' or "
            i = a[1].indexOf(c, 1) ;
            if (i >= 0) {
              sNode = a[1].substring(1, i).trim() ;

              a[2] = a[2].trim() ;
              c = a[2].charAt(0) ;                // should be ' or "
              i = a[2].indexOf(c, 1) ;
              if (i >= 0) {
                sKey = a[2].substring(1, i).trim() ;
                try {
                      node = this._getNode(sNode) ;
                    }
                catch (e)
                    {
                      node = null ;
                    }
                if (sKey && node && node !== -1) {
                  switch(sKey)
                  {
                    case "icon" :       if (this._data.themes.icons) {
                                          ret = node.find(" > a > ins:eq(0)") ;
                                        }
                                        break;
                    case "link" :       ret = node.find(" > a:eq(0)") ;
                                        break;
                    case "disclosure" : if (! this._isLeaf(node)) {
                                          ret = node.find(" > ins:eq(0)") ;
                                        }
                                        break;
                    case "title" :      ret = node.find(" > a > span") ;
                                        break;
                  }
                }
              }
            }
          }
        }

        return ret? (ret.length? ret[0] : null) : null ;

     },


     /**
       *  Hide the node connecting lines
       *  @private
       */
    _hideDots   : function ()
    {
      this._data.themes.dots = false;
      this._$container.children("ul").addClass("oj-tree-no-dots");
    },

     /**
       *  Show the node connecting lines
       *  @private
       */
    _showDots   : function ()
    {
      this._data.themes.dots = true;
      this._$container.children("ul").removeClass("oj-tree-no-dots");
    },

   
   /**
     *  Return a copy of a member of an object.
     *  @private
     */
    _varCopy :  function(obj, s)
    {
       var o = {} ;
       o[s] = obj[s] ;
       var o2 = $.extend(true, {}, o) ;

       return o2[s] ;
    }


  }) ;    // end    $.widget("oj.ojTree", ...

})();
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
/*!
 * JET Checkboxset @VERSION
 */
/**
 * @class
 * @name oj.ojCheckboxset
 * @augments oj.editableValue
 * @classdesc
 * <p>
 * The JET Checkboxset component (ojCheckboxset) enhances a group of 
 * <code class="prettyprint">input type="checkbox"</code> elements and 
 * manages the selected values of the group. It also adds and removes the correct
 * oj-* styles to the dom elements so it has the JET styling and is themable.
 * </p>
 * <p>To use an ojCheckboxset, group one or more checkbox inputs and their labels 
 *  within a container dom element, e.g., <code class="prettyprint">div</code>.
 *   For accessibility, set <code class="prettyprint">aria-labelledby</code> on this container dom element.
 *   Also set each input's <code class="prettyprint">id</code> attribute, and refer to that in the 
 *   input's label's <code class="prettyprint">for</code> attribute.
 *   Then create the ojCheckboxset on this container dom element.  
 * </p>
 * <p>
 *  The <code class="prettyprint">fieldset</code>/<code class="prettyprint">legend</code> elements 
 *  are not a supported way 
 *  to group and label ojCheckboxset, so <code class="prettyprint">fieldset</code> cannot be the 
 *  container dom element on which you create the ojCheckboxset. 
 *  Grouping with a <code class="prettyprint">div</code> element and using 
 *  a <code class="prettyprint">label</code> element allows you to
 *  lay out your labels/fields in more ways than if you used a fieldset/legend. 
 *  Both are equally accessible. 
 * </p>
 * <p>
 *  Checkboxset is used by selecting a container element which contains the 
 *  checkbox input elements and calling <code class="prettyprint">ojCheckboxset()</code>. 
 *  You can enable and disable a checkbox set, 
 *  which will enable and disable all contained checkboxes. 
 * </p>
 * <p>
 *  Checkboxset does not have a readOnly option since HTML does not support
 *  readonly on radios and checkboxes.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help information, if 
 * the applicable API is set. See the <code class="prettyprint">required</code> and 
 * <code class="prettyprint">help</code>
 * options. Use <code class="prettyprint">aria-labelledby</code> to associate the main label with
 * the checkboxset component. Doing this also makes the checkboxset accessible.
 * </p>
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>The checkboxset does not add any extra keyboard navigation to the input checkboxes. 
 * The keyboard interaction comes from the native browser.
 * </p>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>JET Checkboxset takes care of setting <code class="prettyprint">role="group"</code> 
 * on the checkboxset element.  
 * 
 * <p>As shown in the online demos, the application is responsible for applying 
 * <code class="prettyprint">aria-labelledby</code>
 * to point to the main label element for the group of checkboxes.
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio, 
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>, 
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which 
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user 
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio 
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 * <h3 id="label-section">
 *   Label and Checkboxset
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a label element with the checkboxset
 * by putting an <code class="prettyprint">id</code> on the label, and then setting the 
 * <code class="prettyprint">aria-labelledby</code> attribute on the checkboxset dom to be the 
 * label's id.
 * Note: The checkboxset's label is not the same as the label for each checkbox.  
 * The checkboxset's label will have the required and help information on it, 
 * not the label for each checkbox.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code class="prettyprint">required</code> and 
 * <code class="prettyprint">help</code> options are set. 
 * </p>
 * <h3 id="eventHandling-section">
 *   Event Handling
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
 * </h3>
 * <ul>
 *  <li>optionChange(event, ui) - Type: ojoptionchange
 *  <p>
 *   Triggered if the value changes when the user interacts with the component 
 *   (clicking on one of the checkboxe buttons); or if the value has 
 *   changed programmatically via the value option. 
 *  </li>
 * </ul>
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <p>
 *   All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.
 * </p>
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates or re-initializes a JET Checkboxset.  For JET components, re-initing 
 * is generally like a hard refresh, meaning it typically does everything 
 * <code class="prettyprint">refresh()</code> does, plus potentially a bit more. 
 *  For JET Checkboxset, if the DOM changes (for example, you add/remove a checkbox), you should refresh.
 * 
 * <p>Don't confuse the re-initializer with the <code class="prettyprint">option()</code> method, 
 * which (in one overload) also accepts a map of option-value pairs
 * to set on the component, but does not re-init.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the checkboxset with no options specified:</caption>
 * $(".selector").ojCheckboxset();
 * 
 * @example <caption>Initialize the checkboxset with some options and callbacks specified:</caption>
 * $( ".selector" ).ojCheckboxset( { "value": ["copy"], "valuechange": 
 * function( event, ui ) {alert("valuechanged from " + ui.previousValue + " to " + ui.value);} } );             
 * @example <caption>Initialize component using widget API</caption>
 * &lt;label id="grouplabel">Greetings&lt;/label>
 * &lt;div id="checkboxset" aria-labelledby="grouplabel">
 *   &lt;input id="helloid" value="hello" type="checkbox" name="greetings"/&gt;
 *   &lt;label for="helloid"/&gt;Hello&lt;/label>
 *   &lt;input id="bonjourid" value="bonjour" type="checkbox" name="greetings"/&gt;
 *   &lt;label for="bonjourid"/&gt;Bonjour&lt;/label>
 *   &lt;input id="ciaoid" value="ciao" type="checkbox" name="greetings"/&gt;
 *   &lt;label for="ciaoid"/&gt;Ciao&lt;/label>
 * &lt;div>
 * <br/>
 * // set the value to "ciao". (The 'ciao' checkbox will be checked)
 * $("#checkboxset").ojCheckboxset({'option', 'value', ['ciao']});
 * 
 * @example <caption>Initialize a checkboxset via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="checkboxset" data-bind="ojComponent: {component: 'ojCheckboxset', value: ['night']} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="checkbox" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="checkbox" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
  * @example <caption>Using knockout, value bind to observable:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="checkboxset" data-bind="ojComponent: {component: 'ojCheckboxset', value: currentTime} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="checkbox" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="checkbox" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
 * // in the model, make the currentTime variable a knockout observable.
 * // The model and the component's value option will stay in sync. Change the
 * // component's value option and the model will change. Change the model,
 * // and the component's value option will change. Click on a checkbox, and both
 * // will change.
 * self.currentTime = ko.observable(["night"]);
 * @constructor
 */
oj.__registerWidget("oj.ojCheckboxset", $['oj']['editableValue'],
{
  version : "1.0.0",  
  defaultElement : "<div>", 
  widgetEventPrefix : "oj", 
  options : 
  {
     /** 
     * <p>
     * Disabled <code class="prettyprint">true</code> disables the component and disables 
     * all the inputs/labels. 
     * Disabled <code class="prettyprint">false</code> enables the component, and leaves the inputs 
     * disabled state as it is in the dom.
     * <p>
     * After create time, the disabled state should be set via this API, 
     * not by setting the underlying DOM attribute. 
     *  
     * <p>The 2-way <code class="prettyprint">disabled</code> binding offered by 
     * the <code class="prettyprint">ojComponent</code> binding 
     * should be used instead of Knockout's built-in <code class="prettyprint">disable</code> 
     * and <code class="prettyprint">enable</code> bindings, 
     * as the former sets the API, while the latter sets the underlying DOM attribute.
     * 
     * @example <caption>Initialize component with <code class="prettyprint">disabled</code> option:</caption>
     * $(".selector").ojCheckboxset({"disabled": true});
     * 
     * @expose 
     * @type {?boolean}
     * @default <code class="prettyprint">false</code>
     * @public
     * @instance
     * @memberof oj.ojCheckboxset
     */
    disabled: null,
    /** 
     * The value of the component. 
     * 
     * <p>
     * When <code class="prettyprint">value</code> option changes due to programmatic 
     * intervention, the component always clears all messages and runs deferred validation, and 
     * always refreshes UI display value.</br>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>All messages are cleared. This includes  
     * <code class="prettyprint">messagesHidden</code>, <code class="prettyprint">messagesShown</code>
     *  and <code class="prettyprint">messagesCustom</code> options.</li>
     * </ul>
     * 
     *  
     * <h4>Running Validation</h4>
     * <ul>
     * <li>component always runs deferred validation; if there is a validation error the 
     * <code class="prettyprint">messagesHidden</code> option is updated.</li>
     * </ul>
     * </p>
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojCheckboxset({'value': ['coffee']});<br/>
     * @example <caption>Get or set <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns ['coffee']
     * $(".selector").ojCheckboxset("option", "value");
     * // Setter: sets ['coffee', 'tea']
     * $(".selector").ojCheckboxset("option", "value", ['coffee', 'tea']);
     * 
     * @expose 
     * @access public
     * @instance
     * @default <code class="prettyprint">[]</code>
     * When the option is not set, value is set to an array built from the checked checkboxes, if
     * any are checked.
     * @memberof oj.ojCheckboxset
     * @type {Array|undefined|null}
     */
    value: undefined
  },
  /**** start Public APIs ****/
      
   /**
   * Refreshes the checkboxset
   * <p>A <code class="prettyprint">refresh()</code> or re-init is required 
   * when a checkboxset is programatically changed, like in the following circumstances:
   * <ul>
   *   <li>After checkboxes are added or removed or modified (without using ojCheckboxset) in the DOM.</li>
   * </ul>    
   * @expose 
   * @memberof oj.ojCheckboxset
   * @instance
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" ).ojCheckboxset( "refresh" );
   */
  refresh: function() 
  {
    this._super();
    // we have a rule for refresh: if we have an api for it, then the app dev has to use the
    // option, and not expect changing the dom will update the state with refresh.
    // For the this.$radios, before I call refresh on each of them, change their disabled option
    // based on the DOM.

    // !! ensures it is a boolean
    this.$checkboxes.each(function() 
    {
        var disabledValue = $( this ).attr("disabled") !== undefined ? 
          !!$( this ).prop("disabled") : false;
        $( this )._ojRadioCheckbox("option", "disabled", disabledValue);
    });
      
    // refresh the ojRadioCheckbox's that exist, and  of the type=radio inputs that 
    // are not yet ojRadioCheckboxs, make them ojRadioCheckboxs.
    this.$checkboxes = this._findCheckboxesWithMatchingName()
                    .filter( ".oj-checkbox" )
                    ._ojRadioCheckbox("refresh")
                    .end()                  
                    // Create ojCheckbox out of any 'new' checkboxes.

                     // the END is key here. It makes it so that 
                     // this.$checkboxes has ALL the checkboxes.

                     // .not if a filter, it removes elements that do not have the
                     // oj-checkbox style class from the list of all input[type=checkbox]s.
                    .not( ".oj-checkbox" )

                    ._ojRadioCheckbox()
                    .end();
         
    this._setup();
  },
  /**
   * Returns a jQuery object containing the element visually representing the checkboxset. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof oj.ojCheckboxset
   * @instance
   * @return {jQuery} the checkbox
  */
  widget : function ()
  {
    return this.uiCheckboxset;
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/   
     
  /**
   * Overridden to set the options.value. When constructorOptions value is undefined,
   * we read the CHECKED options on the checkboxes and build the value array from that.
   * 
   * @memberof oj.ojCheckboxset
   * @instance
   * @protected
   */  
  _InitOptions : function (originalDefaults, constructorOptions)
  {
    var checkboxes, checkedValues = new Array(), selectedCheckbox, domValue, previousValue,
        props = [{"attribute": "disabled", "defaultOptionValue": false, "validateOption": true},
                 {"attribute": "title", "defaultOptionValue": ""},
                 {"attribute": "placeholder", "defaultOptionValue": ""},
                 //{"attribute": "value", "defaultValue": null},  // code below sets value
                 {"attribute": "required", "defaultOptionValue": false, 
                  "coerceDomValue": true, "validateOption": true
                 }]; 

    this._super(originalDefaults, constructorOptions);
    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);

    // component, app, and constructor are merged into this.options.option by the time _InitOptions 
    // is called. Let's take this example:
    // component (widget) default - 'foo'<br/>
    // app default - 'bar'<br/>
    // dom  - 'lucy'<br/>
    // constructorOptions['value'] - undefined<br/>
    // this.options.option is set to 'bar' initially. We don't want to just take this value, because
    // we want DOM value to win over the app and components default if DOM is set.
    // Therefore, the component needs to check if the constructorOptions['value'] is 
    // undefined and if so, set value option to 'lucy' (the DOM value in this example). <br/>
    // 
    // use DOM value if constructorOptions is undefined. if DOM value is undefined, then
    // leave this.options["value"] alone since it's the merged app/widget default at this point.
    if (constructorOptions['value'] === undefined)
    {
      // constructor option for value is undefined. Then we check the dom.
      checkboxes = this._findCheckboxesWithMatchingName();
      selectedCheckbox = checkboxes.filter(":checked");
      if (selectedCheckbox.length > 0)
      {
        selectedCheckbox.each(function(){
          checkedValues.push($(this).val());
        });
        domValue = checkedValues;
        previousValue = this.options["value"];
        // when defaulting from DOM we want to trigger optionChange to writeback new value
        // _InitializedOptionFromDom keeps track of the options.
        // In _AfterCreate() each option is written back.
        this._InitializedOptionFromDom('value', previousValue);
        this.options["value"] = domValue;
      }
      // if nothing is checked, we leave this.options["value"] as it is if not undefined, else
      // the widget's default is [].
      if (this.options["value"] === undefined)
        this.options["value"] = [];

    }
  },    
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @memberof oj.ojCheckboxset
   * @instance
   */
  _ComponentCreate : function ()
  {
    this._super();
    // first check to see if this.element is NOT a fieldset. If fieldset, throw error.
    if (this.element.is("fieldset"))
    {
      throw new Error("ojCheckboxset cannot be bound to a fieldset. Use a div instead.");
    }
    // turn each checkbox into ojCheckbox. Do this first, since we need it
    // in calls from 'create'.
    this.$checkboxes = this._findCheckboxesWithMatchingName()._ojRadioCheckbox();
    this.uiCheckboxset = this.element.addClass("oj-checkboxset oj-component")
                                  .attr( "role", "group" );
    this._on(this._events);
    this._setup();
    
  },
  /**
   * Sets focus on the element that naturally gets focus. For radioset, this is the first checkbox <br/>
   * 
   * @returns {*} a truthy value if focus was set to the intended element, a falsey value 
   * otherwise.
   * @override
   * @memberof oj.ojCheckboxset
   * @instance
   * @protected
   * @since 0.7
   */
  Focus : function ()
  {
    this._GetContentElement().first().focus();
    return true;
  },
  /**
   * Returns a jquery object that is a set of elements that are input type checkbox
   * and have the name of the first checkbox found.
   * 
   * @return {Object} jquery object of all the checkboxes within the root dom element
   * that have the same 'name' attribute as the first checkbox found.
   * @private
   */
  _findCheckboxesWithMatchingName : function ()

  {
    //return this.element.find('input[type=checkbox]'); // simplest thing to do.
    
    var first = this.element.find("input[type=checkbox]:first"),
      name, allcheckboxes, selector;
    if (first.length === 0)
    {
      oj.Logger.warn("Could not find any input type=checkbox within this element");
    }
    // get the name attribute of the first input checkbox
    name = first.attr("name");
    // find all input checkboxes with matching name
    if (name === undefined)
    {
    	// search for all checkboxes with no name
      allcheckboxes = this.element.find("input[type=checkbox]");
      // now loop and find the ones without 'name' attribute
      return allcheckboxes.not("[name]");
    }
    else
    {
    	// search for all checkboxes with the name
      selector = "input[type=checkbox][name=" + name + "]";
      return this.element.find(selector);
    	
    }
  },
  
  // Override to set custom launcher
  _OpenContextMenu: function(menu, event)
  {
    // Setting the launcher to the first tabbable checkbox in the set.
    // Component owner should feel free to specify a different launcher if appropriate, 
    // e.g. could specify the "current" checkbox rather than the first if desired.
    // See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.
    var launcher = this.element.find("input[type=checkbox]:tabbable").first();
    menu.open(event, {"launcher": launcher, "initialFocus": "menu"});
  },
  /**
   * _setup is called on create and refresh. Use the disabled option to 
   * update the component. If the component's option is disabled, then
   * leave it alone.
   * @memberof oj.ojCheckboxset
   * @instance
   * @private
   */
  _setup: function() 
  {

    // disable checkbox if element was already disabled
    if (this.options.disabled)
    {
      // calls _setOption disable is true, which in turn disables all checkboxs.
      this.disable();
    }
    else if (this.options.disabled === false)
    {
      this.enable();
    }
  },   
  _events : 
  {
    'change' : function (event)
    {
      
      this._HandleChangeEvent(event);
    }
  },

  /**
   * @param {Event} event DOM event 
   * @override
   * @protected
   * @memberof oj.ojCheckboxset
   */
  _HandleChangeEvent: function(event)
  {
    // TODO make sure the target is an input checkbox?
    // TODO any more checks I need to do?
    //alert("XYZ In _changeSetValue target is " + event.target + " And the value of the input is " + event.target.value);

    // should I double check that the event.target is the same as the 'checked'?
    // if (event.target === this.$checkboxes.filter(":checked"))???
    // _SetValue triggers valuechange event
    this._super(event);
  },
                  
  /**
   * Returns the display value that is ready to be passed to the converter.
   * 
   * @param {Object} value the stored value if available that needs to be formatted for display
   * @override
   * @protected
   * @memberof oj.ojCheckboxset
   */
  _GetDisplayValue : function (value) 
  {
    // return the value of the 'checked' checkboxes
    return this._GetElementValue();
  },
  /**
   * Called when the display value on the element needs to be updated 
   * as a result of a value change. 
   * ojCheckboxset stores an Array value, and this value matches the values
   * of the currently checked checkboxes. So, if we need to set the display value,
   * what this means is we need to 'check' the checkboxes whose values match the
   * displayValue.
   * 
   * @param {String} checkedBoxes of the new string to be displayed
   * @override
   * @protected
   * @memberof oj.ojCheckboxset
  */  
 _SetDisplayValue : function (checkedBoxes) 
  {
    var displayValue, valueFilter, checkboxWithMatchingValue;
    this.$checkboxes._ojRadioCheckbox("option", "checked", false);
    if (checkedBoxes != null)
    {
      // Uncheck all the checkboxes then iterate through and checkoff any matching checkboxes from the value
      for(var i = 0; i < checkedBoxes.length; i++) {
        displayValue = checkedBoxes[i];
        valueFilter = "[value='" + displayValue + "']"; 

        checkboxWithMatchingValue = this.$checkboxes.filter(valueFilter);
        if (checkboxWithMatchingValue !== undefined && checkboxWithMatchingValue.length > 0)
        {
          // if not already checked, then mark as checked.
          if (!checkboxWithMatchingValue.prop('checked'))

          {
            checkboxWithMatchingValue._ojRadioCheckbox("option", "checked", true);
          }
        }
      }
    } 
  },
  /**
   * Returns the element's value. Normally, this is a call to this.element.val(),
   * but in the case of ojCheckboxset, the element's value is really the value
   * of the checked checkboxes in the set.
   * @override
   * @protected
   * @memberof oj.ojCheckboxset
   */
  _GetElementValue : function () 
  {
    // "input:checked" selects checkboxes that are currently checked as 
    // reflected in their boolean (true or false) checked property, 
    // which is affected when the user clicks the checkbox for example.
    // for checkbox, there will be one or none checked; 
    // if none are checked, return null (selectedCheckbox.val() is undefined if nothing is checked)
    var checkedValues=new Array();
    var selectedCheckbox = this.$checkboxes.filter(":checked");
    if (selectedCheckbox.length === 0)
      return [];
    else 
    { 
      selectedCheckbox.each(function(){checkedValues.push($(this).val());});
      return checkedValues;
    }
  },

  
  /**
   * Returns the default styleclass for the component. Currently this is 
   * used to pass to the _ojLabel component, which will append -label and 
   * add the style class onto the label. This way we can style the label
   * specific to the input component. For example, for inline labels, the
   * checkboxset/checkboxset components need to have margin-top:0, whereas all the
   * other inputs need it to be .5em. So we'll have a special margin-top style 
   * for .oj-label-inline.oj-checkboxset-label
   * All input components must override
   * 
   * @return {string}
   * @memberof oj.ojCheckboxset
   * @override
   * @protected
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-checkboxset";
  },
  /**
   * Returns a jquery object of the elements representing the content nodes (checkboxes/labels).
   * @protected
   * @override
   * @memberof oj.ojCheckboxset
   */
  _GetContentElement : function ()
  {
    return this._findCheckboxesWithMatchingName();
  },
  /**
   * Called when a aria-required attribute needs to be set or removed. 
   * Most inputs/selects need aria-required on the input element (aka 'content')
   * But it is not legal to have aria-required on radio/checkboxes.
   * Subclasses can override to put aria-required where they want.
   * 
   * @param {boolean=} value the current value of the required option
   * @memberof oj.ojCheckboxset
   * @instance
   * @protected
   */
  _RefreshAriaRequired : function (value)
  {
    var ariaValue, rootNode = this.uiCheckboxset;

    ariaValue = (value) ? true : false;
    if (ariaValue && rootNode) 
    {
      rootNode.attr("aria-required", ariaValue);
    }
    else
    {
      rootNode.removeAttr("aria-required");
    }
  },
  /**
   * @override
   * @private
   */
  _setOption : function (key, value, flags)
  {
    this._super(key, value, flags);

    if ( key === "disabled" ) 
    {
      this.$checkboxes.each(function() 
      {
        // this is the technique to use to call package-private functions
        // Calling it like this.$radios.ojRadioCheckbox("__setAncestorComponentDisabled",value)
        // gives an error because jquery prevents you from calling functions with an "_"
        // 
        // This is how we handle 'disabled' for the checkboxset. We don't change the radiocheckbox
        // component's disabled option ever since if we do that we've lost what the initial disabled
        // state is (we store the disabled dom value from the radio into its disabled option)
        // and we need that when we refresh. Instead what we do
        // is we mark if its ancestor (the checkboxset) is disabled or not. Then, when we render
        // out the checkboxes 'disabled' state, like oj-disabled, we look to see if it is 'effectively
        // disabled' (see _IsEffectivelyDisabled call in ojRadioCheckbox), that is if its 
        // option is disabled OR its ancestor (the checkboxset) is disabled.
        $( this ).data("oj-_ojRadioCheckbox").__setAncestorComponentDisabled(value);
      });
      
      this.$checkboxes._ojRadioCheckbox("refresh"); // re-render
    }
  },
/**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-checkboxset-inputs</b>: the checkboxset's input elements</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof oj.ojCheckboxset
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    var node = this._super(locator), subId;
    if (!node)
    {
      subId = locator['subId'];
      if (subId === "oj-checkboxset-inputs") {
        return this.$checkboxes;
      }
    }    
    // Non-null locators have to be handled by the component subclasses
    return node || null;
  }, 
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function ()
  {  
    if (this.$checkboxes)
    {
      this.$checkboxes._ojRadioCheckbox( "destroy" );
    }
    this._RestoreAttributes(); //remove when _RestoreAttributes is uncommented from jqueryui-base
    return this._super();
  }
  /**** end internal widget functions ****/ 
   /**
   * Removes the checkboxset functionality completely. 
   * This will return the element back to its pre-init state.
   * 
   * <p>This method does not accept any arguments.
   * 
   * @method
   * @name oj.ojCheckboxset#destroy
   * @memberof oj.ojCheckboxset
   * @instance
   * 
   * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
   * $( ".selector" ).ojCheckboxset( "destroy" );
   */
});

//////////////////     SUB-IDS     //////////////////


/**
 * <p>Sub-ID for the checkboxset's checkboxes.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-checkboxset-inputs
 * @memberof oj.ojCheckboxset
 * @instance
 * 
 * @example <caption>Get the nodes for the checkboxes:</caption>
 * var nodes = $( ".selector" ).ojRadioset( "getNodeBySubId", {'subId': 'oj-checkboxset-inputs'} );
 */
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class 
 * @name oj.ojTreemap
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="treemapOverview-section">
 *   JET Treemap Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#treemapOverview-section"></a>
 * </h3>
 * 
 * <p>Treemap component for JET. Treemaps are used to display hierarchical data across two dimensions, represented by 
 * the size and color of the treemap nodes. Treemaps are generally preferred over sunbursts when emphasizing the data
 * for the leaf nodes.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojTreemap',
 *   nodes: [{value: 100, color: "#FFFF00", label: "Total Sales", 
 *            nodes: [{value: 75, color: "#00FF00", label: "Candy"},
 *                    {value: 20, color: "#FFFF00", label: "Fruit"},
 *                    {value: 15, color: "#FF0000", label: "Vegetables"}]}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="treemapOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#treemapOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/treemap.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.  Since component terminology for keyboard 
 * and touch shortcuts can conflict with those of the application, it is the 
 * application's responsibility to provide these shortcuts, possibly via a help 
 * popup.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move focus and selection up to the nearest tile or header in same level.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move focus and selection down to the nearest tile or header in same level.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move focus and selection to the left to nearest tile or header in same level</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move focus and selection to the right to nearest tile or header in same level</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>]</kbd> or <kbd>Alt+UpArrow</kbd></td>
 *       <td>Move focus and selection from tile or header to group header in level above.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>[</kbd> or <kbd>Alt+DownArrow</kbd></td>
 *       <td>Move focus and selection from tile or header to group header in level below.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+UpArrow</kbd></td>
 *       <td>Move focus and extend selection up to the nearest tile or header in same level.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+DownArrow</kbd></td>
 *       <td>Move focus and extend selection down to the nearest tile or header in same level.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+LeftArrow</kbd></td>
 *       <td>Move focus and extend selection to the left to nearest tile or header in same level</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+RightArrow</kbd></td>
 *       <td>Move focus and extend selection to the right to nearest tile or header in same level</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+]</kbd> or <kbd>Shift+Alt+UpArrow</kbd></td>
 *       <td>Move focus and extend selection from tile or header to group header in level above.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+[</kbd> or <kbd>Shift+Alt+DownArrow</kbd></td>
 *       <td>Move focus and extend selection from tile or header to group header in level below.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+UpArrow</kbd></td>
 *       <td>Move focus up to the nearest tile or header in same level, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+DownArrow</kbd></td>
 *       <td>Move focus down to the nearest tile or header in same level, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+LeftArrow</kbd></td>
 *       <td>Move focus to the left to nearest tile or header in same level, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+RightArrow</kbd></td>
 *       <td>Move focus to the right to nearest tile or header in same level, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+]</kbd> or <kbd>Ctrl+Alt+UpArrow</kbd></td>
 *       <td>Move focus from tile or header to group header in level above, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+[</kbd> or <kbd>Ctrl+Alt+DownArrow</kbd></td>
 *       <td>Move focus from tile or header to group header in level below, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+Spacebar</kbd></td>
 *       <td>Multi-select tiles or headers with focus.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+Enter</kbd></td>
 *       <td>Maximize/Restore on a group header.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Treemap.
 * @example <caption>Initialize the Treemap with no options specified:</caption>
 * $(".selector").ojTreemap();
 * 
 * @example <caption>Initialize the Treemap with some options:</caption>
 * $(".selector").ojTreemap({nodes: [{value: 75, color: "#00FF00", label: "Candy"}, {value: 20, color: "#FFFF00", label: "Fruit"}, {value: 15, color: "#FF0000", label: "Vegetables"}]});
 * 
 * @example <caption>Initialize the Treemap via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojTreemap'}">
 */
oj.__registerWidget('oj.ojTreemap', $['oj']['dvtBaseComponent'],
  {
    version: "1.0.0",
    widgetEventPrefix: "oj",
    options: {
      /**
       * Triggered when node isolation is turned on or off.
       * 
       * @property {Object} ui event payload
       * @property {Object} ui.item an object with the following properties
       * @property {string} ui.items.id the id of the node
       * @property {string} ui.type specifies whether the node isolation is being turned 'on' or 'off'
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">isolate</code> callback specified:</caption>
       * $(".selector").ojTreemap({
       *   "isolate": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojisolate</code> event:</caption>
       * $(".selector").on("ojisolate", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojTreemap
       * @instance
       */
      isolate: null,
      
      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
       * intervention. If the new value is the same as the previous value, no event will be fired. Additional options may 
       * be supported in the future, so listeners should verify which option is changing before taking any action. 
     * Currently supports: <code class="prettyprint">isolatedNode</code>, <code class="prettyprint">selectedNodes</code>
       * 
       * @property {Object} data event payload
       * @property {string} data.option the name of the option that changed, i.e. "value"
       * @property {Object} data.previousValue an Object holding the previous value of the option
       * @property {Object} data.value an Object holding the current value of the option
       * @property {Object} ui.optionMetadata information about the option that is changing
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *                    <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
       * $(".selector").ojTreemap({
       *   'optionChange': function (event, data) {} 
       * });
       * 
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
       * $(".selector").on({
       *   'ojoptionchange': function (event, data) {
       *       window.console.log("option changing is: " + data['option']);
       *   };
       * });
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojTreemap
       * @instance
       */
      optionChange: null,
      
      /**
       * Triggered after data items are selected or de-selected.
       * 
       * @property {Object} ui event payload
       * @property {Array} ui.items an array containing objects describing the selected nodes
       * @property {string} ui.items.id the id of the node
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
       * $(".selector").ojTreemap({
       *   "select": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
       * $(".selector").on("ojselect", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojTreemap
       * @instance
       */
      select: null
    },
    
    /**
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @protected
     */
    _CreateDvtComponent: function(context, callback, callbackObj) {
      return DvtTreemap.newInstance(context, callback, callbackObj);
    },
    
    /**
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @protected
     */
    _GetComponentStyleClasses: function() {
      var styleClasses = this._super();
      styleClasses.push('oj-treemap');
      return styleClasses;
    },
    
    /**
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @protected
     */
    _GetChildStyleClasses: function() {
      var styleClasses = this._super();
      styleClasses['oj-treemap-isolate-icon'] = {'path': '_resources/isolate', 'property': 'CSS_URL'};
      styleClasses['oj-treemap-isolate-icon oj-hover'] = {'path': '_resources/isolateOver', 'property': 'CSS_URL'};
      styleClasses['oj-treemap-isolate-icon oj-active'] = {'path': '_resources/isolateDown', 'property': 'CSS_URL'};

      styleClasses['oj-treemap-restore-icon'] = {'path': '_resources/restore', 'property': 'CSS_URL'};
      styleClasses['oj-treemap-restore-icon oj-hover'] = {'path': '_resources/restoreOver', 'property': 'CSS_URL'};
      styleClasses['oj-treemap-restore-icon oj-active'] = {'path': '_resources/restoreDown', 'property': 'CSS_URL'};

      styleClasses['oj-treemap-attribute-type-text'] = {'path': 'styleDefaults/_attributeTypeTextStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-treemap-attribute-value-text'] = {'path': 'styleDefaults/_attributeValueTextStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      // TODO HZHANG add this once drilling is supported
//    styleClasses['oj-treemapCurrentText '] = {'path' : '', 'property' : 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-treemap-node'] = {'path': 'nodeDefaults/labelStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-treemap-node oj-hover'] = {'path': 'nodeDefaults/hoverColor', 'property': 'border-top-color'};
      styleClasses['oj-treemap-node oj-selected'] = [
        {'path': 'nodeDefaults/selectedOuterColor', 'property': 'border-top-color'},
        {'path': 'nodeDefaults/selectedInnerColor', 'property': 'border-bottom-color'}
      ];
      styleClasses['oj-treemap-node-header'] = [
        {'path': 'nodeDefaults/header/backgroundColor', 'property': 'background-color'},
        {'path': 'nodeDefaults/header/borderColor', 'property': 'border-top-color'},
        {'path': 'nodeDefaults/header/labelStyle', 'property': 'CSS_TEXT_PROPERTIES'}
      ];
      styleClasses['oj-treemap-node-header oj-hover'] = [
        {'path': 'nodeDefaults/header/hoverBackgroundColor', 'property': 'background-color'},
        {'path': 'nodeDefaults/header/hoverOuterColor', 'property': 'border-top-color'},
        {'path': 'nodeDefaults/header/hoverInnerColor', 'property': 'border-bottom-color'}
      ];
      styleClasses['oj-treemap-node-header oj-selected'] = [
        {'path': 'nodeDefaults/header/selectedBackgroundColor', 'property': 'background-color'},
        {'path': 'nodeDefaults/header/selectedOuterColor', 'property': 'border-top-color'},
        {'path': 'nodeDefaults/header/selectedInnerColor', 'property': 'border-bottom-color'}
      ];
      return styleClasses;
    },
    
    /**
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @protected
     */
    _GetEventTypes : function() {
      return ['isolate', 'optionChange', 'select'];
    },
    
    /**
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @protected
     */
    _GetTranslationMap: function() {
      // Safe to modify super's map because function guarentees a new map is returned
      var ret = this._super();
      ret['DvtTreemapBundle.COLOR'] = this._GetTranslatedResource('labelColor');
      ret['DvtTreemapBundle.SIZE'] = this._GetTranslatedResource('labelSize');
      return ret;
    },
    
    /**
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @protected
     */
    _HandleEvent: function(event) {
      var type = event && event.getType ? event.getType() : null, selectedItems, selection, i, selectedItem,
        isolatedNodes, isolatedNode, isolateType;
      if (type === DvtSelectionEvent.TYPE) {
        selectedItems = [];
        selection = event.getSelection();
        for (i = 0; i < selection.length; i++) {
          selectedItem = {'id': selection[i]};
          selectedItems.push(selectedItem);
        }
        // update the options selection state
        this._UserOptionChange('selectedNodes', selection);
        this._trigger('select', null, {'items': selectedItems});
      }
      else if (type === DvtTreemapIsolateEvent.TYPE) {
        // Keep track of all isolated nodes
        isolatedNodes = this.options._isolatedNodes;
        if (!isolatedNodes) {
          this.options._isolatedNodes = [];
          isolatedNodes = this.options._isolatedNodes;
        }

        // If event has id, it's an isolate.  If null id, then restore.      
        isolatedNode = event.getId();
        if (isolatedNode) {
          isolateType = "on";
          isolatedNodes.push(isolatedNode);
          this._UserOptionChange('isolatedNode', isolatedNode);
        }
        else {
          isolateType = "off";
          isolatedNode = isolatedNodes.pop();
          this._UserOptionChange('isolatedNode', (isolatedNodes.length > 0) ? isolatedNodes[isolatedNodes.length] : null);
        }

        this._trigger('isolate', null, {'item': {'id': isolatedNode}, 'type': isolateType});
      }
      else {
        this._super(event);
      }
    },
    
    /**
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @protected
     */
    _SupportsOptionChangeEvent : function(key) {
      return key == 'isolatedNode' || key == 'selectedNodes';
    },
    
    /**
     * Returns the subcomponent node represented by the documented locator attribute values.
     * Test authors should target treemap sub elements using the following locators:
     * <ul>
     *   <li>node[nodeIndex0][nodeIndex1]...[nodeIndexN] - A treemap node indexed by its position in the hierarchy</li>
     * </ul>
     * @override
     * @memberof! oj.ojTreemap
     * @instance
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator) {
      return this._super(locator);
    },
    
    /**
     * Returns the subId string for the given child DOM node.  Valid treemap subIds include:
     * <ul>
     *   <li>node[nodeIndex0][nodeIndex1]...[nodeIndexN] - A treemap node indexed by its position in the hierarchy</li>
     * </ul>
     * @override
     * @expose
     * @memberof! oj.ojTreemap
     * @instance
     * @param {Element} node The subcomponent node used by the component to lookup the subId string
     * @return {string|null} - the subId for the DOM node or null when none is found
     */
    getSubIdByNode: function(node) {
      return this._super(node);
    },
    
    /**
     * Returns a TreemapNode object for automation testing verification.
     * @param {Array} subIdPath The array of indices in the subId for the desired node
     * @return {Object} An object containing data for the node at the given subIdPath, or null if none exists
     * @expose
     * @memberof! oj.ojTreemap
     * @instance
     */
    getNode: function(subIdPath) {
      var auto = this._component.getAutomation();
      return new oj.TreemapNode(auto.getNode(subIdPath));
    }
  });
/**
 * An object used for automation verification of treemap nodes
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.TreemapNode = function(data) {
  this._data = data;
};

/**
 * Returns the color of the node
 * @returns {String} The node color
 * @export
 */
oj.TreemapNode.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the label of the node
 * @returns {String} The node label
 * @export
 */
oj.TreemapNode.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};

/**
 * Returns the size of the node
 * @returns {Number} The node size
 * @export
 */
oj.TreemapNode.prototype.getSize = function() {
  return this._data ? this._data['size'] : null;
};

/**
 * Returns the tooltip of the node
 * @returns {String} The node tooltip
 * @export
 */
oj.TreemapNode.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns whether or not the node is selected
 * @returns {Boolean} The node selection state
 * @export
 */
oj.TreemapNode.prototype.isSelected = function() {
  return this._data ? this._data['selected'] : false;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * @class 
 * @name oj.ojAccordion
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="accordionOverview-section">
 *   JET Accordion Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accordionOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant accordion with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Accordion can be created from any valid markup as long as the root element has one or more child elements and 
 * each child element must have two children: the first element for the header and the second element for the content.
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="accordion">
 *   &lt;div id="c1">
 *     &lt;h3>
 *       &lt;img src="images/default.png"/>
 *       &lt;span>Header 1&lt;/span>
 *     &lt;/h3>
 *     &lt;p>Content 1.&lt;/p>
 *   &lt;/div>
 *   &lt;div id="c3" data-bind="ojComponent: {component: 'ojAccordion', expanded:true}">
 *     &lt;h3>Header 3&lt;/h3>
 *     &lt;p>Content 3&lt;/p>
 *   &lt;/div>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>
 * <h5>When the focus is on a collapsible header</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td> Navigate to next collapsible header and if none then the next component on page.</tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td> Navigate to previous collapsible header and if none then the previous component on page.</tr>
 *     <tr>
 *       <td><kbd>UpArrow or LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td> Move focus to the previous collapsible header with wrap around.</tr>
 *     <tr>
 *       <td><kbd>DownArrow or RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td> Move focus to the next collapsible header with wrap around.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td> Move focus to the first collapsible header.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td> Move focus to the last collapsible header.</tr>
 *   </tbody>
 *  </table>
 *
 * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the accordion must be <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-collapsible</code> pseudo-selector can be used in jQuery expressions to select JET Accordion.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-collapsible" ) // selects all JET Accordion on the page
 * $myEventTarget.closest( ":oj-accordion" ) // selects the closest ancestor that is a JET Accordion
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "collapsible".  
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Accordion. 
 * @example <caption>Initialize the accordion with no options specified:</caption>
 * $( ".selector" ).ojAccordion();
 * 
 * @example <caption>Initialize the accordion with some options specified:</caption>
 * $( ".selector" ).ojAccordion( { "multiple": true } );
 * 
 * @example <caption>Initialize the accordion via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="accordion" data-bind="ojComponent: { component: 'ojAccordion', multiple: true}">
 * 
 */
(function ()
{
  oj.__registerWidget("oj.ojAccordion", $['oj']['baseComponent'], 
  {
    widgetEventPrefix : "oj", 
    options : 
    {
      /** 
       * Allow multiple collapsibles to be open at the same time. 
       * Note: if multiple is true, the beforeCollapse/beforeExpand/collapse/expand events will not be fired by the accordion. They are however fired by the collapsibles.
       *
       * @expose 
       * @memberof! oj.ojAccordion
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Initialize the accordion with the <code class="prettyprint">multiple</code> option specified:</caption>
       * $( ".selector" ).ojAccordion( { "multiple": true } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">multiple</code> option, after initialization:</caption>
       * // getter
       * var multiple = $( ".selector" ).ojAccordion( "option", "multiple" );
       * 
       * // setter
       * $( ".selector" ).ojAccordion( "option", "multiple", true );
       */
      multiple : false,

      /** 
       * Array contains either ids or zero-based indices of the collapsibles that should be expanded.<p>
       * Setter value: array of either ids or indices.<p>
       * Getter value: array of either ids or indices. If an expanded collapsible has a page author provided id, that id is returned, otherwise that collapsible's index will be returned.
       *
       * @expose 
       * @memberof! oj.ojAccordion
       * @instance
       * @type {Array}
       * @default <code class="prettyprint">null</code>
       *
       * Note: expanded is default to null<p>
       * which means that accordion doesn't modify the state on the collapsible children.<p>
       * If specified, it overrides the children expanded setting.
       *
       * @example <caption>Initialize the accordion with the 
       * <code class="prettyprint">expanded</code> option specified:</caption>
       * $( ".selector" ).ojAccordion( { "expanded": ["collapsible1Div"] } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">expanded</code> 
       * option after initialization:</caption>
       * // getter
       * var expanded = $( ".selector" ).ojAccordion( "option", "expanded" );
       * 
       * // setter
       * $( ".selector" ).ojAccordion( "option", "expanded", ["collapsible1Div"] );
       */
      expanded : null, 

      // callbacks
      /**
       * Triggered immediately before any collapsible in the accordion is expanded.
       * beforeExpand can be canceled to prevent the content from expanding by returning a false in the event listener.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.toCollapsible The collapsible being expanded.
       * @property {jQuery} ui.fromCollapsible The collapsible being collapsed. 
       * 
       * @example <caption>Initialize any collapsible in the accordion with the <code class="prettyprint">beforeExpand</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "beforeExpand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeexpand</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeexpand", function( event, ui ) {} );
       */
      beforeExpand : null,

      /**
       * Triggered after the accordion has been expanded (after animation completes).
       * The expand can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.toCollapsible The collapsible being expanded.
       * @property {jQuery} ui.fromCollapsible The collapsible being collapsed. 
       * 
       * @example <caption>Initialize the accordion with the <code class="prettyprint">expand</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "expand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
       * $( ".selector" ).on( "ojexpand", function( event, ui ) {} );
       */
      expand : null, 

      /**
       * Triggered immediately before any collapsible in the accordion is collapsed.
       * beforeCollapse can be canceled to prevent the content from collapseing by returning a false in the event listener.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.toCollapsible The collapsible being expanded.
       * @property {jQuery} ui.fromCollapsible The collapsible being collapsed. 
       * 
       * @example <caption>Initialize any collapsible in the accordion with the <code class="prettyprint">beforeCollapse</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "beforeCollapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforecollapse</code> event:</caption>
       * $( ".selector" ).on( "ojbeforecollapse", function( event, ui ) {} );
       */
      beforeCollapse : null,

      /**
       * Triggered after any collapsible in the accordion has been collapsed (after animation completes).
       * The collapse can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.toCollapsible The collapsible being expanded.
       * @property {jQuery} ui.fromCollapsible The collapsible being collapsed. 
       * 
       * @example <caption>Initialize any collapsible in the accordion with the <code class="prettyprint">collapse</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "collapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapse</code> event:</caption>
       * $( ".selector" ).on( "ojcollapse", function( event, ui ) {} );
       */
      collapse : null

    },

    _ComponentCreate : function ()
    {
      this._super();
      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.element
        .addClass("oj-accordion oj-component")
        //aria
        .attr("role", "group");

      this._refresh();
    },

    // Override to set custom launcher
    _OpenContextMenu: function(menu, event)
    {
      // Setting the launcher to the "twisty" icon of the first collapsible in the accordion, since those twisties seem to be 
      // the only tabbable things in the accordion, and they seem to remain tabbable even if the collapsible is disabled.
      // Component owner should feel free to specify a different launcher if appropriate, e.g. could specify the "current" 
      // twisty rather than the first if desired.  See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.
      menu.open(event, {"launcher": this.element.find(".oj-collapsible-header-icon").first(), "initialFocus": "menu"});
    },
    
    _destroy : function ()
    {
      // clean up main element
      this.element
        .removeClass("oj-accordion oj-component")
        .removeAttr("role");

      this.element.children()
        .removeClass("oj-accordion-collapsible");

      //remove collapsibles created by accordion
      this.element.children(".oj-accordion-created")
        .removeClass("oj-accordion-created")
        .ojCollapsible("destroy");
    },

    _setOption : function (key, value, flags)
    {
      var self = this;

      if (key === "multiple")
      {
        // Transition multiple to single.
        // Keep the first expanded one expanded and collapse the rest.
        if (value == false && this.options.multiple == true)
        {
          //Bug 19278184 - when "multiple" option value is changed to false, exception is displayed
          this.element.children(".oj-expanded")
            .first().siblings(".oj-collapsible")
            .ojCollapsible("collapse", false);
        }
      }
      else if (key === "expanded")
      {
        this._setExpandedOption(value);
        return;
      }

      this._super(key, value, flags);

//TODO: ignore disabled until disabled propagation is supported
/*
      if (key === "disabled")
      {
        value = !!value;

        if (value) {
          this.colllapsibles.each(function ()
          {
            //TODO: Don't override if collapsible has disabled set
            if ($(this).ojCollapsible("option", key) == null)
              $(this).ojCollapsible("option", key, value);
          });
        }
        this.element.toggleClass("oj-disabled", value);
      }
*/
    },

    /**
     * Refreshes the visual state of the accordion. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is 
     * programmatically changed underneath the component.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojAccordion
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojAccordion( "refresh" );
     */
    refresh : function ()
    {
      this._super();
      this._refresh();
    },

    _refresh : function ()
    {
      this._makeCollapsible();

      //need to propagate the option to the collapsible children
      this._setOption("disabled", this.options.disabled);
      this._setOption("expanded", this.options.expanded);

      this._setupEvents();
    },

    _makeCollapsible : function ()
    {
      this.element.children(":oj-collapsible")
        .each(function ()
        {
          $(this).ojCollapsible("option", "expandArea", "header");
        });

      this.colllapsibles = 
        this.element.children()
          .not(":oj-ojCollapsible")
            .ojCollapsible(
            {
              expandArea : "header"
            })
            .addClass("oj-accordion-created")
          .end()
          .addClass("oj-accordion-collapsible");
    },

    _setupEvents : function ()
    {
      var events = 
      {
        "keydown" : this._keydown, 
        "ojbeforeexpand" : this._beforeExpandHandler, 
        "ojexpand" : this._expandHandler,
        "ojbeforecollapse" : this._beforeCollapseHandler, 
        "ojcollapse" : this._collapseHandler
      };

      this._off(this.colllapsibles);
      this._on(this.colllapsibles, events);
    },

    _keydown : function (event)
    {
      if (event.altKey || event.ctrlKey)
        return;

      //ignore event if target is not a header
//TODO:
//      if ($(event.target).parentsUntil(event.currentTarget)[0] !== 
//          $(event.currentTarget).children()[0])
      if (! ($(event.target).hasClass("oj-collapsible-header")) &&
          ! ($(event.target).hasClass("oj-collapsible-header-icon")))
        return;

      var keyCode = $.ui.keyCode, 
          enabledCollapsibles = this.colllapsibles.not(".oj-disabled"), 
          length = enabledCollapsibles.length, 
          target = $(event.target).closest(".oj-collapsible"), 
          currentIndex = enabledCollapsibles.index(target), 
          toFocus = false;

      if (currentIndex >= 0)
      {
        switch (event.keyCode)
        {
          case keyCode.RIGHT:
          case keyCode.DOWN:
            toFocus = enabledCollapsibles[(currentIndex + 1) % length];
            break;
          case keyCode.LEFT:
          case keyCode.UP:
            toFocus = enabledCollapsibles[(currentIndex - 1 + length) % length];
            break;
          case keyCode.HOME:
            toFocus = enabledCollapsibles[0];
            break;
          case keyCode.END:
            toFocus = enabledCollapsibles[length - 1];
            break;
        }
      }

      if (toFocus)
      {
        if (target)
        {
          $(target).trigger("ojfocusout");
        }
        $(toFocus).trigger("ojfocus");

        event.preventDefault();
      }
    },

    /* 
     * For single expansion
     *   returns a list of expanded collapsible widgets that are sibling 
     *   of the current event target
     * For multiple expansion
     *   returns an empty set.
     */
    _findTargetSiblings : function (event)
    {
      if (! this.options.multiple)
      {
        var closestCollapsible = $(event.target).closest(".oj-collapsible");

        if (closestCollapsible.parent().is(":oj-ojAccordion"))
          return closestCollapsible
            .siblings(".oj-collapsible.oj-expanded")
            .map(function()
            {
              return $(this).data("oj-ojCollapsible");
            });
      }
      return $();
    },

    /* 
     * Trigger "beforeCollapse" on all expanded siblings in
     * the before expand handler
     */
    _beforeExpandHandler : function (event, eventData)
    {
      if (! this._isTargetMyCollapsible(event))
        return true;

      var result, self = this;
      var newData;

      this._findTargetSiblings(event).each(function()
      {
        var collapsible = this.element;
        newData = self._initEventData(collapsible, $(event.target));

        var beforeCollapsedData = {
          /** @expose */
          header : collapsible.find(".oj-collapsible-header"),

          /** @expose */
          content : collapsible.find(".oj-collapsible-content")
        };

        result = this._trigger("beforeCollapse", event, beforeCollapsedData);
        return result;
      });

      if (! newData)
        newData = self._initEventData(null, $(event.target));

      if (! this.options.multiple)
        this._trigger("beforeExpand", event, newData);

      return result;
    },

    /* 
     * Collapse all expanded siblings and don't allow cancel
     */
    _expandHandler : function (event, eventData)
    {
      if (! this._isTargetMyCollapsible(event))
        return;

      var newData;
      var self = this;

      this._findTargetSiblings(event).each(function ()
      {
        this.collapse(false, event, eventData);
        newData = self._initEventData(this.element, $(event.target));
      });

      if (! newData)
        newData = self._initEventData(null, $(event.target));

      if (! this.options.multiple)
        this._trigger("expand", event, newData);

      this._updateExpanded();

    },

    /* 
     * Trigger "beforecollapse" on all collapsed siblings in
     * the before collapse handler
     */
    _beforeCollapseHandler : function (event, eventData)
    {
      if (this._isTargetMyCollapsible(event) &&
          ! this.options.multiple)
      {
        return this._trigger("beforeCollapse", event, 
                             this._initCollapseEventData(event, eventData));
      }
      return true;
    },

    /* 
     * Collapse all collapsed siblings and don't allow cancel
     */
    _collapseHandler : function (event, eventData)
    {
      if (this._isTargetMyCollapsible(event))
      {
        var newData = this._initCollapseEventData(event, eventData);

        if (! this.options.multiple)
          this._trigger("collapse", event, newData);

        this._updateExpanded();
      }
    },

    _initEventData : function (fromC, toC)
    {
      var eventData =
      {
        /** @expose */
        fromCollapsible : fromC, //the collapsible being collapsed.
        /** @expose */
        toCollapsible : toC      //the collapsible being expanded.
      };

      return eventData;
    },

    _initCollapseEventData : function (event, eventData)
    {
      var newData;
      if (eventData.toCollapsible)
      {
        newData = eventData;
      }
      else
      {
        if (event.originalEvent && event.originalEvent.target)
        {
          var collapsible = $(event.originalEvent.target);
          if (collapsible.hasClass("oj-collapsible"))
          {
            newData = this._initEventData($(event.target), collapsible);
          }
        }
        if (! newData)
          newData = this._initEventData($(event.target), null);
      }

      return newData;
    },

    /*
     * To filter out events from the nested accordion
     */
    _isTargetMyCollapsible : function (event)
    {
      return $(event.target).is(this.colllapsibles);
    },

    _updateExpanded : function ()
    {
      var cid;
      var result = [];
      this.colllapsibles.each(function (index)
      {
        //push collapsible id if provided, otherwise index
        if ($(this).ojCollapsible("option", "expanded"))
        {
          cid = $(this).attr("id");
          result.push(cid ? cid : index);
        }
      });

      this.options.expanded = result;
    },

    _setExpandedOption: function(expanded)
    {
      //map of (id, index)
      var idMap = {};
      this.colllapsibles.each(function(index) {
        //  $(this).ojCollapsible("option", "expanded", true);
        var id = $(this).attr("id");
        if (id)
          idMap[id] = index;
      });

      //expandedList contains indices of expanded collapsibles
      var expandedList = [];
      if (Array.isArray(expanded))
      {
        var ex;
        for (var i = 0; i < expanded.length; i++) {
          ex = expanded[i];
          if (typeof ex === 'string')
          {
            if (idMap[ex] !== undefined)
              expandedList[idMap[ex]] = true;
          }
          else if (typeof ex === 'number')
          {
            expandedList[ex] = true;
          }
        }
      }
    
      //loop thru collapsibles to collapse/expand based on expandedList
      for(var i = 0; i < expandedList.length; i++)
      {
        //Note: expandeList[i] can be true or undefined
        $(this.colllapsibles[i]).ojCollapsible("option", "expanded", !! expandedList[i]);
      }

      this._updateExpanded();
    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     *
     * Test authors should target sub elements using the following names:
     * <ul>
     * <li><b>oj-accordion-collapsible</b>: collapsible div </li>
     * <li><b>oj-accordion-header</b>: collapsible header </li>
     * <li><b>oj-accordion-content</b>: collapsible content </li>
     * <li><b>oj-accordion-header-icon</b>: collapsible disclosure icon </li>
     * </ul>
     *
     * In addition, accordion requires a zero-based index of the child collapsible.
     * @expose
     * @memberof! oj.ojAccordion
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent.<p>
     *        index: a number, the index of collapsible.
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      if (locator == null)
      {
        return this.element ? this.element[0] : null;
      }

      var subId = locator['subId'],
          index = locator['index'];

      if ((typeof index !== 'number') ||
          index < 0 || index >= this.colllapsibles.length)
        return null;

      var collapsible = this.colllapsibles[index];

      switch (subId)
      {
      case 'oj-accordion-content':
        subId = 'oj-collapsible-content';
        break;

      case 'oj-accordion-header':
        subId = 'oj-collapsible-header';
        break;

      case 'oj-accordion-header-icon':
        subId = 'oj-collapsible-header-icon';
        break;

      case 'oj-accordion-collapsible':
        return collapsible;

      default:
        // Non-null locators have to be handled by the component subclasses
        return null;
      }
      return $(collapsible).ojCollapsible("getNodeBySubId", {"subId": subId});
    }


  });
}
());
/**
 * An object used for automation verification of chart axes
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartAxis = function(data) {
  this._data = data;
};

/**
 * Returns the title of an axis
 * @return {String} The axis title
 * @export
 */
oj.ChartAxis.prototype.getTitle = function() {
  return this._data ? this._data['title'] : null;
};

/**
 * Returns the bounds of an axis
 * @return {Object} An object containing the x, y coordinates and width and height of the axis
 * @export
 */
oj.ChartAxis.prototype.getBounds = function() {
  return this._data ? this._data['bounds'] : null;
};

/**
 * An object used for automation verification of spark chart data items
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.SparkChartDataItem = function(data) {
  this._data = data;
};

/**
 * Returns the border color of a spark chart data item
 * @returns {String} The data item border color
 * @export
 */
oj.SparkChartDataItem.prototype.getBorderColor = function() {
  return this._data ? this._data['borderColor'] : null;
};

/**
 * Returns the color of a spark chart data item
 * @returns {String} The data item color
 * @export
 */
oj.SparkChartDataItem.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the date of a spark chart data item.
 * @returns {Date} The data item date
 * @export
 */
oj.SparkChartDataItem.prototype.getDate = function() {
  return this._data ? this._data['date'] : null;
};

/**
 * Returns the float value of a spark chart data item. Only applies to floatingBar sparkChart types.
 * @returns {Number} The data item float value
 * @export
 */
oj.SparkChartDataItem.prototype.getFloatValue = function() {
  return this._data ? this._data['floatValue'] : null;
};

/**
 * Returns the value of a spark chart data item.
 * @returns {Number} The data item value
 * @export
 */
oj.SparkChartDataItem.prototype.getValue = function() {
  return this._data ? this._data['value'] : null;
};


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class 
 * @name oj.ojChart
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="chartOverview-section">
 *   JET Chart Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartOverview-section"></a>
 * </h3>
 * 
 * <p>Chart component for JET with support for bar, line, area, combination, pie, scatter, bubble, and funnel
 * charts.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojChart',
 *   type: 'bar',
 *   series: [{name: 'Q1 Sales', items: [50, 60, 20]}],  
 *   groups: ['Phones', 'Tablets', 'Laptops']
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="chartOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/chart.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.  Since component terminology for keyboard 
 * and touch shortcuts can conflict with those of the application, it is the 
 * application's responsibility to provide these shortcuts, possibly via a help 
 * popup.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move focus and selection to previous data item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move focus and selection to next data item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move focus and selection to previous data item (on left).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move focus and selection to next data item (on right).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+UpArrow</kbd></td>
 *       <td>Move focus and multi-select previous data item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+DownArrow</kbd></td>
 *       <td>Move focus and multi-select next data item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+LeftArrow</kbd></td>
 *       <td>Move focus and multi-select previous data item (on left).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+RightArrow</kbd></td>
 *       <td>Move focus and multi-select next data item (on right).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+UpArrow</kbd></td>
 *       <td>Move focus to previous data item, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+DownArrow</kbd></td>
 *       <td>Move focus to next data item, without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+LeftArrow</kbd></td>
 *       <td>Move focus to previous data item (on left), without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+RightArrow</kbd></td>
 *       <td>Move focus to next data item (on right), without changing the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+Spacebar</kbd></td>
 *       <td>Multi-select data item with focus.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>= or +</kbd></td>
 *       <td>Zoom in one level if zooming is enabled</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>- or _</kbd></td>
 *       <td>Zoom out one level if zooming is enabled</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>PageUp</kbd></td>
 *       <td>Pan up if scrolling is enabled</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>PageDown</kbd></td>
 *       <td>Pan down if scrolling is enabled</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+PageUp</kbd></td>
 *       <td>Pan left in left-to-right locales. Pan right in right-to-left locales.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+PageDown</kbd></td>
 *       <td>Pan right in left-to-right locales. Pan left in right-to-left locales.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Chart.
 * @example <caption>Initialize the Chart with no options specified:</caption>
 * $(".selector").ojChart();
 * 
 * @example <caption>Initialize the Chart with some options:</caption>
 * $(".selector").ojChart({type: 'bar'});
 * 
 * @example <caption>Initialize the Chart via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojChart'}">
 */
oj.__registerWidget('oj.ojChart', $['oj']['dvtBaseComponent'],
  {
    version: "1.0.0",
    widgetEventPrefix: "oj",
    options: {
      /**
       * Triggered when a category of data items is hidden or shown. 
       * 
       * @property {Object} ui event payload
       * @property {Object} ui.category the category that was filtered on
       * @property {string} ui.type specifies whether the category is being filtered 'in' or 'out'
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">categoryFilter</code> callback specified:</caption>
       * $(".selector").ojChart({
       *   "categoryFilter": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryfilter</code> event:</caption>
       * $(".selector").on("ojcategoryfilter", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojChart
       * @instance
       */
      categoryFilter: null,
      /**
       * Triggered when a category of data items is highlighted. 
       * 
       * @property {Object} ui event payload
       * @property {Array} ui.categories the categories that are being highlighted
       * @property {string} ui.type specifies whether highlighting is being turned 'on' or 'off'
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">categoryHighlight</code> callback specified:</caption>
       * $(".selector").ojChart({
       *   "categoryHighlight": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryhighlight</code> event:</caption>
       * $(".selector").on("ojcategoryhighlight", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojChart
       * @instance
       */
      categoryHighlight: null,
    
      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
       * intervention. If the new value is the same as the previous value, no event will be fired. Additional options may 
       * be supported in the future, so listeners should verify which option is changing before taking any action. 
       * Currently supports: <code class="prettyprint">selectedItems</code>
       * 
       * @property {Object} data event payload
       * @property {string} data.option the name of the option that changed, i.e. "value"
       * @property {Object} data.previousValue an Object holding the previous value of the option
       * @property {Object} data.value an Object holding the current value of the option
       * @property {Object} ui.optionMetadata information about the option that is changing
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *                    <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
       * $(".selector").ojChart({
       *   'optionChange': function (event, data) {} 
       * });
       * 
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
       * $(".selector").on({
       *   'ojoptionchange': function (event, data) {
       *       window.console.log("option changing is: " + data['option']);
       *   };
       * });
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojChart
       * @instance
       */
      optionChange: null,
      
      /**
       * Triggered after data items are selected or de-selected.
       * 
       * @property {Object} ui event payload
       * @property {Array} ui.items an array containing objects describing the selected data items
       * @property {string} ui.items.id the id of the data item, if one was specified
       * @property {string} ui.items.group the group of the data item
       * @property {string} ui.items.series the series of the data item
       * @property {string} ui.endGroup the end group of a marquee selection on a chart with categorical axis
       * @property {string} ui.startGroup the start group of a marquee selection on a chart with categorical axis
       * @property {number} ui.xMax the maximum x value of a marquee selection 
       * @property {number} ui.xMin the minimum x value of a marquee selection 
       * @property {number} ui.yMax the maximum y value of a marquee selection 
       * @property {number} ui.yMin the minimum y value of a marquee selection 
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
       * $(".selector").ojChart({
       *   "select": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
       * $(".selector").on("ojselect", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojChart
       * @instance
       */
      select: null,
      
      /**
       * Triggered during a selection gesture, such as a change in the marquee selection rectangle.
       * 
       * @property {Object} ui event payload
       * @property {Array} ui.items an array containing objects describing the selected data items
       * @property {string} ui.items.id the id of the data item, if one was specified
       * @property {string} ui.items.group the group of the data item
       * @property {string} ui.items.series the series of the data item
       * @property {string} ui.endGroup the end group of a marquee selection on a chart with categorical axis
       * @property {string} ui.startGroup the start group of a marquee selection on a chart with categorical axis
       * @property {number} ui.xMax the maximum x value of a marquee selection 
       * @property {number} ui.xMin the minimum x value of a marquee selection 
       * @property {number} ui.yMax the maximum y value of a marquee selection 
       * @property {number} ui.yMin the minimum y value of a marquee selection 
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">selectInput</code> callback specified:</caption>
       * $(".selector").ojChart({
       *   "selectInput": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojselectinput</code> event:</caption>
       * $(".selector").on("ojselectinput", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojChart
       * @instance
       */
      selectInput: null,
      
      /**
       * Triggered after the viewport is changed due to a zoom or scroll operation.
       * 
       * @property {Object} ui event payload
       * @property {string} ui.endGroup the end group of the new viewport on a chart with categorical axis
       * @property {string} ui.startGroup the start group of the new viewport on a chart with categorical axis
       * @property {number} ui.xMax the maximum x value of the new viewport
       * @property {number} ui.xMin the minimum x value of the new viewport
       * @property {number} ui.yMax the maximum y value of the new viewport
       * @property {number} ui.yMin the minimum y value of the new viewport
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">viewportChange</code> callback specified:</caption>
       * $(".selector").ojChart({
       *   "viewportChange": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojviewportchange</code> event:</caption>
       * $(".selector").on("ojviewportchange", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojChart
       * @instance
       */
      viewportChange: null,
      
      /**
       * Triggered during a viewport change gesture, such as a drag operation on the overview window. Note: There are
       * situations where the component cannot determine whether the viewport change gesture is still in progress, such
       * as with mouse wheel zoom interactions. Standard viewportChange events are fired in these cases.
       * 
       * @property {Object} ui event payload
       * @property {string} ui.endGroup the end group of the new viewport on a chart with categorical axis
       * @property {string} ui.startGroup the start group of the new viewport on a chart with categorical axis
       * @property {number} ui.xMax the maximum x value of the new viewport
       * @property {number} ui.xMin the minimum x value of the new viewport
       * @property {number} ui.yMax the maximum y value of the new viewport
       * @property {number} ui.yMin the minimum y value of the new viewport
       * 
       * @example <caption>Initialize the component with the <code class="prettyprint">viewportChangeInput</code> callback specified:</caption>
       * $(".selector").ojChart({
       *   "viewportChangeInput": function(event, ui){}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojviewportchangeinput</code> event:</caption>
       * $(".selector").on("ojviewportchangeinput", function(event, ui){});
       * 
       * @expose 
       * @event 
       * @memberof! oj.ojChart
       * @instance
       */
      viewportChangeInput: null
    },
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _CreateDvtComponent: function(context, callback, callbackObj) {
      return DvtChart.newInstance(context, callback, callbackObj);
    },
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _ProcessStyles: function() {
      this._super();
      if (!this.options['styleDefaults'])
        this.options['styleDefaults'] = {};
      if (!this.options['styleDefaults']['colors']) {
        var handler = new oj.ColorAttributeGroupHandler();
        // override default colors with css attribute group colors
        this.options['styleDefaults']['colors'] = handler.getValueRamp();
      }
    },
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _GetComponentStyleClasses: function() {
      var styleClasses = this._super();
      styleClasses.push('oj-chart');
      return styleClasses;
    },
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _GetChildStyleClasses: function() {
      var styleClasses = this._super();
      styleClasses['oj-chart-footnote'] = {'path': 'footnote/style', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-slice-label'] = {'path': 'styleDefaults/sliceLabelStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-subtitle'] = {'path': 'subtitle/style', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-title'] = {'path': 'title/style', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-xaxis-tick-label'] = {'path': 'xAxis/tickLabel/style', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-xaxis-title'] = {'path': 'xAxis/titleStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-yaxis-tick-label'] = {'path': 'yAxis/tickLabel/style', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-yaxis-title'] = {'path': 'yAxis/titleStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-y2axis-tick-label'] = {'path': 'y2Axis/tickLabel/style', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-chart-y2axis-title'] = {'path': 'y2Axis/titleStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-legend'] = {'path': 'legend/textStyle', 'property': 'CSS_TEXT_PROPERTIES'};
      styleClasses['oj-legend-title'] = {'path': 'legend/titleStyle', 'property': 'CSS_TEXT_PROPERTIES'};

      // Images
      styleClasses['oj-chart-pan-icon'] = {'path': '_resources/panUp', 'property': 'CSS_URL'};
      styleClasses['oj-chart-pan-icon oj-active'] = {'path': '_resources/panDown', 'property': 'CSS_URL'};
      styleClasses['oj-chart-select-icon'] = {'path': '_resources/selectUp', 'property': 'CSS_URL'};
      styleClasses['oj-chart-select-icon oj-active'] = {'path': '_resources/selectDown', 'property': 'CSS_URL'};
      styleClasses['oj-chart-zoom-icon'] = {'path': '_resources/zoomUp', 'property': 'CSS_URL'};
      styleClasses['oj-chart-zoom-icon oj-active'] = {'path': '_resources/zoomDown', 'property': 'CSS_URL'};
      return styleClasses;
    },
    
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _GetEventTypes : function() {
      return ['categoryFilter', 'categoryHighlight', 'optionChange', 'select', 'selectInput', 
              'viewportChange', 'viewportChangeInput'];
    },
    
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _GetTranslationMap: function() {
      // Safe to modify super's map because function guarentees a new map is returned
      var ret = this._super();
      ret['DvtChartBundle.DEFAULT_GROUP_NAME'] = this._GetTranslatedResource('labelDefaultGroupName', ['groupName']);
      ret['DvtChartBundle.EMPTY_TEXT'] = this._GetTranslatedResource('msgNoData');
      ret['DvtChartBundle.INVALID_DATA'] = this._GetTranslatedResource('msgInvalidData');
      ret['DvtChartBundle.LABEL_SERIES'] = this._GetTranslatedResource('labelSeries', ['seriesName']);
      ret['DvtChartBundle.LABEL_GROUP'] = this._GetTranslatedResource('labelGroup', ['groupName']);
      ret['DvtChartBundle.LABEL_VALUE'] = this._GetTranslatedResource('labelValue', ['value']);
      ret['DvtChartBundle.LABEL_TARGET_VALUE'] = this._GetTranslatedResource('labelTargetValue', ['targetValue']);
      ret['DvtChartBundle.LABEL_X'] = this._GetTranslatedResource('labelX', ['x']);
      ret['DvtChartBundle.LABEL_Y'] = this._GetTranslatedResource('labelY', ['y']);
      ret['DvtChartBundle.LABEL_Z'] = this._GetTranslatedResource('labelZ', ['z']);
      ret['DvtChartBundle.LABEL_LOW'] = this._GetTranslatedResource('labelLow', ['low']);
      ret['DvtChartBundle.LABEL_HIGH'] = this._GetTranslatedResource('labelHigh', ['high']);
      ret['DvtChartBundle.LABEL_OTHER'] = this._GetTranslatedResource('labelOther');
      ret['DvtChartBundle.PAN'] = this._GetTranslatedResource('tooltipPan');
      ret['DvtChartBundle.MARQUEE_SELECT'] = this._GetTranslatedResource('tooltipSelect');
      ret['DvtChartBundle.MARQUEE_ZOOM'] = this._GetTranslatedResource('tooltipZoom');
      return ret;
    },
  
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _HandleEvent: function(event) {
      var type = event && event.getType ? event.getType() : null;
      if (type === DvtSelectionEvent.TYPE || type === DvtSelectionEvent.TYPE_INPUT) {
        var selection = event.getSelection();
        if (selection) {
          // Convert the graph selection context into the JET context
          var selectedItems = [];
          for (var i = 0; i < selection.length; i++) {
            var selectedItem = {'id': selection[i].getId(),
              'series': selection[i].getSeries(),
              'group': selection[i].getGroup()};
            selectedItems.push(selectedItem);
          }
          
          // Update the options selection state if this is a non-input event
          if(type === DvtSelectionEvent.TYPE)
            this._UserOptionChange('selectedItems', selectedItems);

          var selectPayload = {
            'items': selectedItems,
            'endGroup': event.getEndGroup(), 'startGroup': event.getStartGroup(),
            'xMax': event.getXMax(), 'xMin': event.getXMin(),
            'yMax': event.getYMax(), 'yMin': event.getYMin()
          };
          
          this._trigger(type === DvtSelectionEvent.TYPE ? 'select' : 'selectInput', null, selectPayload);
        }
      }
      else if (type === DvtCategoryHideShowEvent.TYPE_HIDE || type === DvtCategoryHideShowEvent.TYPE_SHOW) {
        var filterType = (type === DvtCategoryHideShowEvent.TYPE_HIDE) ? 'out' : 'in';
        var series = this.options['series'];
        for (var i = 0; i < series.length; i++) {
          if (series[i]['name'] == event.getCategory())
            series[i]['visibility'] = (type === DvtCategoryHideShowEvent.TYPE_HIDE ? 'hidden' : 'visible');
        }
        this._trigger('categoryFilter', null, {'category': event.getCategory(), 'type': filterType});
      }
      else if (type === DvtCategoryRolloverEvent.TYPE_OVER || type === DvtCategoryRolloverEvent.TYPE_OUT) {
        var highlightType = (type === DvtCategoryRolloverEvent.TYPE_OVER) ? 'on' : 'off';
        this._trigger('categoryHighlight', null, {'categories': [event.getCategory()], 'type': highlightType});
      }
      else if (type === DvtChartViewportChangeEvent.TYPE || type === DvtChartViewportChangeEvent.TYPE_INPUT) {
        var viewportChangePayload = {'endGroup': event.getEndGroup(), 'startGroup': event.getStartGroup(),
          'xMax': event.getXMax(), 'xMin': event.getXMin(),
          'yMax': event.getYMax(), 'yMin': event.getYMin()};
          
        this._trigger(type === DvtChartViewportChangeEvent.TYPE ? 'viewportChange' : 'viewportChangeInput', null, viewportChangePayload);
      }
      else {
        this._super(event);
      }
    },
    
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _LoadResources: function() {
      // Ensure the resources object exists
      if (this.options['_resources'] == null)
        this.options['_resources'] = {};

      var resources = this.options['_resources'];

      // Add images
      resources['overviewGrippy'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/chart/drag_horizontal.png');

      // Add cursors
      resources['panCursorDown'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/chart/hand-closed.cur');
      resources['panCursorUp'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/chart/hand-open.cur');
    },
    
    /**
     * @override
     * @memberof! oj.ojChart
     * @instance
     * @protected
     */
    _SupportsOptionChangeEvent : function(key) {
      return key == 'selectedItems';
    },
    
    /**
     * Returns the subcomponent node represented by the documented locator attribute values.
     * Test authors should target chart sub elements using the following locators:
     * <ul>
     *   <li>dataItem[seriesIndex][groupIndex] - A data item indexed by its series index and group index. [groupIndex] 
     *       is not required for pie and funnel chart types.</li>
     *   <li>series[seriesIndex] - A legend item that represents the series with the given seriesIndex</li>
     *   <li>group[groupIndex] - A categorical axis label that represents the group with the given groupIndex</li>
     * </ul>
     * @override
     * @expose
     * @memberof! oj.ojChart
     * @instance
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator) {
      return this._super(locator);
    },
    
    /**
     * Returns the subId string for the given child DOM node. Valid chart subIds include:
     * <ul>
     *   <li>dataItem[seriesIndex][groupIndex] - A data item indexed by its series index and group index. [groupIndex] 
     *       is not required for pie and funnel chart types.</li>
     *   <li>series[seriesIndex] - A legend item that represents the series with the given seriesIndex</li>
     *   <li>group[groupIndex] - A categorical axis label that represents the group with the given groupIndex</li>
     * </ul> 
     * @override
     * @expose
     * @memberof! oj.ojChart
     * @instance
     * @param {Element} node The subcomponent node used by the component to lookup the subId string
     * @return {string|null} - the subId for the DOM node or null when none is found
     */
    getSubIdByNode: function(node) {
      return this._super(node);
    },
    
    /**
     * Returns the chart title. 
     * @return {String} The chart title
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getTitle: function() {
      var auto = this._component.getAutomation();
      return auto.getTitle();
    },
    
    /**
     * Returns the group corresponding to the given index
     * @param {String} groupIndex the group index
     * @return {String} The group name corresponding to the given group index
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getGroup: function(groupIndex) {
      var auto = this._component.getAutomation();
      return auto.getGroup(groupIndex);
    },
    
    /**
     * Returns the series corresponding to the given index
     * @param {String} seriesIndex the series index
     * @return {String} The series name corresponding to the given series index
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getSeries: function(seriesIndex) {
      var auto = this._component.getAutomation();
      return auto.getSeries(seriesIndex);
    },
    
    /**
     * Returns number of groups in the chart data
     * @return {Number} The number of groups
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getGroupCount: function() {
      var auto = this._component.getAutomation();
      return auto.getGroupCount();
    },
    
    /**
     * Returns number of series in the chart data
     * @return {Number} The number of series
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getSeriesCount: function() {
      var auto = this._component.getAutomation();
      return auto.getSeriesCount();
    },
    
    /**
     * Returns a ChartDataItem object for automation testing verification.
     * @param {Number} seriesIndex The series index
     * @param {Number} groupIndex The group index
     * @return {Object} The chart data item with the given series index and group index 
     *                             or null if none exists
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getDataItem: function(seriesIndex, groupIndex) {
      var auto = this._component.getAutomation();
      return new oj.ChartDataItem(auto.getDataItem(seriesIndex, groupIndex));
    },
    
    /**
     * Returns a ChartLegend object for automation testing verification.
     * @return {Object} The legend for this chart
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getLegend: function() {
      var auto = this._component.getAutomation();
      return new oj.ChartLegend(auto.getLegend());
    },
    
    /**
     * Returns a ChartPlotArea object for automation testing verification.
     * @return {Object} The plot area for this chart
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getPlotArea: function() {
      var auto = this._component.getAutomation();
      return new oj.ChartPlotArea(auto.getPlotArea());
    },
    
    /**
     * Returns a ChartAxis object for automation testing verification.
     * @return {Object} The xAxis for this chart or null if it doesn't exist
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getXAxis: function() {
      var auto = this._component.getAutomation();
      return new oj.ChartAxis(auto.getXAxis());
    },
    
    /**
     * Returns a ChartAxis object for automation testing verification.
     * @return {Object} The yAxis for this chart or null if it doesn't exist
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getYAxis: function() {
      var auto = this._component.getAutomation();
      return new oj.ChartAxis(auto.getYAxis());
    },
    
    /**
     * Returns a ChartAxis object for automation testing verification.
     * @return {Object} The y2Axis for this chart or null if it doesn't exist
     * @expose
     * @instance
     * @memberof! oj.ojChart
     */
    getY2Axis: function() {
      var auto = this._component.getAutomation();
      return new oj.ChartAxis(auto.getY2Axis());
    }
  });
/**
 * An object used for automation verification of a chart plot area
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartPlotArea = function(data) {
  this._data = data;
};

/**
 * Returns the bounds of the plot area
 * @return {Object} An object containing the x, y coordinates and width and height of the plotarea
 * @export
 */
oj.ChartPlotArea.prototype.getBounds = function() {
  return this._data ? this._data['bounds'] : null;
};

/**
 * An object used for automation verification of a chart legend
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartLegend = function(data) {
  this._data = data;
};

/**
 * Returns the title of a legend
 * @return {String} The legend title
 * @export
 */
oj.ChartLegend.prototype.getTitle = function() {
  return this._data ? this._data['title'] : null;
};

/**
 * Returns the bounds of a legend
 * @return {Object} An object containing the x, y coordinates and width and height of the legend
 * @export
 */
oj.ChartLegend.prototype.getBounds = function() {
  return this._data ? this._data['bounds'] : null;
};

/**
 * @class 
 * @name oj.ojSparkChart
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="sparkChartOverview-section">
 *   JET Spark Chart Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sparkChartOverview-section"></a>
 * </h3>
 * 
 * <p>Spark Chart component for JET with support for bar, line, area, and floating bar subtypes.  Spark Charts are
 * designed to visualize the trend of a data set in a compact form factor.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojSparkChart', 
 *   type: 'line', 
 *   items: [5, 8, 2, 7, 0, 9]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="sparkChartOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sparkChartOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/sparkChart.xml">here</a>.</p>
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>The application is responsible for populating the shortDesc value in the 
 * component options object with meaningful descriptors when the component does 
 * not provide a default descriptor.</p>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Spark Chart. 
 * @example <caption>Initialize the Chart with no options specified:</caption>
 * $(".selector").ojSparkChart();
 * 
 * @example <caption>Initialize the Spark Chart with some options:</caption>
 * $(".selector").ojSparkChart({type: 'line', items: [5, 8, 2, 7, 0, 9]});
 * 
 * @example <caption>Initialize the Spark Chart via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojSparkChart'}">
 */
oj.__registerWidget('oj.ojSparkChart', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  
  /**
   * @override
   * @memberof! oj.ojSparkChart
   * @instance
   * @protected
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return DvtSparkChart.newInstance(context, callback, callbackObj);
  },  
  
  /**
   * @override
   * @memberof! oj.ojSparkChart
   * @instance
   * @protected
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-sparkchart');
    return styleClasses;
  },
  
  /**
   * @override
   * @memberof! oj.ojSparkChart
   * @instance
   * @protected
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip. Remove title from div to avoid browser default tooltip.
    if(this.element.attr('title'))
    {
      this.options['shortDesc'] =  this.element.attr('title');
      this.element.data( this.element,'title', this.element.attr('title'));
      this.element.removeAttr('title');
    }
    else if (this.element.data('title'))
      this.options['shortDesc'] =  this.element.data('title');
  
    // Call the super to render
    this._super();
  },  
  
  /**
   * Returns the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spark chart sub elements using the following locators:
   * <ul>
   *   <li>dataItem[itemIndex] - A data item indexed by its location in the item array</li>
   * </ul>
   * @override
   * @expose
   * @memberof! oj.ojSparkChart
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   *        whose value is a string, documented by the component, that allows 
   *        the component to look up the subcomponent associated with that 
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one 
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component 
   *        expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
  getNodeBySubId : function(locator) {
    return this._super(locator);
  },
  
  /**
   * Returns the subId string for the given child DOM node. Valid spark chart subIds include:
   * <ul>
   *   <li>dataItem[itemIndex] - A data item indexed by its location in the item array</li>
   * </ul>
   * @override
   * @expose
   * @memberof! oj.ojSparkChart
   * @instance
   * @param {Element} node The subcomponent node used by the component to lookup the subId string
   * @return {string|null} - the subId for the DOM node or null when none is found
   */
  getSubIdByNode:function(node) {
    return this._super(node);  
  },
  
  /**
   * Returns a SparkChartDataItem object for automation testing verification.
   * @param {String} itemIndex The dataItem index
   * @return {Object} The spark chart data item with the given item index
   * @expose
   * @instance
   * @memberof! oj.ojSparkChart
   */
  getDataItem: function(itemIndex) {
    var auto = this._component.getAutomation();
    return new oj.SparkChartDataItem(auto.getDataItem(itemIndex));
  }
});
/**
 * An object used for automation verification of chart data items
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartDataItem = function(data) {
  this._data = data;
};

/**
 * Returns the group of a chart data item
 * @returns {String} The data item group
 * @export
 */
oj.ChartDataItem.prototype.getGroup = function() {
  return this._data ? this._data['group'] : null;
};

/**
 * Returns the series of a chart data item
 * @returns {String} The data item series
 * @export
 */
oj.ChartDataItem.prototype.getSeries = function() {
  return this._data ? this._data['series'] : null;
};

/**
 * Returns the border color of a chart data item
 * @returns {String} The data item border color
 * @export
 */
oj.ChartDataItem.prototype.getBorderColor = function() {
  return this._data ? this._data['borderColor'] : null;
};

/**
 * Returns the color of a chart data item
 * @returns {String} The data item color
 * @export
 */
oj.ChartDataItem.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the label of a chart data item
 * @returns {String} The data item label
 * @export
 */
oj.ChartDataItem.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};

/**
 * Returns the value of a chart data item.
 * @returns {Number} The data item value
 * @export
 */
oj.ChartDataItem.prototype.getValue = function() {
  return this._data ? this._data['value'] : null;
};

/**
 * Returns the target value of a chart data item. Only applies to funnel chart types.
 * @returns {Number} The data item target value
 * @export
 */
oj.ChartDataItem.prototype.getTargetValue = function() {
  return this._data ? this._data['targetValue'] : null;
};

/**
 * Returns the tooltip of a chart data item.
 * @returns {String} The data item tooltip
 * @export
 */
oj.ChartDataItem.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns the x value of a chart data item.
 * @returns {Number} The data item x value
 * @export
 */
oj.ChartDataItem.prototype.getX = function() {
  return this._data ? this._data['x'] : null;
};

/**
 * Returns the y value of a chart data item.
 * @returns {Number} The data item y value
 * @export
 */
oj.ChartDataItem.prototype.getY = function() {
  return this._data ? this._data['y'] : null;
};

/**
 * Returns the z value of a chart data item.
 * @returns {Number} The data item z value
 * @export
 */
oj.ChartDataItem.prototype.getZ = function() {
  return this._data ? this._data['z'] : null;
};

/**
 * Returns whether or not the data item is selected
 * @returns {Boolean} The data item selection state
 * @export
 */
oj.ChartDataItem.prototype.isSelected = function() {
  return this._data ? this._data['selected'] : false;
};
/**
 * oj.Collection based implementation of TreeDataSource
 * @param {Object} options an object containing the following options:<p>
 * root: an oj.Collection specifying the root level Collection<p>
 * childCollectionCallback: a function(oj.Collection,oj.Model):oj.Collection callback to return a child collection given a root and model representing the parent<p>
 * parseMetadata: a function(oj.Model):Object callback to return key, leaf, depth metadata from a given Model<p>
 * @constructor
 * @export
 * @extends oj.TreeDataSource
 */
oj.CollectionTreeDataSource = function(options)
{
    options = options || {};
    this.rootCollection = options['root'];
    this.childCollectionCallback = options['childCollectionCallback'];
    this.parseMetadata = options['parseMetadata'];
    this.sortkey = null;
    this.sortdir = "none";
    // This is a parent->collection cache
    this.cache = {};
    oj.CollectionTreeDataSource.superclass.constructor.call(this);
};

// Default implementation
oj.CollectionTreeDataSource.prototype.parseMetadata = function(model) {    
    return {'key':model['idAttribute']+"="+model['id']};
};

// Subclass from oj.TreeDataSource
oj.Object.createSubclass(oj.CollectionTreeDataSource, oj.TreeDataSource, "oj.CollectionTreeDataSource");

/**
 * Initializes the data source.
 * @export
 */
oj.CollectionTreeDataSource.prototype.Init = function()
{
    // super
    oj.CollectionTreeDataSource.superclass.Init.call(this);
};


/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {Object} parent the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 * @export
 */
oj.CollectionTreeDataSource.prototype.getChildCount = function(parent)
{
    var childColl = this.cache[parent];    
    if (childColl) {
        if (childColl.length > 0) {
            return childColl.length;
        }
    }
    this.getChildCollection(parent, {'success': function(coll) {
                return coll.length;
        }});
                                       
    return -1;
};

/**
 * Gets a collection representing the specified parent key's children.
 * @param {Object} key the parent key in which to create an OJ collection for.
 * @param {Object} callbacks success and error callbacks.  The success callback will provide the child collection as the first argument
 * @export
 */
oj.CollectionTreeDataSource.prototype.getChildCollection = function(key, callbacks) {
    this.fetchChildren(key, null, {'success':function(nodeSet) {
            callbacks['success'](nodeSet._getCollection());
    }, 'error':callbacks['error']});
};

/**
 * Fetch the children
 * @param {Object} parent the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count.<p>
 * range.start the start index of the range in which the children are fetched.<p>
 * range.count the size of the range in which the children are fetched.  <p>
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".<p>
 * {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.<p>
 * {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.<p>
 * @param {Object=} options optional parameters for this operation. <p>
 * {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain 
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching.
 * @export
 */
oj.CollectionTreeDataSource.prototype.fetchChildren = function(parent, range, callbacks, options)
{
    range = range || {};
    var start = range['start'] ? range['start'] : 0;
    var count = range['count'] ? range['count'] : -1;
    
    if (parent === null) {
        // Do root
        this.FetchCollection(null, start, count, callbacks, null);
        return;
    }
    // Use child collection callback to set up child collection, then fetch it
    var self = this;
    this._getModelForId(this.rootCollection, parent, 0).then(function(parentModel) {
                                                        if (parentModel) {
                                                            var collection = self.GetChildCollection(parentModel.model);
                                                            self.FetchCollection(collection, start, count, callbacks, parent);
                                                        }
                                                        else {
                                                            // Couldn't find a model for the given Id: call the error if present
                                                            if (callbacks && callbacks['error']) {
                                                                callbacks['error'](parent);
                                                            }
                                                        }
                                                     });
};


// Called by common model when a model is added to a collection
oj.CollectionTreeDataSource.prototype.ModelAdded = function(model, collection, options) {
    var index = 0;
    if (options && options['at']) {
        index = options['at'];
    }
    var event = this._createEvent(this, "insert", index, this._getParentChain(collection), this._putModelInRowset(model));
    this.handleEvent("change", event);
};

// Called by common model when a model is removed from a collection
oj.CollectionTreeDataSource.prototype.ModelRemoved = function(model, collection, options) {
    var index = 0;
    if (options && options['index']) {
        index = options['index'];
    }
    this._removeCollectionFromCache(model);
    var event = this._createEvent(this, "delete", index, this._getParentChain(collection), null);
    this.handleEvent("change", event);
};

// Called by common model when a model is updated
oj.CollectionTreeDataSource.prototype.ModelUpdated = function(model, options) {
    var collectionForModel = this._getCollectionForModel(model);
    var index = null;
    var parents = null;
    if (collectionForModel) {
        // If this model's collection is found, get the index where it was found and its parent chain from the actual collection
        index = collectionForModel.index;
        parents = this._getParentChain(collectionForModel.collection);
    }
    var event = this._createEvent(this, "update", index, parents, this._putModelInRowset(model));
    this.handleEvent("change", event);
};

// Called if a collection is refreshed
oj.CollectionTreeDataSource.prototype.CollectionRefreshed = function(collection, resp, options) {
    var event = this._createEvent(this, "refresh", null, this._getParentChain(collection), null);
    this.handleEvent("change", event);
};

oj.CollectionTreeDataSource.prototype._putModelInRowset = function(model) {
    var rows = [];
    rows.push(model.attributes);
    var options = {};
    options['idAttribute'] = model['idAttribute'];    
    var rowset = new oj.ArrayRowSet(rows, options);
    rowset.fetch();
    return rowset;
};

// Return an array of parent keys representing the parentage of the given collection.  Relies on cached collection fetches.  Array is from
// child key of root on down to collection's parent
oj.CollectionTreeDataSource.prototype._getParentChain = function(collection) {
    var parents = [];
    var parent = null;
    var coll = collection;
    do {
        parent = this._getParentOfCollection(coll);
        if (parent !== null) {
            if (parent !== oj.CollectionTreeDataSource.ROOT_CACHE_KEY) {
                parents.unshift(parent);
            }
            coll = this._getCollectionOfKey(parent);
        }
    } while (parent != null);
    return parents;
};

// Generate the cache key
oj.CollectionTreeDataSource.ROOT_CACHE_KEY = "%!@ROOT%#@!";
oj.CollectionTreeDataSource.prototype._getCacheKey = function(model) {
    // If model (parent) is null, look for the root
    // If model is not an oj.Model, just use it as the key
    var key = model instanceof oj.Model ? this.parseMetadata(model)['key'] : model;
    return model ? key : oj.CollectionTreeDataSource.ROOT_CACHE_KEY;
};

// Return a cached collection given a parent Model.  Null if not cached
oj.CollectionTreeDataSource.prototype.__getParentsChildCollectionFromCache = function(model) {
    return this.cache[this._getCacheKey(model)];
};

// Put a collection into the cache whose parent is represented by model
oj.CollectionTreeDataSource.prototype._setCollectionInCache = function(model, collection) {
    // Tack on listeners
    collection.on(oj.Events.EventType['ADD'], this.ModelAdded, this);
    collection.on(oj.Events.EventType['REMOVE'], this.ModelRemoved, this);
    collection.on(oj.Events.EventType['CHANGE'], this.ModelUpdated, this);
    collection.on(oj.Events.EventType['SYNC'], this.CollectionRefreshed, this);
    this.cache[this._getCacheKey(model)] = collection;
};

// Remove any collections with the given model as a parent
oj.CollectionTreeDataSource.prototype._removeCollectionFromCache = function(model) {
    var key = this._getCacheKey(model);
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            if (prop === key) {
                // Found it: remove listeners and delete it
                this.cache[key].off(null, null, this);
                delete this.cache[key];
                return;
            }
        }
    }
};

// Determine if a model representing a given parent key is found in the given collection
oj.CollectionTreeDataSource.prototype._keyInCollection = function(key, collection) {
    var count = collection.length;
    for (var i = 0; i < count; i++) {
        var currKey = this._getCacheKey(collection.at(i));
        if (key === currKey) {
            return true;
        }
    }
    return false;
};

// Get the collection and index of the given model
oj.CollectionTreeDataSource.prototype._getCollectionForModel = function(model) {
    // Search the cache for the parent key
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            var collection = this.cache[prop];
            for (var i = 0; i < collection.length; i++) {
                if (collection.at(i) === model) {
                    return {index:i, collection:collection};
                }
            }
        }
    }
    return null;    
    
};

// Get the collection containing the given key
oj.CollectionTreeDataSource.prototype._getCollectionOfKey = function(key) {
    // Search the cache for the parent key
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            var collection = this.cache[prop];
            if (this._keyInCollection(key, collection)) {
                return collection;
            }
        }
    }
    return null;    
};

// Get the parent key for the given collection from the cache, if found
oj.CollectionTreeDataSource.prototype._getParentOfCollection = function(collection) {
    // Search the cache for the parent key
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            if (this.cache[prop] === collection) {
                return prop;
            }
        }
    }
    return null;
};

// Return an object giving the child collection for the given model along with a boolean indicating whether the collection was found 
// in cache. 
oj.CollectionTreeDataSource.prototype.GetChildCollection = function(parentModel) {    
    // Is it in the cache?
    var cached = true;
    var collection = this.__getParentsChildCollectionFromCache(parentModel);
    if (!collection) {
        // Nothing found at all yet
        cached = false;
        // Ask the app for the child collection for the given model
        collection = this.childCollectionCallback(this.rootCollection, parentModel);
        if (collection != null) {
            // Make sure we transfer sorting properties...
            this._applySortToCollection(collection);
            // And put it in the cache
            this._setCollectionInCache(parentModel, collection);
        }
    }
    
    return {collection:collection,cached:cached};
};

oj.CollectionTreeDataSource.prototype._createEvent = function(source, operation, index, parent, data) {
    return {'source':source, 'operation':operation, 'index':index, 'parent':parent, 'data':data};
};

// Call to fetch models for an already-created collection
oj.CollectionTreeDataSource.prototype.FetchCollection = function(collection, start, count, callbacks, parent) {
    var self = this;
    if (collection === null) {
        // Fetch the root
        // Check for the root in the cache
        collection = this.__getParentsChildCollectionFromCache(null);
        if (!collection) {
            // Not found, put a representation in there
            collection = {collection:self.rootCollection,cached:false};
            self._setCollectionInCache(null, this.rootCollection);
        }
        else {
            // Root was found precached: set up its information
            collection = {collection:collection, cached:true};
        }
    }
    if (collection) {
        self._fetch(collection, function (coll) {
                                    if (callbacks['success']) {
                                        // return a nodeset version of this fetched collection via the callback
                                        callbacks['success'](self._getNodeSet(coll, parent, start, count));
                                    }
                                }, callbacks['error']);    
    }
};

// Turn collection into a CollectionNodeSet
oj.CollectionTreeDataSource.prototype._getNodeSet = function(collection, parent, start, count) {
    return new oj.CollectionNodeSet(parent, collection, this, start, count);
};

// Do any of the models in this collection or its children have the given key
oj.CollectionTreeDataSource.prototype._scanForKey = function(collection, key) {
    // Search collection for key
    var self = this;
 
    return oj.Object.__getPromise(function(resolve, reject) {
        function checkNext(index, collection, key) {
            if (index < collection.length) {
                // Get the model at location index
                collection.at(index, {'deferred':true}).then(function (model) {
                                                            // Does the retrieved model match the key when parsed out?  If so return it
                                                            if (model) {
                                                                var parse = self.parseMetadata(model);
                                                                if (key === parse['key']) {
                                                                    resolve(model);
                                                                    return;
                                                                }
                                                            }
                                                            // No model or no match: go to the next model in the collection
                                                            index++;
                                                            checkNext(index, collection, key);
                                                         });
            }
            else {
                // Hit the end: not found
                resolve(null);
                return;
            }
        };

        // Start checking at the 0th model in the collection
        checkNext(0, collection, key);
    });
};

// Returns a promise with an object giving the model that corresponds to the given key, and the depth in the hierarchy at which it was found
oj.CollectionTreeDataSource.prototype._getModelForId = function(collection, key, depth) {
    var self = this;

    return oj.Object.__getPromise(function(resolve, reject) {
        // Does the starting collection contain the key?
        self._scanForKey(collection, key).then(function (model) {
            // Yes, resolve (return it)
            if (model) {
                resolve({model:model, depth: depth});
                return;
            }
            // It does not
            // Wrong collection: search each model's child collections, and check recursively
            var max = collection.length;

            // Check each model in collection now for key
            function getNextCollection(index, tds) {
                if (index < max) {
                    // Return an object containing the child collection of the current collection + whether its cached
                    var childColl = tds.GetChildCollection(collection.at(index));
                    if (!childColl.collection) {
                        // No child collection found: move on to the next model in the current collection
                        index++;
                        getNextCollection(index, tds);
                    } else {
                        // Fetch the child collection if necessary
                        tds._fetch(childColl, function(fetchColl) {
                                        // Now check the child collection recursively for the key, moving depth down 1
                                        tds._getModelForId(fetchColl, key, depth+1).then(function(childModel) {
                                                                                    // Found the model in this collection: unwind
                                                                                    if (childModel) {
                                                                                        // Found somewhere down this tree
                                                                                        resolve(childModel);
                                                                                        return;
                                                                                    } else {
                                                                                        // Not found down that tree
                                                                                        // Move to the next model
                                                                                        index++;
                                                                                        getNextCollection(index, tds);
                                                                                    }
                                                                                });                                
                                    }, null);
                    }
                }
                else {
                    // Hit the end
                    resolve(null);
                }
            }
            // Start checking the collection at the 0th model
            getNextCollection(0, self);
        });
    });
};

// Do a fetch or just return the collection if it came from cache
oj.CollectionTreeDataSource.prototype._fetch = function(collectionCacheObj, success, error) {
    var cached = collectionCacheObj.cached;
    if (cached) {
        // If it's cached, it's fetched
        success(collectionCacheObj.collection);
    }
    else {
        // apply sorting if necessary
        if (this.sortkey && this.sortkey !== "none") {
            collectionCacheObj.collection.comparator = this.sortkey;
            collectionCacheObj.collection.sortDirection = this.sortdir;
        }
        if (collectionCacheObj.collection.length > 0) {
            // Already fetched: just return
            success(collectionCacheObj.collection);
            return;
        }
        // Do a real fetch from the collection's url
        collectionCacheObj.collection.fetch({'success':function(fetchColl) {
                // Tack on handlers
                success(fetchColl);
        }, 'error':error});
    }
};

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {Object} parent the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".<p>
 * {function(oj.CollectionNodeSet)} success the callback to invoke when fetch completed successfully.<p>
 * {function({status: Object})} error the callback to invoke when fetch children failed.<p>
 * @param {Object=} options optional parameters for this operation.<p>
 *  {number=} start the index related to parent in which to begin fetching descendants from.  If this is not specified, then <p>
 *  {number=} maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count.
 * @export
 */
oj.CollectionTreeDataSource.prototype.fetchDescendants = function(parent, callbacks, options)
{
    var self = this;
    if (parent === null) {
        // Do root
        this.FetchCollection(null, 0, -1, {'success':function(nodeSet) {
                                                    nodeSet.FetchDescendants({'success':function() {
                                                            if (callbacks['success']) {
                                                                callbacks['success'](nodeSet);
                                                            }
                                                    }});
        }}, null);
        return;
    }
    // Use child collection callback to set up child collection, then fetch it
    this._getModelForId(this.rootCollection, parent, 0).then(function(parentModel) {
                                                        if (parentModel) {
                                                            var collection = self.GetChildCollection(parentModel.model);
                                                            self.FetchCollection(collection, 0, -1, {'success':function(nodeSet) {
                                                                    nodeSet.FetchDescendants({'success':function() {
                                                                            if (callbacks['success']) {
                                                                                callbacks['success'](nodeSet);
                                                                            }
                                                                    }});                                                                    
                                                            }}, parent);
                                                        }
                                                     });
};

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction<p>
 * criteria.key the key identifying the attribute (column) to sort on<p>
 * criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)<p>
 * @param {function({status: Object})} callbacks.success the callback to invoke when the sort completed successfully.<p>
 * callbacks.error the callback to invoke when sort failed.
 * @export
 */
oj.CollectionTreeDataSource.prototype.sort = function(criteria, callbacks)
{
    var key = criteria['key'];
    var dir = criteria['direction'];
    var needSort = false;
    if (key !== this.sortkey) {
        this.sortkey = key;
        needSort = true;
    }
    if (dir !== this.sortdir) {
        this.sortdir = dir;
        needSort = true;
    }
    if (needSort) {
        // If clearing, clear the cache
        if (this.sortdir === "none") {
            this.cache = {};
        }
        // Go off and sort each collection, as long as it has "criteria" as one of its attributes
        for (var prop in this.cache) {
            if (this.cache.hasOwnProperty(prop)) {
                var collection = this.cache[prop];
                this._applySortToCollection(collection);
            }
        }
    }
    if (callbacks && callbacks['success']) {
        callbacks['success']();
    }
};

oj.CollectionTreeDataSource.prototype._applySortToCollection = function(collection) {
    collection['comparator'] = this.sortkey;
    collection['sortDirection'] = (this.sortdir === "ascending") ? 1 : -1;
    collection.sort();    
};

/**
 * Returns the current sort criteria of the tree data.
 * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
 *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
 *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 */
oj.CollectionTreeDataSource.prototype.getSortCriteria = function()
{
    return {'key': this.sortkey, 'direction': this.sortdir};
};

/**
 * Moves a row from one location to another (different position within the same parent or a completely different parent)
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @export
 */ 
oj.CollectionTreeDataSource.prototype.move = function(rowToMove, referenceRow, position, callbacks)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Checks whether a move operation is valid.
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @export
 */ 
oj.CollectionTreeDataSource.prototype.moveOK = function(rowToMove, referenceRow, position)
{
    return "invalid";
};

/**
 * Determines whether this CollectionTreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort", 
 *        "move", "fetchDescendants", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".  
 *         For "fetchDescendants", the valid return values are: "enable", "disable", "suboptimal".  
 *         For "move", the valid return values are: "default", "none".  
 *         For "batchFetch", the valid return values are: "enable", "disable".  
 * @export
 */
oj.CollectionTreeDataSource.prototype.getCapability = function(feature)
{
    if (feature === "sort") {
        return "default";
    }
    if (feature === "move") {
        return "none";
    }
    if (feature === "batchFetch") {
        return "disable";
    }
    if (feature === "fetchDescendants") {
        return "disable";
    }
    return null;
};


/**
 * A CollectionNodeSet represents a collection of nodes.  The CollectionNodeSet is an object returned by the success callback
 * of the fetchChildren method on CollectionTreeDataSource.  
 * @constructor
 * @export
 */
oj.CollectionNodeSet = function(parentKey, collection, treeDataSource, start, count)
{
    this.parentKey = parentKey;
    this.collection = collection;
    this.childNodeSet = [];
    this.treeDataSource = treeDataSource;
    // Can't have start exceeding valid indices
    this.start = start < collection.length ? start : collection.length-1;
    // Unknown count: we'll assign it.  Also can't have count exceeding collection size
    this.count = count === -1 ? collection.length : Math.min(collection.length, count);
};

oj.CollectionNodeSet.prototype.FetchDescendants = function(callbacks) {
    this._fetchDescendants(this, true).then(function () {
        if (callbacks['success']) {
            callbacks['success']();
        }
    });
};

oj.CollectionNodeSet.prototype._fetchDescendants = function(nodeSet, topLevel) {  
    return oj.Object.__getPromise(function(resolve, reject) {
        var count = nodeSet.getCount();

        // Walk over each node in this node set, and fetch all the descendants of each
        function nextNode(index) {
            if (index < count) {
                nodeSet.FetchChildNodeSet(index, {'success':function(childNodeSet) {
                                                            if (childNodeSet !== null) {
                                                                nodeSet._fetchDescendants(childNodeSet, false).then(function() {
                                                                    nextNode(index+1);
                                                                });
                                                            }
                                                            else {
                                                                nextNode(index+1);
                                                            }
                                                        }});
            }
            else {
                resolve();
            }
        }
        nextNode(0);
    });
};

oj.CollectionNodeSet.prototype.FetchChildNodeSet = function(index, callbacks) {
    var model = this.collection.at(index);
    var parse = this.treeDataSource.parseMetadata(model);
    if (parse['leaf']) {
        // We're at the leaf: don't fetch any more
        this.childNodeSet[index] = null;
        callbacks['success'](null);
        return;
    }
    
    var collection = this.treeDataSource.GetChildCollection(model);
    var parentKey = this.treeDataSource.parseMetadata(model)['key'];
    var self = this;
    this.treeDataSource.FetchCollection(collection, 0, -1, {'success':function(nodeSet) {
            self.childNodeSet[index] = nodeSet;
            callbacks['success'](nodeSet);
    }}, parentKey); 
};

oj.CollectionNodeSet.prototype._getCollection = function() {
    return this.collection;
};

/**
* Gets the parent key for this result set.  
* @return {Object} the parent key for this result set. 
* @export
*/
oj.CollectionNodeSet.prototype.getParent = function()
{
    return this.parentKey;
};

/**
* Gets the start index of the result set.  
* @return {number} the start index of the result set.
* @export	
*/
oj.CollectionNodeSet.prototype.getStart = function()
{
    return this.start;
};

/**
* Gets the actual count of the result set.  
* @return {number} the actual count of the result set.
* @export	
*/
oj.CollectionNodeSet.prototype.getCount = function()
{
    return this.count;
};

/**
* Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
* 2) the index specified is out of bounds. 
* @param {number} index the index of the node/row in which we want to retrieve the data from.  
* @return {Object} the data for the specified index.  oj.RowData should be returned for data that represents a row
*         with a number of columns.
* @export
*/
oj.CollectionNodeSet.prototype.getData = function(index)
{
    this._checkRange(index);
    return this.collection.at(index).attributes;
};

oj.CollectionNodeSet.prototype._checkRange = function(index) {
    if (index < this.start || index > this.start+this.count) {
        // Out of range
        throw "Out of range";
    }
};

/**
* Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
* 2) the index specified is out of bounds. 
* The metadata that the data source must return are:
*  1) key - Object, the key of the node/row.
*  2) leaf - boolean, true if it's a leaf, false otherwise. 
*  3) depth? - number, the depth of the node/row. (or should the caller just calculate it?)
* @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
* @return {Object} the metadata object for the specific index.
* @export
*/	
oj.CollectionNodeSet.prototype.getMetadata = function(index)
{
    this._checkRange(index);
    
    var metadata = {};

    var model = this.collection.at(index);
    
    var parse = this.treeDataSource.parseMetadata(model);
    metadata['key'] = parse['key'];
    metadata['leaf'] = parse['leaf'];
    metadata['depth'] = parse['depth'];

    return metadata;
};


/**
 * Gets the node set child of the specified index.
 * @param {number} index the index of the node/row in which we want to retrieve the child node set
 * @return {oj.CollectionNodeSet|null} the child node set representing the child collection.
 * @export
 */
oj.CollectionNodeSet.prototype.getChildNodeSet = function(index) {
    this._checkRange(index);
    
    return this.childNodeSet[index];
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * @class 
 * @name oj.ojCollapsible
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="collapsibleOverview-section">
 *   JET Collapsible Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#collapsibleOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant collapsible with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Collapsible can be created from any valid markup as long as the root element has at least two children: the first element for the header and the second element for the content.
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="collapsible">
 *   &lt;h3>Header 1&lt;/h3>
 *   &lt;p>Content 1&lt;/p>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>
 * <h5>When the focus is on the header</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Space or Enter</kbd></td>
 *       <td> Toggle disclosure state.</tr>
 *   </tbody>
 *  </table>
 *
 * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the collapsible must be <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-collapsible</code> pseudo-selector can be used in jQuery expressions to select JET Collapsible.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-collapsible" ) // selects all JET Collapsible on the page
 * $myEventTarget.closest( ":oj-collapsible" ) // selects the closest ancestor that is a JET Collapsible
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>JET Collapsible supports expandArea option: specifies where to click to toggle disclosure. Default is "disclosureIcon", however if a collapsible is inside an Accordion, default is "header"</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "collapsible".  
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Collapsible. 
 * @example <caption>Initialize the collapsible with no options specified:</caption>
 * $( ".selector" ).ojCollapsible();
 * 
 * @example <caption>Initialize the collapsible with some options specified:</caption>
 * $( ".selector" ).ojCollapsible( { "expanded": true } );
 * 
 * @example <caption>Initialize the collapsible via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="collapsible" data-bind="ojComponent: { component: 'ojCollapsible', expanded: true}">
 *
 */
(function ()
{
  var uid = 0, 
      OPEN_ICON = "oj-collapsible-open-icon", 
      CLOSE_ICON = "oj-collapsible-close-icon";

  oj.__registerWidget("oj.ojCollapsible", $['oj']['baseComponent'], 
  {
    widgetEventPrefix : "oj",
    options : 
    {
      /** 
       * Specifies if the content is expanded.
       *
       * @expose 
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">true</code>
       *
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">expanded</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "expanded": false } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">expanded</code> option, after initialization:</caption>
       * // getter
       * var expanded = $( ".selector" ).ojCollapsible( "option", "expanded" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "expanded", true );
       */
      expanded : false, 

      /** 
       * Disables the collapsible if set to <code class="prettyprint">true</code>.
       * @name disabled
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {boolean|null}
       * @default <code class="prettyprint">false</code>
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">disabled</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "disabled": true } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
       * // getter
       * var disabled = $( ".selector" ).ojCollapsible( "option", "disabled" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "disabled", true );

      disabled: null,
       */

      /** 
       * The type of event to expand/collapse the collapsible. 
       * To expand the collapsible on hover, use "mouseover".
       *
       * @expose 
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"click"</code>
       *
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">expandOn</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "expandOn": "mouseover" } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">expandOn</code> option, after initialization:</caption>
       * // getter
       * var expandOn = $( ".selector" ).ojCollapsible( "option", "expandOn" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "expandOn", "mouseover" );
       */
      expandOn : "click", 

      /** 
       * Where in the header to click to toggle disclosure. Valid values: disclosureIcon or header
       *
       * @expose 
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"disclosureIcon"</code>
       *
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">expandArea</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "expandArea": "header" } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">expandArea</code> option, after initialization:</caption>
       * // getter
       * var expandArea = $( ".selector" ).ojCollapsible( "option", "expandArea" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "expandArea", "header" );
       */
      expandArea : "disclosureIcon",

      // callbacks
      /**
       * Triggered immediately before the collapsible is expanded.
       * beforeExpand can be canceled to prevent the content from expanding by returning a false in the event listener.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that is about to be expanded.
       * @property {jQuery} ui.content The content that is about to be expanded.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">beforeExpand</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "beforeExpand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeexpand</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeexpand", function( event, ui ) {} );
       */
      beforeExpand : null,

      /**
       * Triggered after the collapsible has been expanded (after animation completes).
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that was just expanded.
       * @property {jQuery} ui.content The content that was just expanded.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">expand</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "expand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
       * $( ".selector" ).on( "ojexpand", function( event, ui ) {} );
       */
      expand : null, 

      /**
       * Triggered immediately before the collapsible is collapsed.
       * beforeCollapse can be canceled to prevent the content from collapsing by returning a false in the event listener.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that is about to be collapsed.
       * @property {jQuery} ui.content The content that is about to be collapsed.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">beforeCollapse</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "beforeCollapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforecollapse</code> event:</caption>
       * $( ".selector" ).on( "ojbeforecollapse", function( event, ui ) {} );
       */
      beforeCollapse : null,

      /**
       * Triggered after the collapsible has been collapsed.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that was just collapsed.
       * @property {jQuery} ui.content The content that was just collapsed.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">collapse</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "collapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapse</code> event:</caption>
       * $( ".selector" ).on( "ojcollapse", function( event, ui ) {} );
       */
      collapse : null, 

      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic
       * intervention.  If the new value is the same as the previous value, no event will be fired.
       *
       * Currently there is one supported option, <code class="prettyprint">"expanded"</code>.  Additional
       * options may be supported in the future, so listeners should verify which option is changing
       * before taking any action.
       *
       * @expose
       * @event
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {string} ui.option the name of the option that is changing
       * @property {boolean} ui.previousValue the previous value of the option
       * @property {boolean} ui.value the current value of the option
       * @property {Object} ui.optionMetadata information about the option that is changing
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
       *
       */
      optionChange: null

    },

    _ComponentCreate : function ()
    {
      this._super();

      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.element.addClass("oj-collapsible oj-component")

      this._processPanels();
      this._refresh();
    },

    //fire initial expand event
    _init : function ()
    {
      this._initialRender = true;
      this._setExpanded(this.options.expanded);
      this._initialRender = undefined;
    },

    // Override to set custom launcher
    _OpenContextMenu: function(menu, event)
    {
      // Setting the launcher to the "twisty" icon, since that seems to be the only tabbable thing in the collapsible, 
      // and it seems to remain tabbable even if the collapsible is disabled.  See the superclass JSDoc for _OpenContextMenu 
      // for tips on choosing a launcher.
      menu.open(event, {"launcher": this.element.find(".oj-collapsible-header-icon").first(), "initialFocus": "menu"});
    },

    _createIcons : function ()
    {
      var options = this.options;
      var icon = (options.expanded ? OPEN_ICON : CLOSE_ICON);
      var iconTag = this._isDisabled() ? $("<span>") : $("<a href='#'>");

      iconTag.addClass("oj-component-icon oj-clickable-icon oj-collapsible-header-icon " + icon)
        .attr("aria-labelledby", this.header.attr( "id" ))
        .prependTo(this.header);

    },

    _destroyIcons : function ()
    {
      this.header
        .children(".oj-collapsible-header-icon")
        .remove();
    },

    _destroy : function ()
    {
      this._cleanup();

      // clean up main element
      this.element
        .removeClass("oj-collapsible oj-component oj-expanded oj-collapsed oj-disabled");

      // clean up headers
      if (this._isDisabled())
        this._findFocusables(this.header).removeAttr("tabIndex");

      this.header
        .removeClass("oj-collapsible-header")
        .each(function ()
        {
          if (/^oj-collapsible/.test(this.id))
          {
            this.removeAttribute("id");
          }
        });

      //aria
      var focusable = this._findFirstFocusableInHeader();
      focusable.removeAttr("role")
        .removeAttr("aria-controls")
        .removeAttr("aria-expanded")
        .removeAttr("aria-disabled");

      this._destroyIcons();

      this._findFocusables(this.content).removeAttr("tabIndex");

      // clean up content panels
      this.content
        .css("display", "")
        .removeAttr("aria-hidden")
        .removeAttr("tabIndex")
        .removeClass("oj-component-content oj-collapsible-content")
        .each(function ()
        {
          if (/^oj-collapsible/.test(this.id))
          {
            this.removeAttribute("id");
          }
        });
    },

    _cleanup : function ()
    {
      //remove listeners
      this._tearDownEvents();

      //remove wrapper
      if (this.content)
      {
        this.content.unwrap();
        this.wrapper = null;
      }
      //TODO: remove oj-disabled

    },

    _isDisabled : function ()
    {
//TODO: ignore disabled until disabled propagation is supported
//      return this.element.hasClass("oj-disabled");
      return false;
    },

    _getExpandAreaSelector : function ()
    {
      if (this.options.expandArea == "header")
        return "> .oj-collapsible-header";
      else //disclosureIcon
        return "> .oj-collapsible-header > .oj-collapsible-header-icon";
    },

    _setOption : function (key, value, flags)
    {
      if (key === "expanded")
      {
        if (value === this.options.expanded)
          return;
        this._setExpanded(value);
        return;
      }

      if (key === "expandOn" || key === "expandArea")
      {
        this._tearDownEvents();
        this._super(key, value, flags);
        this._setupEvents();
      }
      else 
      {
        this._super(key, value, flags);
      }

      // #5332 - opacity doesn't cascade to positioned elements in IE
      // so we need to add the disabled class to the headers and panels
//TODO: ignore disabled until disabled propagation is supported
/*
      if (key === "disabled")
      {
        this.header
          .add(this.header.next());
        this.element.toggleClass("oj-disabled", !!value);
      }
*/
    },

    _keydown : function (event)
    {
      if (event.altKey || event.ctrlKey)
      {
        return;
      }
      var keyCode = $.ui.keyCode;

      switch (event.keyCode)
      {
        case keyCode.SPACE:
        case keyCode.ENTER:
          this._toggleHandler(event);
          break;
      }
    },

    /**
     * Refreshes the visual state of the collapsible. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is 
     * programmatically changed underneath the component.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojCollapsible
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojCollapsible( "refresh" );
     */
    refresh : function ()
    {
      this._super();
      this._cleanup();
      this._processPanels();
      this._destroyIcons();
      this._refresh();
    },

    _processPanels : function ()
    {
      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.header = this.element.children(":first-child")
                      .addClass("oj-collapsible-header");

      this.content = this.header.next()
        .addClass("oj-collapsible-content oj-component-content");

      this.content.wrap("<div></div>");
      this.wrapper = this.content.parent()
        .addClass("oj-collapsible-wrapper");

      //Note: must set tabIndex=-1 to focusable elements
      //to avoid tabbing in a disabled header

//TODO: ignore disabled until disabled propagation is supported
/*
      if (this.options.disabled)
        this.element.addClass("oj-disabled");
*/
      if (this._isDisabled())
      {
        this._findFocusables(this.header)
          .attr("tabIndex",  -1);
      }
    },

    /**
     * Used for explicit cases where the component needs to be refreshed 
     * (e.g., when the value option changes or other UI gestures).
     * @private
     */
    _refresh : function ()
    {
      var header = this.header, 
          content = this.content, 
          options = this.options;

      var collapsibleId = this.collapsibleId = 
        "oj-collapsible-" + (this.element.attr("id") || ++uid);

      var headerId = header.attr("id"), 
          contentId = content.attr("id");

      if (!headerId)
      {
        headerId = collapsibleId + "-header";
        header.attr("id", headerId);
      }
      if (!contentId)
      {
        contentId = collapsibleId + "-content";
        content.attr("id", contentId);
      }

      //aria
      this._createIcons();
      var focusable = this._findFirstFocusableInHeader();
      focusable.attr("role", "button")
        .attr("aria-controls", contentId)
        .attr("aria-expanded", options.expanded);

      if (this._isDisabled())
      {
        focusable.attr("aria-disabled", "true");
      }

      if (!this._isDisabled())
      {
        this._setContentTabIndex(options.expanded ? "0" : "-1");
      }

      //Bug 19277743 - when collapsible is refreshed, it's content displays & disclosure icon collapsed
      if (options.expanded)
      {
        content.attr("aria-hidden", "false");
      }
      else 
      {
        this.wrapper.css({
          'max-height': 0,
          'overflow-y': 'hidden',
          'display': 'none'
        });
        this.wrapper.css('max-height', 0);
        content.attr("aria-hidden", "true");
      }

      this._setupEvents();
    },

    _setExpanded : function (expanded)
    {
      if (expanded)
        this.expand(true);
      else 
        this.collapse(true);
    },

    _setupEvents : function ()
    {
      var events = 
      {
        "keydown" : this._keydown
      };

      var event = this.options.expandOn;
      if (event)
      {
        var self = this ;
        $.each(event.split(" "), function (index, eventName)
        {
          //security test
          if (/^[a-zA-Z]+$/.test(eventName)) {
            events[eventName] = self._toggleHandler;
          }
        });
      }

      var expandArea = this.element.find(this._getExpandAreaSelector());

      //add listeners on expandArea (event expandArea)
      this._on(expandArea, events);

      this._on(this.wrapper, 
      {
        "transitionend" : this._transitionEndHandler, 
        "webkitTransitionEnd" : this._transitionEndHandler, 
        "otransitionend" : this._transitionEndHandler, 
        "oTransitionEnd" : this._transitionEndHandler
      });

      if (!this._isDisabled())
      {
        this._on(this.element, 
        {
          "ojexpand" : this._expandCollapseHandler, 
          "ojcollapse" : this._expandCollapseHandler, 
          "ojfocus" : this._focusHandler,
          "ojfocusout" : this._focusHandler
        });

        this._hoverable(expandArea);
        this._focusable(expandArea);
        this._activeable(expandArea);

      }
    },

    _tearDownEvents : function ()
    {
      this._off(this.element.find(this._getExpandAreaSelector()));

      //remove wrapper listeners
      if (this.wrapper)
        this._off(this.wrapper);
      this._off(this.element.add(this.content));
    },

    _toggleHandler : function (event)
    {
      if (this._isDisabled())
        return;

      if (this.options.expanded)
        this.collapse(true, event);
      else 
        this.expand(true, event);

      event.preventDefault();
      event.stopPropagation();

      //set focus on the disclosure icon
      this.header.find(".oj-collapsible-header-icon").focus();

    },

    _expandCollapseHandler : function (event)
    {
      if (this._isDisabled())
        return;

      if (event.target !== this.element[0])
        return;

      if (this._initialRender || !event.isDefaultPrevented())
      {
        var element = this.element, 
            options = this.options, 
            content = this.content,
            wrapper = this.wrapper,
            isCollapse = (event.type === "ojcollapse");

        event.preventDefault();

        options.expanded = ! isCollapse;

        //Bug 19004479 - expansion animation on initial render.
        //skip animation
        if (this._initialRender) {

          if (isCollapse)
          {
            element.removeClass("oj-expanded");
            element.addClass("oj-collapsed");
            wrapper.css('max-height', 0);
            wrapper.hide();
          }
          else
          {
            element.removeClass("oj-collapsed");
            element.addClass("oj-expanded");
          }
        }
        // do animation
        else 
        {
          wrapper.contentHeight = wrapper.outerHeight();

          //collapsing
          if (isCollapse)
          {
            // disable transitions & set max-height to content height
            wrapper.removeClass("oj-collapsible-transition");
            wrapper.css({
              'max-height': wrapper.contentHeight,
              'overflow-y': 'hidden'
            });

            setTimeout(function()
            {
              // enable & start transition
              wrapper.addClass('oj-collapsible-transition')
                .css({
                  'max-height': 0   //!important
                });

              element.removeClass("oj-expanded");
              element.addClass("oj-collapsed");

            }, 10); // 10ms timeout is the secret ingredient for disabling/enabling transitions
            // chrome only needs 1ms but FF needs ~10ms or it chokes on the first animation for some reason
          }

          //expanding
          else
          {
            //James: set display:none on the wrapper when it is hidden and then remove display:none when its is shown. 
            //This should trigger JAWS into refreshing the buffer.
            wrapper.show();

            setTimeout(function()
            {
              wrapper.contentHeight += content.outerHeight(); // if closed, add inner height to content height
              wrapper.addClass('oj-collapsible-transition').css(
              {
                'max-height': wrapper.contentHeight
              });
              element.removeClass("oj-collapsed");
              element.addClass("oj-expanded");

            }, 1);
          }
        }

        this.header
          .find(".oj-collapsible-header-icon").toggleClass(OPEN_ICON, !isCollapse)
            // logic or cause same icon for expanded/collapsed state would remove the oj-icon-class
            .toggleClass(CLOSE_ICON, (isCollapse || OPEN_ICON === CLOSE_ICON))
          .end();

        //aria
        this.content.attr("aria-hidden", isCollapse);

        this._findFirstFocusableInHeader().attr("aria-expanded", !isCollapse);

        this._setContentTabIndex(isCollapse ? "-1" : "0");

      }
    },

    _focusHandler : function (event)
    {
      if (this._isDisabled())
        return null;

      if (event.type == "ojfocusout")
      {
        this._findFirstFocusableInHeader()
          .attr("tabIndex", -1);

        event.preventDefault();
        event.stopPropagation();
      }
      else if (event.type == "ojfocus")
      {
        this._findFirstFocusableInHeader()
          .attr("tabIndex", 0)
          .focus();
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _findFirstFocusableInHeader : function ()
    {
      return this._findFocusables(this.header).first();
    },

    _setContentTabIndex : function (value)
    {
      return this._findFocusables(this.content).attr("tabIndex", value);
    },

    _findFocusables : function (start)
    {
      //create <span> or <a> depending on if this.isDisabled
      if (this._isDisabled()) {
        return start.find("span");
      }
      return start.find("a,:input");
    },

    /**
     * Expand a collapsible.<p>
     * Note the beforeExpand event will only be fired when vetoable is true.<p>
     * Please use the <code class="prettyprint">expanded</code> option 
     * for expanding a collapsible so that it triggers the beforeExpand event:
     * $( ".selector" ).ojCollapsible( "option", "expanded", true );
     * 
     * @expose 
     * @memberof! oj.ojCollapsible
     * @instance
     * @param {boolean} vetoable if event is vetoable
     */
    expand : function (vetoable, event)
    {
      if (this._isDisabled())
        return;

      var eventData = 
      {
        /** @expose */
        header : this.header, 
        /** @expose */
        content : this.content
      };

      if (!vetoable || this._trigger("beforeExpand", event, eventData) !== false)
      {
        this._trigger("expand", event, eventData);
        this._fireOptionChange("expanded", false, true, event ? true : false);
      }
    },

    /**
     * Collapse a collapsible.<p>
     * Note the beforeCollapse event will only be fired when vetoable is true.<p>
     * Please use the <code class="prettyprint">expanded</code> option 
     * for collapsing a collapsible so that it triggers the beforeCollapse event:
     * $( ".selector" ).ojCollapsible( "option", "expanded", false );
     * 
     * @expose 
     * @memberof! oj.ojCollapsible
     * @instance
     * @param {boolean} vetoable if event is vetoable
     */
    collapse : function (vetoable, event)
    {
      if (this._isDisabled())
        return;

      //don't fire collapse event on initial render
      if (this._initialRender)
      {
        //call expandCollapseHandler
        var elem = this.element[0];
        this._expandCollapseHandler(
      {
        type : "ojcollapse",
        target : elem,
        currentTarget : elem,
        preventDefault : $.noop
      });

        return;
      }


      var eventData = 
      {
        /** @expose */
        header : this.header, 
        /** @expose */
        content : this.content
      };

      if (!vetoable || this._trigger("beforeCollapse", event, eventData) !== false)
      {
        this._trigger("collapse", event, eventData);
        this._fireOptionChange("expanded", true, false, event ? true : false);
      }
    },

    _transitionEndHandler : function (event)
    {
      if (this._isDisabled())
        return;

      var propName = event.originalEvent? event.originalEvent.propertyName : null;

      //TODO: fire expand and collapse here
      if (propName == "max-height")
      {
        event.preventDefault();
        event.stopPropagation();
      }

      //just completed a collapse transition
      if (this.options.expanded)
      {
        this.wrapper.css({
          'max-height': 9999,
          'overflow-y': ''
        });
      }
      else 
      {
        //James: set display:none on the wrapper when it is hidden and then remove display:none when its is shown. 
        //This should trigger JAWS into refreshing the buffer.
        this.wrapper.hide();
      }

      this.wrapper.removeClass("oj-collapsible-transition");
    },

    /**
     * Fire optionChange event 
     * @param {String} key - 'expanded'
     * @param {boolean} previousValue 
     * @param {boolean} value
     * @param {Boolean} originalEvent  
     *
     * @private
     */
    _fireOptionChange: function(key, previousValue, value, originalEvent) 
    {
      var ui = {
        "option": key,
        "previousValue": previousValue,
        "value": value,
        // (originalEvent is non-null) iff (option change is due to user interaction) 
        // iff (binding should write back the value)
        "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
      };
      this._trigger('optionChange', originalEvent, ui);
    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     *
     * Test authors should target sub elements using the following names:
     * <ul>
     * <li><b>oj-collapsible-header</b>: collapsible header </li>
     * <li><b>oj-collapsible-content</b>: collapsible content </li>
     * <li><b>oj-collapsible-header-icon</b>: collapsible disclosure icon </li>
     * </ul>
     *
     * @expose
     * @memberof! oj.ojCollapsible
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      if (locator == null)
      {
        return this.element ? this.element[0] : null;
      }

      var subId = locator['subId'];

      switch (subId)
      {
      case 'oj-collapsible-content':
        return this.content;

      case 'oj-collapsible-header':
        return this.header;

      case 'oj-collapsible-header-icon':
        return this.header.find("." + subId)[0];
      }

      // Non-null locators have to be handled by the component subclasses
      return null;
    }

  });

}
());
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/**
 * @class 
 * @name oj.ojTabs
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="tabsOverview-section">
 *   JET Tabs Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#tabsOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant tabs with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Tabs can be created from a <code class="prettyprint">div</code> element as long as the root element has one or more child <code class="prettyprint">div</code> elements. 
 * Each child <code class="prettyprint">div</code> element must have at least two children: 
 * The first element for the tab header and the rest of the element(s) for the tab content.
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="tabs">
 *   &lt;div id ="tab-1">
 *     &lt;span>Tab 1&lt;/span>
 *     &lt;p>Tab 1 content&lt;/p>
 *     &lt;p>Tab 1 more content&lt;/p>
 *   &lt;/div>
 *   &lt;div id ="tab-2">
 *     &lt;span>Tab 2&lt;/span>
 *     &lt;p>Tab 2 content&lt;/p>
 *   &lt;/div>
 *   &lt;div id ="tab-3">
 *     &lt;span>Tab 3&lt;/span>
 *     &lt;p>Tab 3 content&lt;/p>
 *   &lt;/div>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>
 * <h5>When the focus is on the tab bar</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td> Only the selected tab is in the tab order.</tr>
 *     <tr>
 *       <td><kbd>UpArrow or LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td> Move focus to the previous tab and select it.</tr>
 *     <tr>
 *       <td><kbd>DownArrow or RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td> Move focus to the next tab and select it.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td> Move focus to the first tabs item.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td> Move focus to the last tabs item.</tr>
 *     <tr>
 *       <td><kbd>Delete</kbd></td>
 *       <td> If deletion is allowed, will delete the current tab.</tr>
 *   </tbody>
 *  </table>
 *
 * <p>
 * <h5>When the focus is on anywhere within the tab content</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td> move focus to the tab for that tab panel.</tr>
 *   </tbody>
 *  </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the tabs must be <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-tabs</code> pseudo-selector can be used in jQuery expressions to select JET Tabs.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-tabs" ) // selects all JET Tabs on the page
 * $myEventTarget.closest( ":oj-tabs" ) // selects the closest ancestor that is a JET Tabs
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <ul>
 *   <li>JQUI Tabs expects the tabs titles either in an ordered or unordered list followed by their content elements. Each tab must have an anchor with the href points to its content element.
 *     <pre class="prettyprint">
 *     <code>
 *       &lt;div id="tabs">
 *         &lt;ul>
 *           &lt;li>&lt;a href="#tabs-1">Tab 1 Title&lt;/a>&lt;/li>
 *           &lt;li>&lt;a href="#tabs-2">Tab 2 Title&lt;/a>&lt;/li>
 *         &lt;/ul>
 *         &lt;div id="tabs-1">
 *           &lt;p>Tab 1 content.&lt;/p>
 *         &lt;/div>
 *         &lt;div id="tabs-2">
 *           &lt;p>Tab 2 content.&lt;/p>
 *           &lt;p>More Tab 2 content.&lt;/p>
 *         &lt;/div
 *       &lt;/div>
 *     </code></pre>
 *   </li>
 *
 *   <li>JET Tabs requires a simplier DOM structures. Like the JQuery Accordion, JET tabs is a list where each tab contains its own title and content. It requires no anchors and pointers to the contents.
 *     <pre class="prettyprint">
 *     <code>
 *       &lt;div id="tabs">
 *         &lt;div id="tabs-1">
 *           &lt;span>Tab 1 Title&lt;/span>
 *           &lt;p>Tab 1 content.&lt;/p>
 *         &lt;/div>
 *         &lt;div id="tabs-2">
 *           &lt;span>Tab 2 Title&lt;/span>
 *           &lt;p>Tab 2 content.&lt;/p>
 *           &lt;p>More Tab 2 content.&lt;/p>
 *         &lt;/div
 *       &lt;/div>
 *     </code></pre>
 *   </li>
 *   </ul>
 *   <li>JET Tabs supports <code class="prettyprint">orientation</code> option: to be placed horizontal (default) or vertical</li>
 *   <li>JET Tabs supports <code class="prettyprint">removable</code> option by adding a close icon to each tab header which when clicked remove the tab from the DOM.</li>
 *   <li>JET Tabs supports <code class="prettyprint">reorderable</code> option allow the tab to be reordered by drag and drop within the Tab bar</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "tabs".  
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Tabs. 
 * @example <caption>Initialize the tabs with no options specified:</caption>
 * $( ".selector" ).ojTabs();
 * 
 * @example <caption>Initialize the tabs with some options specified:</caption>
 * $( ".selector" ).ojTabs( { "orientation": "vertical" } );
 * 
 * @example <caption>Initialize the tabs via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="tabs" data-bind="ojComponent: { component: 'ojTabs', orientation: 'vertical'}">
 *
 */
(function ()
{
  var _CLOSE_ICON = "oj-tabs-close-icon";
  var _CLOSE_ICON_SIZE = 28;
  var _ID_PREFIX = "ojtabs-id_";
  var _DELETE_KEY = 46;

  //Context Menu: menu item id's
  var /** @const */ _arMenuCmdMap = { "cut"          : "ojtabscut",
                                      "paste-before" : "ojtabspastebefore",
                                      "paste-after"  : "ojtabspasteafter"
                                    } ;

  oj.__registerWidget("oj.ojTabs", $['oj']['baseComponent'], 
  {
    widgetEventPrefix : "oj", 
    delay : 300, 
    options : 
    {
      /** 
       * The id or zero-based index of the tab panel that is selected.<p>
       * Setter value: either an id or index.<p>
       * Getter value: id or index. If the selected tab has a page author provided id, that id is returned, otherwise that tab's index will be returned.
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {number|string}
       * @default <code class="prettyprint">0</code>
       *
       * @example <caption>Initialize the tabs with the 
       * <code class="prettyprint">selected</code> option specified:</caption>
       * $( ".selector" ).ojTabs( { "selected": "myTabDiv" } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">selected</code> 
       * option after initialization:</caption>
       * // getter
       * var selected = $( ".selector" ).ojTabs( "option", "selected" );
       * 
       * // setter
       * $( ".selector" ).ojTabs( "option", "selected", "myTabDiv" );
       */
      selected : 0, 

      /** 
       * Array contains either ids or zero-based indices of the tabs that should be disabled.<p> 
       * Setter value: array of either ids or indices.<p>
       * Getter value: array of either ids or indices. If a disabled tab has a page author provided id, that id is returned, otherwise that tab's index will be returned.
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @default <code class="prettyprint">false</code>
       * @type {Array}
       *
       * @example [ 0, "myTabDiv" ] would disable the first tab and the tab with id="myTabDiv"
       * @example <caption>Initialize the tabs with the 
       * <code class="prettyprint">disabledTabs</code> option specified:</caption>
       * $( ".selector" ).ojTabs( { "disabledTabs": [0, "myTabDiv"] } );
       * 
       */
      disabledTabs : null, 

      /** 
       * Truncation option applies to the tab titles when there is not enough room to display
       * all tabs.
       * Valid Values: none, progressive and auto.
       *
       * <ul>
       *  <li> none - tabs always take up the space needed by the title texts. When there
       *   is not enough room, the conveyorBelt's navigation arrows are displayed to allow
       *   the title texts be scrolled within the conveyor.</li>
       *
       *  <li> progressive - If not enough space is available to display all of the tabs, 
       *   then the width of each tab title is restricted just enough to allow all tabs to fit. 
       *   All tab titles that are truncated are displayed with ellipses. However the width 
       *   of each tab title will not be truncated below tabLabelMinWidth. If after all truncation 
       *   has been applied, there still is not enough room, then the conveyorBelt's navigation 
       *   arrows will appear. When the container of the tabs is resized the truncation will 
       *   be reevaluated.</li>
       *
       *  <li> auto - same as "progressive".</li>
       * </ul>
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {string}
       * @default <code class="prettyprint">auto</code>
       *
       * @example <caption>Get or set the <code class="prettyprint">truncation</code> option for
       *      an ojTabs after initialization:</caption>
       * // getter
       * var truncation = $( ".selector" ).ojTabs( "option", "truncation" );
       * 
       * // setter
       * $( ".selector" ).ojTabs( "option", "truncation", "none" );
       */
      truncation : "auto",

      /** 
       * The type of event to select the tab. 
       * To select a tab on hover, use "mouseover".
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"click"</code>
       *
       * @example <caption>Get or set the <code class="prettyprint">selectOn</code> option for
       *      an ojTabs after initialization:</caption>
       * // getter
       * var selectOn = $( ".selector" ).ojTabs( "option", "selectOn" );
       * 
       * // setter
       * $( ".selector" ).ojTabs( "option", "selectOn", "mouseover" );
       */
      selectOn : "click", 

      /** 
       * The orientation of the tab bar. 
       * Valid Values: horizontal and vertical
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"horizontal"</code>
       *
       * @example <caption>Get or set the <code class="prettyprint">orientation</code> option for
       *      an ojTabs after initialization:</caption>
       * // getter
       * var orientation = $( ".selector" ).ojTabs( "option", "orientation" );
       * 
       * // setter
       * $( ".selector" ).ojTabs( "option", "orientation", "vertical" );
       */
      orientation : "horizontal", 

      /** 
       * Specifies if the tabs can be closed (removed)
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Get or set the <code class="prettyprint">removable</code> option for
       *      an ojTabs after initialization:</caption>
       * // getter
       * var removable = $( ".selector" ).ojTabs( "option", "removable" );
       * 
       * // setter
       * $( ".selector" ).ojTabs( "option", "removable", true );
       */
      removable : false, 

      /** 
       * This text is used to provide audible feedback for screen reader users
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {string}
       * @default <code class="prettyprint">Removable</code>
       */
      removeCueText : "Removable",

      /** 
       * Specifies if the tabs can be reordered within the tab bar by drag-and-drop
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Get or set the <code class="prettyprint">reorderable</code> option for
       *      an ojTabs after initialization:</caption>
       * // getter
       * var reorderable = $( ".selector" ).ojTabs( "option", "reorderable" );
       * 
       * // setter
       * $( ".selector" ).ojTabs( "option", "reorderable", true );
       */
      reorderable : false,

      /**
       * Identifies the JET Menu that the component should launch as a context menu on right-click or
       * <kbd>Shift-F10</kbd>. If specified, the browser's native context menu will be replaced by the
       * specified JET Menu.
       * 
       * <p>To specify a JET context menu on a DOM element that is not a JET component, see the
       * <code class="prettyprint">ojContextMenu</code> binding.  
       * 
       * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the
       * context menu via the standard HTML5 syntax shown in the below example.  When the component is
       * initialized, the context menu thus specified will be set on the component.
       *
       * <p>When defining a contextMenu, ojTabs will provide built-in behavior for "cut" and "paste"
       *  if the following format for menu &lt;li&gt; item's is used (no &lt;a&gt; 
       *  elements are required):
       * <ul><li> &lt;li data-oj-command="oj-tabs-cut" /&gt;</li>
       *     <li> &lt;li data-oj-command="oj-tabs-paste-before" /&gt;</li>
       *     <li> &lt;li data-oj-command="oj-tabs-paste-after" /&gt;</li>
       * </ul>
       * The available translated text will be applied to menu items defined this way.
       *
       * <p>The JET Menu should be initialized before any component using it as a context menu.
       * 
       * @member
       * @name contextMenu
       * @memberof! oj.ojTabs
       * @instance
       * @type {string | null}
       * @default <code class="prettyprint">null</code>
       * 
       * @example <caption>Initialize a JET Tabs with a context menu:</caption>
       * // via recommended HTML5 syntax:
       * &lt;div id="myTabs" contextmenu="myMenu" data-bind="ojComponent: { ... }>
       * 
       * // via JET initializer (less preferred) :
       * $( ".selector" ).ojTabs({ "contextMenu": "#myContextMenu"  ... } });
       * 
       * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option for
       *      an ojTabs after initialization:</caption>
       * // getter
       * var menu = $( ".selector" ).ojTabs( "option", "contextMenu" );
       * 
       * // setter
       * $( ".selector" ).ojTabs( "option", "contextMenu", "#myContextMenu" );
       */

      // callbacks
      /**
       * Triggered immediately before a tab is selected.<p>
       * beforeSelect can be canceled to prevent the content from selecting by returning a false in the event listener.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.fromTab The tab being navigated from
       * @property {jQuery} ui.toTab The tab being navigated to
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">beforeSelect</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "beforeSelect": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeselect</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeselect", function( event, ui ) {} );
       */
      beforeSelect : null,

      /**
       * Triggered after a tab has been selected.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.fromTab The tab being navigated from
       * @property {jQuery} ui.toTab The tab being navigated to
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">select</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "select": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
       * $( ".selector" ).on( "ojselect", function( event, ui ) {} );
       */
      select : null, 

      /**
       * Triggered immediately before a tab is deselected.<p>
       * beforeDeselect can be canceled to prevent the content from deselecting by returning a false in the event listener.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.fromTab The tab being navigated from
       * @property {jQuery} ui.toTab The tab being navigated to
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">beforeDeselect</code> callback specified:</caption>
       * $( ".deselector" ).ojTabs({
       *     "beforeDeselect": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforedeselect</code> event:</caption>
       * $( ".deselector" ).on( "ojbeforedeselect", function( event, ui ) {} );
       */
      beforeDeselect : null,

      /**
       * Triggered after a tab has been deselected.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.fromTab The tab being navigated from
       * @property {jQuery} ui.toTab The tab being navigated to
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">deselect</code> callback specified:</caption>
       * $( ".deselector" ).ojTabs({
       *     "deselect": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojdeselect</code> event:</caption>
       * $( ".deselector" ).on( "ojdeselect", function( event, ui ) {} );
       */
      deselect : null, 

      /**
       * Triggered immediately before a tab is removed.
       * beforeRemove can be canceled to prevent the content from removeing by returning a false in the event listener.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.tab The tab that is about to be removed.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">beforeRemove</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "beforeRemove": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeremove</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeremove", function( event, ui ) {} );
       */
      beforeRemove : null,

      /**
       * Triggered after a tab has been removed.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.tab The tab that was just removed.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">remove</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "remove": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojremove</code> event:</caption>
       * $( ".selector" ).on( "ojremove", function( event, ui ) {} );
       */
      remove : null, 

      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic
       * intervention.  If the new value is the same as the previous value, no event will be fired.
       *
       * Currently there is one supported option, <code class="prettyprint">"selected"</code>.  Additional
       * options may be supported in the future, so listeners should verify which option is changing
       * before taking any action.
       *
       * @expose
       * @event
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {string} ui.option the name of the option that is changing
       * @property {Object} ui.previousValue the previous value of the option
       * @property {Object} ui.value the current value of the option
       * @property {Object} ui.optionMetadata information about the option that is changing
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
       *
       */
      optionChange: null

    },

    _ComponentCreate : function ()
    {
      var self = this, 
          options = this.options;

      this._super();
      this.running = false;

      this._setupOrientation(options.orientation);

      //set oj-disabled on panel divs
      this._setOjDisabledOnPanel(options.disabledTabs);

      this._processTabs();

      //update disabledTabs to contains ids if provided, index otherwise
      this._updateDisabledTabs();

      //Bug 18270242 - When ojtab first displays beforeSelect & select events are not raised  
      // select the selected tab after refresh
      var initialSelected = options.selected;
      options.selected = undefined;

      //Context Menu
      this._menu = {};
      this._menu.usermenu = false;
      this._menu.$container = false;
      this._menu.$elemPasteBefore = false;
      this._menu.$elemPasteAfter = false;

      this._initMenu();
      this._applyMenu();

      this._refresh();

      //Bug 18728223 - ojcreate should be raised before ojbeforeselect and ojselect events
      initialSelected = this._getPanelId(initialSelected);
      if (initialSelected === undefined)
        initialSelected = this._indexToId(0);

      options.selected = initialSelected;
    },

    /**
     * Fire select and deselect events right after the component is created.
     * 
     * @memberof! oj.ojTabs
     * @instance
     * @override
     */
    _init : function ()
    {
      //Bug 18728223 - ojcreate should be raised before ojbeforeselect and ojselect events
      this._fireSelectEvents(this.options.selected);
    },

    _fireSelectEvents : function(selected)
    {
      //Bug 18270242 - When ojtab first displays beforeSelect & select events are not raised  
      //Bug 18539151 - ojtabs should not let user set focus on disabled tabs
      //if the selected tab is disabled or undefined, select the next enabled tab
      if (this._isTabDisabled(selected))
      {
        var nextIndex = this._getNextEnabledTab(selected);
        selected = (nextIndex === undefined) ? undefined : this._indexToId(nextIndex);
      }
      this._activate(selected);
    },

    // Override to set custom launcher
    _OpenContextMenu: function(menu, event)
    {
      // Setting the launcher to the current tabbable tab.  Component owner should feel free to specify a different 
      // launcher if appropriate.  See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.
      menu.open(event, {"launcher": this.tablist.children("[tabindex=0]"), "initialFocus": "menu"});
    },

    _tabKeydown : function (event)
    {
      /*jshint maxcomplexity:15*/
      var focusedTab = $(this.document[0].activeElement).closest("li"), 
          selectedIndex = this.tabs.index(focusedTab), goingForward = true;

      if (this._handlePageNav(event))
        return;

      switch (event.keyCode)
      {
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
          selectedIndex++;
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.LEFT:
          goingForward = false;
          selectedIndex--;
          break;
        case $.ui.keyCode.END:
//TODO: disabled tab 
          selectedIndex = this.tabs.length - 1;
          break;
        case $.ui.keyCode.HOME:
          selectedIndex = 0;
          break;

        case _DELETE_KEY:
        // James: remove tab keystroke doesn't seem to work with JAWS. 
        // ALT+DEL seems to conflict with a JAWS keystroke. I have raised an issue on the Authoring 
        // Practices for this. Could we just use Delete as well or does that sound like a bad idea?
//          if (event.altKey)
//          {
            // simulate a click on the close icon of the current selected header
            var anchor = this.active.find("." + _CLOSE_ICON);
            if (anchor)
            {
              event.preventDefault();
              this._removeTabHandler(
                {
                  target : anchor, 
                  currentTarget : anchor, 
                  preventDefault : $.noop
                });
            }
//          }
          return;

        default :
          return;
      }

      // Focus the appropriate tab, based on which key was pressed
      event.preventDefault();
      clearTimeout(this.activating);
      var panelId = this._focusNextTab(selectedIndex, goingForward);

      // Navigating with control key will prevent automatic activation
      if (!event.ctrlKey)
      {
        // Update aria-selected immediately so that AT think the tab is already selected.
        // Otherwise AT may confuse the user by stating that they need to select the tab,
        // but the tab will already be selected by the time the announcement finishes.
        focusedTab.attr("aria-selected", "false");
        this._getTabByPanelId(panelId).attr("aria-selected", "true");

        this.activating = this._delay(function ()
        {
          this.option("selected", panelId);
        },
        this.delay);
      }
    },

    _panelKeydown : function (event)
    {
      if (this._handlePageNav(event))
        return;

      // Ctrl+up moves focus to the current tab
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP)
      {
        event.preventDefault();
        this.active.focus();
      }

    },

    // Ctrl+page up/down moves focus to the previous/next tab (and selects)
    _handlePageNav : function (event)
    {
      var selectedIndex = this._idToIndex(this.options.selected);

      if (event.ctrlKey && event.keyCode === $.ui.keyCode.PAGE_UP)
      {
        this._activate(this._focusNextTab(selectedIndex - 1, false));
        return true;
      }
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.PAGE_DOWN)
      {
        this._activate(this._focusNextTab(selectedIndex + 1, true));
        return true;
      }
    },

    _isTabDisabled : function (index)
    {
      if (index >=0 && index < this.tabs.length)
        return $(this.tabs[index]).hasClass("oj-disabled");
      return false;
    },

    _findNextTab : function (index, goingForward)
    {
      var lastTabIndex = this.tabs.length - 1;

      function constrain()
      {
        if (index > lastTabIndex)
        {
          index = 0;
        }
        if (index < 0)
        {
          index = lastTabIndex;
        }
        return index;
      }

      while (this._isTabDisabled(constrain()))
      {
        index = goingForward ? index + 1 : index - 1;
      }

      return index;
    },

    _focusNextTab : function (index, goingForward)
    {
      index = this._findNextTab(index, goingForward);
      this._getTab(index).focus();
      return this._indexToId(index);
    },

    //return index
    _getNextEnabledTab : function (panelId)
    {
      var index = this._idToIndex(panelId),
          next = index + 1,
          lastTabIndex = this.tabs.length - 1;

      while (next <= lastTabIndex) 
      {
        if (! this._isTabDisabled(next))
        {
          return next;
        }
        next++;
      }
      next = index - 1;
      while (next >= 0)
      {
        if (! this._isTabDisabled(next))
        {
          return next;
        }
        next--;
      }
      return undefined;
    },

    _setOption : function (key, value, flags)
    {
      if (key === "selected")
      {
        value = this._getPanelId(value);
        if (value === undefined)
          return;

        // _activate() will update this.options
        this._activate(value);
        return;
      }

      if (key === "disabledTabs")
      {
        if (Array.isArray(value))
        {
          this._setOjDisabledOnPanel(value);

          //Bug 18679648 - when observable is used to update disabled tabs, tabs do not function right
          this.refresh();

          //update disabledTabs to contains ids if provided, index otherwise
          this._updateDisabledTabs();
        }
        return;
      }

      if (key === "removable")
      {
        this._setRemovable(value);
        return;
      }

      //allow drag and drop a tab within the tab bar
      if (key === "reorderable")
      {
        if (value !== this.options.reorderable)
        {
          this.options.reorderable = value;
          this._setupReorder();
          //Bug 19263316 - if reorderable option is changed to true programmatically,
          //it doesn't take affect
          this.refresh();
        }
        return;
      }

      //change orientation need refresh
      if (key === "orientation")
      {
        this._setupOrientation(value);
        this.refresh();
        return;
      }

      if (key === "truncation")
      {
        this.options.truncation = value;
        this.refresh();
        return;
      }

      if (key === "contextMenu")
      {
        this._clearMenu();
        if (value)
          this._initMenu(value);
      }

      this._super(key, value, flags);

      if (key === "selectOn")
      {
        this._tearDownEvents();
        this._super(key, value);
        this._setupEvents();
      }

      if (key === "removeCueText")
        this.refresh();

    },

    /**
     * Refreshes the visual state of the tabs. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is 
     * programmatically changed underneath the component.
     *
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojTabs
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojTabs( "refresh" );
     */
    refresh : function ()
    {
      this._super();

      this._destroyCloseIcons();
      this._processTabs();

      this._refresh();
    },

    _refresh : function ()
    {
      var options = this.options;

      // check for length avoids error when initializing empty list
      var selectedPanel = this.element.children(".oj-tabs-selected");
      if (selectedPanel.length)
        this.active = this._getTabByPanelId(selectedPanel.attr("id"));
      else
        this.active = $();

      this._createCloseIcons();

      this._tearDownEvents();
      this._setupEvents();

      this.tabs.not(this.active).attr(
      {
        "aria-selected" : "false", 
        "tabIndex" : "-1"
      });
      this.panels.not(this._getPanelForTab(this.active)).hide().attr(
      {
        "aria-expanded" : "false", 
        "aria-hidden" : "true"
      });

      // Make sure one tab is in the tab order
      if (this.active.length)
      {
        this.active.addClass("oj-selected").attr(
        {
          "aria-selected" : "true", 
          "tabIndex" : "0"
        });
        selectedPanel.show().attr(
        {
          "aria-expanded" : "true", 
          "aria-hidden" : "false"
        });
      }
      else 
      {
        this._getTab(0).attr("tabIndex", "0");
      }

      // handle active numbers: negative, out of range
      if (this._activateLater !== undefined)
      {
        this._fireSelectEvents(this._activateLater);
        this._activateLater = undefined;        
      }

      if (options.orientation == "horizontal")
      {
        //always add conveyor
        this._truncateBeforeOverflow();
        this._addConveyor();

       if (this.options.selected === undefined || 
           this._idToIndex(this.options.selected) == 0)
         this.element.addClass("oj-first-child-selected");
       else
         this.element.removeClass("oj-first-child-selected");
      }
      else {
        this.element.removeClass("oj-first-child-selected");
      }

      //Bug 18269323 - After a tab is deleted, reorder does not work
      this._setupReorder();
    },

    _addConveyor : function ()
    {
      var tabsId = this.tablist.uniqueId().attr("id");
      var conveyorDiv = this._getTabbarWrapper().parent();

      this.conveyor = conveyorDiv.ojConveyorBelt(
        {
          orientation: "horizontal", 
          contentParent: "#" + tabsId
        });
    },

    _processTabs : function ()
    {
      var self = this;

      //destroy the old tab bar before creating a new one
      this._destroyTabBar();

      //create a tab bar: create a <ul> and its <li> children based on the 
      //original tabs markup
      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.tablist = $("<ul>")
        .addClass("oj-tabs-nav oj-helper-clearfix")
        .attr("role", "tablist")
        .prependTo(this.element);

      //list of tabs
      this.tabs = $();
      //list of contents
      this.panels = $();
      //list of titles
      this.titles = $();

      this.element.children(":not(.oj-tabs-nav)").each(
        function (index)
        {
          var header = $(this).find("> :first-child");
          var headerClone = header.clone();
          headerClone
            .addClass("oj-tabs-title")
            .css(
            {
              "display": ""
            })
            .attr(
            {
              "aria-hidden": "false"
            });

          self.titles = self.titles.add(headerClone);

          var anchor = headerClone
              .wrap("<li><div><a href='#'></a></div></li>")
              .parent();

          anchor.addClass("oj-tabs-anchor")
            .attr(
            {
              "role" : "presentation", 
              "tabIndex" : "-1"
            });

          var div = anchor.parent()
            .addClass("oj-tabs-tab-content");

          var tab = div.parent()
            .addClass("oj-tabs-tab")
            .attr(
            {
              "role" : "tab", 
              "aria-hidden": "false",
              "tabIndex" : "-1"
            });

          tab.appendTo(self.tablist);
          self.tabs = self.tabs.add(tab);

          //make sure the cloned elements have unique ids
          var chd = headerClone[0];
          if (chd.id)
            self._addPrefixId(chd);
          headerClone.find("[id]").each(function() {
            self._addPrefixId(this);
          });

          //TODO: remove aria-hidden attribute
          header.hide()            
            .attr(
            {
              "aria-hidden": "true"
            });

          var anchorId = anchor.uniqueId().attr("id"),
              originalAriaControls = tab.attr("aria-controls"),
              panel = $(this);

          if (panel.hasClass("oj-disabled")) 
          {
            tab.addClass("oj-disabled")
              .attr("aria-disabled", "true");
            //Bug 18270899 - clicking on disabled tab takes user to the top of the page
            anchor.removeAttr("href");
          }

          if (originalAriaControls)
            tab.data("oj-tabs-aria-controls", originalAriaControls);

          tab.attr(
            {
              "aria-controls" : self._getPanelUniqueId(panel),
              "aria-labelledby" : anchorId
            });

          self.panels = self.panels.add(panel);
          panel.attr("aria-labelledby", anchorId);
        });

      if (this.options.orientation == "vertical")
      {
        //In vertical, "oj-tabs-nav-root" is on the same element as the element with "oj-tabs-nav"
        //as long as the theming doesn't care whether the root is on the same element or not
        self.tablist.addClass("oj-tabs-nav-root");

        /* 
         * calulate tab maxWidth and content left margin in a 0 timeout 
         * because font size is not correctly set
         */
        window.setTimeout(function () {
          //qunit test failure
          if (! self || ! self.active)
            return;

          //get the longest tab width
          var maxTabWidth = 0;

          self.tabs
            .addClass("oj-selected")
            .each(function ()
              {
                var tab = $(this);
                maxTabWidth = Math.max(maxTabWidth, tab.outerWidth());
              })
            .removeClass("oj-selected");

          //reset oj-selected
          self.active.addClass("oj-selected")
          self.tabs.css(
            {
              'width': maxTabWidth + "px"
            });

          //get margin-left and min-height of content
          var outerWidth = self.tablist.outerWidth(true);
          var outerHeight = self.tablist.outerHeight(true);

          var isR2L = (self._GetReadingDirection() == "rtl");
          var rootPadding = isR2L? self.element.css("padding-right") : self.element.css("padding-left");
          rootPadding = parseInt(rootPadding, 10);

          if (isR2L)
          {
            self.panels.css(
              {
                'margin-right': outerWidth - 1 + rootPadding + "px",
                'min-height': outerHeight + "px"
              });
          }
          else
          {
            self.panels.css(
              {
                'margin-left': outerWidth - 1 + rootPadding + "px",
                'min-height': outerHeight + "px"
              });
          }
        }, 0);
      }

      this.panels.addClass("oj-tabs-panel")
        .attr("role", "tabpanel");

    },

    _setupEvents : function ()
    {
      var events = 
      {
        'keydown' : this._tabKeydown
      };

      var event = this.options.selectOn;
      var selectOnClick = false;
      if (event)
      {
        var self = this;
        $.each(event.split(" "), function (index, eventName)
        {
          //Bug 19377933 - mousedown is a better default for jtab selecton than click 
          if (eventName == "click")
            selectOnClick = true;

          //security test
          if (/^[a-zA-Z]+$/.test(eventName)) {
            events[eventName] = self._eventHandler;
          }
        });
      }

      var enabledTabs = this.tabs.not(".oj-disabled");

      this._on(enabledTabs, events);

      //Bug 19377933 - mousedown is a better default for jtab selecton than click 
      if (! selectOnClick) {
        this._on(enabledTabs,
        {
	  // prevent the default action
          'click' : function(e) {e.preventDefault();}
        });
      }

      this._on(this.panels, 
      {
        'keydown' : this._panelKeydown
      });

      //add listeners on close icon
      if (this.options.removable)
      {
        var revents = 
        {
          "click" : this._removeTabHandler
        }
        this._on(enabledTabs.find("." + _CLOSE_ICON), revents);
      }

      this._focusable(enabledTabs);
      this._hoverable(enabledTabs);
      this._activeable(enabledTabs);

    },

    _tearDownEvents : function ()
    {
      var enabledTabs = this.tabs.not(".oj-disabled");
      this._off(enabledTabs);
      this._off(this.panels);

    },

    _eventHandler : function (event)
    {
      var options = this.options, 
          active = this.active, 
          tab = $(event.currentTarget).closest("li"), 
          clickedIsActive = (active && tab[0] === active[0]), 
          oToContent = this._getPanelForTab(tab),
          oFromContent = (active && active.length) ? this._getPanelForTab(active) : $(),

          eventData = 
          {
            /** @expose */
            fromTab : oFromContent,
            /** @expose */
            toTab : oToContent
          };

      event.preventDefault();

      if (tab.hasClass("oj-disabled") || 

          // can't switch durning an animation
          this.running || 
          // click on active header, 
          clickedIsActive || 

          // allow canceling deselect
          // Bug 18681075 - ojbeforedeseselect & ojdeselect events shouldn't be raised
          // when tab is rendered initially
          (oFromContent && oFromContent.length &&
           this._trigger("beforeDeselect", event, eventData) === false) ||

          // allow canceling select
          (this._trigger("beforeSelect", event, eventData) === false))
      {
        return;
      }

      options.selected = this._getPanelIdOrIndex(tab);
      this.active = tab;

      //add or remove oj-selected on the corresponding panel
      oToContent.addClass("oj-tabs-selected");
      oFromContent.removeClass("oj-tabs-selected");

      if (!eventData.fromTab.length && ! eventData.toTab.length)
      {
        $.error("ojTabs: Mismatching fragment identifier.");
      }

      this._toggle(event, eventData);
    },

    // handles show/hide for selecting tabs
    _toggle : function (event, eventData)
    {
      var self = this, 
          toShow = eventData.toTab, 
          toHide = eventData.fromTab,
          fromId,
          toId;

      if (eventData)
      {
        if (toHide)
          fromId = toHide.attr("id");

        if (toShow)
          toId = toShow.attr("id");
      }
      this.running = true;

      function complete()
      {
        self.running = false;

        //Bug 18681075 - ojbeforedeseselect & ojdeselect events shouldn't be raised 
        //when tab is rendered initially
        if (fromId !== undefined)
          self._trigger("deselect", event, eventData);
        self._trigger("select", event, eventData);

        self._fireOptionChange("selected", 
                               self._getPanelIdOrIndex(null, toHide, fromId),
                               self._getPanelIdOrIndex(null, toShow, toId),
                               event ? true : false);
      }

      function show()
      {
        self._getTabByPanelId(toId).addClass("oj-selected");
        if (self.options.orientation == "horizontal" && self.tabs.length > 0) {
          if (self._idToIndex(toId) == 0)
            self.element.addClass("oj-first-child-selected");
          else
            self.element.removeClass("oj-first-child-selected");
        }

        toShow.show();
        //Bug 19429607 - unable to stretch ojtable in an initially hidden ojtab
        if (toShow.length > 0)
          oj.Components.subtreeShown(toShow[0]);
        complete();
      }

      // start out by hiding, then showing, then completing
      var fromTab = this._getTabByPanelId(fromId)
        .removeClass("oj-selected");

      toHide.hide();
      //Bug 19429607 - unable to stretch ojtable in an initially hidden ojtab
      if (toHide.length > 0)
        oj.Components.subtreeHidden(toHide[0]);
      show();

      toHide.attr(
      {
        "aria-expanded" : "false", 
        "aria-hidden" : "true"
      });

      fromTab.attr("aria-selected", "false");        

      // If we're switching tabs, remove the old tab from the tab order.
      // If we're opening from collapsed state, remove the previous tab from the tab order.
      if (toShow.length && toHide.length)
      {
        fromTab.attr("tabIndex", "-1");
      }
      else if (toShow.length)
      {
        this.tabs.filter(function ()
        {
          return $(this).attr("tabIndex") === "0";
        })
          .attr("tabIndex", "-1");
      }

      toShow.attr(
      {
        "aria-expanded" : "true", 
        "aria-hidden" : "false"
      });

      this._getTabByPanelId(toId).attr(
      {
        "aria-selected" : "true", 
        "tabIndex" : "0"
      });

    },

    _activate : function (panelId)
    {
      if (panelId === undefined)
        return;

      var active = this._getTabByPanelId(panelId),
          anchor;

      // trying to activate the already active panel
      if (this.active && (active[0] === this.active[0]))
        return;

      //Bug 18539151 - ojtabs should not let user set focus on disabled tabs
      //this.options.selected = panelId;

      // simulate a click on the new active header
      anchor = active.find(".oj-tabs-anchor")[0];
      this._eventHandler(
      {
        target : anchor, 
        currentTarget : anchor, 
        preventDefault : $.noop
      });
    },

    _createCloseIcons : function ()
    {
      //Bug 18727052 - for vertical tabs, removable option should be ignored
      //create close icon only if it's horizontal and  not disabled
      if (this.options.removable && this.options.orientation == "horizontal")
      {
        var removeCueText = this.getTranslatedString(this.options.removeCueText);
        this.tabs.not(".oj-disabled").each(function (index)
        {
          var div = $(this).find("> :first-child");
          div.addClass("oj-removable");

          //add cue text for removable icon for screen reader users
          var rmId = _ID_PREFIX + "rm_" + index;
          $(this).attr("aria-describedby", rmId);

          $("<a href='#'>")
            .addClass("oj-tabs-icon oj-component-icon oj-clickable-icon " + _CLOSE_ICON)
            .attr(
              {
                "id": rmId,
                "tabIndex" : "-1",
                "aria-label" : removeCueText,
                "role" : "presentation"
              })
            .appendTo(div);

        });
      }
    },

    _destroyCloseIcons : function ()
    {
      this.tabs.find(_CLOSE_ICON).remove();
    },

    _destroyTabBar : function ()
    {
      //remove listener
      this._tabMaxWidthApplied = false;
      if (this._hasResizeListener)
      {
        oj.DomUtils.removeResizeListener(this.element[0], this._resizeHandler);
        this._hasResizeListener = false;
        this._originalWidth = undefined;
      }

      if (this.conveyor) {
        this.conveyor.ojConveyorBelt( "destroy" );
        this.conveyor.remove();
        this.conveyor = null;
        this.active = null;
      }
      else
      {
        this.element.children(".oj-tabs-nav").remove();
      }
    },

    _destroy : function ()
    {
      this._clearMenu();

      var orientation = this.options.orientation;
      if (orientation == "vertical")
        this.element.removeClass("oj-tabs oj-component oj-tabs-vertical oj-helper-clearfix");
      else
        this.element.removeClass("oj-tabs oj-component oj-tabs-horizontal oj-first-child-selected");

      //destroy tab bar and conveyor
      this._tearDownEvents();
      this._destroyTabBar();

      var self = this;
      this.panels.each(function ()
      {
        $(this).removeAttr("tabIndex")
          .removeAttr("aria-expanded")
          .removeAttr("aria-selected")
          .removeAttr("aria-labelledby")
          .removeAttr("aria-hidden")
          .removeAttr("role")
          .removeClass("oj-active oj-disabled oj-tabs-selected oj-tabs-gid oj-tabs-panel")
          .removeUniqueId()
          .css("display", "");

        if (orientation == "vertical")
        {
          $(this).css("margin-left", "")
            .css("min-height", "");
        }

        //remove display:none
        var header = $(this).find("> :first-child");
        header.css("display", "")
          .removeAttr("aria-hidden");

      });
    },

    _setRemovable : function (removable)
    {
      if (removable === this.options.removable)
        return;

      this.options.removable = removable;
      this.refresh();
    },

    _removeTabHandler : function (event)
    {
      var icon = $(event.currentTarget),
          tab = icon.closest("li"),
          panel = this._getPanelForTab(tab),
          eventData = 
          {
            /** @expose */
            tab : panel
          };

      //trigger before delete event and only delete if it's not cancelled
      if (tab && this._trigger("beforeRemove", event, eventData) !== false)
      {
        //if tab to be removed is selected, select the next enabled tab
        if (tab.hasClass("oj-selected"))
        {
          //fire select event 
          var nextIndex = this._getNextEnabledTab(panel.attr("id"));
          // no enabled tabs left
          if (nextIndex === undefined)
          {
            this.options.selected = undefined;
            this.active = undefined;
          }
          else
          {
            this.options.selected = this._getPanelIdOrIndex(this.tabs[nextIndex]);
            this._activateLater = this._indexToId(nextIndex);
          }
        }

        panel.remove();
        tab.remove();

        //Bug 18269291 - If user closes tab then index for tabs changes and disabled tab becomes enable
        // update indices of disabled tabs 
        this._updateDisabledTabs();

        this.refresh();

        //set focus on the active
        if (this.active)
          this.active.focus();

        this._trigger("remove", event, eventData);
      }
    },

    /**
     * Add a tab to the end of the tabs
     * 
     * @expose 
     * @memberof! oj.ojTabs
     * @instance
     * @param {jQuery} newTab jQuery object of the new tab
     * @example <caption>Invoke the <code class="prettyprint">addTab</code> method:</caption>
     * $( ".selector" ).ojTabs( "addTab", $("&lt;div>&lt;h3>New Tab&lt;/h3>&lt;p>Content of New Tab&lt;/p>&lt;/div>") );
     */
    addTab : function (newTab)
    {
      this.element.append(newTab);

      //in case all tabs are disabled, make sure the new tab is enabled.
      var selectedPanel = this.element.children(".oj-tabs-selected");
      if (! selectedPanel.length)
      {
        var panelId = this._getPanelUniqueId(newTab);
        this._activateLater = panelId;
      }

      this.refresh();

      //Bug 18427258 - new tabs don't get focus
      this.tabs.last()[0].scrollIntoView(false);
    },

    _setupReorder : function ()
    {
      //enable sortable
      //Bug 18793240 - when one of the tab is disabled, sorting does not work
      if (this.options.reorderable && this.options.disabledTabs.length !== this.tabs.length)
      {
        var self = this;
        this.tablist.sortable(
        {
          axis: (self.options.orientation == "horizontal") ? "x" : "y",
          stop: function(event, ui) {              
            //find the element that was moved
            var mvTab = ui.item;
            self._doReorder(mvTab, mvTab.prev());
          }
        })
      }
      //disable sortable
      else
      {
        this.tablist.sortable({ disabled: true });
      }
    },

    _setupOrientation : function (value)
    {
      if (! value)
        value = this.options.orientation;

      if (value == "horizontal")
      {
        if (this.options.orientation == "vertical" && this.panels)
        {
          this.element.removeClass("oj-tabs-vertical oj-helper-clearfix");
          this.panels.each(function ()
          {
            $(this).css("margin-left", "")
              .css("min-height", "");
          });
        }
        this.element.addClass("oj-tabs oj-component oj-tabs-horizontal");
      }
      else if (value == "vertical")
      {
        if (this.options.orientation == "horizontal" && this.panels)
        {
          this.element.removeClass("oj-tabs-horizontal");
        }
        this.element.addClass( "oj-tabs oj-component oj-tabs-vertical oj-helper-clearfix" );
      }
      else
        return;

      this.options.orientation = value;
    },

    //Bug 18290621 - ojtabs do not work with tabs whose id has '::' 
    _sanitizeSelector: function( hash ) {
      return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
    },

    _getPanelForTab : function (tab)
    {
      var id = $(tab).attr("aria-controls");
      return this.element.find(this._sanitizeSelector("#" + id));
    },

    _getTab : function (index)
    {
      return this.tabs.eq(index);
    },

    _getTabbarWrapper: function()
    {
      var ulParent = this.tablist.parent();
      if (! ulParent.hasClass("oj-tabs-conveyor"))
      {
        ulParent = this.tablist
            .wrap("<div>")
            .parent()
            .addClass("oj-tabs-conveyor");

        //Bug 19209791 - truncation not working
        //need to create the "oj-tabs-nav-root" before addConveyor
        //otherwise, all skin selectors wont apply

        // add special class so tabs component can skin the conveyor 
        // overflow indicators to add padding between them and the tabs
        var navRoot = ulParent
          .wrap("<div>")
          .parent()
          .addClass("oj-tabs-nav-root");

        navRoot.uniqueId().attr("id");
      }
      return ulParent;
    },

    _addPrefixId : function (elem)
    {
      if (elem.id.indexOf(_ID_PREFIX) < 0)
        $(elem).attr("id", _ID_PREFIX + elem.id);
    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     *
     * Test authors should target sub elements using the following names:
     * <ul>
     * <li><b>oj-tabs-tab</b>: tab div </li>
     * <li><b>oj-tabs-title</b>: tab title text </li>
     * <li><b>oj-tabs-panel</b>: tab content panel </li>
     * <li><b>oj-tabs-close-icon</b>: tab close icon </li>
     * <li><b>oj-conveyorbelt</b>: conveyorbelt </li>
     * </ul>
     *
     * In addition, tabs requires a zero-based index of the child tab.
     *
     * @expose
     * @memberof! oj.ojTabs
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent.<p>
     *        index: a number, the index of tab.
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      if (locator == null)
      {
        return this.element ? this.element[0] : null;
      }

      var subId = locator['subId'],
          index = locator['index'];

      if (subId != 'oj-conveyorbelt' &&
          ((typeof index !== 'number') ||
           index < 0 || index >= this.panels.length))
        return null;

      switch (subId)
      {
      case 'oj-conveyorbelt':
        return this.conveyor ? this.conveyor[0] : null;

      case 'oj-tabs-panel':
        return this.panels[index];

      case 'oj-tabs-tab':
        return this.tabs[index];

      case 'oj-tabs-title':
        return this.titles[index];

      case 'oj-tabs-close-icon':
        return this._getTab(index).find("." + subId)[0];
      }

      // Non-null locators have to be handled by the component subclasses
      return null;
    },

    _getTabsWidth: function()
    {
      return this.element[0].clientWidth;
    },

    _isOverflow: function()
    {
      return (this._originalWidth > this._getTabsWidth());
    },

    _isMaxWidthApplied: function()
    {
      return this._tabMaxWidthApplied;
    },

    _setMaxWidthApplied: function(bval)
    {
      this._tabMaxWidthApplied = bval;
    },

    _getTabMaxWidth: function()
    {
      var max = Math.floor(this._getTabsWidth()  / this.tabs.length);

      if (this.options.removable)
        max -= _CLOSE_ICON_SIZE;

      return max;
    },

    _applyTabMaxWidth: function()
    {
      if (! this._isMaxWidthApplied())
      {
        var maxWidth = this._getTabMaxWidth();

        this.titles.each(function (index)
        {
          $(this)
            .css("max-width", "" + maxWidth + "px")
            .addClass("oj-tabs-title-overflow");
        });

        this._setMaxWidthApplied(true);
        this._logMessage("apply max width");
      }
    },

    _removeTabMaxWidth: function()
    {
      if (this._isMaxWidthApplied())
      {
        this.titles.each(function (index)
        {
          $(this)
            .css("max-width", "")
            .removeClass("oj-tabs-title-overflow");
        });

        this._setMaxWidthApplied(false);
        this._logMessage("remove max width");
      }
    },

    _logMessage: function(msg)
    {
//      console.log(msg);
    },

    /* resize handler */
    _handleResize: function(width, height)
    {
      this._logMessage("width " + width + " ulWidth " + this._originalWidth +
                       " clientWidth " + this._getTabsWidth());

      if (this._isOverflow())
      {
        this._logMessage("overflow");
        this._applyTabMaxWidth();
      }
      else
      {
        this._logMessage("underflow");
        this._removeTabMaxWidth();
      }
    },

    _isProgressive: function()
    {
      return this.options.truncation == "auto" ||
        this.options.truncation == "progressive";
    },

    _truncateBeforeOverflow: function()
    {
      var options = this.options;
      if (options.orientation == "horizontal" && this.tabs.length > 0 && 
          this._isProgressive())
      {
        if (this._resizeHandler == null)
          this._resizeHandler = this._handleResize.bind(this);

        oj.DomUtils.addResizeListener(this.element[0], this._resizeHandler);
        this._hasResizeListener = true;

        //handle initial overflow
        this._originalWidth = this._getTabbarWrapper()[0].scrollWidth;

        if (this._isOverflow())
          this._applyTabMaxWidth();
      }
    },

    /**
     * Fire optionChange event 
     * @param {String} key - 'selected'
     * @param {Object} previousValue 
     * @param {Object} value
     * @param {Boolean} originalEvent  
     *
     * @private
     */
    _fireOptionChange: function(key, previousValue, value, originalEvent) 
    {
      var ui = {
        "option": key,
        "previousValue": previousValue,
        "value": value,
        // (originalEvent is non-null) iff (option change is due to user interaction) 
        // iff (binding should write back the value)
        "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
      };
      this._trigger('optionChange', originalEvent, ui);
    },

    /**
     *  @private
     */
    _handleContextMenuBeforeShow: function(e, ui)
    {
      //Context Menu: 
      //got here either by right mouse click (e.which == 3)
      //or <shift F10> key (ev.keyCode = 121 and ev.shiftKey = true)
      var ev = e['originalEvent']['originalEvent'];

      if (ev['type'] === 'keydown') {
        this._menu.tab = this.active;
      }
      else  {
        this._menu.tab = $(e.originalEvent.target).closest("li");
      }
      this._menu.tabId = this._menu.tab.attr("id");

      // TODO: Should set "of" only for keyboard, like Table/DataGrid do, so that 
      // for right-clicks the menu is positioned at the event.
      // TODO: Rather than setting "position" in this beforeOpen listener, probably better to 
      // override _OpenContextMenu() and pass "position" in its call to menu.open().  That way, 
      // if the app wants to tweak the position in its beforeOpen listener, its success 
      // doesn't depend on who gets their listeners registered first.
      ui.openOptions.position = {"my" : "start top",
                                 "at" : "start bottom",
                                 "of" : this._menu.tab[0]};

      // Set menu "Paste" disable state, depending on whether there's been a
      // previous "cut"
      if (this._menu.usermenu && 
          (this._menu.$elemPasteBefore || this._menu.$elemPasteAfter)) {

        var disabledState = (! this._menu.cutTab);
        var state = this._menu.$elemPasteBefore.hasClass("oj-disabled");

        if (state != disabledState) {
          if (disabledState) {
            this._menu.$elemPasteBefore.addClass("oj-disabled");
            this._menu.$elemPasteAfter.addClass("oj-disabled");
          }
          else {
            this._menu.$elemPasteBefore.removeClass("oj-disabled");
            this._menu.$elemPasteAfter.removeClass("oj-disabled");
          }
          this._menu.$container.ojMenu("refresh");
        }
      }
    },

    _buildContextMenuItem : function(cmd)
    {
      var id = _arMenuCmdMap[cmd];
      var label = '<a href="#">' + this.getTranslatedString(cmd) + '</a>';
      return $('<li id=' + id + '>' + label + '</li>');
     },

    /**
     *  Menu "cut" functionality
     *  @private
     */
    _menu_cut : function (obj)
    {
      if (!obj || !obj.length)  {
        return false;
      }

      this._menu.cutTab = obj;
    },

    /**
     *  Menu "paste" functionality
     *  @private
     */
    _menu_paste : function (obj, pasteBefore)
    { 
      if (!obj || !obj.length) {
        return false;
      }
      if (! this._menu.cutTab)  {
        return false;
      }

      var mvTab = this._menu.cutTab;
      this._menu.cutTab = false;
      this._doReorder(mvTab, obj, pasteBefore);

    },

    /**
     *   Check menu selected to see if it one of tabs predefined cut/paste id's
     *   @private
     */
    _handleContextMenuSelect: function(ev, ui)
    {
      var  id = ui? ui.item.attr("id") : undefined;

      if (id === "ojtabscut") {
        this._menu_cut(this._menu.tab);
      }
      else if (id === "ojtabspastebefore") {
        this._menu_paste(this._menu.tab, true);
      }
      else if (id === "ojtabspasteafter") {
        this._menu_paste(this._menu.tab, false);
      }
    },

    /**
     *  Initialize the context menu.  This is called on startup, or on option
     *  "contextMenu" change.
     *  @param {Object=} newVal   true if called because of an option change.
     *  @private
     */
    _initMenu : function(newVal)
    {
      var  menu, t, html, $html;

      // check for contextmenu attribute on the root element
      if ((! newVal) && (! this.options["contextMenu"])) {
        menu = this.element.attr("contextmenu");
        if (menu) {
          this.options["contextMenu"] = "#" + menu;
        }
      }

      if ((! newVal) && (! this.options["contextMenu"])) {
        return;
      }

      menu =  newVal || this.options["contextMenu"];
      t = $.type(menu);
      if (t == "function") {
        try {
          menu = menu();             // call user's method to get the context menu
        }
        catch (e) {
          menu = null;
        }
        t = $.type(menu);
      }

      if (t !== "string") {
        return;
      }

      var $m = $(menu);                    // get the user's <ul> list   
      if ($m) {
        $m.css("display", "none");         // ensure it's not visible
        var  dm = this._menu;
        if (! dm)
          return;

        dm.$container = $m;
        dm.usermenu   = true;              // have a context menu
      }
      
      // if we have a context menu
      if (this._menu.usermenu) {
        if (newVal) {                      // and it is it being changed
          this._applyMenu();               // complete menu creation/attachnment
        }
      }

      //  If not a new val from options, Menu will be noted at the end of initialization in _start()
    },


    /**
     *   Attach the user menu <ul> list to the tabs div, and set up listeners on it.
     *   @private
     */
    _applyMenu : function()
    {
      if (! this._menu || ! this._menu.usermenu || ! this.options.reorderable) {
        return;
      }

      // Add our listeners so that we can handle build-in cut/paste, etc
      var $menuContainer = this._menu.$container;
      var self = this;

      $menuContainer.on("ojselect",     $.proxy(this._handleContextMenuSelect,     this));
      $menuContainer.on("ojbeforeopen", $.proxy(this._handleContextMenuBeforeShow, this));

      // If there are any ojTabs built in menu item ids, construct the menu items
      var listItems = $menuContainer.find("[data-oj-command]");
      var bChanged  = false;

      listItems.each(function()  {
        if ($(this).children('a').length === 0)  {

          var command = $(this).attr('data-oj-command').slice("oj-tabs-".length);
          $(this).replaceWith(self._buildContextMenuItem(command));
          $(this).addClass("oj-menu-item")

          bChanged = true;
        }
      });

      if (bChanged) {
        $menuContainer.ojMenu('refresh');
      }

      //  Note "paste" elements for disabling if no prev "cut"
      this._menu.$elemPasteBefore = $menuContainer.find("#ojtabspastebefore");
      this._menu.$elemPasteAfter = $menuContainer.find("#ojtabspasteafter");       
    },
       
    /**
     *  Clear out any contextMenu data.
     *  @private
     */
    _clearMenu : function()
    {
      var menu = this._menu;
      if (menu && menu.usermenu)
      {
        menu.usermenu = false;
        menu.$container.off("ojselect");
        menu.$container.off("ojbeforeopen");
        menu.$container = null;
      }
    },

    _doReorder: function (mvTab, prevTab, pasteBefore)
    {
      //Bug 19263181 - if a tab is removed, any re-ordering performed on the tabs is lost
      //don't allow reorder on a disabled tab
      if (this._isTabDisabled(this.tabs.index(mvTab)))
        return;

      var mvContent = this._getPanelForTab(mvTab);

      if (prevTab.length)
      {
        if (pasteBefore) {
          this._getPanelForTab(prevTab).before(mvContent);
        }
        else {
          this._getPanelForTab(prevTab).after(mvContent);
        }
      }
      else if (this.panels.length > 0)
      {
        this.panels.first().before(mvContent);
      }

      //Bug 18680706 - calling refresh after reordering tabs causes tabs to loose there disabled state 
      //update disabled and active
      this._updateDisabledTabs();

      //Bug 18721093 - add new tab. move it to first place. add another tab.first tab disappears.
      this.refresh();
    },

    _getPanelUniqueId: function (panel)
    {
      var id = panel.attr("id");
      if (! id) {
        id = panel.uniqueId().attr("id");
        panel.addClass("oj-tabs-gid");
      }
      return id;
    },

    _getTabByPanelId: function (panelId)
    {
      return this._getTab(this._idToIndex(panelId));
    },

    _getPanelId: function (idOrIndex)
    {
      if (typeof idOrIndex === 'number') {
        if (idOrIndex >= 0 && idOrIndex < this.panels.length) {
          return this._indexToId(idOrIndex);
        }
      }
      else if (typeof idOrIndex === 'string') {
        if (this._idToIndex(idOrIndex) != -1)
          return idOrIndex;
      }
      return undefined;
    },

    _indexToId: function (index)
    {
      return this.panels.eq(index).attr("id");
    },

    //Note: return -1 if not valid id
    _idToIndex: function (id)
    {
      if (typeof id === 'number')
        return id;

      return this.panels.index($("#" + id));
    },

    /* 
     * return either page author provided id or index
     */
    _getPanelIdOrIndex: function (tab, panel, id) {
      if (! tab && ! panel)
        return undefined;

      if (tab) {
        panel = this._getPanelForTab(tab);
        id = panel.attr("id");
      }
      return panel.hasClass("oj-tabs-gid") ? this._idToIndex(id) : id;
    },

    _setOjDisabledOnPanel: function (disTabs)
    {
      //clear oj-disabled that were on the tabs and panels
      this.element.children().removeClass("oj-disabled");
      if (this.tabs) {
        $(this.tabs).removeClass("oj-disabled");
      }

      //for each disabled tab in otpions.disabledTabs, add oj-disabled to the corresponding panel 
      if (disTabs && disTabs.length > 0) {
        var children = this.element.children();
        var startIndex = this.conveyor ? (children.index(this.conveyor) + 1) : 0;
        var idOrIndex;

        for (var i = 0; i < disTabs.length; i++) {
          idOrIndex = disTabs[i];

          //Note: this.tabs may be undefined if this method is called from componenetCreate
          if ((typeof idOrIndex === 'number') &&
              idOrIndex >= 0 && (startIndex + idOrIndex) < children.length) {
            $(children[startIndex + idOrIndex]).addClass("oj-disabled");
          }
          else if (typeof idOrIndex === 'string') {
            this.element.find("#" + idOrIndex).addClass("oj-disabled");
          }
        }
      }
    },

    /* 
     * update disabledTabs array
     * entry value is either page author provided id or index
     */
    _updateDisabledTabs: function () {
      var arr  = [];
      var self = this;
      this.tablist.children(".oj-disabled").each(
        function() {
          arr.push(self._getPanelIdOrIndex($(this)));
        }
      );
      this.options.disabledTabs = arr;
    }


  });
}
());


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * @export
 * A CellSet represents a collection of cells.  The CellSet is an object returned by the success callback
 * of the fetchCells method on DataGridDataSource.  The CollectionCellSet is an oj collection specific 
 * implementation of methods on CellSet. 
 * @param {number} startRow the start row index of the cell set
 * @param {number} endRow the end row index of the cell set
 * @param {number} startColumn the start column index of the cell set
 * @param {number} endColumn the end column index of the cell set
 * @param {Array|null} columns the set of column keys
 * @constructor
 */
oj.CollectionCellSet = function(startRow, endRow, startColumn, endColumn, columns)
{
    // assert startRow/startColumn are number
    oj.Assert.assertNumber(startRow, null);
    oj.Assert.assertNumber(endRow, null);
    oj.Assert.assertNumber(startColumn, null);
    oj.Assert.assertNumber(endColumn, null);
    oj.Assert.assertArrayOrNull(columns);

    this.m_startRow = startRow;
    this.m_endRow = endRow;
    this.m_startColumn = startColumn;
    this.m_endColumn = endColumn;
    this.m_columns = columns;
};

/**
 * Sets the models used in this cell set.
 * @param {Array} models an array of oj model for the cell set
 * @private
 */
oj.CollectionCellSet.prototype.setModels = function(models)
{
    oj.Assert.assertArray(models);
    // make sure the array size is valid
    if (models != null && models.length === this.getCount("row"))
    {
        this.m_models = models;
    }
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the data from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object} the data object for the specified index.
 * @export
 */
oj.CollectionCellSet.prototype.getData = function(indexes)
{
    var column, model;

    // indexes are validated in _getModel
    model = this._getModel(indexes);
    if (model == null)
    {
        return null;
    }

    // extract column index
    column = indexes['column'];

    return model.get(this.m_columns[column]);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the metadata from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return the metadata object for the specific index.  The metadata that the DataGrid supports are: 
 *         1) keys - the key (of each axis) of the cell.
 * @export
 */
oj.CollectionCellSet.prototype.getMetadata = function(indexes)
{
    var column, model, keys;

    // indexes are validated in _getModel
    model = this._getModel(indexes);
    if (model == null)
    {
        return null;
    }

    // extract column index
    column = indexes['column'];

    keys = {"row": oj.CollectionDataGridUtils._getModelKey(model), "column": this.m_columns[column]};
    return {"keys": keys};
};

/**
 * Gets the Model based on indexes.
 * @private
 */
oj.CollectionCellSet.prototype._getModel = function(indexes)
{
    var row, column;

    // make sure models is populated
    if (this.m_models == null)
    {
        return null;
    }

    oj.Assert.assertObject(indexes);

    // extract row and column index
    row = indexes['row'];
    column = indexes['column'];

    // make sure index are valid
    oj.Assert.assert(row >= this.m_startRow && row <= this.m_endRow && column >= this.m_startColumn && column <= this.m_endColumn); 

    return this.m_models[row - this.m_startRow];
};

/**
 * Gets the actual count of the result set for the specified axis.  Valid values are "row" and "column".
 * @param {string} axis the axis in which to inquire the actual count of the result set.
 * @return {number} the actual count of the result set for the specified axis.  
 * @export
 */
oj.CollectionCellSet.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return Math.max(0, this.m_endRow - this.m_startRow);
    }
    
    if (axis === "column")
    {
        return Math.max(0, this.m_endColumn - this.m_startColumn);
    }

    return 0;
};

/**
 * Gets the m_startRow property
 * @export
 */
oj.CollectionCellSet.prototype.getStartRow = function()
{
    return this.m_startRow;
};

/**
 * Gets the m_endRow property
 * @export
 */
oj.CollectionCellSet.prototype.getEndRow = function()
{
    return this.m_endRow;
};

/**
 * Gets the m_startColumn property
 * @export
 */
oj.CollectionCellSet.prototype.getStartColumn = function()
{
    return this.m_startColumn;
};

/**
 * Gets the m_endColumn property
 * @export
 */
oj.CollectionCellSet.prototype.getEndColumn = function()
{
    return this.m_endColumn;
};

/**
 * Gets the m_columns property
 * @export
 */
oj.CollectionCellSet.prototype.getColumns = function()
{
    return this.m_columns;
};


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * This class contains all utility methods used by the data grid colelction model.
 * @constructor
 */
oj.CollectionDataGridUtils = function()
{
};

/**
 * Returns the key of the model. It is the id if one is set otherwise
 * it is the cId
 * @param {Object} model the model to chececk for id and cid
 * @return {String} the id or cid for the model
 */
oj.CollectionDataGridUtils._getModelKey = function(model)
{
    var key;
    key = model.GetId();
    if (key == null)
    {
        key = model.GetCid();
    }
    return key;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * @export
 * A HeaderSet represents a collection of headers.  The HeaderSet is an object returned by the success callback
 * of the fetchHeaders method on DataGridDataSource.  This is an oj collection specific implementation of the HeaderSet.
 * @param {number} start the start index of header set.
 * @param {number} end the end index of the header set.
 * @param {Array} headers the array of headers
 * @param {string=} rowHeader the id of the row header column.  Required for row headers.
 * @constructor
 */
oj.CollectionHeaderSet = function(start, end, headers, rowHeader)
{
    // assert start/end are number
    oj.Assert.assertNumber(start, null);
    oj.Assert.assertNumber(end, null);
    oj.Assert.assertArrayOrNull(headers);

    this.m_start = start;
    this.m_end = end;
    this.m_headers = headers;
    this.m_rowHeader = rowHeader;
};

/**
 * Sets the models used in this header set.
 * @param {Array} models an array of oj model for the header set
 * @private
 */
oj.CollectionHeaderSet.prototype.setModels = function(models)
{
    oj.Assert.assertArray(models);
    // make sure the array size is valid
    if (models != null && models.length === this.getCount())
    {
        this.m_models = models;
    }
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the header in which we want to retrieve the header from.  
 * @return {Object} the data object for the specific index.
 * @export
 */
oj.CollectionHeaderSet.prototype.getData = function(index)
{
    var model;

    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 

    // row or column header
    if (this.m_rowHeader != null)
    {
        if (this.m_models == null)
        {
            return null;
        }

        model = this.m_models[index - this.m_start];
        return model.get(this.m_rowHeader);
    }
    else
    {
        return this.m_headers[index];
    }
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source can optionally return are:
 *  1) sortDirection - the initial sort direction of the header.  Valid values are "ascending" and "descending".
 *  2) key - the key of the row/column header.
 * @param {number} index the index of the header in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.CollectionHeaderSet.prototype.getMetadata = function(index)
{
    var data, model;

    // row header case
    if (this.m_rowHeader != null)
    {
        if (this.m_models == null)
        {
            return null;
        }

        model = this.m_models[index - this.m_start];        
        return {'key':oj.CollectionDataGridUtils._getModelKey(model)};
    }    
    else
    {
        data = this.getData(index);
        return {'key': data};
    }    
    
};

/**
 * Gets the actual count of the result set.
 *
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.CollectionHeaderSet.prototype.getCount = function()
{
    return Math.max(0, this.m_end - this.m_start);
};

/**
 * Gets the m_start property
 * @export
 */
oj.CollectionHeaderSet.prototype.getStart = function()
{
    return this.m_start;
};

/**
 * Gets the m_end property
 * @export
 */
oj.CollectionHeaderSet.prototype.getEnd = function()
{
    return this.m_end;
};

/**
 * Gets the m_headers property
 * @export
 */
oj.CollectionHeaderSet.prototype.getHeaders = function()
{
    return this.m_headers;
};

/**
 * Gets the m_rowHeader property
 * @export
 */
oj.CollectionHeaderSet.prototype.getRowHeader = function()
{
    return this.m_rowHeader;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * An OJ Collection based implementation of the DataGridDataSource.
 * @param {Object} collection the oj collection to adapter the DataGridDataSource
 * @param {Object=} options optional settings on this oj collection data source
 * @param {string=} options.rowHeader the key of the attribute designated as the row header
 * @param {Array.<string>=} options.columns explicitly specifies columns to display and in 
 *        what order.  These columns must be a subset of attributes from Model. * @constructor
 * @export
 * @constructor
 * @extends oj.DataGridDataSource
 */
oj.CollectionDataGridDataSource = function(collection, options)
{
    this.collection = collection;
    if (options != null)
    {
        this.rowHeader = options['rowHeader'];
        this.columns = options['columns'];
    }
    this._startIndex = 0;
    this._pageSize = -1;
    oj.CollectionDataGridDataSource.superclass.constructor.call(this);
};

//subclass of DataGridDataSource
oj.Object.createSubclass(oj.CollectionDataGridDataSource, oj.DataGridDataSource, "oj.CollectionDataGridDataSource");

/**
 * Initial the OJ collection based data source.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.Init = function()
{
    // call super
    oj.CollectionDataGridDataSource.superclass.Init.call(this);

    this.pendingHeaderCallback = {};

    if (!this._isRemote())
    {
        // extract column info for local collection
        if (this.columns == null && this.collection.length > 0)
        {
            this.columns = this.collection.first().keys();
            if (this.columns.indexOf(this.rowHeader) != -1)
            {
                this.columns.splice(this.columns.indexOf(this.rowHeader),1);
            }
        }
        else
        {
            //local empty collection case
            this.columns = [];
        }
    }
 
    this._registerEventListeners();
};

/**
 * Register event handlers on the underlying OJ collection.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._registerEventListeners = function()
{
    this.collection.on("add", this._handleModelAdded.bind(this));
    this.collection.on("remove", this._handleModelDeleted.bind(this));
    this.collection.on("change", this._handleModelChanged.bind(this));
    this.collection.on("refresh", this._handleCollectionRefresh.bind(this));
};

/**
 * Whether this collection is associated with a remote rest services
 * @private
 */
oj.CollectionDataGridDataSource.prototype._isRemote = function()
{
    // if this is a url specified in the option
    return (this.collection['url'] != null || this.collection['customURL'] != null);
};

/**
 * Determines if data is locally available.
 * @return {boolean} true if data is locally available, false otherwise.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._isDataAvailable = function()
{
    if (this._isRemote())
    {
        return (this.data != null);
    }
    // for local collection, always return true;
    return true;
};

/**
 * Determines if header data is locally available.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {boolean} true if data is locally available, false otherwise.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._isHeaderAvailable = function(axis)
{
    if (this._isRemote())
    {
        if (axis === "column")
        {
            return (this.columns != null);
        }
        else if (axis === "row")
        {
            // only if row header is specified
            if (this.rowHeader != null)
            {
                return (this.data != null);
            }
        }
    }
    // for local collection, always return true;
    return true;
};

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown. In the case of paging returns the total number of rows/colums on the page.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCount = function(axis)
{
    // not done fetching yet, provide an estimate count
    if (!this._isHeaderAvailable(axis))
    {
        this.precision = "estimate";
        return -1;
    }

    this.precision = "exact";
    if (axis == "row")
    {
        return this.size();
    }
    if (axis == "column")
    {
        return this.columns.length;
    }

    // should not get here
    return 0;
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "actual" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "actual".
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCountPrecision = function(axis)
{
    // if precision has not been determine, invoke getCount
    if (this.precision == null)
    {
        this.getCount(axis);
    }
    return this.precision;
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    var axis, callback;

    axis = headerRange.axis;
    if (this._isHeaderAvailable(axis))
    {
        // headers are locally available
        this._handleHeaderFetchSuccess(headerRange, callbacks, callbackObjects);
    }
    else
    {
        // still fetching, just store the callback info
        if (callbacks != null)
        {
            callback = {};
            callback.headerRange = headerRange;
            callback.callbacks = callbacks;
            callback.callbackObjects = callbackObjects;
            this.pendingHeaderCallback[axis] = callback;
        }
    }
};

/**
 * Handle success fetchHeaders request
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @param {Object=} actualRange the count and start returned from the server
 * @param {number} actualRange.start the start index of the data the server returned
 * @param {number} actualRange.count the size of the range the server returned
 */
oj.CollectionDataGridDataSource.prototype._handleHeaderFetchSuccess = function(headerRange, callbacks, callbackObjects, actualRange)
{
    var axis, start, count, end, headerSet;

    axis = headerRange.axis;
    start = headerRange.start;
    count = headerRange.count;	                

    oj.Assert.assert(axis === 'row' || axis === 'column');    
    oj.Assert.assert(count > 0);
	      
    if (axis === "column")
    {  
        // column headers, this.columns should be populated by now
        if (this.columns != null)
        {
            end = Math.min(this.columns.length, start+count);
            headerSet = new oj.CollectionHeaderSet(start, end, this.columns);
        }
        else
        {
            // no row header, return empty result set
            headerSet = new oj.ArrayHeaderSet(start, start, axis, null);
        }
    }
    else if (axis === "row")
    {
        // row headers, return non-empty header set if row header is specified
        if (this.rowHeader != null)
        {
            //need the actual rows that the server returned to create the header set
            if (actualRange != null)
            {
                count = actualRange.count;	                
            }
            end = Math.min(this.size(), start+count);
            if (this._pageSize > 0)
            {
                end = Math.min(end, this.totalSize() - this._startIndex);
            }

            headerSet = new oj.CollectionHeaderSet(start, end, this.columns, this.rowHeader);     
            // resolve any promises before invoking callbacks
            this._resolveModels(start, end, headerSet, headerRange, callbacks, callbackObjects);

            // resolveModels will invoke callbacks
            return;
        }
        else
        {
            // no row header, return empty result set
            headerSet = new oj.ArrayHeaderSet(start, start, axis, null);
        }
    }

    // invoke callback
    if (callbacks != null && callbacks['success'])
    {
        callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
    }
};

/**
 * Helper method to extract range information from cellRanges
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @return {Object} an object containing rowStart, rowCount, colStart, colCount
 * @private
 */
oj.CollectionDataGridDataSource.prototype._getRanges = function(cellRanges)
{
    var i, cellRange, rowStart, rowCount, colStart, colCount;

    // extract the start and end row/column info from cellRanges (there should only be two, one for each axis)
    for (i=0; i<cellRanges.length; i+=1)
    {
        cellRange = cellRanges[i];   
        oj.Assert.assert(cellRange['axis'] === 'row' || cellRange['axis'] === 'column');
        oj.Assert.assert(cellRange['count'] > 0);
        if (cellRange['axis'] === "row")
        {
            rowStart = cellRange['start'];
            rowCount = cellRange['count'];
        }
        else if (cellRange['axis'] === "column")
        {
            colStart = cellRange['start'];
            colCount = cellRange['count'];
        }
    }			

    // return object containing the ranges
    return {'rowStart': rowStart, 'rowCount': rowCount, 'colStart': colStart, 'colCount': colCount};
};

/**
 * Handle success fetchCells request
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @param {Object=} actualRange the count and start returned from the server
 * @param {number} actualRange.start the start index of the data the server returned
 * @param {number} actualRange.count the size of the range the server returned        
 * @private
 */
oj.CollectionDataGridDataSource.prototype._handleCellFetchSuccess = function(cellRanges, callbacks, callbackObjects, actualRange)
{
    var ranges, rowStart, rowEnd, colStart, colEnd, cellSet;

    // extract the start and end row/column info from cellRanges (there should only be two, one for each axis)
    ranges = this._getRanges(cellRanges);
    rowStart = ranges['rowStart'];
    //use the actual rows returned by the server
    if (actualRange != null)
    {
        rowEnd = Math.min(this.size(), rowStart + actualRange['count']);
    }
    else
    {
        rowEnd = Math.min(this.size(), rowStart + ranges['rowCount']);        
    }
    colStart = ranges['colStart'];
    colEnd = Math.min(this.columns.length, colStart + ranges['colCount']);       

    if (this._pageSize > 0)
    {
        rowEnd = Math.min(rowEnd, this.totalSize() - this._startIndex);    
    }

    // resolves models at row range
    cellSet = new oj.CollectionCellSet(rowStart, rowEnd, colStart, colEnd, this.columns);
    this._resolveModels(rowStart, rowEnd, cellSet, cellRanges, callbacks, callbackObjects);
};

/**
 * Resolves all the promises from Collection before invoking callbacks
 * @param {number} rowStart the start row index in the cell set
 * @param {number} rowEnd the end row index in the cell set
 * @param {Object} set the result HeaderSet or CellSet that is return to callbacks when models are resolved
 * @param {Array.<Object>|Object} ranges Information about the header/cell range.  
 * @param {function(Object)} callbacks.success the callback to invoke when fetch headers/cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch headers/cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._resolveModels = function(rowStart, rowEnd, set, ranges, callbacks, callbackObjects)
{
    var promises, i;

    promises = [];
    for (i = rowStart; i < rowEnd; i++) 
    {
        promises.push(this.collection.at(i+this._startIndex, {'deferred':true}));
    }
    
    // resolves all promises
    Promise.all(promises).then(function(models) 
    {
        // all promises resolved, invoke callback with cell/header set
        set.setModels(models);
        callbacks['success'].call(callbackObjects['success'], set, ranges);
    });
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
    var rowEnd, colEnd;
    rowEnd = 0;
    colEnd = 0;

    // checks if data is locally available
    if (this._isDataAvailable())
    {
        this._handleCellFetchSuccess(cellRanges, callbacks, callbackObjects);
    }
    else
    {
        // still fetching, just store the callback info
        if (callbacks != null)
        {
            this.pendingCellCallback = {};
            this.pendingCellCallback.cellRanges = cellRanges;
            this.pendingCellCallback.callbacks = callbacks;
            this.pendingCellCallback.callbackObjects = callbackObjects;
        }
        
        // kick start a setRangeLocal call on the collection
        this._fetchCells(cellRanges);
    }
};

/**
 * Processing pending header callbacks.
 * @param {string} axis the axis to check for pending header callbacks.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._processPendingHeaderCallbacks = function(axis)
{
    var pendingCallback, headerRange, callbacks, callbackObjects, actualRange;

    // check if there's callback remaining for the axis
    pendingCallback = this.pendingHeaderCallback[axis];
    if (pendingCallback != null)
    {
        // todo: check whether pending header range matches result
        headerRange = pendingCallback.headerRange;
        callbacks = pendingCallback.callbacks;
        callbackObjects = pendingCallback.callbackObjects;
        if (axis === "row")
        {
            actualRange = pendingCallback.actualRange;
        }
        this._handleHeaderFetchSuccess(headerRange, callbacks, callbackObjects, actualRange);
            
        // clear any pending callback
        this.pendingHeaderCallback[axis] = null;
    } 
};

/**
 * Processing pending cell callbacks.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._processPendingCellCallbacks = function()
{
    var cellRanges, callbacks, callbackObjects, actualRange;

    cellRanges = this.pendingCellCallback.cellRanges;
    callbacks = this.pendingCellCallback.callbacks;
    callbackObjects = this.pendingCellCallback.callbackObjects;
    actualRange = this.pendingCellCallback.actualRange;
    // handles success cell fetch
    this._handleCellFetchSuccess(cellRanges, callbacks, callbackObjects, actualRange);
};

/**
 * Internal method to handle fetching of cells for virtualized collection.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @private
 */
oj.CollectionDataGridDataSource.prototype._fetchCells = function(cellRanges)
{
    var ranges, rowStart, rowCount;

    ranges = this._getRanges(cellRanges);
    rowStart = ranges['rowStart'];
    if (this._pageSize > 0)
    {
        rowStart += this._startIndex;
    }
    rowCount = ranges['rowCount'];

    // set the range local for the requested range
    this.collection.setRangeLocal(rowStart, rowCount).then(function (actual)
    {
        var first = this.collection.at(rowStart, {'deferred':true});
        
        this._setActualCallbackRanges(actual.start, actual.count);
        
        // check if we need to poach columns from row
        if (first != null && this.columns === undefined)
        {
            first.then(function(model)
            {
                this._setupColumns(model);
                // now we can complete the fetch
                this._fetchCellsComplete();
            }.bind(this));

            // process must be done after columns are discovered
            return;
        }
        else
        {
            this._fetchCellsComplete();
        }       
    }.bind(this));
};

/**
 * Finish fetch cells operation
 * @private
 */
oj.CollectionDataGridDataSource.prototype._fetchCellsComplete = function()
{
    // check outstanding header calls
    if (this.pendingHeaderCallback != null)
    {
        this._processPendingHeaderCallbacks('column');    
        this._processPendingHeaderCallbacks('row');
    }        

    // finally process outstanding cell calls
    if (this.pendingCellCallback != null)
    {          
        this._processPendingCellCallbacks();
    }        
		
    //communicates with paging control to indicate fetch end
    if (this._pageSize > 0)
    {
        oj.DataGridDataSource.superclass.handleEvent.call(this, 'sync', true);    
    }
};

/**
 * Takes the actual result start and count from the server and adds it to the pending callbcak objects
 * as the attribute actualRange
 * @param {number} start the start index from the server
 * @param {number} count the count of records from the server
 * @private
 */
oj.CollectionDataGridDataSource.prototype._setActualCallbackRanges = function(start, count)
{
    var actualRange = {'start':start, 'count':count};
    
    if (this.pendingHeaderCallback['row'] != null)
    {
        this.pendingHeaderCallback['row'].actualRange = actualRange; 
    }
    
    if (this.pendingCellCallback != null)
    {
        this.pendingCellCallback.actualRange = actualRange;
    }
};

oj.CollectionDataGridDataSource.prototype._setupColumns = function(model) 
{
    this.columns = model.keys();
    if (this.columns.indexOf(this.rowHeader) != -1)
    {
        this.columns.splice(this.columns.indexOf(this.rowHeader),1);
    }
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object} a Promise object which upon resolution will pass in an object containing the keys for each axis
 * @export
 */
oj.CollectionDataGridDataSource.prototype.keys = function(indexes)
{
    var rowIndex, columnIndex, rowKey, columnKey, atPromise, self;
    rowIndex = indexes['row'] + this._startIndex;
    columnIndex = indexes['column'];
    self = this;

    return oj.Object.__getPromise(function(resolve, reject) {
        atPromise = self.collection.at(rowIndex, {deferred: true});
        //.at() will return null if index known to be OOB
        if (atPromise != null)
        {
            atPromise.then(function(rowModel) {
                rowKey = oj.CollectionDataGridUtils._getModelKey(rowModel);
                if (self.columns == null)
                {
                    self._setupColumns(rowModel);
                }
                columnKey = self.columns[columnIndex];
                resolve({"row": rowKey == null ? null : rowKey, "column": columnKey == null ? null : columnKey});
            }.bind(self));
        }
        else
        {
            resolve({"row": null , "column": null});
        }
    });
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object} a Promise object which upon resolution will pass in an object containing the indexes for each axis
 * @export
 */
oj.CollectionDataGridDataSource.prototype.indexes = function(keys)
{
    var rowKey, columnKey, columnIndex, self;
    rowKey = keys['row']; 
    columnKey = keys['column'];
    self = this;
    
    return oj.Object.__getPromise(function(resolve, reject) 
    {
        self.collection.indexOf(rowKey, {deferred:true}).then(function(rowIndex)
        {
            if (rowIndex != -1)
            {
                rowIndex -= this._startIndex;
            }
            if (self.columns == null)
            {
                self.collection.first(1, {'deferred':true}).then(function(model)
                {
                    self._setupColumns(model);
                    columnIndex = self.columns.indexOf(columnKey);            
                    resolve({"row": rowIndex, "column": columnIndex});                    
                }.bind(self));
            }
            else
            {
                columnIndex = self.columns.indexOf(columnKey);
                resolve({"row": rowIndex, "column": columnIndex});
            }            
        }.bind(self));
    });
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For sort, the valid return values are: "full", "none".  Returns null if the
 *         feature is not recognized.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCapability = function(feature)
{
    if (feature === 'sort')
    {
        // OJ collection based data source supports column sorting only
        return 'column';
    }
    else if (feature === 'move')
    {
        // OJ collection based data source supports row moving only
        return 'row';        
    }
    return null;
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    var comparator, direction = criteria['direction'], key = criteria['key'], axis = criteria['axis'];

    // make sure callbackObjects is not null
    if (callbackObjects == null)
    {
        callbackObjects = {};
    }

    if (axis === "column") {
        //check to see if collection is virtual, if so set the comparator and direction
        if (this.collection.fetchSize > -1 && this.collection.hasMore)
        {
            this.collection['comparator'] = key;
            if (direction === 'ascending') 
            {
                this.collection['sortDirection'] = 1;
            }
            else
            {
                this.collection['sortDirection'] = -1;                
            }
        }
        else
        {
            //if the collection is local supply a comparator to allow date sorting
            if (direction === 'ascending') {
                comparator = function(a, b) {
                    var as, bs;
                    //Get the values from the model objects
                    a = a.get(key);
                    b = b.get(key);
                    //Strings of numbers return false, so we can compare strings of numebers with numbers                
                    as = isNaN(a);
                    bs = isNaN(b);
                    //If they dates, turn them into sortable strings         
                    if (a instanceof Date) {
                        a = a.toISOString();
                        as = true;
                    }
                    if (b instanceof Date) {
                        b = b.toISOString();
                        bs = true;
                    }
                    //both are string
                    if (as && bs)
                    {
                        return a < b ? -1 : a === b ? 0 : 1;
                    }
                    //only a is a string
                    if (as)
                    {
                        return 1;
                    }
                    //only b is a string
                    if (bs)
                    {
                        return -1;
                    }
                    //both are numbers
                    return a - b;
                };
            }
            if (direction === 'descending') {
                comparator = function(a, b) {
                    var as, bs;
                    a = a.get(key);
                    b = b.get(key);
                    as = isNaN(a);
                    bs = isNaN(b); 
                    if (a instanceof Date) {
                        a = a.toISOString();
                    }
                    if (b instanceof Date) {
                        b = b.toISOString();
                    }
                    if (as && bs)
                    {
                        return a > b ? -1 : a === b ? 0 : 1;
                    }
                    if (as)
                    {
                        return -1;
                    }
                    if (bs)
                    {
                        return 1;
                    }
                    return b - a;
                };
            }                
            this.collection['comparator'] = comparator;                
        }

        this.collection.sort();

        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(callbackObjects['success']);
        }
    }
    else
    { 
        if (callbacks != null && callbacks['error'] != null)
        {
            callbacks['error'].call(callbackObjects['error'], "Axis value not supported");
        }
    }
};

/**
 * Move a model to a new index in the collection, if atKey is null adds to the end
 * @param {Object} moveKey the key of the model that should be moved
 * @param {Object} atKey the key of the model that the moved model should be inserted before or after
 * @param {string} position The position of the moved row relative to the reference row.  
 *        Valid values are: "before", "after" 
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.move = function(moveKey, atKey, position, callbacks, callbackObjects)
{
    var indexPromise;
    this.collection.get(moveKey, {deferred: true}).then(
        function(moveModel) {
            if (atKey == null)
            {
                this.collection.remove(moveModel);
                this.collection.add(moveModel);
            }
            else
            {
                if (moveKey === atKey)
                {
                    indexPromise = this.collection.indexOf(atKey, {deferred: true});
                    this.collection.remove(moveModel);
                }
                else
                {
                    this.collection.remove(moveModel);
                    indexPromise = this.collection.indexOf(atKey, {deferred: true});
                }

                indexPromise.then(function(newIndex) {
                    this.collection.add(moveModel, {at: newIndex, force:true});
                }.bind(this));
            }
        }.bind(this));
};

//////////////////////////////////// Event listeners /////////////////////////////////////
/**
 * Returns an Object for an event 
 * @param {string} operation the operation done on the model
 * @param {Object|null} rowKey the key for the row axis
 * @param {Object|null} columnKey the key for the column axis
 * @param {number=} rowIndex the index for the row axis
 * @param {number=} columnIndex the index for the column axis
 * @return {Object} an object containing the the source, operation, and keys of the event
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._getModelEvent = function(operation, rowKey, columnKey, rowIndex, columnIndex)
{
    var event = {};
    event['source'] = this;
    event['operation'] = operation;
    event['keys'] = {'row': rowKey, 'column': columnKey};
    event['indexes'] = {'row': rowIndex, 'column': columnIndex};
    return event;
};

/**
 * Handle a model add to the collection
 * @param {Object} model The model being added to the collection 
 * @param {Object} collection The coleection the model was added to 
 * @param {Object} args additional params passed by the event
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleModelAdded = function(model, collection, args)
{
    var event, rowKey;
    this.collection.indexOf(model, {deferred: true}).then(function(index)
    {
        var rowIndex, atPromise;
        rowKey = oj.CollectionDataGridUtils._getModelKey(model);
        rowIndex = index - this._startIndex > 0 ? index - this._startIndex : 0;
        event = this._getModelEvent('insert', rowKey, null, rowIndex, -1);
        this.handleEvent("change", event);

        //remove the model at the end of the page
        if (index < this._pageSize + this._startIndex)
        {
            //at can return null if the index is OOB right now
            atPromise = this.collection.at(this._startIndex + this._pageSize, {deferred: true});
            if (atPromise != null)
            {
                atPromise.then(function(overfillModel) {
                    if (model != null)
                    {
                        this._handleModelDeleted(overfillModel, collection, {'index':this._startIndex + this._pageSize - 1});
                    }
                }.bind(this));
            }
        }
    }.bind(this));    
};

/**
 * Handle a model delete from the collection
 * @param {Object} model The model being deleted from the collection 
 * @param {Object} collection The coleection the model was added to 
 * @param {Object} args additional params passed by the event
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleModelDeleted = function(model, collection, args)
{
    var event, rowKey, rowIndex, atPromise;
    rowIndex = args['index'];
    if (this._pageSize > 0 && rowIndex < this._startIndex)
    {
        if (rowIndex < this._startIndex)
        {
            rowIndex = 0;
        }

        atPromise = this.collection.at(this._startIndex - 1, {deferred: true});
        if (atPromise != null)
        {
            atPromise.then(function(model) {
                if (model != null)
                {
                    rowKey = oj.CollectionDataGridUtils._getModelKey(model);
                    event = this._getModelEvent('delete', rowKey, null, rowIndex, -1);
                    this.handleEvent("change", event);
                }
            }.bind(this));
        }
    }
    else
    {
        if (this._pageSize > 0)
        {
            rowIndex -= this._startIndex;
        }
        rowKey = oj.CollectionDataGridUtils._getModelKey(model);        
        event = this._getModelEvent('delete', rowKey, null, rowIndex, -1);
        this.handleEvent("change", event);    
    }
       
};

/**
 * Handle a model change in the collection
 * @param {Object} model The model being changed in the collection  
 * @param {Object} collection The coleection the model was added to 
 * @param {Object} args additional params passed by the event
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleModelChanged = function(model, collection, args)
{
    var event, rowKey;
	//pass the indexes into the grid on model change
    this.collection.indexOf(model, {deferred: true}).then(function(index) 
    {
        rowKey = oj.CollectionDataGridUtils._getModelKey(model);
        index = index - this._startIndex > 0 ? index - this._startIndex : -1;
        event = this._getModelEvent('update', rowKey, null, index, -1);         
        this.handleEvent("change", event);    
    }.bind(this)); 
};

/**
 * Handle a colelction reset, by passing refresh to the data grid
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleCollectionRefresh = function()
{
    var event = this._getModelEvent('refresh', null, null);
    this.handleEvent("change", event);
};

/**
 * Set or change the number of models in a page
 * @export
 * @param {number} n page size
 */
oj.CollectionDataGridDataSource.prototype.setPageSize = function(n) {
    this._pageSize = n; 
};

/**
 * @export
 * Get the length of the collection. -1 if an initial fetch has not been
 * done yet. Default to the size of the collection. If pageSize is set then
 * limit it.
 * @returns {number} length of the collection
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.size = function() 
{
    if (this._pageSize != null && this._pageSize > 0)
    {
        if (this.collection.size() > this._pageSize)
        {
            return this._pageSize;
        }
    }
    return this.collection.size();
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.totalSize = function() 
{ 
    if (this.collection != null)
    {
        return this.collection['totalResults'];
    }
    return -1;
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.hasMore = function() 
{    
    if (this.collection != null)
    {
        return this.collection.hasMore;
    }
    return false;
};

/**
 * Perform a fetch call from the options specified
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.fetch = function(options) 
{    
    this._startIndex = options != null ? (options['startIndex'] != null ? options['startIndex'] : 0) : 0;    
    this.handleEvent("change", {'operation': 'sync', 'pageSize': this._pageSize});    
};

//////////////////////////////////// Property Getters  /////////////////////////////////////    
/**
 * Gets the collection property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCollection = function()
{
    return this.collection;
};    

/**
 * Gets the columns property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getColumns = function()
{
    return this.columns;
};    

/**
 * Gets the rowHeader property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getRowHeader = function()
{
    return this.rowHeader;
};

/**
 * Gets the _startIndex property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getStartIndex = function()
{
    return this._startIndex;
};

/**
 * Gets the _pageSize property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getPageSize = function()
{
    return this._pageSize;
};

/**
 * Gets the data property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getData = function()
{
    return this.data;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @preserve Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

// jeanne retrieved from https://raw.github.com/jquery/jquery-ui/1-10-stable/ui/jquery.ui.spinner.js on 6/2013, and then modified

/*!
 * JET InputNumber @VERSION
 *
 *
 * Depends:
 *  jquery.ui.widget.js
 */

/**
 * @class
 * @name oj.ojInputNumber
 * @augments oj.editableValue
 * 
 * @classdesc
 * <h3 id="inputNumberOverview-section">
 *   JET InputNumber Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputNumberOverview-section"></a>
 * </h3>
 * <p>Description: The ojInputNumber component enhances a browser input element 
 * into one that holds numbers and it has a spinbox to quickly increment or 
 * decrement the number. The <code class="prettyprint">value</code> option must be a number and must 
 * be within the <code class="prettyprint">min</code> and <code class="prettyprint">max</code> range. 
 * </p>
 * <p>A step mismatch is when
 * the value is not a multiple of <code class="prettyprint">step</code>, 
 * starting at the <code class="prettyprint">min</code> 
 * or 0 if no <code class="prettyprint">min</code> is set.
 * A step mismatch will not be flagged as a validation error by default, but
 * the step up and step down feature will change the value to be a step match
 * if it isn't already.
 * </p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd> or <kbd>Tab</kbd></td>
 *       <td>Submit the value you typed in the input field. If you type in
 *       a value out of range, and press Enter, you will see a validation error.
 *       Step mismatch errors will not cause a validation error.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Increment the number in the input field; alternatively you can click 
 *           on the up arrow icon. If the resulting value is above the
 *           <code class="prettyprint">max</code>, below the <code class="prettyprint">min</code>, 
 *           or results in a step 
 *           mismatch, the value will be adjusted to the closest valid value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Decrement the number in the input field; alternatively you can click
 *           on the down arrow icon. If the resulting value is above the 
 *           <code class="prettyprint">max</code>, below the <code class="prettyprint">min</code>, 
 *           or results in a step
 *           mismatch, the value will be adjusted to the closest valid value.</td>
 *     </tr>
 * </tbody></table>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * <p>
 * The component is accessible; it sets and maintains the appropriate aria- attributes, 
 * like aria-valuenow, aria-valuemax, aria-valuemin and aria-valuetext.
 * </p>
 * <p>
 * It is up to the application developer to associate the label to the input component.
 * For inputNumber, you should put an <code class="prettyprint">id</code> on the input, and then set 
 * the <code class="prettyprint">for</code> attribute on the label to be the input's id.
 * </p>
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio, 
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>, 
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which 
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user 
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio 
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 * <h3 id="label-section">
 *   Label and InputNumber
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a label element with the input
 * by putting an <code class="prettyprint">id</code> on the input, and then setting the 
 * <code class="prettyprint">for</code> attribute on the label to be the input's id.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code class="prettyprint">required</code> and <code class="prettyprint">help</code> options are set. 
 * </p>
 * <h3 id="state-section">
 *   Setting the Value Option
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#state-section"></a>
 * </h3>
 * <p>If the value option is undefined, 
 * then the DOM value property is used, if any; else it is null.</p>
 * <p>The value option (if it is not null or undefined) 
 * is coerced (+ val). e.g., "123a" is coerced to NaN</p>
 * <p>To clear out the value option, you can set it to null.
 * <code class="prettyprint">$(".selector").ojInputNumber("option", "value", null);</code>
 * </p>
 *
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * @desc Creates an ojInputNumber component
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize component using widget API</caption>
 * &lt;input id="spin" type="text"/&gt;<br/>
 * $("#spin").ojInputNumber({'value': 10, 'max':100, 'min':0, 'step':2});
 * $("#spin").ojInputNumber({'option', 'value', 10});
 * @example <caption>Using knockout, value, min, max bind to observables - salary, salaryMax, salaryMin</caption> 
 * &lt;input id="foo" data-bind="ojComponent: 
 *   {component: 'ojInputNumber', value: salary, min:salaryMin, max:salaryMax, step:5}"/&gt;
 * 
 * @constructor
 */
oj.__registerWidget("oj.ojInputNumber", $['oj']['editableValue'],
{
  version: "1.0.0",
  defaultElement: "<input>",
  widgetEventPrefix: "oj",
  options:
  {
    // TODO: revisit
    // It's expensive to create a default converter ahead of time when a page author can set a custom 
    // one for if they do this will be promptly discarded. 
    
    /** 
     * A number converter instance that duck types {@link oj.NumberConverter}. Or an object literal 
     * containing the properties listed below. 
     * <p>
     * When <code class="prettyprint">converter</code> option changes due to programmatic 
     * intervention, the component performs various tasks based on the current state it is in. </br>
     * 
     * <h4>Steps Performed Always</h4>
     * <ul>
     * <li>Any cached converter instance is cleared and new converter created. The converter hint is 
     * pushed to messaging. E.g., notewindow displays the new hint(s).
     * </li>
     * </ul>
     * 
     * <h4>Running Validation</h4>
     * <ul>
     * <li>if component is valid when <code class="prettyprint">converter</code> option changes, the 
     * display value is refreshed.</li>
     * <li>if component is invalid and is showing messages -
     * <code class="prettyprint">messagesShown</code> option is non-empty, when 
     * <code class="prettyprint">converter</code> option changes, then all messages generated by the 
     * component are cleared and full validation run using its current display value. 
     * <ul>
     *   <li>if there are validation errors, then <code class="prettyprint">value</code> 
     *   option is not updated, and the errors pushed to <code class="prettyprint">messagesShown</code>
     *   option. The display value is not refreshed in this case. </li>
     *   <li>if no errors result from the validation, <code class="prettyprint">value</code> 
     *   option is updated; page author can listen to the <code class="prettyprint">optionChange</code> 
     *   event on the <code class="prettyprint">value</code> option to clear custom errors. The 
     *   display value is refreshed with the formatted value provided by converter.</li>
     * </ul>
     * </li>
     * <li>if component is invalid and has deferred messages -  
     * <code class="prettyprint">messagesHidden</code> option is non-empty, when 
     * <code class="prettyprint">converter</code> option changes, then the display value is 
     * refreshed with the formatted value provided by converter.</li>
     * </ul>
     * </p>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>When component messages are cleared in the cases described above, messages created by 
     * the component that are present in both <code class="prettyprint">messagesHidden</code> and 
     * <code class="prettyprint">messagesShown</code> options are cleared.</li>
     * <li><code class="prettyprint">messagesCustom</code> option is not cleared. Page authors can 
     * choose to clear it explicitly when setting the converter option.</li>
     * </ul>
     * </p>
     * 
     * @property {string} type - the converter type registered with the oj.ConverterFactory. 
     * Usually 'number'. See {@link oj.NumberConverterFactory} for details. <br/>
     * E.g., <code class="prettyprint">{converter: {type: 'number'}</code>
     * @property {Object=} options - optional Object literal of options that the converter expects. 
     * See {@link oj.IntlNumberConverter} for options supported by the jet number converter. 
     * E.g., <code class="prettyprint">{converter: {type: 'number', options: {style: 'decimal'}}</code>
     * 
     * @example <caption>Initialize component to use default converter</caption>
     * $(".selector").ojInputNumber({value: 25000});
     * 
     * @example <caption>Initialize the component with a number converter instance:</caption>
     * // Initialize converter instance using currency options
     * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
     * var numberConverterFactory = oj.Validation.converterFactory("number");
     * var salaryConverter = numberConverterFactory.createConverter(options);<br/>
     * // set converter instance using converter option
     * $(".selector").ojInputNumber({ 
     *   value: 25000,
     *   converter: salaryConverter
     * });
     * 
     * @example <caption>Initialize the component with converter object literal:</caption>
     * $(".selector").ojInputNumber({
     *   value: 25000,
     *   converter: {
     *     type: 'number', 
     *     options : {
     *       style: 'currency', 
     *       currency: 'USD', 
     *       maximumFractionDigits: 0
     *     }
     *   }
     * });
     * 
     * @example <caption>Change the converter option:</caption>
     * // new converter instance 
     * var options = {style: 'currency', currency: 'USD', 'currencyDisplay': 'name', maximumFractionDigits: 2};
     * var numberConverterFactory = oj.Validation.converterFactory("number");
     * var salaryConverter = numberConverterFactory.createConverter(options);<br/>
     * // set converter instance using converter option
     * $(".selector").ojInputNumber("option", "converter", salaryConverter);
     * 
     * 
     * @default <code class="prettyprint">oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER).createConverter()</code>. 
     * When initialized with no options, the default options for the current locale are assumed.
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof oj.ojInputNumber
     * @type {Object|undefined}
     */    
    converter: oj.Validation.converterFactory(
            oj.ConverterFactory.CONVERTER_TYPE_NUMBER).createConverter(),

    /** 
     * The maximum allowed value. This number is used in the range validator; if the 
     * <code class="prettyprint">value</code> is greater than the <code class="prettyprint">max</code>,
     * then the range validator flags an error to the user. The up arrow
     *  is disabled when the maximum value is reached. 
     *  <p>
     * The element's <code class="prettyprint">max</code> attribute is used if it 
     * exists and the option is not explicitly set.
     * <p>
     *  <code class="prettyprint">Max</code> must be a
     *  <code class="prettyprint">number</code> or <code class="prettyprint">null</code>; 
     *  <code class="prettyprint">null</code> indicates no maximum. If not null, 
     *  the <code class="prettyprint">max</code> option value will be coerced (+). 
     *  If the coerced value is <code class="prettyprint">NaN</code>, 
     *  an <code class="prettyprint">Error</code> is thrown.
     * <p>
     * The <code class="prettyprint">max</code> must not be less than the 
     * <code class="prettyprint">min</code>, else an Error is thrown during initialization.
     * @expose 
     * @memberof oj.ojInputNumber
     * @instance
     * @type {?number|undefined}
     * @default <code class="prettyprint">null</code>
     * @example <caption>Initialize the inputNumber with the 
     * <code class="prettyprint">max</code> option specified:</caption>
     * $( ".selector" ).ojInputNumber( { "max": 100 } );
     * @example <caption>Change the 
     * <code class="prettyprint">max</code> option to a float:</caption>
     * $( ".selector" ).ojInputNumber("option", "max", 100.5);
     * @example <caption>To remove the maximum range restriction from inputNumber:</caption>
     * $( ".selector" ).ojInputNumber( { "max": null } );
     * @example <caption>Set the <code class="prettyprint">max</code> to a non-number 
     * which will throw an Error:</caption>
     * $( ".selector" ).ojInputNumber( { "max": "123abc" } );
     * $( ".selector" ).ojInputNumber( { "max": "abc123" } );
     * @example <caption>Set the <code class="prettyprint">max</code> to a number inside 
     * of quotes; this is valid and will be coerced to a number,
     * -100 in this example:</caption>
     * $( ".selector" ).ojInputNumber( { "max": "-100" } );
     */
    max: undefined,
    
    /** 
     * The minimum allowed value. This number is used in the range validator; if the 
     * <code class="prettyprint">value</code> is less than the <code class="prettyprint">min</code>,
     * then the range validator flags an error to the user. The down arrow
     *  is disabled when the minimum value is reached. 
     *  <p>
     * The element's <code class="prettyprint">min</code> attribute is used if it 
     * exists and the option is not explicitly set.
     * <p>
     *  <code class="prettyprint">Min</code> must be a
     *  <code class="prettyprint">number</code> or <code class="prettyprint">null</code>; 
     *  <code class="prettyprint">null</code> indicates no minimum. If not null, 
     *  the <code class="prettyprint">min</code> option value will be coerced (+). 
     *  If the coerced value is <code class="prettyprint">NaN</code>, 
     *  an <code class="prettyprint">Error</code> is thrown.
     * <p>
     * The <code class="prettyprint">max</code> must not be less than the 
     * <code class="prettyprint">min</code>, else an Error is thrown during initialization.
     * @expose 
     * @memberof oj.ojInputNumber
     * @instance
     * @type {?number|undefined}
     * @default <code class="prettyprint">null</code>
     * @example <caption>Initialize the inputNumber with the 
     * <code class="prettyprint">min</code> option specified:</caption>
     * $( ".selector" ).ojInputNumber( { "min": -100 } );
     * @example <caption>Change the 
     * <code class="prettyprint">min</code> option to a float:</caption>
     * $( ".selector" ).ojInputNumber("option", "min", 1.5);
     * @example <caption>To remove the minimum range restriction from inputNumber:</caption>
     * $( ".selector" ).ojInputNumber( { "min": null } );
     * @example <caption>Set the <code class="prettyprint">min</code> to a non-number 
     * which will throw an Error:</caption>
     * $( ".selector" ).ojInputNumber( { "min": "123abc" } );
     * $( ".selector" ).ojInputNumber( { "min": "abc123" } );
     * @example <caption>Set the <code class="prettyprint">min</code> to a number inside 
     * of quotes; this is valid and will be coerced to a number,
     * -100 in this example:</caption>
     * $( ".selector" ).ojInputNumber( { "min": "-100" } );
     */
    min: undefined,
  
    /**
     * The placeholder text to set on the element. Though it is possible to set placeholder 
     * attribute on the element itself, the component will only read the value when the component
     * is created. Subsequent changes to the element's placeholder attribute will not be picked up 
     * and page authors should update the option directly.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> option:</caption>
     * &lt;input id="number" data-bind="ojComponent: {
     *   component: 'ojInputNumber', placeholder: 'Please enter a number'}" /&gt;
     * 
     * @example <caption>Initialize <code class="prettyprint">placeholder</code> option from html attribute:</caption>
     * &lt;input id="number" data-bind="ojComponent: {component: 'ojInputNumber'}" 
     *   placeholder="Please enter a number" /&gt;
     * 
     * @default when the option is not set, the element's placeholder attribute is used if it exists. 
     * If the attribute is not set then the default can be a converter hint. See displayOptions for 
     * details.
     * 
     * @expose 
     * @instance
     * @memberof oj.ojInputNumber
     * @type {string|null|undefined}
     */
    placeholder: undefined,
    
    /** 
     * Whether the component is readOnly. The element's <code class="prettyprint">readOnly</code>
     *  property is used as its initial 
     * value if it exists, when the option is not explicitly set. When neither is set, 
     * <code class="prettyprint">readOnly </code>
     * defaults to false.
     * 
     * @example <caption>Initialize component with <code class="prettyprint">readOnly</code> option:</caption>
     * $(".selector").ojInputNumber({"readOnly": true});
     * 
     * @expose 
     * @type {?boolean|undefined}
     * @default <code class="prettyprint">false</code>
     * @instance
     * @memberof oj.ojInputNumber
     */
    readOnly: undefined,
    
    /** 
     * The size of the step to take when spinning via buttons or via the 
     * <code class="prettyprint">stepUp()</code>/<code class="prettyprint">stepDown()</code> methods. 
     * The element's <code class="prettyprint">step</code> attribute is used if it 
     * exists and the option is not explicitly set. Step must be a 
     * <code class="prettyprint">number</code>
     * greater than 0, otherwise an exception is thrown. It defaults to 
     * <code class="prettyprint">1</code> if nothing, or <code class="prettyprint">null</code>, is specified.
     *  If not null, the <code class="prettyprint">step</code> option value will be 
     *  coerced (+). 
     *  If the coerced value is <code class="prettyprint">NaN</code>, 
     *  an <code class="prettyprint">Error</code> is thrown.
     * <p>
     * The step up and step down feature will change the value to be a step match if it isn't already.
     * A step match is when the value is a multiple of step, starting at the 
     * <code class="prettyprint">min</code> or <code class="prettyprint">0</code> if no 
     * <code class="prettyprint">min</code> is set.
     * A value can be a step mismatch; if the <code class="prettyprint">value</code> is set 
     * to be a step mismatch, it will not be flagged as a validation error.
     * @expose 
     * @instance
     * @type {?number|undefined}
     * @default <code class="prettyprint">1</code>
     * @memberof oj.ojInputNumber 
     * @example <caption>Initialize the inputNumber with the 
     * <code class="prettyprint">step</code> option specified:</caption>
     * $( ".selector" ).ojInputNumber( { "step": 10 } );
     * @example <caption>Change the 
     * <code class="prettyprint">step</code> option to a float:</caption>
     * $( ".selector" ).ojInputNumber("option", "step", 0.5);
     * @example <caption>Set the <code class="prettyprint">step</code> to a non-number 
     * which will throw an Error:</caption>
     * $( ".selector" ).ojInputNumber( { "step": "123abc" } );
     * $( ".selector" ).ojInputNumber( { "step": "abc123" } );
     * @example <caption>Set the <code class="prettyprint">step</code> to a number inside 
     * of quotes; this is valid and will be coerced to a number,
     * 10 in this example:</caption>
     * $( ".selector" ).ojInputNumber( { "step": "10" } );
     * */
    step: undefined,
    /** 
     * The value of the component. 
     * 
     * <p>
     * When <code class="prettyprint">value</code> option changes due to programmatic 
     * intervention, the component always clears all messages and runs deferred validation, and 
     * always refreshes UI display value. If the value cannot be coerced to a number, an
     * Error is thrown.</br>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>All messages are cleared. This includes  
     * <code class="prettyprint">messagesHidden</code>, <code class="prettyprint">messagesShown</code>
     *  and <code class="prettyprint">messagesCustom</code> options.</li>
     * </ul>
     * 
     *  
     * <h4>Running Validation</h4>
     * <ul>
     * <li>component always runs deferred validation; if there is a validation error the 
     * <code class="prettyprint">messagesHidden</code> option is updated.</li>
     * </ul>
     * </p>
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojInputNumber({'value': 55});<br/>
     * @example <caption>Get or set <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns 55
     * $(".selector").ojInputNumber("option", "value");
     * // Setter: sets 20
     * $(".selector").ojInputNumber("option", "value", 20);
     * @example <caption>Set the <code class="prettyprint">value</code> to a non-number 
     * which will throw an Error:</caption>
     * $( ".selector" ).ojInputNumber( { "value": "123abc" } );
     * $( ".selector" ).ojInputNumber( { "value": "abc123" } );
     * @example <caption>Set the <code class="prettyprint">value</code> to a number inside 
     * of quotes; this is valid and will be coerced to a number,
     * 10 in this example:</caption>
     * $( ".selector" ).ojInputNumber( { "value": "10" } );
     * @example <caption>Set the <code class="prettyprint">value</code> to an empty string; 
     * this is valid and value is coerced (+), to 0 in this example:</caption>
     * $( ".selector" ).ojInputNumber( { "value": "" } );
     * @expose 
     * @access public
     * @instance
     * @default <code class="prettyprint">null</code>
     * When the option is not set, the element's dom value is used as its initial value 
     * if it exists.
     * @memberof oj.ojInputNumber
     * @type {Object|undefined|null}
     */
    value: undefined
  },
  // P U B L I C    M E T H O D S
  /**
 * <p>Sub-ID for the inputNumber's Up arrow.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-inputnumber-up
 * @memberof oj.ojInputNumber
 * @instance
 * 
 * @example <caption>Get the node for the Up arrow:</caption>
 * var node = $( ".selector" ).ojInputNumber( "getNodeBySubId", {'subId': 'oj-inputnumber-up'} );
 */
  getNodeBySubId: function(locator)
  {
    var node = this._superApply(arguments), subId;
    if (!node)
    {
      subId = locator['subId'];
      if (subId === "oj-inputnumber-up") {
        node = this.widget().find(".oj-inputnumber-up")[0];
      }
      if (subId === "oj-inputnumber-down") {
        node = this.widget().find(".oj-inputnumber-down")[0];
      }
      if (subId === "oj-inputnumber-input") {
        node = this.widget().find(".oj-inputnumber-input")[0];
      }
    }
    // Non-null locators have to be handled by the component subclasses
    return node || null;
 },
  /**
   * Refreshes the inputNumber component
   * <p>A <code class="prettyprint">refresh()</code> or re-init is required 
   * when an inputNumber is changed in a non-option way, like in the following circumstances:
   * <ul>
   *   <li>Button translations change.</li>
   * </ul>    
   * @expose 
   * @memberof oj.ojInputNumber
   * @instance
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" ).ojInputNumber( "refresh" );
   */
  refresh: function() 
  {
    this._super();
    this._setup();
  },
  /**
   * <p>Decrements the value by the specified number of steps. 
   * Without the parameter, a single step is decremented.</p>
   <p>If the resulting value is above the max, below the min, 
   or results in a step mismatch, the value will be adjusted to the closest valid value.</p>
   * @param {Number} steps - Number of steps to decrement, defaults to 1.
   * @expose
   * @instance
   * @memberof oj.ojInputNumber 
   */
  stepDown: function(steps)
  {
    this._step(steps, false);
  },
   /**
   * <p>Increments the value by the specified number of steps. 
   * Without the parameter, a single step is incremented.</p>
   <p>If the resulting value is above the max, below the min, 
   or results in a step mismatch, the value will be adjusted to the closest valid value.</p>
   * @param {Number} steps - Number of steps to increment, defaults to 1.
   * @expose
   * @instance
   * @memberof oj.ojInputNumber 
   */
  stepUp: function(steps)
  {
    this._step(steps, true);
  },

  /**
   * Returns a jQuery object containing the element visually representing the inputnumber. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof oj.ojInputNumber
   * @instance
   * @return {jQuery} the inputnumber
   */
  widget: function()
  {
    return this.uiInputNumber;
  },
  
  // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

  // *********** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) **********
  
  
  /**
  * Called at component create time primarily to initialize options, often using DOM values. This 
  * method is called before _ComponentCreate is called, so components that override this method 
  * should be aware that the component has not been rendered yet. The element DOM is available and 
  * can be relied on to retrieve any default values. <p> 
  * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors
  * @param {?Object} constructorOptions - options passed into the widget constructor
  * 
  * @memberof oj.ojInputNumber
  * @instance
  * @protected
  */
  _InitOptions: function(originalDefaults, constructorOptions)
  {
    var that = this;

    var props = 
      [{"attribute": "disabled", "defaultOptionValue": false, "validateOption": true},
      {"attribute": "pattern", "defaultOptionValue": ""},
      {"attribute": "placeholder", "defaultOptionValue": ""},
      {"attribute": "value", "defaultOptionValue": null}, // don't coerce here. I do it myself
      {"attribute": "readonly", "option": "readOnly", "defaultOptionValue": false,
        "validateOption": true},
      {"attribute": "required", "defaultOptionValue": false,
        "coerceDomValue": true, "validateOption": true},
      {"attribute": "title", "defaultOptionValue": ""},
      {"attribute": "min", "defaultOptionValue": null},
      {"attribute": "max", "defaultOptionValue": null},
      {"attribute": "step", "defaultOptionValue": 1}];

    this._superApply(arguments);
    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);
    // coerce regardless of where the option value came from - dom/constructor
    this.options['value'] = this._parse("value", this.options['value']);
    if (this.options['step'] != null)
      this.options['step'] = this._parseStep(this.options['step']);
    if (this.options['min'] != null)
      this.options['min'] = this._parse("min", this.options['min']);
    if (this.options['max'] != null)
      this.options['max'] = this._parse("max", this.options['max']);   
    // now make sure min < max, else throw an Error
    if (this.options['min'] != null && this.options['max'] != null)
    {
      if (this.options['max'] < this.options['min'])
      {
        throw new Error("ojInputNumber's max must not be less than min");
      }
    }
    
  },
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @instance
   * @memberof oj.ojInputNumber
   */
  _ComponentCreate: function()
  {
    var node = this.element;
    this._super();

    this._draw();

    this._on(this._events);

    // turning off autocomplete prevents the browser from remembering the
    // value when navigating through history, so we re-enable autocomplete
    // if the page is unloaded before the widget is destroyed. #7790
    this._on(this.window,
            {
              "beforeunload": function()
              {
                node.removeAttr("autocomplete");
              }
            });

    // input type=number does not support the 'pattern' attribute, so
    // neither should ojInputNumber.
    // remove this before EditableValue grabs it and uses it.
    node.removeAttr("pattern");

    this._inputNumberDefaultValidators = {};
  },
  /**
   * This is where we do things right after the component was created.
   * this._super should be called first.
   * 
   * @override
   * @memberof oj.ojInputNumber
   * @instance
   * @protected
   */
  _AfterCreate: function()
  {
    this._super();
    this._setup();

  },
    /**
   * Performs post processing after _SetOption() is called. Different options when changed perform
   * different tasks. See _AfterSetOption[OptionName] method for details.
   * 
   * @param {string} option
   * @param {Object|string=} previous
   * @param {Object=} flags 
   * @protected
   * @memberof! oj.ojInputNumber
   * @instance
   */
  _AfterSetOption : function (option, previous, flags)
  {
    this._superApply(arguments);
    switch (option)
    {
      case "min": 
      case "max":
        this._Refresh(option, this.options[option]);
        break; 
      default:
        break;
    }
    
  },
  
  /**
   * Handles options specific to inputnumber.
   * Note that _setOption does not get called during create in the super class. 
   * It only gets called when the component has already been created.
   * However, we do call _setOption in _draw for certain attributes 
   * (disabled)
   * @override
   * @protected
   * @memberof oj.ojInputNumber
   */
  _setOption: function(key, value, flags)
  {
    var coercedValue;

    if (key === "value" || key === "max" || key === "min")
    {
      coercedValue = this._parse(key, value);
    }
    else if (key === "step")
    {
      coercedValue = this._parseStep(value);    
    }
    else
      coercedValue = value;
    

    // the superclass calls _Refresh. Our _Refresh calls _updateButtons
    // and _refreshAriaMinMaxValue.
    // call _super with the newly coerced 'value' property.
    this._super(key, coercedValue, flags);
    
    if (key === "max" || key === "min")
    {
      // since validators are immutable, they will contain min + max as local values. 
      // Because of this will need to recreate
      this._createRangeValidator();
      this._AfterSetOptionValidators();
    }

    // when a dom element supports disabled, use that, and not aria-disabled.
    // having both is an error. 
    // having aria-disabled on root dom element is ok (if it is added in base class)
    if (key === "disabled")
    {
      // force it to be a boolean. this is what/how ojbutton, EditableValue does.
      this.element.prop("disabled", !!value);
    }
    // when a dom element supports readonly, use that, and not aria-readonly.
    // having both is an error
    if (key === "readOnly")
    {
      this.element.prop("readonly", !!value);
      this._refreshStateTheming("readOnly", this.options.readOnly);
      this._refreshRoleSpinbutton("readOnly", this.options.readOnly);
    }
  },
  /**
   * Override of protected base class method.  
   * Method name needn't be quoted since is in externs.js.
   * @protected
   * @memberof oj.ojInputNumber
   * @instance
   */
  _destroy: function()
  {
    this._off(this.element, "keydown keyup focus blur mousedown mouseup mouseenter mouseleave");
    this.uiInputNumber.replaceWith(this.element);
    clearTimeout(this.timer);
    return this._super();
  },
  /**
   * Used for explicit cases where the component needs to be refreshed 
   * (e.g., when the value option changes or other UI gestures).
   * @override
   * @protected
   * @memberof oj.ojInputNumber
   */
  _Refresh: function(name, value, forceDisplayValueRefresh)
  {
    this._superApply(arguments);
    var valueMinMax = (name === "value" || name === "max" || name === "min");
    if (valueMinMax)
      this._refreshAriaMinMaxValue();
    // needs to get called if value, min, max, or disabled change, but not otherwise.
    // put this condition since EditableValue calls _Refresh for every
    // option change, and we don't want to updateButtons for every single option
    // change.
    if (valueMinMax || name === "disabled")
      this._updateButtons();
  },
  // *********** END WIDGET FACTORY METHODS **********
  /**
   * Whether the a value can be set on the component. 
   * If the component is disabled (or readOnly) then 
   * then setting value on component is a no-op. 
   * 
   * @see #_SetValue
   * @memberof oj.ojInputNumber
   * @instance
   * @protected
   */
  _CanSetValue: function()
  {
    var canSetValue = this._superApply(arguments);

    if (!canSetValue)
      return false;

    var readOnly = this.options['readOnly'] || false;

    if (readOnly)
    {
      return false;
    }

    return true;
  },
  /**
   * Need to override since we allow users to set the converter to null, undefined, and etc and when 
   * they do we use the default converter
   * 
   * @return {Object} a converter instance or null
   * 
   * @memberof oj.ojInputNumber
   * @instance
   * @protected
   * @override
   */
  _GetConverter : function () 
  {
    return this.options['converter'] ? 
        this._superApply(arguments) : 
        $["oj"]["ojInputNumber"]["prototype"]["options"]["converter"];
  },
  /**
   * Sets up the default numberRange validators if there is a min or max.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof oj.ojInputNumber
   */
  _GetImplicitValidators: function()
  {
    var ret = this._superApply(arguments);
    if (this.options['min'] != null || this.options['max'] != null)
    {
      this._createRangeValidator();
    }

    return $.extend(this._inputNumberDefaultValidators, ret);
  },
  /**
   * Returns the default styleclass for the component.
   * 
   * @return {string}
   * @memberof oj.ojInputNumber
   * @override
   * @protected
   */
  _GetDefaultStyleClass: function()
  {
    return "oj-inputnumber";
  },
  _events:
          {
            'keydown': function(event)
            {
              var keyCode = $.ui.keyCode;
              if (event.keyCode === keyCode.ENTER)
              {
                this._blurEnterSetValue(event);
                event.preventDefault();
              }
              else if (this._start() && this._keydown(event))
              {
                event.preventDefault();
              }
            },
            'keyup': function(event) {
              this._stop(event);
            },
            'focus': function()
            {
              this.previous = this.element.val();
            },
            'blur': function(event)
            {
              if (this.cancelBlur)
              {
                delete this.cancelBlur;
                return;
              }
              this._blurEnterSetValue(event);
            },
            "mousedown .oj-inputnumber-button": function(event)
            {
              var previous;

              // We never want the buttons to have focus; whenever the user is
              // interacting with the inputnumber, the focus should be on the input.
              // If the input is focused then this.previous is properly set from
              // when the input first received focus. If the input is not focused
              // then we need to set this.previous based on the value before spinning.
              previous = this.element[0] === this.document[0].activeElement ?
                      this.previous : this.element.val();

              function checkFocus()
              {
                var isActive = this.element[0] === this.document[0].activeElement;
                if (!isActive)
                {
                  this.element.focus();
                  this.previous = previous;
                  // support: IE
                  // IE sets focus asynchronously, so we need to check if focus
                  // moved off of the input because the user clicked on the button.
                  this._delay(function()
                  {
                    this.previous = previous;
                  });
                }
              }

              // ensure focus is on (or stays on) the text field
              event.preventDefault();
              checkFocus.call(this);

              // support: IE
              // IE doesn't prevent moving focus even with event.preventDefault()
              // so we set a flag to know when we should ignore the blur event
              // and check (again) if focus moved off of the input.
              this.cancelBlur = true;
              this._delay(function()
              {
                delete this.cancelBlur;
                checkFocus.call(this);
              });

              this._start();

              this._repeat(null, $(event.currentTarget).hasClass("oj-inputnumber-up") ? 1 : -1, event);
            },
            "mouseup .oj-inputnumber-button": function(event)
            {
              this._stop(event);
            },
            "mouseenter .oj-inputnumber-button": function(event)
            {
              // button will add oj-active if mouse was down while mouseleave and kept down
              if (!$(event.currentTarget).hasClass("oj-active"))
              {
                return;
              }

              this._start();

              this._repeat(null, $(event.currentTarget).hasClass("oj-inputnumber-up") ? 1 : -1, event);
            },
            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .oj-inputnumber-button": function(event)
            {
              this._stop(event);
            }
          },
  // I N T E R N A L   P R I V A T E   C O N S T A N T S    A N D   M E T H O D S 
  // Subclasses should not override or call these methods
  /**
   * @private
   * @const
   */
  _BUNDLE_KEY:
          {
            _TOOLTIP_DECREMENT: 'tooltipDecrement',
            _TOOLTIP_INCREMENT: 'tooltipIncrement'
          },
  /**
   * when below listed options are passed to the component, corresponding CSS will be toggled
   * @private
   * @const
   * @type {Object}
   */
  _OPTION_TO_CSS_MAPPING: {
    "readOnly": "oj-read-only"
  },
    /**
   * _setup is called on create and refresh.
   * @private
   */
  _setup: function() 
  {

    // button bindings. interesting.
    var incrementString =
            this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_INCREMENT);
    var decrementString =
            this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_DECREMENT);
    this.uiInputNumber.find(".oj-inputnumber-up").ojButton({display: 'icons',
      icons: {start: 'oj-component-icon oj-inputnumber-up-icon'},
      label: incrementString});
    this.uiInputNumber.find(".oj-inputnumber-down").ojButton({display: 'icons',
      icons: {start: 'oj-component-icon oj-inputnumber-down-icon'},
      label: decrementString});
    this._refreshAriaMinMaxValue();
    this._updateButtons();
    // update element DOM for readOnly
    if (typeof this.options['readOnly'] === "boolean")
    {
      this.element.prop("readonly", this.options['readOnly']);
    }
    this._refreshStateTheming("readOnly", this.options.readOnly);
    this._refreshRoleSpinbutton("readOnly", this.options.readOnly);
  }, 
  /**
   * @private
   */
  _draw: function()
  {
    var uiInputNumber = this.uiInputNumber = this.element.addClass("oj-inputnumber-input")
            .attr("autocomplete", "off")
            .wrap(this._uiInputNumberHtml()).parent()
            // add buttons
            .append(this._buttonHtml());

    // 
    // TODO: need to save off attributes and reset on destroy generically.
    this.saveType = this.element.prop("type");
    this.element.attr("type", "text");


    // add aria-hidden=true to buttons. As they are not in the keyboard sequence 
    // we decided it makes more sense to just add aria-hidden="true" to them 
    // and rely on the up/down arrow keys
    this.buttons = uiInputNumber.find(".oj-inputnumber-button")
            .attr("tabIndex", "-1").attr("aria-hidden", true);
  },
  /**
   * @private
   */
  _keydown: function(event)
  {
    var options = this.options, keyCode = $.ui.keyCode;

    switch (event.keyCode)
    {
      // keeping the up/down pressed repeats
      // using the up and down arrows will adjust the value so that it is 
      // a multiple of step and it is in min/max, same as if you used the 
      // up and down buttons
      case keyCode.UP:
        this._repeat(null, 1, event);
        return true;
      case keyCode.DOWN:
        this._repeat(null, -1, event);
        return true;
    }

    return false;
  },
  /**
   * @private
   */
  _uiInputNumberHtml: function()
  {
    return "<span class='oj-inputnumber oj-component'></span>";
  },
  /**
   * @private
   */
  _buttonHtml: function()
  {
    return "" + "<a class='oj-inputnumber-button oj-inputnumber-down'></a>" +
            "<a class='oj-inputnumber-button oj-inputnumber-up'></a>";
  },
  /**
   * @private
   */
  _start: function()
  {
    this.spinning = true;
    return true;
  },
  /**
   * @private
   */
  _repeat: function(i, steps, event)
  {
    // repeat spinning as long as the key is down and min/max isn't reached
    i = i || 500;

    clearTimeout(this.timer);
    this.timer = this._delay(function()
    {
      this._repeat(40, steps, event);
    },
            i);

    this._spin(steps * this.options.step, event);
  },
  /**
   * @private
   * @param {Number} step - Number of steps to increment.
   * @param {Object=} event an optional event if this was a result of ui interaction.
   */
  _spin: function(step, event)
  {
    // When the component's 'value' changes, the displayValue is automatically updated.
    // So reading the component's display value should always give you the element's value
    var value = this._getConvertedDisplayValue();
    value = this._adjustValue(value, step);

    this._SetValue(value, event, this._VALIDATION_MODE.VALIDATORS_ONLY);
  },
  /**
   * called from _adjustValue
   * @private
   */
  _precision: function()
  {
    var precision = this._precisionOf(this.options.step);
    if (this.options.min != null)
    {
      precision = Math.max(precision, this._precisionOf(this.options.min));
    }
    return precision;
  },
  /**
   * return the number of digits after the '.'
   * called from _adjustValue->_precision
   * @private
   * @param {Number} num - Number from which to calculate the precision
   */
  _precisionOf: function(num)
  {
    var str = num.toString(), decimal = str.indexOf(".");
    return decimal === -1 ? 0 : str.length - decimal - 1;
  },
  /**
   * adjust the value to be "valid".
   * The logic follows that of HTML-5's input number.
   * http://www.w3.org/TR/html5/forms.html#dom-input-stepup
   * A valid value is one that is a multiple of 
   * step starting at stepBase, where stepBase is min (if present),
   * else initial value (if present) TODO,
   * else (if type == number) 0 
   * If max is not a valid value, stepUp/stepDown will never go to max. It
   * will go to the calculated valid max (one that is the largest value 
   * that is an integral multiple of the step, and that is less than or equal
   * to the maximum.
   * @private
   */
  _adjustValue: function(value, step)
  {
    var newValue;
    var stepBase, aboveMin, options = this.options;
    var precision = this._precision();

    // make sure we're at a valid step when we step up or down.
    // - find out where we are relative to the base (min or 0)
    stepBase = options.min != null ? options.min : 0;

    // From http://www.w3.org/TR/html5/forms.html#dom-input-stepup:
    // If value subtracted from the step base is not an integral multiple 
    // of the step, then set value to the nearest value that, when subtracted
    // from the step base, is an integral multiple of the allowed value step,
    // and that is less than value if the method invoked was stepDown() and
    // more than value if the method invoked was stepUp().

    // is value-stepBase an integral multiple of step?
    aboveMin = value - stepBase;
    var rounded = Math.round(aboveMin / options.step) * options.step;
    rounded = parseFloat(rounded.toFixed(precision));
    var multiple = (rounded === aboveMin);

    if (!multiple)
    {
      if (step < 0)
        aboveMin = Math.ceil(aboveMin / options.step) * options.step;
      else
      {
        aboveMin = Math.floor(aboveMin / options.step) * options.step;
      }

      // rounding is based on 0, so adjust back to our base
      newValue = stepBase + aboveMin + step;
    }
    else
    {
      newValue = value + step;
    }

    // fix precision from bad JS floating point math
    // toFixed returns the newValue with a specific # of digits after the 
    // decimal point (this_precision() looks at max of step/min's # of 
    // digits.
    newValue = parseFloat(newValue.toFixed(precision));

    if (options.min != null && newValue < options.min)
      return options.min;

    if (options.max != null && newValue > options.max)
    {
      var validMax = (Math.floor((options.max - stepBase) / options.step) *
              options.step) + stepBase;
      // fix precision from bad JS floating point math
      validMax = parseFloat(validMax.toFixed(precision));
      return validMax;
    }

    return newValue;
  },
  /**
   * @private
   */
  _stop: function(event)
  {
    if (!this.spinning)
    {
      return;
    }
    clearTimeout(this.timer);
    this.spinning = false;
  },
  /**
   * @private
   */
  _updateButtons: function()
  {
    // When the component's 'value' changes, the displayValue is automatically updated.
    // So reading the component's display value gives you the value you see
    // on the screen. We want to update the up/down buttons to match.
    // We need the parsed version of displayValue, since displayValue could
    // be something like $10.00..
    var value = this._getConvertedDisplayValue();

    var min = this.options.min, max = this.options.max;
    if (!this.uiInputNumber)
      return;
    var downButton = this.uiInputNumber.find(".oj-inputnumber-down").ojButton();
    var upButton = this.uiInputNumber.find(".oj-inputnumber-up").ojButton();

    if (this.options.disabled || value === undefined)
    {
      downButton.ojButton("disable");
      upButton.ojButton("disable");
    }
    else if (max != null && value >= max)
    {
      downButton.ojButton("enable");
      upButton.ojButton("disable");
    }
    else if (min != null && value <= min)
    {
      downButton.ojButton("disable");
      upButton.ojButton("enable");
    }
    else
    {
      downButton.ojButton("enable");
      upButton.ojButton("enable");
    }

  },
  /**
   * @private
   */
  _getConvertedDisplayValue: function()
  {
    var value, displayValue;
    try
    {
      displayValue = this._GetDisplayValue() || 0;
      // if displayValue is not parseable, say it is 'abc', 
      // then _parseValue throws an error. catch it and move on.
      // TODO: Make _parseValue public in EditableValue();
      value = this._parseValue(displayValue);
    }
    catch (e)
    {
      // catch the error, set value to undefined, and continue to update
      // the buttons. both the up/down buttons will be disabled in this case.
      value = undefined;
    }
    return value;
  },
  /**
   * @private
   */
  _blurEnterSetValue: function(event)
  {
    this._stop();
    if (this.previous !== this.element.val())
    {
      this._refreshAriaMinMaxValue();
      this._updateButtons();
      // _SetValue triggers valuechange event
      this._SetValue(this.element.val(), event);
    }
  },
  /**
   * @private
   */
  _createRangeValidator: function()
  {
    var newMin = this.options['min'] != null ? this.options['min'] : undefined;
    var newMax = this.options['max'] != null ? this.options['max'] : undefined;
    
    var reqTrans = this.options['translations'] ? 
      this.options['translations']['numberRange'] || {}: {};

    var hintMin, hintMax, hintInRange;
    var messageDetailRangeOverflow, messageDetailRangeUnderflow;
    var messageSummaryRangeOverflow, messageSummaryRangeUnderflow;

    var hint = reqTrans['hint'] || {};
    var messageDetail = reqTrans['messageDetail'] || {};
    var messageSummary = reqTrans['messageSummary'] || {};

    if (hint !== null)
    {
      hintMin = hint['min'] || null;
      hintMax = hint['max'] || null;
      hintInRange = hint['inRange'] || null;
    }
    if (messageDetail !== null)
    {
      messageDetailRangeOverflow = messageDetail['rangeOverflow'] || null;
      messageDetailRangeUnderflow = messageDetail['rangeUnderflow'] || null;
    }
    if (messageSummary !== null)
    {
      messageSummaryRangeOverflow = messageSummary['rangeOverflow'] || null;
      messageSummaryRangeUnderflow = messageSummary['rangeUnderflow'] || null;
    }

    var numberRangeOptions = {
      'min': newMin,
      'max': newMax,
      'hint' : {'min':hintMin || null,
                'max':hintMax || null,
                'inRange': hintInRange || null
               },
      'messageDetail' : {
                'rangeOverflow':messageDetailRangeOverflow || null, 
                'rangeUnderflow': messageDetailRangeUnderflow || null},
      'messageSummary' : {
                'rangeOverflow':messageSummaryRangeOverflow || null, 
                'rangeUnderflow': messageSummaryRangeUnderflow || null},
      'converter': this._GetConverter()};
     
    this._inputNumberDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE] =
            oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE)
            .createValidator(numberRangeOptions);
  },

  // The user can clear out min/max by setting the option to null, so we
  // do not coerce null.
  /**
   * @param {string} option name of the option. this will show up in the error if thrown
   * @param val value to parse
   * @throws {Error} if option value is invalid
   * @private
   */
  _parse: function(option, val)
  {
    var returnValue;
    if (val !== null)
      returnValue = +val;
    else
      returnValue = val;

    // isNaN(null) returns false, which is what we want
    if (isNaN(returnValue))
      throw new Error("ojInputNumber's " + option + " option is not a number");
   
    return returnValue;
  },
  /**
   * parse the step's value
   * We are following the behavior of HTML-5 the best we can. According
   * to the spec, it says step must be a number greater than 0. 
   * Chrome defaults it to 1 if it is not.
   * @throws {Error} if option value is invalid 
   * @private
   */
  _parseStep: function(val)
  {
    var defaultStep = 1, parsedStep;
    if (val === null)
      return defaultStep;
    parsedStep = this._parse("step", val);
    if (parsedStep <= 0)
    {
      // throw an exception
      throw new Error("Invalid step for ojInputNumber; step must be > 0");
    }
    // DEFAULT to 1 if it isn't > 0
    if (parsedStep === null || parsedStep <= 0)
      parsedStep = defaultStep;
    return parsedStep;
  },
  /**
   * Toggles css selector on the widget. E.g., when readOnly option changes, 
   * the oj-read-only selector needs to be toggled.
   * @param {string} option
   * @param {Object|string|boolean} value 
   * @private
   */
  _refreshStateTheming: function(option, value)
  {
    if (Object.keys(this._OPTION_TO_CSS_MAPPING).indexOf(option) != -1)
    {
      // value is a boolean
      this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], !!value);
    }
  },
  /**
   * When readOnly option changes, 
   * the role spinbutton needs to be toggled We don't have role spinbutton
   * on readOnly inputNumber.
   * @param {string} option
   * @param {Object|string|boolean} value 
   * @private
   */
  _refreshRoleSpinbutton: function(option, value)
  {
    value = !!value;
    // if readonly is true, remove role spinbutton
    // if readonly is false, add role spinbutton
    if (value)
      this.widget().removeAttr("role");
    else
      this.widget().attr("role", "spinbutton");
  },
  /* updates the aria-value information */
  _refreshAriaMinMaxValue: function()
  {
    // valuenow needs to be the converted display value.
    var valuenow = this._getConvertedDisplayValue();
    var valuetext = this.element.val();

    this.element.attr(
            {
              "aria-valuemin": this.options.min, "aria-valuemax": this.options.max,
              // TODO: what should we do with values that can't be parsed?
              // TODO: Ask Pavitra, do we need to parse the value?
              "aria-valuenow": valuenow
            });
    if (!this._ValueEquals("" + valuenow, valuetext))
      this.element.attr({"aria-valuetext": valuetext});
  },
  /**
   * step the inputnumber value up or down
   * @private
   * @param {Number} steps - Number of steps to increment.
   * @param {boolean} up If true step up, else step down.
   */
  _step: function(steps, up)
  {
    this._start();
    if (up)
      this._spin((steps || 1) * this.options.step);
    else
      this._spin((steps || 1) * -this.options.step);
    this._stop();
  }

  /**
   * Removes the inputNumber functionality completely. 
   * This will return the element back to its pre-init state.
   * 
   * <p>This method does not accept any arguments.
   * 
   * @method
   * @name oj.ojInputNumber#destroy
   * @memberof oj.ojInputNumber
   * @instance
   * 
   * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
   * $( ".selector" ).ojInputNumber( "destroy" );
   */
});

//////////////////     SUB-IDS     //////////////////



/**
 * <p>Sub-ID for the inputNumber's Down arrow.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-inputnumber-down
 * @memberof oj.ojInputNumber
 * @instance
 * 
 * @example <caption>Get the node for the Down arrow:</caption>
 * var node = $( ".selector" ).ojInputNumber( "getNodeBySubId", {'subId': 'oj-inputnumber-down'} );
 */

/**
 * <p>Sub-ID for the inputNumber's input element.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-inputnumber-input
 * @memberof oj.ojInputNumber
 * @instance
 * 
 * @example <caption>Get the node for the input element:</caption>
 * var node = $( ".selector" ).ojInputNumber( "getNodeBySubId", {'subId': 'oj-inputnumber-input'} );
 */

/**
 * @class Utility methods for blending Knockout observables with the data model
 * @export
 */
oj.KnockoutUtils = function () {};

oj.KnockoutUtils.internalObjectProperty = "oj._internalObj";
oj.KnockoutUtils.underUpdateProp = "oj._underUpdate";
oj.KnockoutUtils.collUpdatingProp = "oj.collectionUpdating";

/**
 * Turns the attributes in a model object (or the attributes of all models in a collection object) into Knockout observables for use with components' view models.  
 * @param {Object} m The model or collection containing the attributes to be converted to Knockout observables. 
 * @param {function(Object)=} callback Called once per model so that a caller can add their own Knockout computed observables to the model. 
 * @param {boolean=} array Should function return an observable array if m is an oj.Collection, vs. an array of observables?
 * 
 * @return {Object|undefined} array of Knockout observables or an observable array
 * @export
 */
oj.KnockoutUtils.map = function (m, callback, array) 
{
  var koObject, i, updateCollection, updateObservableArrayRemove, updateObservableArrayAdd,
      data, prop, converted, updateModel, updateObservable, updateObservableArrayReset, updateObservableArraySort;

  function _makeUpdateModel(argProp) {
      return function(value) {
          //arguments.callee refers to the callback function itself, so we can use the stored '_prop' object (see below)
          if (!koObject[oj.KnockoutUtils.underUpdateProp]) {
              // Make sure we don't circuluarly fire the event
              m.set(argProp, value);
          }
        };
      }
      
  if (m instanceof oj.Collection)
  {
    koObject = array ? ko.observableArray() : [];
    
    // Need access to original wrapped collection
    oj.KnockoutUtils._storeOriginalObject(koObject, m);
    
    for (i = 0; i < m._getLength(); i=i+1) 
    {
        koObject.push(oj.KnockoutUtils.map(m._atInternal(i, null, true, false), callback));
    }
            
    // Subscribe to the observable Array, if it is one
    updateCollection = function(changes)
    {
       var modArray, i, len;
       try {
            if (!koObject[oj.KnockoutUtils.underUpdateProp]) {
                koObject[oj.KnockoutUtils.collUpdatingProp] = true;
/*                // Pull out an array of model objects from the new observable array
                modArray = oj.KnockoutUtils._getModels(value);
                m.set(modArray);
                */
                // Process change information
                for (i = 0; i < changes.length; i++) {
                    var index = changes[i]['index'];
                    var model = oj.KnockoutUtils._getModel(changes[i]['value']);
                    var status = changes[i]['status'];
                    if (status === 'added') {
                        if (index >= m.length-1) {
                            m.add(model);
                        }
                        else {
                            m.add(model, {'at':index});
                        }
                    }                    
                    else if (status === 'deleted') {
                        m._removeInternal(model, index);
                    }
                }
                if (m['comparator']) {
                    koObject[oj.KnockoutUtils.underUpdateProp] = true;
                    // These could have been resorted--need to alter the observable array
                   koObject.sort(function(a, b) { 
                                        return oj.KnockoutUtils._callSort(a, b, m['comparator'], m, this);
                                    });       
                    koObject[oj.KnockoutUtils.underUpdateProp] = false;
                }
            }
       }
       catch (e) {
           throw e;
       }
       finally {
           koObject[oj.KnockoutUtils.collUpdatingProp] = false;
       }           
    };    
    if (array && koObject['subscribe']) {
        koObject['subscribe'](updateCollection, null, 'arrayChange');
    }
    
     updateObservableArrayRemove = function(model, collection, options) {
         var index;
         try
         {
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
                index = options['index'];
                koObject.splice(index, 1);
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };
     updateObservableArrayAdd = function(model, collection, options) {
         var index, newObservable, len;
         try
         {
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
                index = collection._localIndexOf(model);
                if (index !== undefined && index > -1) {
                    // Make sure to map with original callback from closure, if any
                    newObservable = oj.KnockoutUtils.map(model, callback);
                    if (options['fillIn']) {
                        // First, make sure there's enough room, that index actually exists in koObject...
                        var currLen = Array.isArray(koObject) ? koObject.length : koObject().length;
                        for (var i = currLen; i < index; i++) {
                            koObject.splice(i, 0, oj.KnockoutUtils.map(collection._atInternal(i, null, true, false), callback));
                        }
                        // If we're just filling in on a virtual collection, for example, then just set don't add
                        koObject.splice(index, 1, newObservable);
                    }
                    else {
                        koObject.splice(index, 0, newObservable);
                    }
                }                   
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };     
     updateObservableArrayReset = function(collection, options) {
         try
         {
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
               // koObject.splice(0, koObject().length);
                    if (ko.isObservable(koObject)) {
                        koObject.removeAll();
                    }
                    else {
                        koObject = [];
                    }
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };     
     
     updateObservableArraySort = function(collection, options) {
         try
         {
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
                // Redo the knockout observable array

                koObject.sort(function(a, b) { 
                                return oj.KnockoutUtils._callSort(a, b, m['comparator'], collection, this);
                             });   
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };
     
     // Register these, ignoring the silent flags from normal API calls--knockout always needs to be updated
     m.OnInternal(oj.Events.EventType['ADD'], updateObservableArrayAdd, undefined, undefined, true);    
     m.OnInternal(oj.Events.EventType['REMOVE'], updateObservableArrayRemove, undefined, undefined, true);    
     m.OnInternal(oj.Events.EventType['RESET'], updateObservableArrayReset, undefined, undefined, true);
     m.OnInternal(oj.Events.EventType['SORT'], updateObservableArraySort, undefined, undefined, true);
  }
  else
  {
    if (m === undefined) {
        return;
    }
    
    koObject = {};
    
    data = m.attributes;
    prop = null;
    
    for (prop in data)
    {
      if (data.hasOwnProperty(prop)) {
        converted = ko.observable(m.get(prop));
        koObject[prop] = converted;

        updateModel = _makeUpdateModel(prop);
        updateModel._prop = prop;

        // Subscribe to any changes pushed by Knockout into the observable
        if (converted['subscribe']) {
            converted['subscribe'](updateModel);
        }
      }
     }

     updateObservable = function(model, options) {
         var attrs, prop;
         try
         {
            koObject[oj.KnockoutUtils.underUpdateProp] = true;
            attrs = model.changedAttributes();
            for (prop in attrs) {
                if (attrs.hasOwnProperty(prop)) {
                 koObject[prop](model.get(prop));
                }
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };
     m.OnInternal(oj.Events.EventType['CHANGE'], updateObservable, undefined, undefined, true);
     // Need access to original wrapped model
    oj.KnockoutUtils._storeOriginalObject(koObject, m);

    // Activate user callback if specified, to allow user computed observables, etc.
    if (callback) {
        callback(koObject);
    }
  }
  
  return koObject;     
};

oj.KnockoutUtils._getModels = function(arr) {
    var modelArray = [], i, model;
    for (i = 0; i < arr.length; i=i+1) {
        model = oj.KnockoutUtils._getModel(arr[i]);
        modelArray.push(model);
    }
    return modelArray;
};

oj.KnockoutUtils._getModel = function(val) {
    if (val instanceof oj.Model) {
        return val;
    }
    
    if (val.hasOwnProperty(oj.KnockoutUtils.internalObjectProperty)) {
        return val[oj.KnockoutUtils.internalObjectProperty];
    }
    return val;
};

oj.KnockoutUtils._callSort = function(a, b, comparator, collection, caller) {
    return oj.Collection.SortFunc(oj.KnockoutUtils._getModel(a), oj.KnockoutUtils._getModel(b), comparator, collection, caller);
};
    

// Attempt to hide original object from enumeration of properties
oj.KnockoutUtils._storeOriginalObject = function(object, value) {
    // Store any callback along with model for use in event-driven mapping of new additions
       Object.defineProperty(object, oj.KnockoutUtils.internalObjectProperty, {value: value, enumerable:false});
};

/*oj.KnockoutUtils._createArray = function(collection, getCallback) {
    if (collection._isVirtual()) {
        return oj.KnockoutUtils._augment(collection.length, getCallback);
    }
    return [];
};

oj.KnockoutUtils._augment = function(len, getCallback) {
    var array;
    if (len.constructor === Array) {
        array = new Array(len.length);
        array.storage = len;
    }
    else {
        array = new Array(len);
        array.storage = new Array(len);
    }
    function makePropDef(arr) {
        return function (index, callback) {
                Object.defineProperty(arr, index.toString(), {
                    configurable:true,
                    get: function() { 
                        // Someone is accessing this location: if not set, set it using the callback before returning
                        if (!arr.storage[index]) {
                            arr.storage[index] = callback.call(this, index);
                        }
                        return arr.storage[index];
                    },
                    set: function(val) {
                        arr.storage[index] = val;
                    }
                });
            };
    }

    array.getCallback = getCallback;
        
    function setup(arr) {
        var i;
        arr.length = arr.storage.length;
        for (i = 0; i < arr.storage.length; i++) {
            makePropDef(arr)(i, arr.getCallback);
        }
    }
    setup(array);
    
    array.length = array.storage.length;
    
    array['pop'] = function() {
        var retVal = this.storage.pop();
        this.length = this.storage.length;
        return retVal;
    };
    array['push'] = function(val) {
        var index = this.length;
        this.storage.push(val);
        Object.defineProperty(this, index.toString(), {
                configurable:true,
                get: function() { 
                        // Someone is accessing this location: if not set, set it using the callback before returning
                        if (!this.storage[index]) {
                            this.storage[index] = this.getCallback.call(this, index);
                        }
                        return this.storage[index];
                },
                set: function(val) {
                    this.storage[index] = val;
                }
            });    
        return this.length;
    };
    array['shift'] = function() {
        var self = this;
        var retVal = self.storage.shift();
        setup(self);
        return retVal;
    };
    array['unshift'] = function() {
        var args = Array.prototype.slice.call(arguments), i;
        for (i = 0; i < args.length; i++) {
            this.storage.unshift(args[i]);
        }
        setup(this);
        return this.length;
    };
    array['reverse'] = function() {
        this.storage = this.storage.reverse();
        setup(this);
        return this;
    };
    array['slice'] = function(start, end) {
        var newArr = oj.KnockoutUtils._augment(this.storage.slice(start, end), this.getCallback);
        return newArr;
    };
    array['splice'] = function() {
        var args = Array.prototype.slice.call(arguments);    
        // Just redo the array after modifying storage
        Array.prototype.splice.apply(this.storage, args);
        setup(this);
    };
    return array;
};*/
/**
   * The ojTrain component allows a user to display a navigation visual that allows a user to go between different "steps"
   * Each step can display information about the visited of the step("visited", "unvisited", "disabled")
   * and display a message type("error", "confirmation", "warning", "info", "fatal")
   *
   *
   * @example <caption>Initialize component using widget API</caption>
   * &lt;div id="train"/&gt;<br/>
   * $("#train").ojTrain({'selected': "stp1", 'steps': [{label:'Step One', id:'stp1'},
   * {label:'Step Two', id:'stp2'},{label:'Step Three', id:'stp3'}]});
   * @example <caption>Using knockout, selected bind to observables - selectedStep</caption>
   * &lt;div id="train" data-bind="ojComponent:{component: 'ojTrain', selected: selectedStep, steps:[{label:'Step One', id:'stp1'},
   * {label:'Step Two', id:'stp2'},{label:'Step Three', id:'stp3'}]}"/&gt;gt;
   *
   * @class
   * @constructor
   * @name oj.ojTrain
   * @augments oj.baseComponent
   */
  (function() 
  {
    oj.__registerWidget("oj.ojTrain", $['oj']['baseComponent'], 
	{
      version: "1.0.0",
      defaultElement: "<div>",
      widgetEventPrefix: "oj",
      options: {
        /**
         * The array of step objects. Each step must have an 'id' and 'label' variable, optional additonal variables are:
         * 'disabled' - Indicates if the step is selectable. 'disabled' is a boolean type with a default value of false.
         * 'visited' - Indicates if the step has been visited. 'visited' is a boolean type with a default value of false.
         * 'messageType' - The messageType icon to display on the step. Possible options are 'confirmation', 'info', 'error', 'fatal', or 'warning'. Default value is null.
         * @expose
         * @public
         * @instance
         * @memberof! oj.ojTrain
         */
        steps: [],
        /**
         * The selected variable indicates the id of the current selected step.
         * @expose
         * @public
         * @instance
         * @memberof! oj.ojTrain
         */
        selected: "",
        // Events

        /**
         * Fired whenever a supported component option changes, whether due to user interaction or programmatic
         * intervention.  If the new value is the same as the previous value, no event will be fired.
         *
         * Currently there is one supported option, <code class="prettyprint">"selected"</code>.  Additional
         * options may be supported in the future, so listeners should verify which option is changing
         * before taking any action.
         *
         * @expose
         * @event
         * @memberof! oj.ojTrain
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {string} ui.option the name of the option that is changing
         * @property {string} ui.previousValue the previous value of the option
         * @property {string} ui.value the current value of the option
         * @property {Object} ui.optionMetadata information about the option that is changing
         * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
         *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
         *
         */
        optionChange: null,
        /**
         * Triggered immediately before a step is deselected.
         * The beforeDeselect can be cancelled by calling <code class="prettyprint">event.
         
         Default()</code>.
         *
         * @expose 
         * @event 
         * @memberof! oj.ojTrain
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.toStep The step that is about to be deselected.
         * @property {jQuery} ui.fromStep The step that is about to be selected.
         * 
         * @example <caption>Initialize the train with the <code class="prettyprint">beforeDeselect</code> callback specified:</caption>
         * $( ".deselector" ).ojTrain({
         *     "beforeDeselect": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforedeselect</code> event:</caption>
         * $( ".deselector" ).on( "ojbeforedeselect", function( event, ui ) {} );
         */
        beforeDeselect: null,
        /**
         * Triggered after a step has been deselected.
         * The deselect can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         *
         * @expose 
         * @event 
         * @memberof! oj.ojTrain
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.toStep The step that is about to be deselected.
         * @property {jQuery} ui.fromStep The step that is about to be selected.
         * 
         * @example <caption>Initialize the train with the <code class="prettyprint">deselect</code> callback specified:</caption>
         * $( ".deselector" ).ojTrain({
         *     "deselect": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojdeselect</code> event:</caption>
         * $( ".deselector" ).on( "ojdeselect", function( event, ui ) {} );
         */
        deselect: null,
        /**
         * Triggered immediately before a Step is selected.
         * The beforeSelect can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         *
         * @expose 
         * @event 
         * @memberof! oj.ojTrain
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.toStep The step that is about to be deselected.
         * @property {jQuery} ui.fromStep The step that is about to be selected.
         * 
         * @example <caption>Initialize the train with the <code class="prettyprint">beforeSelect</code> callback specified:</caption>
         * $( ".selector" ).ojTrain({
         *     "beforeSelect": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeselect</code> event:</caption>
         * $( ".selector" ).on( "ojbeforeselect", function( event, ui ) {} );
         */
        beforeSelect: null,
        /**
         * Triggered after a step has been selected.
         *
         * @expose 
         * @event 
         * @memberof! oj.ojTrain
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.toStep The step that is about to be deselected.
         * @property {jQuery} ui.fromStep The step that is about to be selected.
         * 
         * @example <caption>Initialize the train with the <code class="prettyprint">select</code> callback specified:</caption>
         * $( ".selector" ).ojTrain({
         *     "select": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
         * $( ".selector" ).on( "ojselect", function( event, ui ) {} );
         */
        select: null
      },
	  
      /**
       * Variable for storing the number of steps in the train
       *
       * @private
       */
      _stepNum: 0,
	  
      /**
       * Variable for storing the train information about each step in 2D Array form
       *
       * @private
       */
      _stepArray: null,
	  
      /**
       * _create contains all actions that are needed fo the initialization of the train and is only called once.
       *
       * @override
       * @private
       */
      _ComponentCreate: function() {
        this._super();
        
        // Constrain initial value
        var options = this.options;
        var steps = options.steps;
        this._stepNum = steps.length;
	
        // Train Wrapper
        this._wrapper = $("<div class='oj-train-wrapper'></div>");
        this._wrapper.appendTo(this.element);
        
        this._connectorWrapper = $("<div class='oj-train-connector-wrapper'></div>");
        this._connectorWrapper.appendTo(this._wrapper);
        
        this._stretch = this.element.attr('class').indexOf("oj-train-stretch") >=0 ? true : false;
        if(this._stretch)
            this._connectorWrapper.css("padding", "0 " + 100 / (this._stepNum *2) + "%");
		
        // Draw the connector bar  for the train
        this._connector = $("<div class='oj-train-connector'></div>");
        this._connector.appendTo(this._connectorWrapper);
		
        this._stepList = $("<ul>");
        this._stepList.addClass('oj-train-step-list');
        

        // Initialize the background progressbar object that will be updated to have the correct width based on the current step.
        this._connectorFill = $("<div class='oj-train-connector-fill'></div>");
        this._connectorFill.appendTo(this._connectorWrapper);

        // Setup array that stores train information for each step.
        this._setupArray();
        this._selectedIndex = this._getStepIndex(options.selected);
        if (this._selectedIndex === -1)
        {
          this._selectedIndex = 0;
          options.selected = steps[0]['id'];
        }

        // Draw each step. Visually each step consists of a background circle, a button, an icon, and a label.
        for (var i = 0; i < this._stepNum; i++)
        {
          // Create a list item to store each step.
          var stepTag = $("<li>")
		          .addClass("oj-train-step-list-item")
                  .attr({'id': this._stepArray[i][1]})              
          stepTag.appendTo(this._stepList);
          this._drawLabel(i);
          this._drawStepFill(i);
          this._drawButton(i);
          this._drawMessageType(i);
          if(this._stretch)
            stepTag.css("width", 100 / (this._stepNum) + "%");  
        }
        // Update background progressbar width to show the progress.
        var connectorFillWidth = this._stepNum - 1 === this._selectedIndex ? 100 : (100/ (2 *(this._stepNum - 1)) + this._selectedIndex / (this._stepNum - 1) * 100)
        this._connectorFill.css({'width':  connectorFillWidth + "%"});
        this._stepList.appendTo(this._wrapper);
        this.element.addClass("oj-train");
      },
	  
	  
      /**
       * Set up the _stepArray(). The first dimension indicates the step index and the second dimension indicates the step variables.
       * The order of the step variables are: label, id, selection, visited, messageType
       *
       * @private
       */
      _setupArray: function() {
        var options = this.options;
        this._stepArray = [];
        for (var i = 0; i < this._stepNum; i++) {
          var step = options.steps[i];
          this._stepArray[i] = new Array(5);
          this._stepArray[i][0] = step['label'] ? step['label'] : null;
          this._stepArray[i][1] = step['id'] ? step['id'] : null;
          this._stepArray[i][2] = step['disabled'] ? true : false;
          this._stepArray[i][3] = step['visited'] ? true : false;
          this._stepArray[i][4] = step['messageType'] ? step['messageType'] : null;
        }
      },
	  
      /**
       * Draw the button object for the step based on the index. If a button for that step alread exists remove it and draw the new one.
       * @param {number} index - The index of the step for which the button is being drawn.
       *
       * @private
       */
      _drawButton: function(index)
      {
        var button = $("<div/>")
             .addClass("oj-train-button");
        var scrnRead = $("<span/>");
        var self = this;
        var desc = "";
        if (this._stepArray[index])
        {
          var visited = this._stepArray[index][3];
          var disabled = this._stepArray[index][2];
          if (this._selectedIndex === index) {
            button.addClass("oj-selected");
            desc = " current ";
          }
          else
          {
            if (visited && !disabled) {
              button.addClass("oj-visited");
              desc = " visited ";
            }
            else if (!visited && !disabled) {
              button.addClass("oj-default");
              desc = " not visited ";
            }
            else
              button.addClass("oj-disabled");
          }

          if (!this._stepArray[index][2] && this._selectedIndex !== index) {
            this._hoverable(button);
            button.on("click" + this.eventNamespace, function() {
              var oldStepId = self.options.selected;
              self.options.selected = this.parentNode.parentNode.id;
              self._fireOptionChange("selected", oldStepId, this.parentNode.parentNode.id, true);
              self.refresh();
            });
          };
          var stepBackground = this._stepList.children().eq(index).find('.oj-train-button-connector');

          // Check that there are at least 3 items in the list item indicating that a button has already been created for this step.
          // If there is remove it and insert the new button in the same position. If there isn't a preexsisting button, simply add one.
          if (stepBackground.length >= 1) {
            stepBackground.children().remove();
            stepBackground.append(button);
          }
          else
             stepBackground.append(button);
          scrnRead.text(desc);
          scrnRead.addClass("oj-helper-hidden-accessible");
          this._stepList.children().eq(index).find('a').append(scrnRead);
        }
      },
	  
      /**
       * Draw the icon that displays the messageType for the step based on the index. If there already is an icon remove it and draw the new one.
       * @param {number} index - The index of the step for which the icon is being drawn.
       *
       * @private
       */
      _drawMessageType: function(index)
      {
        var icon = $("<div/>")
		     .addClass("oj-train-icon");
        var scrnRead = $("<span/>");
        var desc = "";
        var self = this;
        if (this._stepArray[index])
        {
          var messageType = this._stepArray[index][4];
          if (messageType === "confirmation") {
            icon.addClass("oj-confirmation");
            desc = " Confirmation ";
          }
          else if (messageType === "info") {
            icon.addClass("oj-info");
            desc = " Info ";
          }
          else if (messageType === "error") {
            icon.addClass("oj-error");
            desc = " Error ";
          }
          else if (messageType === "fatal") {
            icon.addClass("oj-error");
            desc = " Error ";
          }
          else if (messageType === "warning") {
            icon.addClass("oj-warning");
            desc = " Warning ";
          }

          // Remove previous messageType
          var button = this._stepList.children().eq(index).find('.oj-train-button');
          if (button.children().length >= 1) {
            button.children().remove();
          }
          // Make icon clickable
          if (!this._stepArray[index][2] && this._selectedIndex !== index) {
            this._hoverable(icon);
            icon.on("click" + this.eventNamespace, function() {
              var oldStepId = self.options.selected;
              self._fireOptionChange("selected", oldStepId, this.parentNode.parentNode.parentNode.id, true);
              self.refresh();
            });
          }
          // Add new message
          if (messageType != null) {
            // If there is remove it and insert the new icon in the same position.
            // Add description to span
            scrnRead.text(desc);
            scrnRead.addClass("oj-helper-hidden-accessible");
            this._stepList.children().eq(index).find('a').append(scrnRead);
            button.append(icon);

          }
        }
      },
	  
      /**
       * Fire optionChange event 
       * @param {String} key - 'selected'
       * @param {String} previousValue 
       * @param {String} value
       * @param {Boolean} originalEvent  
       *
       * @private
       */
      _fireOptionChange: function(key, previousValue, value, originalEvent)
      {

        var optionChangeData = {
          "option": key,
          "previousValue": previousValue,
          "value": value,
          // (originalEvent is non-null) iff (option change is due to user interaction) iff (binding should write back the value)
          "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
        };
        var eventData = {
          "option": key,
          "fromStep": this.getStep(previousValue),
          "toStep": this.getStep(value),
          // (originalEvent is non-null) iff (option change is due to user interaction) iff (binding should write back the value)
          "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
        };
        if(this._trigger("beforeDeselect", null, eventData) === false || this._trigger("beforeSelect", null, eventData) === false)
          return;
        
        // Set the previous step to visited
        var stepIndex = this._getStepIndex(previousValue);
        if( stepIndex !== -1) {
          var oldStepProperties = this.options.steps[stepIndex];
          oldStepProperties['visited'] = true;
        }
        
        this._trigger("deselect", null, eventData);
        this.options.selected = value;
        this._trigger("select", null, eventData);
        
        this._trigger('optionChange', originalEvent, optionChangeData);

      },
	  
      /**
       * Draw the background circle for the step which is either light or dark base on if the step is before or after the selected step.
       * @param {number} index - The index of the step for which the icon is being drawn.
       *
       * @private
       */
      _drawStepFill: function(index)
      {
        var stepFill = $("<div/>");
        stepFill.addClass("oj-train-button-connector");
        if (this._stepArray[index])
        {
          if (index <= this._selectedIndex)
            stepFill.addClass("oj-train-fill");
          var stepLi = this._stepList.children().eq(index).children();
          stepFill.insertBefore(stepLi);
        }
      },
	  
      /**
       * Draw the label for the step.
       * @param {number} index - The index of the step for which the icon is being drawn.
       *
       * @private
       */
      _drawLabel: function(index)
      {
        var self = this;
        if (this._stepArray[index])
        {
          var labelWrapper = $("<div/>")
		            .addClass("oj-train-label-wrapper");
          var label = $("<a>" + this._stepArray[index][0] + "</a>");
          labelWrapper.append(label);
          label.addClass("oj-train-label");
          if (index === this._selectedIndex)
            label.addClass("oj-selected");
          else if (this._stepArray[index][3])
            label.addClass("oj-visited");
          else if (this._stepArray[index][2])
            label.addClass("oj-disabled");
          if (!this._stepArray[index][2] && this._selectedIndex !== index) {
            label.attr("href", "#");
            this._hoverable(label);
            label.on("click keydown" + this.eventNamespace,
							 /**
							 * @suppress {missingProperties}
							 */
                            function(event) {
                              if (event.keyCode === $.ui.keyCode.ENTER || event.type === "click") {
                                event.preventDefault();
                                var oldStepId = self.options.selected;
                                self._fireOptionChange("selected", oldStepId, this.parentNode.parentNode.id, true);
                                self.refresh();
                              }
                            });
                  }
          var stepLi = this._stepList.children().eq(index).children();
          if (stepLi.length >= 1)
            stepLi[0].remove();
          this._stepList.children().eq(index).append(labelWrapper);
        }
      },
	  
      /**
       * Return the index of the step
       * @param {String} id - The index of the id whose id is being passed in.
       * @return {number} index of step. -1 for not valid ids.
       * @private
       */
      _getStepIndex: function(id)
      {
        for (var i = 0; i < this._stepNum; i++) {
          if (this._stepArray[i] && this._stepArray[i][1] === id)
            return i;
        }
        return -1;
      },
	  
      /**
       * <p>Returns the step based on the id passed in. If the step doesn't exist, return null;</p>
       * @public
       * @param {String} id - The id of the step.
       * @return {Object} step object.
       * @expose
       * @instance
       * @memberof! oj.ojTrain
       */
      getStep: function(id)
      {
        for (var i = 0; i < this._stepNum; i++) {
          if (this._stepArray[i] && this._stepArray[i][1] === id)
            return jQuery.extend({}, this.options.steps[i]);
        }
        return null;
      },
	  
      /**
       * <p>Returns the id of the next selectable step based on the selected id. If the current step is the last selectable step, returns null</p>
       * @public
       * @return {String} next selectable Id
       * @expose
       * @instance
       * @memberof! oj.ojTrain
       */
      nextSelectableStep: function()
      {
        for (var i = this._selectedIndex; i < this._stepNum; i++) {
          if (i + 1 < this._stepNum && this._stepArray[i + 1] && !this._stepArray[i + 1][2])
          {
            return this._stepArray[i + 1][1];
          }
        }
        return null;

      },
	  
      /**
       * <p>Returns the id of the previous selectable step based on the selected id. If the current step is the first selectable step, returns null</p>
       * @public
       * @return {String} previous selectable Id
       * @expose
       * @instance
       * @memberof! oj.ojTrain
       */
      previousSelectableStep: function()
      {
        for (var i = this._selectedIndex; i >= 0; i--) {
          if (this._stepArray[i - 1] && !this._stepArray[i - 1][2])
          {
            return this._stepArray[i - 1][1];
          }
        }
        return null;
      },
	  
      /**
       * <p>Sets the properties for the step. Takes in the object conatining the properties for the step.</p>
       * @public
       * @param {Object} stepProperties - The property bag to overwrite properties on the step.
       * @expose
       * @instance
       * @memberof! oj.ojTrain
       */
      setStep: function(stepProperties)
      {

        if (stepProperties['id'])
        {
          var stepInfo = this.getStep(stepProperties['id']);
          var stepIndex = this._getStepIndex(stepProperties['id']);
          if(stepIndex !== -1)
          {
            var stepObj = this.options.steps[stepIndex];
            if (stepProperties['label'])
            {
                  stepInfo[0] = stepProperties['label'];
                  stepObj['label'] = stepProperties['label'];
            }
            if (typeof (stepProperties['disabled']) === 'boolean')
            {
                  stepInfo[2] = stepProperties['disabled'];
                  stepObj['disabled'] = stepProperties['disabled'];
            }
            if (typeof (stepProperties['visited']) === 'boolean')
            {
                  stepInfo[3] = stepProperties['visited'];
                  stepObj['visited'] = stepProperties['visited'];
            }
            if (stepProperties['messageType'])
            {
              stepInfo[4] = stepProperties['messageType'];
              stepObj['messageType'] = stepProperties['messageType'];
            }
          }
        }
      },
      _setOption: function(key, value, flags) {
        if (key === "selected")
        {
          var oldValue = this.options.selected;
          this.options.selected = value;
          if (oldValue)
            this._fireOptionChange("selected", oldValue, value, true);
        }
        this._super(key, value, flags);
      },
      _setOptions: function(options) {
        this._super(options);
        this.refresh();
      },
	  
      /**
       * Refreshes the train.
       *
       * <p>This method does not accept any arguments.</p>
       * 
       * @expose 
       * @memberof! oj.ojTrain
       * @instance
       */
      refresh: function()
      {
        this._super();
        this._destroy();
        this._ComponentCreate();
      },
	  
      /**
       * @override
       * @private
       */
      _destroy: function()
      {
        this.element.removeClass("oj-train oj-train-bar oj-train-wrapper oj-train-connector-wrapper oj-train-connector oj-train-connector-fill oj-train-fill oj-component-initnode");
        this._wrapper.remove();
        this._connectorWrapper.remove();
        this._connector.remove();
        this._connectorFill.remove();
        this._stepList.remove();
        this._stepList.children().each(function() {
          $(this).remove();
        })
        this._super();
      },
	  
      /**
       * Return the subcomponent node represented by the documented locator attribute values.
       *
       * 
       *      *
       * Test authors should target sub elements using the following names:
       * <ul>
       * <li><b>oj-train-button</b>: train step button </li>
       * <li><b>oj-train-button-connector</b>: train step button connector background </li>
       * <li><b>oj-train-connector</b>: train connector bar </li>
       * <li><b>oj-train-connector-fill</b>: train connector fill indicating progress </li>
       * <li><b>oj-train-icon</b>: train step message icon </li>
       * <li><b>oj-train-label</b>: train step label </li>
       * </ul>
       *
       * @expose
       * @override
       * @memberof! oj.ojTrain
       * @instance
       * @param {Object} locator An Object containing at minimum a subId property 
       * whose value is a string, documented by the component, that allows the component to 
       * look up the subcomponent associated with that string.  It contains:
       * <ul>
       * <li>
         index: a number, the index of train.
       * </li>
       * <li>
       * subId: the string, documented by the component, that the component expects 
       * in getNodeBySubId to locate a particular subcomponent 
       * </li>
       * </ul>  
       * @returns {Element|null} the subcomponent located by the subId string 
       * passed in locator, if found.
       */
      getNodeBySubId: function(locator)
      {

        if (locator === null)
        {
          return this.element ? this.element[0] : null;
        }

      var subId = locator['subId'],
          index = locator['index'];

      if ((typeof index !== 'number') ||
           index < 0 || index >= this._stepNum)
        return null;

      switch (subId)
      {
      case 'oj-train-button':
        return this._stepList.children().eq(index).find('.oj-train-button');

      case 'oj-train-button-connector':
        return this._stepList.children().eq(index).find('.oj-train-button-connector');

      case 'oj-train-connector':
        return this._connector;

      case 'oj-train-connector-fill':
        return this._connectorFill;

      case 'oj-train-icon':
        return this._stepList.children().eq(index).find('.oj-train-icon');
        
      case 'oj-train-label':
        return this._stepList.children().eq(index).find('.oj-train-button');
      }

      // Non-null locators have to be handled by the component subclasses
      return null;
    }
      
    });
  }
());
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
/*!
 * JET Radioset @VERSION
 */
/**
 * @class
 * @name oj.ojRadioset
 * @augments oj.editableValue
 * @classdesc
 * <p>
 * The JET Radioset component (ojRadioset) enhances a group of 
 * <code class="prettyprint">input type="radio"</code> elements. It 
 * manages the selected value of the group and it adds required validation. 
 * It also adds and removes the correct
 * oj-* styles to the dom elements so it has the JET styling and is themable.
 * </p>
 * <p>To use an ojRadioset, group all the inputs and their labels within a 
 *   container dom element, e.g., <code class="prettyprint">div</code>.
 *   For accessibility, set <code class="prettyprint">aria-labelledby</code> on 
 *   this container dom element.
 *   Also set each input's <code class="prettyprint">id</code> attribute, and 
 *   refer to that in the input's label's 
 *   <code class="prettyprint">for</code> attribute.
 *   Then create the ojRadioset on this container dom element.  
 * </p>
 * <p>
 *  The <code class="prettyprint">fieldset</code>/<code class="prettyprint">legend</code> elements 
 *  are not a supported way 
 *   to group and label ojRadioset, so <code class="prettyprint">fieldset</code> cannot be the 
 *   container dom element on which you create the ojRadioset. 
 *   Grouping with a <code class="prettyprint">div</code> element and using 
 *   a <code class="prettyprint">label</code> element allows you to
 *   lay out your labels/fields in more ways than if you used a fieldset/legend. 
 *   Both are equally accessible. 
 * </p>
 * <p>
 *  Radioset is used by selecting a container element which contains the 
 *  radio input elements and calling <code class="prettyprint">ojRadioset()</code>. 
 *  You can enable and disable a radio set, 
 *  which will enable and disable all contained radios. 
 * </p>
 * <p>
 *  Radioset does not have a readOnly option since HTML does not support
 *  readonly on radios and checkboxes.
 * </p>
 * 
 * <h3 id="keyboard-section">
   *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>The radioset does not add any extra keyboard navigation to the input radios. 
 * The keyboard interaction comes from the native browser.
 * </p>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>JET Radioset takes care of setting 
 * <code class="prettyprint">role="radiogroup"</code> on the radioset element.  
 * 
 * <p>As shown in the online demos, the application is responsible for applying 
 * <code class="prettyprint">aria-labelledby</code>
 * to point to the radioset's <code class="prettyprint">label</code> element for the group of radios.
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio, 
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>, 
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which 
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user 
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio 
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 * <h3 id="label-section">
 *   Label and Radioset
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#label-section"></a>
 * </h3>
 * <p>
 * For accessibility, you should associate a <code class="prettyprint">label</code> element with the 
 * radioset by putting an <code class="prettyprint">id</code> on the label, and then setting the 
 * <code class="prettyprint">aria-labelledby</code> attribute on the radioset dom to be the label's 
 * <code class="prettyprint">id</code>.
 * Note: The radioset's label is not the same as the label for each radio. The 
 * radioset's label will have the required and help information on it, 
 * not the label for each radio.
 * </p>
 * <p>
 * The component will decorate its associated label with required and help 
 * information, if the <code class="prettyprint">required</code> and 
 * <code class="prettyprint">help</code> options are set. 
 * </p>
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <p>
 *   All JQUI and JET components inherit <code class="prettyprint">disable()</code> 
 *   and <code class="prettyprint">enable()</code> methods from the base class. 
 *    This API duplicates the functionality of the 
 *    <code class="prettyprint">disabled</code> option.  
 *    In JET, to keep the API as lean as possible, we have chosen not to document 
 *    these methods outside of this section.
 * </p>
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Radioset.
 *  For JET Radioset, if the DOM changes (for example, you add/remove a radio), 
 *  you should <code class="prettyprint">refresh()</code>.
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the radioset with no options specified:</caption>
 * $(".selector").ojRadioset();
 * 
 * @example <caption>Initialize the radioset with some options and callbacks specified:</caption>
 * $( ".selector" ).ojRadioset( { "value": "copy", "valuechange": 
 * function( event, ui ) {alert("valuechanged from " + ui.previousValue + " to " + ui.value);} } );             
 * @example <caption>Initialize component using widget API</caption>
 * &lt;label id="grouplabel">Greetings&lt;/label>
 * &lt;div id="radioset" aria-labelledby="grouplabel">
 *   &lt;input id="helloid" value="hello" type="radio" name="greetings"/&gt;
 *   &lt;label for="helloid"/&gt;Hello&lt;/label>
 *   &lt;input id="bonjourid" value="bonjour" type="radio" name="greetings"/&gt;
 *   &lt;label for="bonjourid"/&gt;Bonjour&lt;/label>
 *   &lt;input id="ciaoid" value="ciao" type="radio" name="greetings"/&gt;
 *   &lt;label for="ciaoid"/&gt;Ciao&lt;/label>
 * &lt;div>
 * <br/>
 * // set the value to "ciao". (The 'ciao' radio will be checked)
 * $("#radioset").ojRadioset({'option', 'value', 'ciao'});
 * 
 * @example <caption>Initialize a radioset via the JET 
 * <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="radioset" data-bind="ojComponent: {component: 'ojRadioset', value: 'night'} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="radio" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="radio" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
  * @example <caption>Using knockout, value bind to observable:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="radioset" data-bind="ojComponent: {component: 'ojRadioset', 
 * value: currentTime} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="radio" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="radio" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
 * // in the model, make the currentTime variable a knockout observable.
 * // The model and the component's value option will stay in sync. Change the
 * // component's value option and the model will change. Change the model,
 * // and the component's value option will change. Click on a radio, and both
 * // will change.
 * self.currentTime = ko.observable("night");
 * @constructor
 */
oj.__registerWidget("oj.ojRadioset", $['oj']['editableValue'],
{
  version : "1.0.0",  
  defaultElement : "<div>", 
  widgetEventPrefix : "oj", 
  options : 
  {
    /** 
     * <p>
     * Disabled <code class="prettyprint">true</code> disables the component and disables all the 
     * inputs/labels. 
     * Disabled <code class="prettyprint">false</code> enables the component, and leaves the 
     * inputs' <code class="prettyprint">disabled</code> property as it is in the dom.
     * <p>
     * After create time, the disabled state should be set via this API, 
     * not by setting the underlying DOM attribute. 
     *  
     * <p>The 2-way <code class="prettyprint">disabled</code> binding offered by 
     * the <code class="prettyprint">ojComponent</code> binding 
     * should be used instead of Knockout's built-in <code class="prettyprint">disable</code> 
     * and <code class="prettyprint">enable</code> bindings, 
     * as the former sets the API, while the latter sets the underlying DOM attribute.
     * 
     * @example <caption>Initialize component with <code class="prettyprint">disabled</code> option:</caption>
     * $(".selector").ojRadioset({"disabled": true});
     * 
     * @expose 
     * @type {?boolean}
     * @default <code class="prettyprint">false</code>
     * @public
     * @instance
     * @memberof oj.ojRadioset
     */
    disabled: null,
    /** 
     * The value of the component. 
     * 
     * <p>
     * When <code class="prettyprint">value</code> option changes due to programmatic 
     * intervention, the component always clears all messages and runs deferred validation, and 
     * always refreshes UI display value.</br>
     * 
     * <h4>Clearing Messages</h4>
     * <ul>
     * <li>All messages are cleared. This includes  
     * <code class="prettyprint">messagesHidden</code>, <code class="prettyprint">messagesShown</code>
     *  and <code class="prettyprint">messagesCustom</code> options.</li>
     * </ul>
     * 
     *  
     * <h4>Running Validation</h4>
     * <ul>
     * <li>component always runs deferred validation; if there is a validation error the 
     * <code class="prettyprint">messagesHidden</code> option is updated.</li>
     * </ul>
     * </p>
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojRadioset({'value': 'coffee'});<br/>
     * @example <caption>Get or set <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns 'coffee'
     * $(".selector").ojRadioset("option", "value");
     * // Setter: sets 'tea'
     * $(".selector").ojRadioset("option", "value", 'tea');
     * 
     * @expose 
     * @access public
     * @instance
     * @default <code class="prettyprint">null</code>
     * When the option is not set, the value of the checked radio is used, if a radio is checked.
     * @memberof oj.ojRadioset
     * @type {string|undefined|null}
     */
    value: undefined
  },
  /**** start Public APIs ****/
      
   /**
   * Refreshes the radioset
   * <p>A <code class="prettyprint">refresh()</code> is required 
   * when a radioset is programatically changed, like in the following circumstances:
   * <ul>
   *   <li>After radios are added or removed or modified (without using ojRadioset) in the DOM.</li>
   * </ul>    
   * @expose 
   * @memberof oj.ojRadioset
   * @instance
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" ).ojRadioset( "refresh" );
   */
  refresh: function() 
  {
    this._super();
    // we have a rule for refresh: if we have an api for it, then the app dev has to use the
    // option, and not expect changing the dom will update the state with refresh.
    // For the this.$radios, before I call refresh on each of them, change their disabled option
    // based on the DOM.

    // !! ensures it is a boolean
    this.$radios.each(function() 
    {
        var disabledValue = $( this ).attr("disabled") !== undefined ? 
          !!$( this ).prop("disabled") : false;
        $( this )._ojRadioCheckbox("option", "disabled", disabledValue);
    });
      
    // refresh the ojRadioCheckbox's that exist, and  of the type=radio inputs that 
    // are not yet ojRadioCheckboxs, make them ojRadioCheckboxs.
    this.$radios = this._findRadiosWithMatchingName()
                    .filter( ".oj-radio" )
                    ._ojRadioCheckbox("refresh")
                    .end()                  
                    // Create ojRadioCheckbox out of any 'new' radios.
                     // the END is key here. It makes it so that 
                     // this.$radios has ALL the radios.
                     // .not if a filter, it removes elements that do not have the
                     // oj-radio style class from the list of all input[type=radio]s.
                    .not( ".oj-radio" )
                    ._ojRadioCheckbox()
                    .end();
         
    this._setup();
  },
  /**
   * Returns a jQuery object containing the element visually representing the radioset. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof oj.ojRadioset
   * @instance
   * @return {jQuery} the radio
  */
  widget : function ()
  {
    return this.uiRadioset;
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/   
  /**
   * @protected
   * @override
   * @instance
   * @memberof oj.ojRadioset
   */
  _InitOptions : function (originalDefaults, constructorOptions)
  {
    var radios, checkedRadio, domValue, previousValue;
    // TODO: When Max fixes it so that disabled can be undefined in initial options, then 
    // change it to undefined. Otherwise we aren't getting the defaultOptionValue of false,
    // since the initializeOptionsFromDom code checks for undefined before it sets default.
    // However, if we set disabled: false in our widget options, then this would be the merged
    // value that was written to this.options, and we wouldn't have to use the defaultOptionValue here.
    // There is a debate going on about which is the best thing to do.
    // Right now I use disabled: null, but that's not so good, because disabled is a boolean,
    // and when I init ojRadioset, then ask for the disabled option, it shouldn't return null.
    var props = [{"attribute": "disabled", "defaultOptionValue": false, "validateOption": true},
                 {"attribute": "placeholder", "defaultOptionValue": ""},
                 {"attribute": "required", "defaultOptionValue": false, 
                  "coerceDomValue": true, "validateOption": true},
                 {"attribute": "title", "defaultOptionValue": ""}
                 // {"attribute": "value", "defaultOptionValue": null} // code below sets value
               ]; 
    
    this._super(originalDefaults, constructorOptions);
    oj.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);  
    
    // component, app, and constructor are merged into this.options.option by the time _InitOptions 
    // is called. Let's take this example:
    // component (widget) default - 'foo'<br/>
    // app default - 'bar'<br/>
    // dom  - 'lucy'<br/>
    // constructorOptions['value'] - undefined<br/>
    // this.options.option is set to 'bar' initially. We don't want to just take this value, because
    // we want DOM value to win over the app and components default if DOM is set.
    // Therefore, the component needs to check if the constructorOptions['value'] is 
    // undefined and if so, set value option to 'lucy' (the DOM value in this example). <br/>
    // 
    // use DOM value if constructorOptions is undefined. if DOM value is undefined, then
    // leave this.options["value"] alone since it's the merged app/widget default at this point.
    if (constructorOptions['value'] === undefined)
    {
      // return the checked values by simply looking at DOM node
      radios = this._findRadiosWithMatchingName();
      checkedRadio = radios.filter(":checked");
      domValue = (checkedRadio.length === 0) ? undefined : checkedRadio.val();
      // we only use the dom if SOMETHING is checked. If nothing is checked, we stay with whatever
      // is in this.options['value'].
      if (domValue !== undefined)
      {
        previousValue = this.options['value'];
        this.options['value'] = domValue;
        // when defaulting from DOM we want to trigger optionChange to writeback new value
        // _InitializedOptionFromDom keeps track of the options.
        // In _AfterCreate() each option tracked is written back.
        this._InitializedOptionFromDom('value', previousValue);
      }
      // widget defaults to null
      if (this.options['value'] === undefined)
        this.options['value'] = null;
    }
    

  },      
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @memberof oj.ojRadioset
   * @instance
   */
  _ComponentCreate : function ()
  {
    this._super();
    // first check to see if this.element is NOT a fieldset. If fieldset, throw error.
    if (this.element.is("fieldset"))
    {
      throw new Error("ojRadioset cannot be bound to a fieldset. Use a div instead.");
    }
    // turn each radio into ojRadioCheckbox. Do this first, since we need it
    // in calls from 'create'.
    this.$radios = this._findRadiosWithMatchingName()._ojRadioCheckbox();

    this.uiRadioset = this.element.addClass("oj-radioset oj-component")
                                  .attr( "role", "radiogroup" );
    this._on(this._events);
    this._setup();

  },
  /**
   * Sets focus on the element that naturally gets focus. For radioset, this is the first radio <br/>
   * 
   * @returns {*} a truthy value if focus was set to the intended element, a falsey value 
   * otherwise.
   * @override
   * @memberof oj.ojRadioset
   * @instance
   * @protected
   * @since 0.7
   */
  Focus : function ()
  {
    this._GetContentElement().first().focus();
    return true;
  },
  /**
   * Returns a jquery object that is a set of elements that are input type radio
   * and have the name of the first radio found.
   * 
   * @return {Object} jquery object of all the radios within the root dom element
   * that have the same 'name' attribute as the first radio found.
   * @private
   */
  _findRadiosWithMatchingName : function ()
  {
    //return this.element.find('input[type=radio]'); // simplest thing to do.
    
    var first = this.element.find("input[type=radio]:first"), 
      name, allradios, selector;
    if (first.length === 0)
    {
      oj.Logger.warn("Could not find any input type=radio within this element");
    }
    // get the name attribute of the first input radio
    name = first.attr("name");
    // find all input radios with matching name
    if (name === undefined)
    {
    	// search for all radios with no name
      allradios = this.element.find("input[type=radio]");
      // now loop and find the ones without 'name' attribute
      return allradios.not("[name]");
    }
    else
    {
    	// search for all radios with the name
      selector = "input[type=radio][name=" + name + "]";
      return this.element.find(selector);
    	
    }
  },
  // Override to set custom launcher
  _OpenContextMenu: function(menu, event)
  {
    // Setting the launcher to the checked radio if any (since that's what's tabbable in mainstream browsers), 
    // else the first enabled radio (when no selection, all enabled radios are tabbable).
    // Component owner should feel free to specify a different launcher if appropriate.
    // See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.
    var radios = this.element.find("input[type=radio]");
    var checked = radios.filter(":checked");
    var launcher = checked.length ? checked : radios.filter(":enabled").first(); 
    menu.open(event, {"launcher": launcher, "initialFocus": "menu"});
  },
  /**
   * _setup is called on create and refresh. Use the disabled option to 
   * update the component. If the component's option is disabled, then
   * leave it alone.
   * @memberof oj.ojRadioset
   * @instance
   * @private
   */
  _setup: function() 
  {
    // disable radio if element was already disabled
    if (this.options.disabled === true)
    {
      // calls _setOption disable is true, which in turn disables all radios.
      this.disable();
    }
    else if (this.options.disabled === false)
    {
      this.enable();
    }
  },   
  _events : 
  {
    'change' : function (event)
    {
      
      this._HandleChangeEvent(event);
    }
  },

  /**
   * @param {Event} event DOM event 
   * @override
   * @protected
   * @memberof oj.ojRadioset
   */
  _HandleChangeEvent: function(event)
  {
    // TODO make sure the target is an input radio?
    // TODO any more checks I need to do?
    //alert("XYZ In _changeSetValue target is " + event.target + " And the value of the input is " + event.target.value);

    // should I double check that the event.target is the same as the 'checked'?
    // if (event.target === this.$radios.filter(":checked"))???
    // _SetValue triggers valuechange event
    this._super(event);
  },
                  
  /**
   * Returns the display value that is ready to be passed to the converter.
   * 
   * @param {Object} value the stored value if available that needs to be formatted for display
   * @override
   * @protected
   * @memberof oj.ojRadioset
   */
  _GetDisplayValue : function (value) 
  {
    // return the value of the 'checked' radio
    return this._GetElementValue();
  },
  /**
   * Called when the display value on the element needs to be updated 
   * as a result of a value change. 
   * ojRadioset stores a String value, and this value matches the value
   * of the currently checked radio. So, if we need to set the display value,
   * what this means is we need to 'check' the radio whose value matches the
   * displayValue.
   * 
   * @param {String} displayValue of the new string to be displayed
   * @override
   * @protected
   * @memberof oj.ojRadioset
  */  
  _SetDisplayValue : function (displayValue) 
  {
    var valueFilter, radioWithMatchingValue;
    if (displayValue != null)
    {
      // If we found a radio with a matching value, and it isn't already checked,
      // then check it. If it is already checked, do nothing.
      // If we can't find a radio with a matching value, then we uncheck 
      // all the radios. We do this so that the radio state matches the value option
      // value.
      
      valueFilter = "[value='" + displayValue + "']"; 
      if (valueFilter !== undefined && this.$radios !== undefined)
      {
        radioWithMatchingValue = 
            this.$radios.filter(valueFilter);
        // found a radio with a matching value
        if (radioWithMatchingValue !== undefined && radioWithMatchingValue.length > 0)
        {
          // if not already checked, then mark as checked.
          if (!radioWithMatchingValue.prop('checked'))
          {
            radioWithMatchingValue._ojRadioCheckbox("option", "checked", true);
          }
        }
        else
        {
          // did not find any radios with a matching value, so uncheck
          // all of them.
          this.$radios._ojRadioCheckbox("option", "checked", false);
        }
      }
    } 
  },
  /**
   * Returns the element's value. Normally, this is a call to this.element.val(),
   * but in the case of ojRadioset, the element's value is really the value
   * of the checked radio in the set.
   * @override
   * @protected
   * @memberof oj.ojRadioset
   */
  _GetElementValue : function () 
  {
    // "input:checked" selects radios that are currently checked as 
    // reflected in their boolean (true or false) checked property, 
    // which is affected when the user clicks the radio for example.
    // for radio, there will be one or none checked; 
    // if none are checked, return null (checkedRadio.val() is undefined if nothing is checked)
    var checkedRadio = this.$radios.filter(":checked");
    if (checkedRadio.length === 0)
      return null;
    else
      return checkedRadio.val();
  },
          
 
 
  
  /**
   * Returns the default styleclass for the component. Currently this is 
   * used to pass to the _ojLabel component, which will append -label and 
   * add the style class onto the label. This way we can style the label
   * specific to the input component. For example, for inline labels, the
   * radioset/checkboxset components need to have margin-top:0, whereas all the
   * other inputs need it to be .5em. So we'll have a special margin-top style 
   * for .oj-label-inline.oj-radioset-label
   * All input components must override
   * 
   * @return {string}
   * @memberof oj.ojRadioset
   * @override
   * @protected
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-radioset";
  },
  /**
   * Returns a jquery object of the elements representing the 
   * content nodes (input type=radio). This is used in EditableValue to add
   * aria-describedby to the input when there is a help icon, to add
   * aria-required and aria-invalid
   * @protected
   * @override
   * @memberof oj.ojRadioset
   */
  _GetContentElement : function ()
  {
    return this._findRadiosWithMatchingName();
  },
   /**
   * Called when a aria-required attribute needs to be set or removed. 
   * Most inputs/selects need aria-required on the input element (aka 'content')
   * But it is not legal to have aria-required on radio/checkboxes.
   * Subclasses can override to put aria-required where they want.
   * 
   * @param {Object=} value the current value of the required option
   * @memberof oj.ojRadioset
   * @instance
   * @protected
   */
  _RefreshAriaRequired : function (value)
  {
    var ariaValue, rootNode = this.uiRadioset;

    ariaValue = value; //value === "required" ? true : false;
    if (ariaValue && rootNode) 
    {
      rootNode.attr("aria-required", ariaValue);
    }
    else
    {
      rootNode.removeAttr("aria-required");
    }
  }, 
  /**
   * Note that _setOption does not get called during create in the super class. 
   * It only gets called when the component has already been created.
   * @override
   * @private
   */
  _setOption : function (key, value)
  {
    this._superApply(arguments);
        
    if ( key === "disabled" ) 
    {
      this.$radios.each(function() 
      {
        // this is the technique to use to call package-private functions
        // Calling it like this.$radios.ojRadioCheckbox("__setAncestorComponentDisabled",value)
        // gives an error because jquery prevents you from calling functions with an "_"
        // 
        // This is how we handle 'disabled' for radioset. We don't change the radiocheckbox
        // component's disabled option ever since if we do that we've lost what the initial disabled
        // state is (we store the disabled dom value from the radio into its disabled option)
        // and we need that when we refresh. Instead what we do
        // is we mark if its ancestor (the radioset) is disabled or not. Then, when we render
        // out the radios 'disabled' state, like oj-disabled, we look to see if it is 'effectively
        // disabled' (see _IsEffectivelyDisabled call in ojRadioCheckbox), that is if its 
        // option is disabled OR its ancestor (the radioset) is disabled.
        $( this ).data("oj-_ojRadioCheckbox").__setAncestorComponentDisabled(value);
      });
 
      this.$radios._ojRadioCheckbox("refresh");
    }
  },
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-radioset-inputs</b>: the radioset's input elements</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof oj.ojRadioset
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    var node = this._super(locator), subId;
    if (!node)
    {
      subId = locator['subId'];
      if (subId === "oj-radioset-inputs") {
        node = this.$radios;
      }
    }
    
    // Non-null locators have to be handled by the component subclasses
    return node || null;
  }, 
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function ()
  {  
    if (this.$radios)
    {
      this.$radios._ojRadioCheckbox( "destroy" );
    }
    this._RestoreAttributes(); //remove when _RestoreAttributes is uncommented from jqueryui-base
    return this._super();
  }
  /**** end internal widget functions ****/ 
 
  /**
   * Removes the radioset functionality completely. 
   * This will return the element back to its pre-init state.
   * 
   * <p>This method does not accept any arguments.
   * 
   * @method
   * @name oj.ojRadioset#destroy
   * @memberof oj.ojRadioset
   * @instance
   * 
   * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
   * $( ".selector" ).ojRadioset( "destroy" );
   */
});

//////////////////     SUB-IDS     //////////////////


/**
 * <p>Sub-ID for the radioset's radios.
 * 
 * <p>See the <a href="#getNodeBySubId">getNodeBySubId</a> and 
 * <a href="#getSubIdByNode">getSubIdByNode</a> methods for details.
 * 
 * @ojsubid
 * @member
 * @name oj-radioset-inputs
 * @memberof oj.ojRadioset
 * @instance
 * 
 * @example <caption>Get the nodes for the radios:</caption>
 * var nodes = $( ".selector" ).ojRadioset( "getNodeBySubId", {'subId': 'oj-radioset-inputs'} );
 */


/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
/*!
 * JET Radio This component is private. @VERSION
 */
/**
 * The _ojRadio component enhances a browser input element into one that is 
 * of type=radio. This is a private component used by ojRadioset.
 * 
 * <h3>Events:</h3>
 * <ul>
 *   <li>clicked/checked?<p>
 *   Triggered if the checkbox is clicked; or if the checkbox was checked programatically
 *   with the checked option.
 *   </li>
 * </ul>
 * 
 * @class
 * @private
 * @constructor
 * @name oj._ojRadioCheckbox
 * @augments oj.baseComponent TODO: Should I extend this? 
 * Pros: it gives me oj-disabled/oj-enabled. (easy to add myself)
 * Cons: It gives me tooltip stuff that I don't want. I want that on the div or on the first checkbox only.
 * Pro/Con?: it rewrites required for me if it is on the dom node, but then it makes it required??? Should I rewrite required or don't care?
 */
oj.__registerWidget("oj._ojRadioCheckbox", $['oj']['baseComponent'],
{
  version : "1.0.0",  
  defaultElement : "<input>", 
  widgetEventPrefix : "oj", 
  options : 
  {	 
    /** 
     * First we look for the disabled option to be explicitly set. If not, then
     * we look if disabled is on the dom. If null, disabled defaults to false.
     * @expose 
     * @type {?boolean|undefined}
     * @default <code class="prettyprint">false</code>
     * @public
     * @instance
     * @memberof oj._ojRadioCheckbox
     */
    disabled: null,
    /** 
     * First we look for the checked option to be explicitly set. If not, then
     * we look if checked is on the dom. If null, checked defaults to false.
     * @expose 
     * @type {?boolean}
     * @public
     * @instance
     * @memberof oj._ojRadioCheckbox */
    checked : null,
    /** 
     * First we look for the disabled option to be explicitly set. If not, then
     * we look if disabled is on the dom. If null, disabled defaults to false.
     * @expose 
     * @type {?boolean}
     * @default <code class="prettyprint">false</code>
     * @public
     * @instance
     * @memberof oj._ojRadioCheckbox
     */
     type: null	
  },
  /**** start Public APIs ****/
  /**
   * 
   * <p>This method does not accept any arguments.
   * 
   * @public
   * @expose
   * @memberof oj.RadioCheckbox 
   * @return {jQuery} the label(s) for the checkbox/radio input
  */
  label : function ()
  {
    if (this.$label === undefined)
    {
      this.$label = this._getLabelsForElement();
    }
    return this.$label;
  },  
  /**
   * @expose 
   * @memberof oj._ojRadioCheckbox
   * @instance
   * @override
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" )._ojRadioCheckbox( "refresh" );
   */
  refresh: function() 
  {
    this._super();
    this._setup();
  },    
  /**
   * Returns a jQuery object containing the element visually representing the checkbox. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof oj._ojRadioCheckbox
   * @instance
   * @return {jQuery} the checkbox or radio
  */
  widget : function ()
  {
      return this.uiRadioCheckbox;
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/   
 /**
  * Called at component create time primarily to initialize options, often using DOM values. This 
  * method is called before _ComponentCreate is called, so components that override this method 
  * should be aware that the component has not been rendered yet. The element DOM is available and 
  * can be relied on to retrieve any default values. <p> 
  * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors
  * @param {?Object} constructorOptions - options passed into the widget constructor
  * 
  * @memberof oj._ojRadioCheckbox
  * @instance
  * @protected
  */
  _InitOptions: function(originalDefaults, constructorOptions)
  {
    this._super(originalDefaults, constructorOptions);
    // CHECKED:
    // if options.checked is not set, or not valid, get it from the element
    // if options.checked is set to a valid value (boolean), set it on the 
    // element to keep the two in sync (we do this in _AfterCreate -> _setup)
    // TODO: throw an Error if the options.checked or disabled is set to something other than a boolean!
    if (this.options.checked === null)
    {
      // !! ensures it is a boolean
      this.options.checked = this.element.attr("checked") !== undefined ? 
          !!this.element.prop("checked") : false;
    }
    else if (typeof this.options.checked !== "boolean")
    {
      throw new Error("checked option must be a boolean");
    }
    // DISABLED:
    // if options.disabled is not set, or not valid, get it from the element
    // if options.disabled is set to a valid value (boolean), set it on the 
    // element to keep the two in sync (we do this in _AfterCreate -> _setup)
    if (this.options.disabled === null)
    {
      // !! ensures it is a boolean
      this.options.disabled = this.element.attr("disabled") !== undefined ? 
          !!this.element.prop("disabled") : false;
    }
    else if (typeof this.options.disabled !== "boolean")
    {
      throw new Error("disabled option must be a boolean");
    } 
	
	// TYPE:
	// Get's the type which will be either radio or checkbox
    this.options.type = this.element.prop( "type" );
  },
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @instance
   * @memberof oj._ojRadioCheckbox
   */
  _ComponentCreate: function()
  {
    this._super();

    var type = this.options.type;
    if (type == "checkbox") {
        this.uiRadioCheckbox = this.element.addClass("oj-checkbox oj-component");
        this.$label = this._getLabelsForElement();
        this.$label.addClass("oj-checkbox-label");
    }
    else if (type == "radio") {
        this.uiRadioCheckbox = this.element.addClass("oj-radio oj-component");
        this.$label = this._getLabelsForElement();
        this.$label.addClass("oj-radio-label");
    }	
    
    // oj-hover/oj-focus/oj-active should be added/removed in code as needed, 
    // however these should only be added when the item is enabled. 
    // When the item is disabled these classes should not be added.
    var self = this;
    this._hoverable( this.element );
    this._focusable( this.element );
    this._activeable( this.element );
    // loop through each label
    $.each(self.$label, function ()
    {
      self._hoverable(this);
      self._focusable(this);
      self._activeable(this);
    });
    this._on(this._events);    
  },
  /**
   * This is where we do things right after the component was created.
   * this._super should be called first.
   * 
   * @override
   * @memberof oj._ojRadioCheckbox
   * @instance
   * @protected
   */
  _AfterCreate: function()
  {
    this._super();
    this._setup();

  },
  /* _setup called during creation and refresh */
  _setup : function() 
  {
    this._renderDisabled();

    // set checked checkbox or radio dom if component checked option is true
    if (this.options.checked)
    {
      this._setOption("checked", true);
    }
    else
    {
      this._setOption("checked", false);
    }
  },
  _renderDisabled : function()
  {
    var effectivelyDisabled = this._IsEffectivelyDisabled();
    if (effectivelyDisabled)
    {
      // set the dom to show DISABLED, but do NOT change the disabled option!
      // 
      // when a dom element supports disabled, use that, and not aria-disabled.
     // having both is an error.
     this.element.prop("disabled", true).removeAttr( "aria-disabled")
     .removeClass("oj-enabled").addClass("oj-disabled");

     this.$label.removeClass("oj-enabled")
     .addClass("oj-disabled");
    }
    else // option not set to disabled. nor is parent. On refresh this is ok, since we get it from the option.
    {
      // when a dom element supports disabled, use that, and not aria-disabled.
      // having both is an error.
      this.element.prop("disabled", false)
      .removeAttr( "aria-disabled").removeClass("oj-disabled")
      .addClass("oj-enabled");
      this.$label.addClass("oj-enabled")
      .removeClass("oj-disabled");      
    }
  },
  _events : 
  {

  },
  /**
   * @override
   * @private
   */
  _setOption : function (key, value)
  {

    this._superApply(arguments);

    if (key === "disabled")
    {
      value = !!value;
      this._renderDisabled(value);
    }
 
    if (key === "checked")
    {
      if (value)
      {
        this.element.prop("checked", true);
      }
      else 
      {
        this.element.prop("checked", false);
      }
      this.element.toggleClass("oj-selected", value);
    }
  }, 
  /**
   * Returns the list of labels for the element. Most likely this will be 
   * one label, not multiple labels.
   * We do not guarantee that the returned list is live
   * We do not guarantee that the returned list is in document order
   * We first check if we are nested in a label, and then we check a jquery 
   * selector query on <label>s with a 'for' id equal to our id.
   * NOTE: The .labels DOM property does not work on most browsers, so we don't use it.
   * e.g,
   * <pre>
   * <input id="opt3" type="checkbox" name="rb" value="opt3">
   * <label class="oj-choice-label" for="opt3">Checkbox Option 3</label>
   * </pre>
   * @private
   */
  _getLabelsForElement: function() 
  {
    // .closest("label") - For each element in the set, get the first element   
    // that matches the selector by testing the element itself and traversing up 
    // through its ancestors in the DOM tree.   
    var labelClosestParent = this.element.closest("label");
    var id = this.element.prop("id");
    var labelForQuery = "label[for='" + id + "']";
    // combine these two query results to return the label we are nested in
    //  and/or the label with the for attribute pointing to the checkbox's id.
    return labelClosestParent.add($(labelForQuery)); 
  },
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-radiocheckbox-input</b>: the radio/checkbox's input</li>
   * <li><b>oj-radiocheckbox-label</b>: the radio/checkbox's label</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof oj._ojRadioCheckbox
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    var node = this._super(locator);    
    if (!node)
    {
      var subId = locator['subId'];
      if (subId === "oj-radiocheckbox-input") {
        node = this.element[0];
      }
      if (subId === "oj-radiocheckbox-label") {
        // this.label() returns a jquery object. we want to return a dom element
        node = this.label()[0];
      }
    }
    // Non-null locators have to be handled by the component subclasses
    return node || null;
  },  
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function ()
  {   
    var type = this.options.type;
    // this.$label is the label for the checkbox/radio, NOT the label for the radioset/checkboxset.
    // We don't save and restore these attributes in base class, so we need to clean up ourselves
    if (type == "checkbox") 
    {
      this.$label.removeClass("oj-enabled oj-disabled oj-checkbox-label");
    }
    else if (type == "radio") 
    {
      this.$label.removeClass("oj-enabled oj-disabled oj-radio-label");
    }
    this._RestoreAttributes(); //remove when _RestoreAttributes is uncommented from jqueryui-base
    return this._super();
  }
  
  /**** end internal widget functions ****/ 
 
});
/**
 * An object used for automation verification of legend items
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.LegendItem = function(data) {
  this._data = data;
};

/**
 * Returns the text of a legend item
 * @returns {String} The legend item text
 * @export
 */
oj.LegendItem.prototype.getText = function() {
  return this._data ? this._data['text'] : null;
};
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

/**
 * @class 
 * @name oj.ojLegend
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="legendOverview-section">
 *   JET Legend Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#legendOverview-section"></a>
 * </h3>
 * 
 * <p>Legend component for JET.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojLegend',
 *   orientation: 'vertical',
 *   sections: [{text : "Database"},
 *              {text : "Middleware"},
 *              {text : "Applications"}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="legendOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#legendOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/legend.xml">here</a>.</p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move focus to previous item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move focus to next item.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move focus to previous item (on left).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move focus to next item (on right).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Hides or unhides the data associated with the current item.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>
 *   As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the 
 *   component must be <code class="prettyprint">refresh()</code>ed.
 * </p>
 * 
 * @desc Creates a JET Legend.
 * @example <caption>Initialize the Legend with no options specified:</caption>
 * $(".selector").ojLegend();
 * 
 * @example <caption>Initialize the Legend with some options:</caption>
 * $(".selector").ojLegend({orientation: 'vertical', sections: [{text : "Database"}, {text : "Middleware"}, {text : "Applications"}});
 * 
 * @example <caption>Initialize the Legend via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojLegend'}">
 */
oj.__registerWidget('oj.ojLegend', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj",  
  options: {
    /**
     * Triggered when a category of data items is hidden or shown. TODO: This event is in development and may change.
     * 
     * @property {Object} ui event payload
     * @property {Object} ui.category the category that was filtered on
     * @property {string} ui.type specifies whether the category is being filtered 'in' or 'out'
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">categoryFilter</code> callback specified:</caption>
     * $(".selector").ojLegend({
     *   "categoryFilter": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryfilter</code> event:</caption>
     * $(".selector").on("ojcategoryfilter", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojLegend
     * @instance
     */
    categoryFilter : null,
    
    /**
     * Triggered when a category of data items is highlighted. TODO: This event is in development and may change.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.categories the categories that are being highlighted
     * @property {string} ui.type specifies whether highlighting is being turned 'on' or 'off'
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">categoryHighlight</code> callback specified:</caption>
     * $(".selector").ojLegend({
     *   "categoryHighlight": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryhighlight</code> event:</caption>
     * $(".selector").on("ojcategoryhighlight", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojLegend
     * @instance
     */
    categoryHighlight : null
  },
  
  /**
   * @override
   * @memberof! oj.ojLegend
   * @instance
   * @protected
   */
  _CreateDvtComponent : function(context, callback, callbackObj) {
    return DvtLegend.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   * @memberof! oj.ojLegend
   * @instance
   * @protected
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses['oj-legend'] = {'path' : 'textStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-legendTitle'] = {'path' : 'titleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    // TODO HZHANG: Need to support a default sectionTitleStyle property
    styleClasses['oj-legendSectionTitle'] = {'path' : '_sectionTitleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    return styleClasses;
  },
  
  /**
   * @override
   * @memberof! oj.ojLegend
   * @instance
   * @protected
   */
  _GetEventTypes : function() {
    return ['categoryFilter', 'categoryHighlight'];
  },
    
  /**
   * @override
   * @memberof! oj.ojLegend
   * @instance
   * @protected
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null, filterType, highlightType;
    if(type === DvtCategoryHideShowEvent.TYPE_HIDE || type === DvtCategoryHideShowEvent.TYPE_SHOW) {
      filterType = (type === DvtCategoryHideShowEvent.TYPE_HIDE) ? 'out' : 'in';
      this._updateLegendItemVisibility(this.options['sections'], event.getCategory(), filterType);
      this._trigger('categoryFilter', null, {'category': event.getCategory(), 'type': filterType});
    }
    else if(type === DvtCategoryRolloverEvent.TYPE_OVER || type === DvtCategoryRolloverEvent.TYPE_OUT) {
      highlightType = (type === DvtCategoryRolloverEvent.TYPE_OVER) ? 'on' : 'off';
      this._trigger('categoryHighlight', null, {'categories': [event.getCategory()], 'type': highlightType});
    }
    else {
      this._super(event);
    }
  },
  
  /**
   * Updates item visibility state in options for categoryFilter events
   * @param {Array} sections An array of legend sections
   * @param {String} category The category of the categoryFilter event
   * @param {String} filterType The filtered state: out for hidden or in for visible.
   * @private
   */
  _updateLegendItemVisibility : function(sections, category, filterType) {
    if (!sections)
      return;
    for (var i = 0; i < sections.length; i++) {
      if (!sections[i]['items']) {
        this._updateLegendItemVisibility(sections[i]['sections'], category, filterType);
      } else {
        var items = sections[i]['items'];
        for (var j = 0; j < items.length; j++) {
          if ((items[j]['id'] && items[j]['id'] == category) || 
            (!items[j]['id'] && items[j]['text'] == category)) {
            items[j]['categoryVisibility'] = (filterType == 'out' ? 'hidden' : 'visible');
          }
        }
      }
    }
  },
  
  /**
   * Returns the subcomponent node represented by the documented locator attribute values.
   * Test authors should target legend sub elements using the following locators:
   * <ul>
   *   <li>section[sectionIndex] - A legend indexed by its position in the legend's section array</li>
   *   <li>section[sectionIndex]:item[itemIndex] - A legend item indexed by its position in its parent section's
   *                                               item array and its parent's sectionIndex</li>
   * </ul>
   * @override
   * @expose
   * @memberof! oj.ojLegend
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   *        whose value is a string, documented by the component, that allows 
   *        the component to look up the subcomponent associated with that 
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one 
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component 
   *        expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
  getNodeBySubId : function(locator) {
    return this._super(locator);
  },
  
  /**
   * Returns the subId string for the given child DOM node. Valid legend subIds include:
   * <ul>
   *   <li>section[sectionIndex] - A legend indexed by its position in the legend's section array</li>
   *   <li>section[sectionIndex]:item[itemIndex] - A legend item indexed by its position in its parent section's
   *                                               item array and its parent's sectionIndex</li>
   * </ul>
   * @override
   * @expose
   * @memberof! oj.ojLegend
   * @instance
   * @param {Element} node The subcomponent node used by the component to lookup the subId string
   * @return {string|null} - the subId for the DOM node or null when none is found
   */
  getSubIdByNode:function(node) {
    return this._super(node);  
  },
  
  /**
   * Returns the legend title for automation testing verification.
   * @return {String} The legend title
   * @expose
   * @instance
   * @memberof! oj.ojLegend
   */
  getTitle : function() {
    var auto = this._component.getAutomation();
    return auto.getTitle();
  },
  
  /**
   * Returns a LegendSection  object for automation testing verification.
   * @param {Array} subIdPath The array of indices in the subId for the desired legend section
   * @return {Object} An object containing data for the legend section at the given subIdPath, or null if none exists
   * @expose
   * @instance
   * @memberof! oj.ojLegend
   */
  getSection : function(subIdPath) {
    var auto = this._component.getAutomation();
    return new oj.LegendSection(auto.getSection(subIdPath));
  },
  
  /**
   * Returns a LegendItem object for automation testing verification.
   * @param {Array} subIdPath The array of indices in the subId for the desired legend item
   * @return {Object} An object containing data for the legend item at the given subIdPath, or null if none exists
   * @expose
   * @instance
   * @memberof! oj.ojLegend
   */
  getItem : function(subIdPath) {
    var auto = this._component.getAutomation();
    return new oj.LegendItem(auto.getItem(subIdPath));
  },
          
  /**
   * Returns the preferred size of the legend, given the available width and height.
   * @param {Number} width The available width.
   * @param {Number} height The available height.
   * @return {Object} An object containing the preferred width and height.
   * @expose
   * @instance
   * @memberof! oj.ojLegend
   */
  getPreferredSize : function(width, height) {
    var dims = this._component.getPreferredSize(this.options, width, height);
    return {'width': dims.getWidth(), 'height': dims.getHeight()};
  }
});
/**
 * An object used for automation verification of legend sections
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.LegendSection = function(data) {
  this._data = data;
};

/**
 * Returns the title of a legend section
 * @returns {String} The legend section title
 * @export
 */
oj.LegendSection.prototype.getTitle = function() {
  return this._data ? this._data['title'] : null;
};

/**
 * Returns a nested section within a legend section
 * @param {Number} sectionIndex The position of the desired section in the sections array
 * @returns {Object} The legend section
 * @export
 */
oj.LegendSection.prototype.getSection = function(sectionIndex) {
  return this._data['sections'] ? new oj.LegendSection(this._data['sections'][sectionIndex]) : null;
};

/**
 * Returns an item within a legend section
 * @param {Number} itemIndex The position of the desired item in the items array
 * @returns {Object} The legend item
 * @export
 */
oj.LegendSection.prototype.getItem = function(itemIndex) {
  return this._data['items'] ? new oj.LegendItem(this._data['items'][itemIndex]) : null;
};


/*!
 * jQuery UI Popup @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.position.js
 */(function ()
{

  /**
   * List of all pseudo marker selectors that defines rules for where a tail is aligned.
   * @private
   * @const
   */
  var _TAIL_STYLES = ["oj-left", "oj-center", "oj-right", "oj-top", "oj-middle", "oj-bottom"];

  /**
   * Mapping of horizontal-vertical (x,y) positon using alignment to jet tail pseudo marker selectors.
   *
   * horizontal: right, left, center
   * vertical: top, bottom, middle
   *
   * @private
   * @const
   */
  var _TAIL_ALIGN_RULES = 
  {
    'right-top' : 'oj-right oj-top', 'right-middle' : 'oj-right oj-middle', 'right-bottom' : 'oj-right oj-bottom', 'left-top' : 'oj-left oj-top', 'left-middle' : 'oj-left oj-middle', 'left-bottom' : 'oj-left oj-bottom', 'center-top' : 'oj-center oj-top', 'center-middle' : 'oj-left oj-middle', 'center-bottom' : 'oj-center oj-bottom'
  };

  /**
   * @class
   * @name oj.ojPopup
   * @augments oj.baseComponent
   *
   * @classdesc
   * <h3 id="popupOverview-section">
   *   JET Popup Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#popupOverview-section"></a></h3>
   *
   * <p>Description: Themeable, WAI-ARIA-compliant popup that can display arbitrary content.</p>
   *
   * <p>A JET popup can be created from a block ( <code class="prettyprint">&lt;div></code> ) or inline element
   *   ( <code class="prettyprint">&lt;span></code> ).  This element will become the immediate child of the content element.
   *   Dynamic content can be inserted under this element.</p>
   *
   * <pre class="prettyprint">
   * <code>&lt;span id="popup">
   *   Hello World!
   * &lt;/span>
   * </code></pre>
   *
   * <p>For WAI-ARIA compliance, JET automatically adds <code class="prettyprint">role="tooltip"</code> to
   * the root popup dom element.  It also adds the <code class="prettyprint">aria-describedby="popup-id"</code>
   * to the launcher while the popup is open.
   * </p>
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Use</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Forward or backward (<kbd>Shift+Tab</kbd>) tabbing will traverse within the content of the popup.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>F6</kbd></td>
   *       <td>Focus can be toggled from the launcher to the popups content and back using the F6 function key.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Esc key from within the content of the popup or from the launcher will close the popup.</td>
   *     </tr>
   * </tbody></table>
   * <br/><br/>
   *   
   * <h3 id="accessibility-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
   * </h3>
   * 
   * <p>One point often overlooked is making the gestures that launch a popup accessible.
   *   There are no constraints to what events a page developer might choose to trigger opening a
   *   popup.  The choice should be accessible for screen reader users.  Page 
   *   developers should take care when using mouse events to trigger opening of a popup.
   *   This is especially important if the content of the popup can't be derived from other 
   *   visible areas on the page. In cases that mouseover, mouseout, mouseenter, mouseleave and hover
   *   events are used to launch popups, there needs to be a keyboard functional equivalency.
   * </p> 
   * 
   * <h3 id="eventHandling-section">
   *   Event Handling
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
   * </h3>
   * <ul>
   *  <li>beforeClose(event, ui) - Triggered before a popup closes. Event can prevent closing the popup.</li>
   *  <li>beforeOpen(event, ui) - Triggered before a popup closes. Event can prevent opening the popup.</li>
   *  <li>close(event, ui) - Triggered after the popup has closed.</li>
   *  <li>create(event, ui) - Triggered after the component has been bound to an associated dom element.</li>
   *  <li>focus(event, ui) - Triggered when initial focus is established on opening, depending on the value of the initalFocus 
   *      option, or <kbd>F6</kbd> focus toggle from the associated launcher.</li>
   *  <li>open(event, ui) - Triggered after the popup has been made visible.</li>
   * </ul>
   *
   * @desc Creates a JET Popup.  If called after the popup is already created, it is equivalent to the
   * "set many options" overload of <code class="prettyprint">option()</code>.
   *
   * @param {Object=} options a map of option-value pairs to set on the component
   *
   * @example <caption>Initialize the popup with no options specified:</caption>
   * $( ".selector" ).ojPopup();
   *
   * @example <caption>Initialize the popup with behaviors of a notewindow:</caption>
   * $( ".selector" ).ojPopup({initialFocus: 'none', autoDismiss: 'focusLoss', tail: 'simple'});
   *
   * @example <caption>Initialize a popup via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
   * &lt;div id="popup1" data-bind="ojComponent: {component: 'ojPopup'}">This is a popup!&lt;/div>
   *
   */
  oj.__registerWidget("oj.ojPopup", $['oj']['baseComponent'], 
  {
    widgetEventPrefix : "oj",
    options : 
    {
      /**
       * Defines conditions that will cause an open popup to auto close dismiss.  A value of <code class="prettyprint">focusLoss</code>
       * defines the dismissal condition where focus has left the content of the popup or from the associated
       * launcher.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"focusLoss"</code>
       * @ojvalue {string} "none" disables auto dismissal behaviors.
       * @ojvalue {string} "focusLoss" defines auto dismissal behavior when focus leaves the content of the popup or
       *                   associated launcher.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">autoDismiss</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "autoDismiss": "focusLoss" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">autoDismiss</code> option, after initialization:</caption>
       * // getter
       * var autoDismiss = $( ".selector" ).ojPopup( "option", "autoDismiss" );
       * // setter
       * $( ".selector" ).ojPopup( "option", "autoDismiss", "none" );
       */
       autoDismiss: 'focusLoss',
      /**
       * Defines the presents of border, shadow and background color of the root popup dom.  Value of
       * <code class="prettyprint">none</code> applies the <code class="prettyprint">oj-popup-no-chrome</code>
       * selector defined by the active theme to the root dom of the popup to remove the default chrome.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"default"</code>
       * @ojvalue {string} "default" describes the popups border, shadow, and background color defined by the active theme.
       * @ojvalue {string} "none" turns off the outer chrome defined by the active theme.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">chrome</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "chrome": "none" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">chrome</code> option, after initialization:</caption>
       * // getter
       * var chrome = $( ".selector" ).ojPopup( "option", "chrome" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "chrome", "none" );
       */
      chrome : 'default', 
      /**
       * Determines if the popup should steal focus to its content when initially open. A value of <code class="prettyprint">none</code>
       * prevents the popup from grabbing focus when open.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"none"</code>
       * @ojvalue {string} "none" prevents the popup from stealing focus when open.
       * @ojvalue {string} "initialFocus" defines that a popup should grab focus to its content when open.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">initialFocus</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "initialFocus": "none" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">initialFocus</code> option, after initialization:</caption>
       * // getter
       * var initialFocus = $( ".selector" ).ojPopup( "option", "initialFocus" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "initialFocus", "none" );
       */
      initialFocus : 'none',
      /**
       * <p>Position object is defined by the jquery position API and is used to establish the location the
       * popup will appear relative to another element.  The postion object contains the following properties:
       * "my", "at", "of", "colision", "using" and "within".</p>
       *
       * <p>The "my" and "at" properties defines aligment points relative to the popup and other element.  The
       * "my" property represents the popups alignment where the "at" property represents the other element
       * that can be identified by "of" or defauts to the launcher when the popup opens.  The values of these
       * properties describe a "horizontal vertical" location.</p>
       *
       * <p>Acceptable "horizontal" alignments values are: "right", "center", "left", "start", "end".  Note: Jet has
       * added "start" and "end" options to be more RTL friendly.  The Jet values of "start" and "end" normalize
       * to "right" or "left" depending on the direction of the document.</p>
       *
       * <p>Acceptable "vertical" alignment values are: "top", "center" and "bottom".</p>
       *
       * The following is a short summary of the most interesting positon properties:
       * <ul>
       *   <li><code class="prettyprint">my</code> - A "vertical horizontal" rule that defines the location of the popup
       *       used for alignment.</li>
       *   <li><code class="prettyprint">at</code> - A "vertical horizontal" rule that defines the location of the
       *       other element for used alignment. The other element is defined by "of" or defaults to the open launcher
       *       argument if not specified.</li>
       * </ul>
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {Object}
       * @default <code class="prettyprint">{my: "start top", at: "start bottom", collision: "flip"}</code>
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">position</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "position": {"my": "left top", "at": "right top"} } );
       *
       * @example <caption>Get or set the <code class="prettyprint">position</code> option, after initialization:</caption>
       * // getter
       * var position = $( ".selector" ).ojPopup( "option", "position" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "position", {"my": "start bottom", "at": "end+14 top" } );
       */
      position : 
      {
        /**
         * Defines which position on the popup to align with the target ("of") element: "horizontal vertical" alignment.
         * A single value such as "right" will be normalized to "right center", "top" will be normalized to "center top"
         * (following CSS convention). Acceptable horizontal values: "left", "center", "right".
         * Acceptable vertical values: "top", "center", "bottom". Example: "left top" or "center center".
         * Each dimension can also contain offsets, in pixels or percent, e.g., "right+10 top-25%". Percentage offsets are relative
         * to the popup being positioned.
         *
         *
         * @expose
         * @memberof! position#
         * @alias position.my
         * @type {string}
         * @default <code class="prettyprint">left top</code>
         */
         'my' : 'start top', 
        /**
         * Defines which position on the target element ("of") to align the positioned element against: "horizontal vertical"
         * alignment. See the my option for full details on possible values. Percentage offsets are relative to the target element.
         *
         * @expose
         * @type {string}
         * @memberof! position#
         * @alias position.at
         * @default <code class="prettyprint">left bottom</code>
         */
         'at' : 'start bottom', 
        /**
         * Which element to position the popup against.  The default is the <code class="prettyprint">launcher</code> argument
         * passed to the <code class="prettyprint">open</code> method. If you provide a selector or jQuery object,
         * the first matching element will be used. If you provide an event object, the pageX and pageY properties
         * will be used.
         *
         * @expose
         * @memberof! position#
         * @alias position.of
         * @type {string}
         * @default <code class="prettyprint">''</code>
         */
         'of' : '', 
        /**
         *  When the positioned element overflows the window in some direction, move it to an alternative position. Similar to my and
         *  at, this accepts a single value or a pair for horizontal/vertical, e.g., "flip", "fit", "fit flip", "fit none".
         *
         *  <ul>
         *    <li>"flip": Flips the element to the opposite side of the target and the collision detection is run again to see if it
         *        will fit. Whichever side allows more of the element to be visible will be used.</li>
         *    <li>"fit": Shift the element away from the edge of the window.</li>
         *    <li>"flipfit": First applies the flip logic, placing the element on whichever side allows more of the element to be
         *        visible. Then the fit logic is applied to ensure as much of the element is visible as possible.</li>
         *    <li>"none": Does not apply any collision detection.</li>
         *  </ul>
         * @expose
         * @memberof! position#
         * @alias position.collision
         * @type {string}
         * @default <code class="prettyprint">flip</code>
         */
         'collision' : 'flip'
      },
      /**
       * Determines if a decoration will be displayed from the popup that points to the element the popup is aligned to.
       * The <code class="prettyprint">simple</code> value enables the tail defined by the current theme.  In addtion,
       * the <code class="prettyprint">oj-popup-tail-simple</code> selector will be applied to the root dom element.  This
       * is to allow the box-shadow, z-index and other chrome styling to vary per tail decoration.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"none"</code>
       * @ojvalue {string} "none" no decoration will be displayed from the popup pointing to the launcher.
       * @ojvalue {string} "simple" enables showing the tail defined by the current theme.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">tail</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "tail": "simple" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">tail</code> option, after initialization:</caption>
       * // getter
       * var tail = $( ".selector" ).ojPopup( "option", "tail" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "tail", "simple" );
       */
      tail : 'none', 

      // Events 
      /**
       * Triggered before the popup is launched via the <code class="prettyprint">open()</code> method.
       * The launch can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       * 
       * @example <caption>Initialize the popup with the <code class="prettyprint">beforeOpen</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "beforeOpen": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeopen</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeopen", function( event, ui ) {} );
       */
      beforeOpen : null, 
      /**
       * Triggered after the popup is launched via the <code class="prettyprint">open()</code> method.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">open</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "open": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojopen</code> event:</caption>
       * $( ".selector" ).on( "ojopen", function( event, ui ) {} );
       */
      open : null, 
      /**
       * Triggered before the popup is dismissed via the <code class="prettyprint">close()</code> method.
       * The close can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">beforeClose</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "beforeClose": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeclose</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeclose", function( event, ui ) {} );
       */
      beforeClose : null, 
      /**
       * Triggered after the popup is dismissed via the <code class="prettyprint">close()</code> method.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">close</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "close": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojclose</code> event:</caption>
       * $( ".selector" ).on( "ojclose", function( event, ui ) {} );
       */
      close : null,
      /**
       * Triggered after focus has been transfered to the popup. This will occur after the 
       * <code class="prettyprint">open()</code> method is called, depending on the value
       * of the <code class="prettyprint">initialFocus</code> option.  It's also triggered when using the
       * <kbd>F6</kbd> key to toggle focus from the associated launcher element to the content of the popup.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">focus</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "focus": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojfocus</code> event:</caption>
       * $( ".selector" ).on( "ojfocus", function( event, ui ) {} );
       */
      focus : null
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @protected
    * @override 
    * @return {void}
    */
     _ComponentCreate: function ()
    {
      this._super();
      
      var rootStyle = this._getRootStyle();
      var rootElement = $("<div>");
      this._rootElement = rootElement.hide().addClass(rootStyle).attr("aria-hidden", "true");
      rootElement.addClass("oj-helper-reset-inheritable oj-component");

      var content = $("<div>").addClass([rootStyle, "content"].join("-"));
      content.appendTo(rootElement);
      this.element.after(rootElement);
      this.element.appendTo(content);
      this.element.show();

      this._createTail();
      this._setChrome();
      this._createLiveRegion();

      // callback that overrides the positon['using'] for setting the tail.
      this._usingCallback = $.proxy(this._usingHandler, this);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @protected
    * @override 
    * @return {void}
    */
    _destroy : function ()
    {
      this._super();

      if (this.isOpen())
        this.close();

      this._destroyTail();
      this._destroyLiveRegion();
      delete this._usingCallback;

      this._rootElement.replaceWith(this.element);
      this.element.hide();

    },
    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the generated wrapper.
     * This method does not accept any arguments.
     *
     * @expose
     * @name oj.ojpopup#widget
     * @memberof! oj.ojPopup
     * @instance
     * @return {jQuery} the popup
     *
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojPopup( "widget" );
     */
    widget : function ()
    {
      return this._rootElement;
    },
    /**
     * Opens the popup. This method accepts two arguments but both are optional.
     *
     * @expose
     * @method
     * @name oj.ojPopup#open
     * @memberof! oj.ojPopup
     * @instance
     * @param {?(string|jQuery|Element)} launcher jquery object, jquery selector or dom element that
     *                                   is associated with the popup.
     * @param {?Object} position an element relative to another
     * @return {void}
     * @fires oj.ojPopup#beforeOpen
     * @fires oj.ojPopup#open
     *
     * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
     * var open = $( ".selector" ).ojPopup( "open" );
     */
    open : function (launcher, position)
    {

      if (this.isOpen())
      {
        this.close();

        //if beforeClose handler prevents that action, just bail out.
        if (this.isOpen())
          return;
      }

      this._setLauncher(launcher);

      var rootElement = this._rootElement;
      launcher = this._launcher;
      oj.Assert.assertPrototype(rootElement, jQuery);
      oj.Assert.assertPrototype(launcher, jQuery);

      if (oj.StringUtils.isEmptyOrUndefined(rootElement.attr("id")))
        rootElement.uniqueId();

      if (this._trigger("beforeOpen") === false)
        return;

      this._setPosition(position);


      var options = this.options;
      this._setAutoDismiss(options["autoDismiss"]);

      this._on(true, $(window), 
      {
        'resize' : this._resizeHandler,
        'scroll' : this._resizeHandler
      });
      this._on(true, rootElement, 
      {
        'keydown' : this._keydownHandler
      });
      this._on(true, launcher, 
      {
        'keydown' : this._keydownHandler
      });

      this._addDescribedBy();

      rootElement.removeAttr("aria-hidden");
      rootElement.attr("role", "tooltip");

      position = options["position"];
      rootElement.show();
      var isRtl = this._GetReadingDirection() === "rtl";
      rootElement.position(oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl));

      this._trigger("open");

      this._intialFocus();

      var message = this.getTranslatedString("none" === options["initialFocus"] ?
                                             "ariaLiveRegionInitialFocusNone":
                                             "ariaLiveRegionInitialFocusFirstFocusable");
      this._announceLiveRegion(message);
    },
    /**
     * Closes the popup. This method does not accept any arguments.
     *
     * @expose
     * @method
     * @name oj.ojPopup#close
     * @memberof! oj.ojPopup
     * @instance
     * @return {void}
     * @fires oj.ojPopup#beforeClose
     * @fires oj.ojPopup#close
     *
     * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
     * var close = $( ".selector" ).ojPopup( "close" );
     */
    close : function ()
    {
      if (!this.isOpen())
        return;

      if (this._trigger("beforeClose") === false)
        return;

      // if the content has focus, restore the the launcher
      this._restoreFocus();

      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      oj.Assert.assertPrototype(launcher, jQuery);

      rootElement.hide();
      rootElement.attr("aria-hidden", "true");

      this._removeDescribedBy();
      this._setAutoDismiss();

      var jqWindow = $(window);
      this._off(jqWindow, "resize");
      this._off(jqWindow, "scroll");
      this._off(rootElement, "keydown");
      this._off(launcher, "keydown");

      delete this._launcher;

      var position = this.options["position"];

      // if the open has set the of because one was not provided by default,
      // remove the override to the launcher.
      if (position["_ofo"])
      {
        delete position["_ofo"];
        delete position["of"];
      }

      //clear live region message
      this._announceLiveRegion(null);

      this._trigger("close");
    },
    /**
     * Returns the state of whether the popup is currently open. This method does not accept any arguments.
     *
     * @expose
     * @method
     * @name oj.ojPopup#isOpen
     * @memberof! oj.ojPopup
     * @instance
     * @return {boolean} <code>true</code> if the popup is open.
     *
     * @example <caption>Invoke the <code class="prettyprint">isOpen</code> method:</caption>
     * var isOpen = $( ".selector" ).ojPopup( "isOpen" );
     */
    isOpen : function ()
    {
      return this._rootElement.is(":visible");
    },
    /**
     * Causes the popup to reevaluate its position.  Call this function after 
     * the content of the popup has dynamically changed while the popup is open.
     *
     * <p>This method does not accept any arguments.</p>
     * 
     * @expose
     * @method
     * @name oj.ojPopup#isOpen
     * @memberof! oj.ojPopup
     * @instance
     * @return {void}
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojPopup( "refresh" );
     */
    refresh : function ()
    {
      this._super();

      if (this.isOpen())
        this._resizeHandler();
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @protected
    * @param {string} key option name
    * @param {?Object} value of the target option identified by the key
    * @override
    */
    _setOption : function (key, value)
    {

      var options = this.options;
      switch (key)
      {
        case "tail":
          if (value !== options["tail"])
          {
            this._setTail(value);
          }
          break;
        case "chrome":
          if (value !== options["chrome"])
            this._setChrome(value);
          break;
        case "position":
          this._setPosition(value);
          if (this.isOpen())
            this._resizeHandler();
          // don't call super because setPosition sets the option after creating a new
          // instance.  This prevents the same position instance from getting registered
          // with multiple component instances.
          return;
        case "autoDismiss":
          if (this.isOpen() && value !== options["autoDismiss"])
            this._setAutoDismiss(value);
          break;
      }

      this._superApply(arguments);
    },
   /**
    * Returns the root selector prefix for the popup components.  In the future if the popup is subcassed,
    * this method can be made protected and override to change the root selector names for the target
    * component.
    *
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {string}
    */
    _getRootStyle : function ()
    {
      return "oj-popup";
    },
   /**
    * Handles setting up the target tail.
    *
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} tail option value
    * @return {void}
    */
    _setTail : function (tail)
    {
      this._destroyTail();
      this._createTail(tail);
      this._resizeHandler();
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} tail option value
    * @return {void}
    */
    _createTail : function (tail)
    {
      var tailDecoration = tail ? tail : this.options['tail'];
      if ("none" === tailDecoration)
        return;

      var rootStyle = this._getRootStyle();
      var tailMarkerStyle = [rootStyle, "tail"].join("-");
      var tailStyle = [tailMarkerStyle, tailDecoration].join("-");

      var tailDom = $("<div>").hide().addClass(tailMarkerStyle).addClass(tailStyle);

      // id over "marker style" due to nesting popups in popups
      this._tailId = "#" + tailDom.uniqueId().attr("id");
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      tailDom.appendTo(rootElement);

      // tail "value" style is applied to the root dom for shadow and z-index adjustments
      rootElement.addClass(tailStyle);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {jQuery}
    */
    _getTail : function ()
    {
      var tailId = this._tailId;
      if (!tailId)
        return null;

      return $(tailId);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _destroyTail : function ()
    {

      var tail = this._getTail();
      if (tail)
        tail.remove();

      delete this._tailId;

      var tailDecoration = this.options['tail'];
      var rootStyle = this._getRootStyle();
      var tailStyle = [rootStyle, "tail", tailDecoration].join("-");

      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      rootElement.removeClass(tailStyle);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} chrome option value
    * @return {void}
    */
    _setChrome : function (chrome)
    {
      var chromeDecoration = (chrome ? chrome : this.options["chrome"]);
      var noChromeStyle = [this._getRootStyle(), "no-chrome"].join("-");
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      if ("default" === chromeDecoration && rootElement.hasClass(noChromeStyle))
        rootElement.removeClass(noChromeStyle);
      else if ("none" === chromeDecoration && !rootElement.hasClass(noChromeStyle))
        rootElement.addClass(noChromeStyle);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string|Node|jQuery|null} launcher provided when the popup is open
    * @return {void}
    */
    _setLauncher: function (launcher)
    {
      if (!launcher)
        launcher = $(document.activeElement);
      else if ($.type(launcher) === "string")//id jquery selector    
        launcher = $(launcher);
      else if (launcher.nodeType === 1)//dom element
        launcher = $(launcher);

      // if a jquery collection, select the first dom node not in the popups content
      if (launcher instanceof jQuery && launcher.length > 1)
      {
        var rootElement = this._rootElement;
        oj.Assert.assertPrototype(rootElement, jQuery);

        for (var i = 0;i < launcher.length;i++)
        {
          var target = launcher[0];
          //if (rootElement.has(target).length === 0) {
          if (!oj.DomUtils.isAncestorOrSelf(rootElement[0], target))
          {
            launcher = $(target);
            break;
          }
        }
      }
      else if (!(launcher instanceof jQuery) || //object is not a jq
               ((launcher instanceof jQuery) && launcher.length === 0))// empty jq collection
        launcher = $(document.activeElement);

      oj.Assert.assertPrototype(launcher, jQuery);
      this._launcher = launcher;
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {?Object} position object set as an option or passed as an argument to the open method.
    * @return {void}
    */
    _setPosition : function (position)
    {

      var options = this.options;

      // new postion extends the existing object
      if (position)
        options["position"] = $.extend(options[position], position);

      // grab the updated postion
      position = options["position"];

      var usingCallback = this._usingCallback;
      oj.Assert.assertFunction(usingCallback);

      // if they provided a using function that is not our callback, stash it
      // away so that we can delegate to it in our proxy.
      if ($.isFunction(position["using"]) && position["using"] !== usingCallback)
        position["origUsing"] = position["using"];

      // override with our proxy to handle positioning of the tail
      position["using"] = usingCallback;

      //override "of" alignment node to the launcher if not specified
      var launcher = this._launcher;
      oj.Assert.assertPrototype(launcher, jQuery);

      if (!position["of"])
      {
        position["of"] = launcher;
        position["_ofo"] = true;
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Object} pos "my" element associated with the postion object
    * @param {Object} props directions as to where the element should be moved
    * @return {void}
    */
    _usingHandler : function (pos, props)
    {
      var rootElement = props["element"]["element"];
      oj.Assert.assertPrototype(rootElement, jQuery);

      var tail = this._getTail();
      if (!tail)
      {
        rootElement.css(pos);
        return;
      }

      tail.hide();

      for (var i = 0;i < _TAIL_STYLES.length;i++)
      {
        tail.removeClass(_TAIL_STYLES[i]);
        rootElement.removeClass(_TAIL_STYLES[i]);
      }
      tail.removeAttr("style");

      var alignMnemonic = [props["horizontal"], props["vertical"]].join("-");
      var tailStyle = _TAIL_ALIGN_RULES[alignMnemonic];
      oj.Assert.assertString(tailStyle);
      tail.addClass(tailStyle);
      rootElement.addClass(tailStyle);
      tail.show();

      // adjust the vertical and horizontal positioning to account for the tail
      // so that the page developer doesn't have to factor that in
      if ("left" === props["horizontal"] || "right" === props["horizontal"])
      {
        var tailHOffset = (tail.outerWidth() - 1) * ("left" === props["horizontal"] ? 1 :  - 1);
        pos["left"] = pos["left"] + tailHOffset;
      }
      else if ("center" === props["horizontal"])
      {
        var tailVOffset = (tail.outerHeight() - 1) * ("top" === props["vertical"] ? 1 :  - 1);
        pos["top"] = pos["top"] + tailVOffset;
      }
      rootElement.css(pos);

      // adjustments to the vertical or horizontal centering.  The 50% alignment is from
      // the edge of the tail versus the center of the image.  The tail can't be located
      // at cetner, middle so the vertical alignment wins.
      if ("middle" === props["vertical"])
      {
        var rootHeight = rootElement.height();
        var topPercent = Math.round((((rootHeight / 2) - (tail.outerHeight() / 2)) / rootHeight) * 100);
        tail.css(
        {
          top : topPercent + '%'
        });
      }
      else if ("center" === props["horizontal"])
      {
        var rootWidth = rootElement.width();
        var leftPercent = Math.round((((rootWidth / 2) - (tail.outerWidth() / 2)) / rootWidth) * 100);
        tail.css(
        {
          left : leftPercent + '%'
        });
      }

      var options = this.options;
      var origUsing = options["position"]["origUsing"];
      if (origUsing)
        origUsing(pos, props);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {jQuery=} event jQuery event triggered from a window resize
    * @return {void}
    */
    _resizeHandler : function (event)
    {
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      var position = this.options["position"];
      oj.Assert.assertObject(position);

      var isRtl = this._GetReadingDirection() === "rtl";
      rootElement.position(oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl));
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {?boolean} skipOptionCheck focus established via keyboard versus from open API
    * @return {void}
    */
    _intialFocus : function (skipOptionCheck)
    {
      var options = this.options;
      if (!skipOptionCheck && "none" === options["initialFocus"])
        return;

      if (skipOptionCheck || "firstFocusable" === options["initialFocus"])
      {
        var nodes = this.element.find(":focusable");
        if (nodes.length > 0)
        {
          var first = nodes[0];
          oj.Assert.assertDomElement(first);
          $(first).focus();
        }
        else
        {
          var rootElement = this._rootElement;
          oj.Assert.assertPrototype(rootElement, jQuery);
          rootElement.attr("tabindex", "-1");
          rootElement.focus();
        }

        this._trigger("focus");
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Element} activeElement from the event being handled
    * @return {boolean} <code>true</code> if the active element is within the content of the popup
    */
    _isFocusInPopup : function (activeElement)
    {
      if (!activeElement)
        activeElement = document.activeElement;
      oj.Assert.assertDomElement(activeElement);
      
      // added to avoid automation issues where an active element is not established
      if (!activeElement)
        return false;

      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      // return rootElement.is(activeElement) || rootElement.has(activeElement).length > 0;
      return oj.DomUtils.isAncestorOrSelf(rootElement[0], activeElement);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Element} activeElement from the event being handled
    * @return {boolean} <code>true</code> if the active element the launcher or a decedent of the launcher
    */
    _isFocusInLauncher : function (activeElement)
    {
      if (!activeElement)
        activeElement = document.activeElement;
      oj.Assert.assertDomElement(activeElement);

      var launcher = this._launcher;
      oj.Assert.assertPrototype(launcher, jQuery);

      // return launcher.is(activeElement) || launcher.has(activeElement).length > 0;
      return oj.DomUtils.isAncestorOrSelf(launcher[0], activeElement);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _restoreFocus : function ()
    {

      if (this._isFocusInPopup())
      {
        var launcher = this._launcher;
        oj.Assert.assertPrototype(launcher, jQuery);

        launcher.focus();
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {jQuery.Event|Event} event jquery event wrapper
    * @return {void}
    */
    _keydownHandler : function (event)
    {
      if (event.isDefaultPrevented())
        return;

      var target = event.target;
      oj.Assert.assertDomElement(target);
      if (event.keyCode === 27)
      {
        event.preventDefault();
        this.close();
      }
      else if (event.keyCode === 117)
      {
        //F6 - toggle focus to launcher or popup
        if (this._isFocusInPopup(target))
        {
          event.preventDefault();
          var launcher = this._launcher;
          oj.Assert.assertPrototype(launcher, jQuery);
          launcher.focus();
        }
        else if (this._isFocusInLauncher(target))
        {
          event.preventDefault();
          this._intialFocus(true);
        }
      }
      else if (event.keyCode === 9 && this._isFocusInPopup(target))
      {
        // TAB within popup
        var nodes = this.element.find(":tabbable");
        if (nodes.length > 0)
        {
          var firstNode = nodes[0];
          oj.Assert.assertDomElement(firstNode);

          var lastNode = nodes[nodes.length - 1];
          oj.Assert.assertDomElement(lastNode);

          if (firstNode === target && event.shiftKey)
          {
            //tabbing backwards, cycle focus to last node
            event.preventDefault();
            $(lastNode).focus();
          }
          else if (lastNode === target && !event.shiftKey)
          {
            //tabbing forwards, cycle to the first node
            event.preventDefault();
            $(firstNode).focus();
          }
        }
        else
        {
          // if there is nothing in the popup that is tabbable, handle as a F6
          // toggle to the launcher
          event.preventDefault();
          var launcher = this._launcher;
          oj.Assert.assertPrototype(launcher, jQuery);
          launcher.focus();
        }
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string|null} autoDismiss option value
    * @return {void}
    */
    _setAutoDismiss : function (autoDismiss)
    {

      var documentElement = document.documentElement;
      // unregister any existing handlers, might need to add mouseOut in the future
      var focusLossCallback = this._focusLossCallback;
      if (focusLossCallback)
      {
        documentElement.removeEventListener("mousedown", focusLossCallback, true);
        documentElement.removeEventListener("focus", focusLossCallback, true);
        delete this._focusLossCallback;
      }

      if ("focusLoss" === autoDismiss)
      {
        focusLossCallback = this._focusLossCallback = $.proxy(this._dismissalHandler, this);
        documentElement.addEventListener("mousedown", focusLossCallback, true);
        documentElement.addEventListener("focus", focusLossCallback, true);
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Object} event native dom
    * @return {void}
    */
    _dismissalHandler : function (event)
    {
      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(launcher, jQuery);
      oj.Assert.assertPrototype(rootElement, jQuery);

      var target = event.target;
      oj.Assert.assertDomElement(target);

      // if event target is not under the laucher or popup root dom subtrees, dismiss
      if (!oj.DomUtils.isAncestorOrSelf(launcher[0], target) && !oj.DomUtils.isAncestorOrSelf(rootElement[0], target))
        this.close();
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _addDescribedBy: function () 
    {
      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(launcher, jQuery);
      oj.Assert.assertPrototype(rootElement, jQuery);

      var popupId = rootElement.attr("id");
      var describedby = launcher.attr("aria-describedby");
      var tokens = describedby ? describedby.split(/\s+/) : [];
      tokens.push(popupId);
      describedby = $.trim(tokens.join(" "));
      launcher.attr("aria-describedby", describedby);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _removeDescribedBy: function() {
      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(launcher, jQuery);
      oj.Assert.assertPrototype(rootElement, jQuery);

      var popupId = rootElement.attr("id");
      var describedby = launcher.attr("aria-describedby");
      var tokens = describedby ? describedby.split(/\s+/) : [];
      var index = $.inArray(popupId, tokens);
      if (index !== -1)
        tokens.splice(index, 1);

      describedby = $.trim(tokens.join(" "));
      if (describedby)
        launcher.attr("aria-describedby", describedby);
      else
        launcher.removeAttr("aria-describedby");
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _createLiveRegion: function()
    {
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      // append the aria-live region communicating navigation keys
      var liveRegionId = this._getSubId("ariaLive");
      var liveRegion = this._liveRegion = $( "<div>" );
      liveRegion.attr({'id': liveRegionId, 'role': 'log', 'aria-live': 'polite', 'aria-relevant': 'additions'});
      liveRegion.addClass("oj-helper-hidden-accessible");
      liveRegion.appendTo(document.body);
      rootElement.data("oj-aria-controls", liveRegionId);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} message to be announced in the live region
    * @return {void}
    */
    _announceLiveRegion: function(message)
    {
      var liveRegion = this._liveRegion;
      oj.Assert.assertPrototype(liveRegion, jQuery);
      liveRegion.children().remove();
      if (!oj.StringUtils.isEmpty(message))
        $("<div>").text(message).appendTo(liveRegion);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _destroyLiveRegion: function()
    {
      var liveRegion = this._liveRegion;
      oj.Assert.assertPrototype(liveRegion, jQuery);
      liveRegion.remove();
      delete this._liveRegion;

      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      rootElement.removeData("oj-aria-controls");
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} sub id that will become a composite id prefixed with the components uuid
    * @return {string}
    */
    _getSubId: function(sub)
    {
      return this["uuid"] + "_" + sub;
    }
  });

}
());
/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */
 
/**
 * @class 
 * @name oj.ojRowExpander
 * @augments oj.baseComponent
 *
 * @classdesc
 * <h3 id="rowexpanderOverview-section">
 *   JET RowExpander Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rowexpanderOverview-section"></a>
 * </h3>
 * <p>Description: A JET RowExpander is a component that is primarily used inside the JET Table and JET DataGrid widgets.  It enables hierarchical data to be display in a JET Table and JET DataGrid.</p>
 *
 * <p>To enable expand and collapse of rows, developers must specify oj.FlattenedTreeTableDataSource as data when used within JET Table and oj.FlattenedTreeDataGridDataSource as data when used within JET DataGrid.</p>
 *
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Ctrl+Right Arrow</kbd></td>
 *       <td>Expand the currently focused row that contains a row expander.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+Left Arrow</kbd></td>
 *       <td>Collapse the currently focused row that contains a row expander.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>The location of the row expander will be reversed in RTL reading direction.</p>
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the component containing the row expander (JET Table or JET DataGrid) must be <code class="prettyprint">refresh()</code>ed.  
 */
oj.__registerWidget('oj.ojRowExpander', $['oj']['baseComponent'],
{
    version: "1.0.0",
    widgetEventPrefix: 'oj',
    options:
            {
                /**
                 * The context object obtained from the column renderer (Table) or cell renderer (DataGrid)
                 * 
                 * @expose 
                 * @memberof! oj.ojRowExpander
                 * @instance
                 * @type {Object}
                 * @default <code class="prettyprint">null</code>
                 * 
                 */
                context: null,
                /**
                 * Triggered when a expand is performed on the row expander
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojRowExpander
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {string} ui.rowKey the key of the row expanded
                 * 
                 * @example <caption>Initialize the row expander with the <code class="prettyprint">expand</code> callback specified:</caption>
                 * $( ".selector" ).ojRowExpander({
                 *     "expand": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
                 * $( ".selector" ).on( "ojexpand", function( event, ui ) {} );
                 */
                expand: null,
                /**
                 * Triggered when a collapse is performed on the row expander
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojRowExpander
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {string} ui.rowKey the key of the row collapsed
                 * 
                 * @example <caption>Initialize the row expander with the <code class="prettyprint">collapse</code> callback specified:</caption>
                 * $( ".selector" ).ojRowExpander({
                 *     "collapse": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapse</code> event:</caption>
                 * $( ".selector" ).on( "ojcollapse", function( event, ui ) {} );
                 */
                collapse: null
            },
    classNames:
            {
                'root': 'oj-rowexpander',
                'icon': 'oj-component-icon',
                'clickable': 'oj-clickable-icon-nocontext',
                'expand': 'oj-rowexpander-expand-icon',
                'collapse': 'oj-rowexpander-collapse-icon',
                'leaf': 'oj-rowexpander-leaf-icon',
                'lazyload': 'oj-rowexpander-lazyload-icon',
                'toucharea': 'oj-rowexpander-touch-area',
                'indent': 'oj-rowexpander-indent',
                'iconspacer': 'oj-rowexpander-icon-spacer',
                'depth0': 'oj-rowexpander-depth-0',
                'depth1': 'oj-rowexpander-depth-1',
                'depth2': 'oj-rowexpander-depth-2',
                'depth3': 'oj-rowexpander-depth-3',
                'depth4': 'oj-rowexpander-depth-4',
                'depth5': 'oj-rowexpander-depth-5',
                'depth6': 'oj-rowexpander-depth-6',
                'depth7': 'oj-rowexpander-depth-7'
    },
    constants :{
        MAX_STYLE_DEPTH: 7,
        NUM5_KEY: 53
    },
    /**
     * Create the row expander
     * @override
     * @memberof! oj.ojRowExpander
     * @protected
     */
    _ComponentCreate: function()
    {
        this._super();
        this.element.addClass(this.classNames['root']);
        this._initContent();
    },
    /**
     * Initialize the row expander after creation
     * @private
     */        
    _initContent : function () 
    {
        var self = this, context;
        
        context = this.options['context'];
        this.component = context['component'];
        this.datasource = context['datasource'];

        //root hidden so subtract 1
        this.depth = context['depth'];
        this.iconState = context['state'];
        this.rowKey = context['key'];
        this.index = context['index'];
        this.parentKey = context['parentKey'];

        this._addIndentation();
        this._addIcon();
        this._setIconStateClass();

        if (this.iconState === 'expanded' || this.iconState === 'collapsed')
        {
            $(this.toucharea).on('click', function(event) {
                //prevent scroll to top and # append
                event.preventDefault();
                self._fireExpandCollapse();
            });
            $(this.element).on('keypress', function(event) {
                var code = event.keyCode || event.which;
                if (code === $.ui.keyCode.ENTER || $.ui.keyCode.SPACE)
                {
                    // do expand or collapse
                    self._fireExpandCollapse();
                    // stop browser from for example scrolling the page
                    event.preventDefault();
                    // ensure focus stays
                    event.target.focus();
                }
            });

            // listen for key down event from host component
            if (this.component != null)
            {
                this.handleKeyDownCallback = this._handleKeyDownEvent.bind(this);
                $(this.component.element).on('ojkeydown', this.handleKeyDownCallback);
            }

            // listens for expand and collapse event from flattened datasource
            // this could be due to user clicks, keyboard shortcuts or programmatically
            if (this.datasource != null)
            {
                this.handleExpandCallback = this._handleExpandEvent.bind(this);
                this.handleCollapseCallback = this._handleCollapseEvent.bind(this);

                this.datasource.on("expand", this.handleExpandCallback, this);
                this.datasource.on("collapse", this.handleCollapseCallback, this);
            }
        }

        // listen for active key change event from host component
        if (this.component != null)
        {
            this.handleActiveKeyChangeCallback = this._handleActiveKeyChangeEvent.bind(this);
            $(this.component.element).on('ojactive', this.handleActiveKeyChangeCallback);
        }
    },
    /**
     * Refresh the row expander having made external modifications
     *      
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojRowExpander
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojRowExpander( "refresh" );
     */
    refresh: function()
    {
        this.element.empty();
        this._initContent();
    },
    /**
     * destroy the row expander
     *      
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojRowExpander
     * @instance
     * @private     
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojRowExpander( "destroy" );
     */
    _destroy: function()
    {
        // unregister keydown and active key change handlers
        if (this.component != null)
        {
            $(this.component.element).off('ojkeydown', this.handleKeyDownCallback);
            $(this.component.element).off('ojactive', this.handleActiveKeyChangeCallback);
        }

        // unregister expand/collapse events
        if (this.datasource != null)
        {
            this.datasource.off("expand", this.handleExpandCallback, this);
            this.datasource.off("collapse", this.handleCollapseCallback, this);
        }

        this.removeClass(this.classNames['root']);
        this.element.empty();
    },
    /**
     * Sets a single option value
     * @param {Object} key the option key
     * @param {Object} value the option value
     * @param {Object} flags additional flags for option* 
     * @override
     * @private
     */
    _setOption: function(key, value, flags)
    {
        this._super(key, value, flags);
        // refresh if context is updated
        if (key == 'context')
        {
            this.refresh();
        }
    },
    /**
     * Add athe indentation spacers to the row 
     * @private	 
     */
    _addIndentation: function()
    {
        var remainder, i, depth;
        //0 index the depth for style purposes
        depth = this.depth-1;
        if (depth < this.constants.MAX_STYLE_DEPTH)
        {
            this._appendSpacer(depth);
        }
        else
        {
            for (i=1; i <= (depth/(this.constants.MAX_STYLE_DEPTH)); i++)
            {
                this._appendSpacer(this.constants.MAX_STYLE_DEPTH);
            }
            remainder = (depth % this.constants.MAX_STYLE_DEPTH);
            if (remainder < this.constants.MAX_STYLE_DEPTH)
            {
                this._appendSpacer(remainder);
            }
        }
    },
    /**
     * Append appropriate spacer based on depth to the row expander
     * @param {number} depth the depth
     * @private
     */
    _appendSpacer: function(depth)
    {
        var spacer = $(document.createElement('span')).addClass(this.classNames['indent']).addClass(this.classNames['depth'+depth]);
        this.element.append(spacer);
    },
    /**
     * Add an icon to the row expander with appropriate class names for a clickable icon.
     * @private	 
     */
    _addIcon: function()
    {
        var iconSpacer = $(document.createElement('div')).addClass(this.classNames['iconspacer']);
        this.toucharea = $(document.createElement('div')).addClass(this.classNames['toucharea']);
        this.icon = $(document.createElement('a')).attr('href', '#').addClass(this.classNames['icon']).addClass(this.classNames['clickable']);
        this.element.append(iconSpacer.append(this.toucharea.append(this.icon)));
    },
    /**
     * Add a class name on the icon
     * @private	 
     * @param {string} classKey the key of the appropriate icon class expand/collapse/leaf
     */
    _addIconClass: function(classKey)
    {
        this.icon.addClass(this.classNames[classKey]);
    },
    /**
     * Remove a class name on the icon
     * @private
     * @param {string} classKey the key of the appropriate icon class expand/collapse/leaf
     */
    _removeIconClass: function(classKey)
    {
        this.icon.removeClass(this.classNames[classKey]);
    },
    /**
     * Set the icon class to the the iconState property
     * @private
     */
    _setIconStateClass: function()
    {
        switch (this.iconState)
        {
            case 'leaf':
                this._removeIconClass('icon');                
                this._removeIconClass('clickable');                
                this._addIconClass('leaf');
                break;
            case 'collapsed':
                this._addIconClass('expand');
                this._ariaExpanded(false);
                break;
            case 'expanded':
                this._addIconClass('collapse');
                this._ariaExpanded(true);
                break;
            case 'loading':
                this._removeIconClass('clickable');                 
                this._addIconClass('lazyload');
                break;
        }

    },
    /**
     * Removes the icon class of the iconState property
     * @private
     */
    _removeIconStateClass: function()
    {
        switch (this.iconState)
        {
            case 'leaf':
                this._removeIconClass('leaf');
                this._addIconClass('icon');   
                this._addIconClass('clickable');                                
                break;
            case 'collapsed':
                this._removeIconClass('expand');
                break;
            case 'expanded':
                this._removeIconClass('collapse');
                break;
            case 'loading':
                this._removeIconClass('lazyload');
                this._addIconClass('clickable');                    
                break;
        }

    },
    /**
     * Handles active key change event from host component (ojDataGrid or ojTable)
     * @param {Event} event
     * @param {Object} ui
     * @private
     */
    _handleActiveKeyChangeEvent: function(event, ui)
    {
        var rowKey, context, state;

        if (ui['activeKey'] != null)
        {
            rowKey = ui['activeKey']['rowKey'];
            // if the event is for this row and the active key change event is triggered
            // by row change and not column change
            if (this.rowKey === rowKey && (ui['previousActiveKey'] == null || ui['previousActiveKey']['row'] != ui['activeKey']['row']))
            {   
                // if the component allows AccessibleContext to be set
                if (this.component._setAccessibleContext)
                {
                    // row context of row expander for screen reader
                    // todo: get index from TreeDataSource as well since that could change
                    context = this.getTranslatedString('accessibleRowDescription', {'level': this.depth, 'num': this.index+1, 'total': this.datasource.getWrappedDataSource().getChildCount(this.parentKey)});
                    // state of row expander for screen reader
                    if (this.iconState === 'collapsed')
                    {
                        state = this.getTranslatedString('accessibleStateCollapsed');
                    }
                    else if (this.iconState === 'expanded')
                    {
                        state = this.getTranslatedString('accessibleStateExpanded');
                    }
                    else
                    {
                        // for leaf node don't read anything
                        state = '';
                    }

                    this.component._setAccessibleContext({'context': context, 'state': state});
                }
            }
        }
    },
    /**
     * Handles keydown event from host component (ojDataGrid or ojTable)
     * @param {Event} event
     * @param {Object} ui
     * @private
     */
    _handleKeyDownEvent: function(event, ui)
    {
        var rowKey, code, context;

        rowKey = ui['rowKey'];
        if (this.rowKey === rowKey)
        {
            code = event.keyCode || event.which;
            // ctrl (or equivalent) is pressed
            if (oj.DomUtils.isMetaKeyPressed(event))
            {
                // Ctrl+Right expands, Ctrl+Left collapse in accordance with WAI-ARIA best practice
                // consume the event as it's processed
                if (code == $.ui.keyCode.RIGHT)
                {
                    this._loading();
                    this.datasource.expand(this.rowKey);
                }
                else if (code == $.ui.keyCode.LEFT)
                {
                    this._loading();
                    this.datasource.collapse(this.rowKey);
                }
                else if (event.altKey && code == this.constants.NUM5_KEY)
                {
                    // read current cell context
                    if (this.component._setAccessibleContext)
                    {
                        context = this.getTranslatedString('accessibleRowDescription', {'level': this.depth, 'num': this.index+1, 'total': this.datasource.getWrappedDataSource().getChildCount(this.parentKey)});
                        this.component._setAccessibleContext({'context': context, 'state': ''});
                    }
                }
            }
        }
    },
    /**
     * Put row expander in a loading state.  This is called during expand/collapse.
     * @private
     */
    _loading: function()
    {
        this._removeIconStateClass();
        this.iconState = 'loading';
        this._setIconStateClass();
    },
    /**
     * Handle an expand event coming from the datasource, 
     * update the icon and the aria-expand property
     * @param {Object} event the expand event from the data source, should contain rowKey
     * @private
     */
    _handleExpandEvent: function(event)
    {
        var rowKey = event['rowKey'];
        if (rowKey === this.rowKey)
        {
            this._removeIconStateClass();
            this.iconState = 'expanded';
            this._setIconStateClass();
            this._ariaExpanded(true);
            this._trigger('expand', null, {'rowKey': rowKey});
        }
    },
    /**
     * Handle a collapse event coming from the datasource, 
     * update the icon and the aria-expand property
     * @param {Object} event the collapse event from the data source, should contain rowKey
     * @private
     */
    _handleCollapseEvent: function(event)
    {
        var rowKey = event['rowKey'];
        if (rowKey === this.rowKey)
        {
            this._removeIconStateClass();
            this.iconState = 'collapsed';
            this._setIconStateClass();
            this._ariaExpanded(false);
            this._trigger('collapse', null, {'rowKey': rowKey});        
        }
    },
    /**
     * Fire the expand or collapse on the datasource and the oj event on the widget 
     * @private
     */
    _fireExpandCollapse: function()
    {
        var state = this.iconState; 

        // show loading icon, note this changes the icon state to 'loading'
        this._loading();
        
        // invoke expand/collapse on datasource
        if (state === 'collapsed')
        {
            this.datasource.expand(this.rowKey);
        }
        else if (state === 'expanded')
        {
            this.datasource.collapse(this.rowKey);
        }
    },
    /**
     * Sets the icon's aria-expanded property to the boolean passed in
     * @param {boolean|null} bool true if expanded false if not
     * @private
     */
    _ariaExpanded: function(bool)
    {
        this.icon.attr('aria-expanded', bool);
    },
    /**
     * Return the subcomponent node represented by the documented locator attribute values.
     * <p>
     * To lookup the expand/collapse icon the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-rowexpander-icon'</li>
     * </ul>          
     *          
     * @expose
     * @memberof! oj.ojRowExpander
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *         the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Array.<(Element|null)>|Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
        var subId;
 
        if (locator == null)
        {
          return this.element ? this.element[0] : null;
        }

        subId = locator['subId'];
        if (subId === 'oj-rowexpander-icon')
        {
          return this.icon;
        }
        // Non-null locators have to be handled by the component subclasses
        return null;
    }
});

/**
 * @preserve Copyright (c) 2014, Oracle and/or its affiliates.
 * All rights reserved.
 */

(function() { // Toolbar wrapper function, to keep "private static members" private

/**
 * @class
 * @name oj.ojToolbar
 * @augments oj.baseComponent
 * @since 0.6
 * 
 * @classdesc
 * <h3 id="toolbarOverview-section">
 *   JET Toolbar Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toolbarOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant toolbar component.
 * 
 * <p>The JET Toolbar component can contain [JET Buttons]{@link oj.ojButton}, [JET Buttonsets]{@link oj.ojButtonset}, and non-focusable content 
 * such as separator icons.  Toolbar provides WAI-ARIA-compliant focus management.
 * 
 * <p>A toolbar that contains radios should contain all radios in the radio group.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard End User Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>JET Toolbar is a single tabstop, with arrow-key navigation within the toolbar, as follows:
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td>Navigates to the next enabled button, wrapping around at the end.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td>Navigates to the previous enabled button, wrapping around at the end.</td>
 *     </tr>
 *   </tbody>
 * </table>
 * 
 * <p>See also the [JET Button]{@link oj.ojButton} keyboard doc, for details on interacting with 
 * the individual buttons.
 * 
 * 
 * <h3 id="keyboard-appdev-section">
 *   Keyboard Application Developer Information
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-appdev-section"></a>
 * </h3>
 * 
 * <p>Any buttonsets placed in the toolbar should have <code class="prettyprint">focusManagement</code> set to <code class="prettyprint">"none"</code>, 
 * so as not to compete with the toolbar's focus management.  
 * 
 * <p>The application should not do anything to interfere with the Toolbar's focus management, such as setting the <code class="prettyprint">tabindex</code> 
 * of the buttons.  Also, enabled buttons should remain user-visible, without which arrow-key navigation to the button would cause the focus to 
 * seemingly disappear.
 * 
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>JET Toolbar takes care of focus management, as noted above.  
 * 
 * <p>To create an accessible toolbar separator, use the following markup.  Separators should be placed around any buttonsets in the toolbar, and 
 * anywhere else in the toolbar that a separator is desirable.
 * 
 * <pre class="prettyprint">
 * <code>&lt;span role="separator" aria-orientation="vertical" class="oj-toolbar-separator"></span>
 * </code></pre>
 * 
 * <p>As shown in the online demos, the application is responsible for applying <code class="prettyprint">aria-label</code> and/or 
 * <code class="prettyprint">aria-controls</code> attributes to the toolbar element, if applicable per the instructions that follow:
 * 
 * <p>If this toolbar is (or might be) placed in context with other toolbars, then the application should apply an 
 * <code class="prettyprint">aria-label</code> to the toolbar element to distinguish it, e.g. an "Edit" toolbar.  The 
 * <code class="prettyprint">aria-label</code> is optional when there is only one toolbar.
 * 
 * <p>If the toolbar is controlling something else on the page, e.g. bold / italic / underline buttons controlling a rich 
 * text editor, then the application should apply an <code class="prettyprint">aria-controls</code> attribute to the toolbar element, 
 * e.g. <code class="prettyprint">aria-controls="myTextEditor"</code>.
 * 
 * <p>Disabled content: JET supports an accessible luminosity contrast ratio, 
 * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>, 
 * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which 
 * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user 
 * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio 
 * required of enabled content, it cannot be used to convey meaningful information.<p>
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the 
 * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
 * is changed post-create, the toolbar must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded. 
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-toolbar</code> pseudo-selector can be used in jQuery expressions to select JET Toolbars.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-toolbar" ) // selects all JET Toolbars on the page
 * $myEventTarget.closest( ":oj-toolbar" ) // selects the closest ancestor that is a JET Toolbar
 * </code></pre>
 * 
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <p>For components like Toolbar and Menu that contain a number of like items, applications may wish to use a <code class="prettyprint">foreach</code> Knockout binding 
 * to stamp out the contents.  This binding cannot live on the same node as the JET <code class="prettyprint">ojComponent</code> binding, and must instead live on a nested 
 * virtual element as follows:
 * 
 * <pre class="prettyprint">
 * <code>&lt;div id="myToolbar" class="oj-button-half-chrome" 
 *      data-bind="ojComponent: {component: 'ojToolbar'}">
 *     &lt;!-- ko foreach: myButtons -->
 *         &lt;button data-bind="attr: {id: id}, 
 *                            ojComponent: { component: 'ojButton', label: label }">
 *         &lt;/button>
 *     &lt;!-- /ko -->
 * &lt;/div>
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "toolbar" or "menu".  
 * E.g. if JQUI had a toolbar component, and if it followed the usual pattern, then it would have a <code class="prettyprint">toolbarcreate</code> 
 * event, while JET's is called <code class="prettyprint">ojcreate</code>, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Toolbars (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-toolbar", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Toolbar.  If called after the toolbar is already created, is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the toolbar with no options specified:</caption>
 * $( ".selector" ).ojToolbar();
 * 
 * @example <caption>Initialize the toolbar with a callback specified:</caption>
 * $( ".selector" ).ojToolbar( { "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the toolbar via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="beverages" data-bind="ojComponent: { component: 'ojToolbar', 
 *                                               create: setupToolbar }">
 */
oj.__registerWidget("oj.ojToolbar", $['oj']['baseComponent'], {
    widgetEventPrefix : "oj", 

    options: { // options is in externs.js.  TODO: same as other prototype fields.
        /**
         * <p>JET Toolbar does not support a 
         * <code class="prettyprint">disabled</code> option.  The following 
         * one-liner can be used to disable or enable all buttons in a toolbar:
         * 
         * <pre class="prettyprint">
         * <code>$("#myToolbar").find(":oj-button").ojButton("option", "disabled", myBoolean);
         * </code></pre>
         * 
         * @expose
         * @memberof oj.ojToolbar
         * @instance
         */
        // We inherit the disabled option whether we want it or not, so init it to 
        // null here, so we can tell if app set it, so we can log a warning.
        // TODO: when do create refactoring, use constructorOptions to tell if app set it, 
        // and init to user-facing value (or just don't re-declare here, since super inits to false).
        disabled: null

        // Events
        
        /**
         * Triggered when the toolbar is created.
         *
         * @event 
         * @name create
         * @memberof oj.ojToolbar
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the toolbar with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojToolbar({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
    },

    _create: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this.element
            .addClass( "oj-toolbar oj-component" )
            .attr( "role", "toolbar" );

        if (this.options.disabled !== null)
            oj.Logger.warn("Caller attempted to set the 'disabled' option on Toolbar, but Toolbar does not support the 'disabled' option.  See API doc.");

        // call _setup from _create, not _init, so create listeners (called after _create before _init) see a fully inited component.
        // We don't implement _init at all, since it's intended to perform startup behaviors like autoOpen, 
        // not initing state or performing a refresh, and we have no such startup behaviors.
        this._setup(true);
        
        this._super(); // TODO: call this at beginning of method.  This will happen as part of the JET create-time refactoring.
    },

    // Override to set custom launcher
    _OpenContextMenu: function(menu, event) {
        // set launcher to the current tabbable button
        menu.open(event, {"launcher": this.element.find(":oj-button[tabindex=0]"), "initialFocus": "menu"});
    },

    _setOption: function( key, value ) { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        if ( key === "disabled" ) {
            oj.Logger.warn("Caller attempted to set the 'disabled' option on Toolbar, but Toolbar does not support the 'disabled' option.  See API doc.  Ignoring the call.");
            return;
        }

        this._superApply( arguments );
    },

    /**
     * Refreshes the toolbar, including the following:
     * 
     * <ul>
     *   <li>Re-applies focus management / keyboard navigation.
     *   <li>Rechecks the reading direction (LTR vs. RTL).
     * </ul>
     * 
     * 
     * <p>A <code class="prettyprint">refresh()</code> is required in the following circumstances:
     * <ul>
     *   <li>After buttons are added to or removed from the toolbar.</li>
     *   <li>After a change to the <code class="prettyprint">disabled</code> status of any of the buttons in the toolbar.</li>
     *   <li>After a programmatic change to the <code class="prettyprint">checked</code> status of a radio button in the toolbar
     *       (which should be done via Buttonset's <code class="prettyprint">checked</code> option).  This applies only to radios, 
     *       not to checkboxes or push buttons.</li>
     *   <li>After the reading direction (LTR vs. RTL) changes.</li>
     * </ul>
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof oj.ojToolbar
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojToolbar( "refresh" );
     */
    refresh: function() {
        this._super();
        this._setup(false);
    },
    
    _setup: function(isCreate) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var self = this;
        this.isRtl = this._GetReadingDirection() === "rtl";
        
        // When toolbar is binding listeners to buttons, use the Toolbar's eventNamespace, not the Button's 
        // eventNamespace, to facilitate later unbinding only the Toolbar listeners.

        // For checkbox/radio, we're binding to inputs, not labels.

        // Put listeners on every button, b/c it's too unreliable to put them on the toolbar node and rely on event bubbling.
        // - E.g. bubbling doesn't work for antonym buttons (is this still true after the refactoring?) -- see comment on Button._setLabelOption().
        // - Likewise, focus mgmt can't just break if app listener stops propagation.
        // - Both of these problems still happen when using the delegation / selector overload of .on(); there is no special JQ bubbling magic.

        this.$buttons = this.element.find( ":oj-button" )
            .unbind( "keydown" + this.eventNamespace )
            .bind( "keydown" + this.eventNamespace, function(event) { 
                self._handleKeyDown(event, $(this)); 
            })
            
            .unbind( "click" + this.eventNamespace )
            .bind( "click" + this.eventNamespace, function(event) {
                if ( !$(this).ojButton("option", "disabled") ) { 
                    // Normally the button will be tabbable after the click, since (a) if we reach here, the clicked button is enabled, and 
                    // (b) an unchecked radio before the click will normally be checked after the click.  But just in case it's unchecked 
                    // (e.g. due to app listener), we let callee run it thru _mapToTabbable() before using, as usual.
                    self._setTabStop( $(this) );
                }
            })
            .unbind( "focus" + this.eventNamespace )
            .bind( "focus" + this.eventNamespace, function(event) { 
                self._setTabStop( $(this) );
            });
        
        // the subset of Toolbar buttons that are enabled.  Disabled buttons are not tabbable.
        this.$enabledButtons = this.$buttons.filter(function(index) {
            return !$( this ).ojButton( "option", "disabled" );
        });
        
        this._initTabindexes(isCreate);
    },
    
    // For create, make only the first enabled button tabbable.  (We decided to have Shift-Tab go to first, not last, button.)
    // For refreshes, keep the existing tabstop if we can, otherwise proceed as with create.
    // Either way, if that button is a radio and some radio in its group is checked, make that one tabbable instead.
    // If there are no enabled buttons, makes them all untabbable.
    // No return value.
    _initTabindexes: function(isCreate) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // even for refreshes where we'll wind up keeping the same tabstop, must make everything untabbable first, to ensure any new buttons become untabbable.
        var $last = $(this._lastTabStop);
        this._lastTabStop = undefined;
        this.$buttons.attr( "tabindex", "-1" );
        var $newTabStop; // callee might map this to radio groupmate
        
        // TBD: for refreshes when $last is a disabled radio with a checked enabled groupmate and they are in the toolbar, the groupmate would be 
        // a valid tabstop, but this defaults to the first.
        if (isCreate || !$last.is(this.$enabledButtons)) {
            // is create, or is refresh but must treat like create b/c $last is empty, or not enabled, or no longer in the toolbar
            $newTabStop = this.$enabledButtons.first(); // if empty (none enabled), no tabstop will be set
        } else {
            // is a refresh, and $last is non-empty and is an enabled button still in the toolbar.  May be a radio whose groupmate
            // has become checked, in which case callee will map it to that groupmate.
            $newTabStop = $last;
        }
        this._setTabStop( $newTabStop );
    },
    
    // For each button in $button (in our usage always 0-1 button hence $button singular), if that button is an unchecked radio 
    // with a checked groupmate (which means it's not tabbable), then map it to the checked one (checked enabled radios are 
    // tabbable, and we know it's enabled per the argument below).
    // 
    // $button contains 0 or more buttons to map.  Must be enabled since disabled buttons aren't tabbable.
    // Returns the mapped JQ object (which the caller will make the tabstop).
    // 
    // We know that this.$enabledButtons contains all buttons in $button, and all of their potentially checked radio-groupmates, since:
    // - The above "enabled" requirement guarantees that $button's contents are all in $enabledButtons.
    // - The prohibition against radio groupmates that are not in the toolbar, and the prohibition against checked disabled groupmates 
    //   of enabled radios, guarantee that if $button is a radio, then all of its potentially checked groupmates are enabled and thus in 
    //   $enabledButtons.
    // 
    // Firefox browser issue:   (TODO: should we doc this?  File FF and/or JET bug?)
    // 
    // When this method maps an unchecked radio to its checked groupmate, the caller ensures that the former still has focus, but the latter
    // is the tabstop for when the user tabs out and back in.  When tabbing / Shift-Tabbing from the unchecked radio in the direction of the 
    // checked one, Chrome and IE9 are smart enough to tab out of the radio group to the adjacent tabstop as desired.  But in FF, focus goes to 
    // the checked one, which is not what we want.
    // 
    // Reason: Chrome and IE9 are smart enough never to tab within a radio group.  If focus is in the radio group, Tab and Shift-Tab exit the radio group.
    // But in FF, [a radio is reachable via Tab/Shift-Tab from within the group] if [it's enabled, tabindex != -1, and either checked or has no 
    // checked groupmates], i.e. [it would be reachable via Tab/Shift-Tab from outside the group if all its groupmates happened to be untabbable 
    // (e.g. disabled)].  In other words, FF is the only one that fails to distinguish between radios that could be valid tabstops from outside, and
    // those that should be valid tabstops from inside.  
    // 
    // This impl improves on the native behavior.  In FF, in an unchecked radio group, every single radio is a tabstop.  Our use of tabindex=-1 
    // guarantees that we never tab within the group in that case.  It's only a checked groupmate that can be tabbed to from within. (So at 
    // most one unwanted tabstop.)
    // 
    // After much time and effort, the latter issue seems to be infeasible to fix in any robust, non-brittle way.  E.g.:
    // - Clearing all tabstops and restoring on tab-out of toolbar:  FF provides no reliable way to find out whether a blur is exiting the entire 
    //   toolbar.  The obvious setTimeout workaround needed to be unacceptably long (e.g. 250ms) and even then was unreliable.  If we ever fail 
    //   to restore the tabstop, the toolbar becomes untabbable and inaccessible.
    // - Every other approach had similar robustness issues. 
    _mapToTabbable: function( $button ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var $enabledButtons = this.$enabledButtons;
        return $button.map(function(index, elem) {
            // Buttons other than radios, and checked radios, are always tabbable if they're enabled, which this method requires.
            // Radios w/ name="" (incl name omitted) are not in a radio group, not even with other radios with w/ name="".  Radios 
            // with no groupmates are always tabbable, since either they're checked, or they're unchecked with no checked groupmate.
            if (elem.type != "radio" || elem.checked || elem.name == "") { 
                return elem;
            } else {
                // elem is unchecked radio in real (not "") group, which is tabbable iff no groupmate is checked.  Per above doc, we know that 
                // all of its potentially checked groupmates are in $enabledButtons.
                var $checkedRadio = _radioGroup(elem, $enabledButtons).filter(":checked");
                return ($checkedRadio.length ? $checkedRadio[0] : elem);
            }
        });
    },
    
    // Set which button is in the tab sequence.
    // $button should contain 0 or 1 button to be made tabbable (since at most one should be tabbable at a time).
    //   If 0 (i.e. no enabled buttons), all will become untabbable.  If 1, it must be tabbable in every way (e.g. enabled) except possibly 
    //   being an unchecked radio with a checked groupmate, which this method will map to its checked groupmate, which 
    //   we know is enabled thus tabbable since we require that checked radios with enabled groupmates not be disabled.  
    // No return value.
    _setTabStop: function( $button ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
//        if (!window.setTabStopCounter) window.setTabStopCounter=1; // REMOVE, is only for console.log's
//        console.log("in _setTabStop: " + window.setTabStopCounter++ + ".  Orig (premap) button checked: " + $button[0].checked); // + " and is:");
//        console.log($button[0]);
        
        $button = this._mapToTabbable( $button );
        var button = $button[0]; // button is undefined iff $button is empty iff we need to clear all tabstops b/c there are no enabled buttons to make tabbable
        var last = this._lastTabStop; // last is undefined iff $(last) is empty iff there are no existing tabstops to clear (b/c _initTabindexes just ran 
                                      // or previously there were no enabled buttons to make tabbable)
        
//        console.log("mapped button and last button are:");  console.log(button);  console.log(last);  console.log(".");
        
        // Cases: both are undefined: have no tabstops; want to keep it that way (b/c none enabled), so do nothing
        //        both are node X: X is the tabstop; want to keep it that way, so do nothing
        //        last is node X; button is undefined: X is the tabstop; want to clear it w/o replacing it (b/c none enabled).  This logic does that.
        //        last is undefined; button is node X: no existing tabstop; want to make X the tabstop.  This logic does that.
        //        last is node X; button is node Y: X is the tabstop; want to clear it and make Y the tabstop.  This logic does that.
        if ( button !== last) {
            //console.log("setting tab stop to " + $button.attr("id"));  console.log("$(last).length:");  console.log($(last).length);
            
            $(last).attr( "tabindex", "-1" ); // no-op iff $(last) is empty iff (see comment above)
            $button.attr( "tabindex", "0" ); // no-op iff $button is empty iff (see comment above)
            this._lastTabStop = button;
        }
    },
    
    // No return value.
    _handleKeyDown: function(event, $button) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        switch (event.which) {
            case $.ui.keyCode.LEFT:  // left arrow
            case $.ui.keyCode.RIGHT: // right arrow
                event.preventDefault();
                
                var $enabledButtons = this.$enabledButtons;
                var length = $enabledButtons.length;
                if (length<2) // nowhere to navigate to; currently focused button is the only enabled one in toolbar
                    break;
                
                var oldIndex = $enabledButtons.index($button);
                var increment = ((event.which == $.ui.keyCode.RIGHT) ^ this.isRtl) ? 1 : -1;
                var newIndex = (oldIndex+increment+length)%length; // wrap around if at start/end of toolbar
                
                // A11y office recommended treating radios like other buttons: Arrow moves focus without selecting, Spacebar selects, 
                // which we prefer too.  Since we're using role='button', not 'radio', we don't need to follow the WAI-ARIA radio behavior 
                // where Arrow moves focus and selects, Ctrl-Arrow moves focus without selecting.  
                $enabledButtons.eq(newIndex).focus();
                break;
            case $.ui.keyCode.UP:   // up arrow
            case $.ui.keyCode.DOWN: // down arrow
                // Per above comment, treating radios like buttons, which have no native or WAI-ARIA-mandated up/down arrow behavior, 
                // so disable native focus-and-select behavior.  
                if ( $button.attr("type")=="radio" )
                    event.preventDefault();
                break;
            
            // Don't need Space/Enter handlers.  For all buttons except already-checked radios in some browsers, Space/Enter fire a click event 
            // (natively or manually), which already calls _setTabStop.  For checked radios (which are focused if they're getting 
            // this key event), _setTabStop has already been called for whichever happened 2nd:  focus (an already checked radio) or
            // check (an already focused radio) via click/Space/Enter.  If checking was done programmatically (via Bset.checked option), we require a refresh().
        }
    },
    
    _destroy: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        // this entire stmt can be removed once restoreAttrs code is running.
        this.element
            .removeClass( "oj-toolbar oj-component" )
            .removeAttr( "role" );
    
        // Since we're not destroying the buttons themselves, the restoreAttrs code will NOT take care of this.
        this.$buttons.attr( "tabindex", "0" ); // bsets in a toolbar should not have focusMgmt turned on, so this is OK, but should revert to orig value, not assume 0.
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the toolbar element.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojToolbar#widget
     * @memberof oj.ojToolbar
     * @instance
     * @return {jQuery} the toolbar element
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojToolbar( "widget" );
     */

    /**
     * Removes the toolbar functionality completely. This will return the element back to its pre-init state, 
     * and remove the toolbar's focus management from the contained buttons.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojToolbar#destroy
     * @memberof oj.ojToolbar
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojToolbar( "destroy" );
     */
});

// -----------------------------------------------------------------------------
// "private static members" shared by all toolbars: 
// -----------------------------------------------------------------------------

/**
 * In all cases, the return value includes only radios that are an :oj-button, i.e. radios that have been buttonized.
 * 
 * Where this method looks for radio groupmates:
 *
 * - If $elems is present (even if empty), 
 *     - This method will only look in that set, and will not attempt to weed out any false positives as defined below. 
 *       (So in this case, return value includes the specified radio iff it's an :oj-button in $elems.)
 * - Else this method looks in exactly the places where groupmates (including the original radio) would live, i.e. not in 
 *   the places false positives would live.  (So in both of the following cases, return value includes the specified radio 
 *   iff it's an :oj-button.)  Specifically:
 *     - If radio is in a form, this method will only look in that form.
 *     - Else, this method will look in the radio's document, but not in any forms.
 * 
 * Radios w/ name="" (incl name omitted) are not in a radio group (i.e. no SelectOne semantics), not even with other radios with 
 * w/ name="".  So if radio is nameless, the return value will include only radio (or nothing at all if it isn't an :oj-button, or 
 * if $elems is passed and it doesn't include radio).  
 * 
 * False positives: radios with nonempty names that match radio's name, but are actually not groupmates (i.e. no SelectOne 
 * relationship), e.g. because they're from a different form.
 * 
 * 
 * @param {!Element} radio  a radio button.  Not a JQ object, other button or element type, or null.
 * @param {jQuery=} $elems  optional JQ object, containing 0 or more elems that aren't necessarily radios or buttons, in which to look for groupmates.
 *                          E.g. the elements in a buttonset or toolbar.  Must not contain any false positives as defined above.
 */
var _radioGroup = function( radio, $elems ) {
    var name = radio.name,
        form = radio.form,
        $radios;
    if ( name ) {
        name = name.replace( /'/g, "\\'" ); // escape single quotes
        var selector = ":radio[name='" + name + "']:oj-button";
        if ( $elems ) {
            $radios = $elems.filter( selector );
        } else if ( form ) {
            $radios = $( form ).find( selector );
        } else {
            $radios = $( selector, radio.ownerDocument )
                .filter(function() {
                    return !this.form;
                });
        }
    } else {
        $radios = ($elems ? $elems.filter( radio ) : $( radio )).filter(":oj-button");
    }
    return $radios;
};

}() ); // end of Toolbar wrapper function

//ojprogressbar is based of JQueryUI porgressbar and was modified by Eugene
/*!
 * jQuery UI Progressbar 1.10.3
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/progressbar/
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
 
 /**
 * The ojProgressbar component allows a user to display progress of an input in a rectangular horizontal meter. 
 * If a developer does not witsh to display the exact value, a value of '-1' can be passed in to display an indeterminate value.
 * 
 * 
 * @example <caption>Initialize component using widget API</caption>
 * &lt;div id="progressBar"/&gt;<br/>
 * $("#progressBar").ojProgressbar({'value': loadValue, 'max':100});
 * @example <caption>Using knockout, value bind to observables - loadValue</caption> 
 * &lt;div id="progressBar" data-bind="ojComponent: {role: 'ojProgressbar', value: loadValue, max:100}"/&gt;gt;
 * 
 * @class
 * @constructor
 * @name oj.ojProgressbar
 * @augments oj.baseComponent
 */
(function() {
   /*
	* <h3 id="markup-section">
    *   HTML Markup and Style Classes
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#markup-section"></a>
    * </h3>
    *
    * <p>To create the start label for the progressbar wrap the start label text in a div with the  <code class="prettyprint"> oj-progressbar-start-label </code> class. </p>
	*
	* <p>To create the end label for the progressbar wrap the end label text in a div with the  <code class="prettyprint"> oj-progressbar-end-label </code> class. </p>
    *
	*/
oj.__registerWidget("oj.ojProgressbar",  $['oj']['baseComponent'], {
	version: "1.0.0",
	defaultElement : "<div>", 
    widgetEventPrefix : "oj", 
	options: {
		/** 
		 * The maximum allowed value. The element's max attribute is used if it 
		 * is provided, otherwise the default value of 100 is used. 
		 * @expose 
		 * @public
		 * @instance
		 * @memberof! oj.ojProgressbar 
		 * @default <code class="prettyprint">100</code>
		 */
		max: 100,
		/** 
		 * The value of the progressbar. The element's value attribute is used if it 
		 * is provided, otherwise the default value of 0 is used. For indeterminate progressbar, set value to -1.
		 * @expose 
		 * @public
		 * @instance
		 * @memberof! oj.ojProgressbar 
		 * @default <code class="prettyprint">0</code>
		 */
		value: 0,
		/** 
		 * If disbled is set to true, then the progressbar will not change if a new value is passed in.
		 * By default this parameter is set to false.
		 * @expose 
		 * @public
		 * @instance
		 * @memberof! oj.ojProgressbar 
		 * @default <code class="prettyprint">false</code>
		 */
		disabled: false
		
		/**
         * Triggered when the progressbar is created.
         *
         * @event 
         * @name create
         * @memberof! oj.ojProgressbar
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         */
	},
    // The min value is a constant and 0 is the value set for it.
	min: 0,
	
	 /** 
	   * Variable used to indicate that the value is indeterminate
	   *
	   * @override
	   * @private
	   */
	_indeterminate: false,
	
	 /**
	   * 
	   * _create contains all actions that are needed fo the initialization of the progressbar and is only called once.
	   *
	   * @override
	   * @private
	   */
	_create: function() {
		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element
			.addClass( "oj-progressbar" )
			.attr({
				// Only set static values, aria-valuenow and aria-valuemax are
				// set inside _refreshValue()
				"role": "progressbar",
				"aria-valuemin": this.min
			});

		this.valueDiv = $( "<div class='oj-progressbar-value'></div>" )
			.appendTo( this.element );

		this._refreshValue();
		
		this._super();
	},
	
  
  _InitOptions : function (originalDefaults, constructorOptions)
  {
    var element = this.element, savedAttributes = this._GetSavedAttributes(element);
    
    this._super(originalDefaults, constructorOptions);
    // TODO: PAVI - this needs revisiting because if you are reading from DOM, we only do this if 
    // options.max === undefined. 

    // MAX: (number)
    if (this.options['max'] == null) // null or undefined
    {
      this.options['max'] = 'max' in savedAttributes ? savedAttributes['max']['prop'] : undefined;
    }
  },
	
  /**
   * Check that value is valid and within the correct bounds. A value of -1 indicates an indeterminate value.
   * @param {number} newValue - The new value of the progressbar being passed in.
   * @override
   * @private
   */
	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}
		
        // Indicates that the value is indeterminate.
		this._indeterminate = (newValue == -1 );

		// sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = isNaN(newValue) ? 0 : Number(newValue);

		}

		return this._indeterminate ? -1 :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},
  /**
   * Set the value
   * @param {Object} options - The options being set
   * @override
   * @private
   */
	_setOptions: function( options, flags ) {
		// Ensure "value" option is set after other values (like max)
		if( !this.options.disabled) {
		    var value = options.value;
		    delete options.value;

		    this._super( options, flags );
		    this.options.value = this._constrainedValue( value );
		    this._refreshValue();
		}
	},

   /**
   * Check that the max value is not less than the min 
   * @param {string} key - The key for the option being set
   * @param {string|number} value - The value being set
   * @override
   * @private
   */
	_setOption: function( key, value, flags ) {
		if ( key === "max" ) {
			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}

		this._super( key, value, flags );
	},
  /**
   * Calculates the percentage of the progressbar that has been loaded based on min, max, and value.
   *
   * @override
   * @private
   */
	_percentage: function() {
		return this._indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

   /**
    * This function is used to update the value when the value has changed.
    *
    * @override
    * @private
    */
	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this._indeterminate || value > this.min )
			.width( percentage.toFixed(0) + "%" );

		this.element.toggleClass( "oj-progressbar-indeterminate", this._indeterminate );


		if ( this._indeterminate) {
			this.element.attr({
				"aria-valuetext": "In Progress"
			});
			this.element.removeAttr( "aria-valuenow" );
			this.element.removeAttr( "aria-valuemin" );
			this.element.removeAttr( "aria-valuemax" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div class='oj-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
			    this.overlayDiv.addClass("oj-indeterminate");
			}
		} else {
			this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			});
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}
	},
	
   /**
    * Overide the destory function to remove appropriate class and atrributes.
    *
    * @override
    * @private
    */	
	_destroy: function() {
		this.element
			.removeClass( "oj-progressbar" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	}
});

}( ));

})();